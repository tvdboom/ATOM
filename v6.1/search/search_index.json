{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "about/", "title": "About", "text": ""}, {"location": "about/#what-is-it", "title": "What is it?", "text": "<p>Automated Tool for Optimized Modeling (ATOM) is an open-source Python package designed to help data scientists fasten up the exploration phase of their machine learning projects. ATOM is a low-code, easy-to-use library, capable of running experiments quickly and efficiently, enabling the user to go from raw data to generating insights in just a few lines of code. Click here to get started.</p> <p></p>"}, {"location": "about/#what-can-i-do-with-it", "title": "What can I do with it?", "text": "<p>ATOM is an end-to-end solution for machine learning pipelines. It supports the user from raw data ingestion to the final results' analysis and model deployment. Click on the icons to read more about its main functionalities.</p> Data cleaning Feature engineering Model selection Hyperparametertuning Model training Model predictions Experiment logging Analysis &amp;Interpretability"}, {"location": "about/#who-is-it-intended-for", "title": "Who is it intended for?", "text": "<ul> <li>Data scientists that want to fasten up the exploration phase of their machine   learning projects.</li> <li>Data scientists that want to run a simple modeling experiment without having   to spend too much time on coding.</li> <li>Data scientists that are new to Python and are not (yet) familiar with all   the relevant machine learning packages.</li> <li>Data analysts without extensive knowledge of machine learning that want to   try out model-based solutions.</li> <li>Anyone who wants to rapidly build a Proof of Concept, for example during a hackathon.</li> <li>Anyone who is new to the field of machine learning and wants a low-code,   easy to learn package, to get started building predictive pipelines.</li> </ul>"}, {"location": "about/#citing-atom", "title": "Citing ATOM", "text": "<p>If you use ATOM in a scientific publication, please consider citing this documentation page as the resource. ATOM\u2019s first stable release v2.0.3 was made publicly available in November 2019. A formatted version of the citation would look like this:</p> <p>ATOM v2.0.3, November 2019. URL https://tvdboom.github.io/ATOM/</p> <p>BibTeX entry:</p> <pre><code>@Manual{ATOM,\n    title = {ATOM: A Python package for fast exploration of machine learning pipelines},\n    author = {Mavs},\n    year={2019},\n    mont={November},\n    note = {ATOM version 2.0.3},\n    url = {https://tvdboom.github.io/ATOM/},\n}\n</code></pre> <p></p>"}, {"location": "about/#support", "title": "Support", "text": "<p>ATOM recognizes the support from JetBrains by providing core project contributors with a set of developer tools free of charge.</p> <p> </p> <p></p>"}, {"location": "about/#integrations", "title": "Integrations", "text": ""}, {"location": "contributing/", "title": "Contributing", "text": "<p>Are you interested in contributing to ATOM? Do you want to report a bug? Do you have a question? Before you do, please read the following guidelines.</p> <p></p>"}, {"location": "contributing/#submission-context", "title": "Submission context", "text": ""}, {"location": "contributing/#question-or-problem", "title": "Question or problem?", "text": "<p>For quick questions, there's no need to open an issue. Check first if the question isn't already answered in the FAQ section. If not, reach us through the discussions page or on the slack channel.</p>"}, {"location": "contributing/#report-a-bug", "title": "Report a bug?", "text": "<p>If you found a bug in the source code, you can help by submitting an issue to the issue tracker in the GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines.</p>"}, {"location": "contributing/#missing-a-feature", "title": "Missing a feature?", "text": "<p>You can request a new feature by submitting an issue to the GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first. Please consider what kind of change it is:</p> <ul> <li> <p>For a major feature, first open an issue and outline your proposal so   that it can be discussed. This will also allow us to better coordinate our   efforts, prevent duplication of work, and help you to craft the change so   that it is successfully accepted into the project.</p> </li> <li> <p>Small features and bugs can be crafted and directly submitted as a Pull   Request. However, there is no guarantee that your feature will make it into   <code>master</code>, as it's always a matter of opinion whether if benefits the   overall functionality of the project.</p> </li> </ul>"}, {"location": "contributing/#project-layout", "title": "Project layout", "text": "<p>The latest stable release of ATOM is on the <code>master</code> branch, whereas the latest version of ATOM in development is on the <code>development</code> branch. Make sure you are looking at and working on the correct branch if you're looking to contribute code.</p> <p>In terms of directory structure:</p> <ul> <li>All of ATOM's code sources are in the <code>atom</code> directory.</li> <li>The documentation sources are in the <code>docs_sources</code> directory.</li> <li>Images in the documentation are in the <code>docs_sources/img</code> directory.</li> <li>Tutorial notebooks are in the <code>examples</code> directory. If you want to   include the example to the documentation as well, add the <code>.ipynb</code> file   to <code>docs_sources/examples</code> and update the <code>mkdocs.yml</code> file accordingly.</li> <li>Unit tests are in the <code>tests</code> directory. Make sure to add the tests to the   file corresponding to the module in the <code>atom</code> directory with the code that   is being tested.</li> </ul> <p>Make sure to familiarize yourself with the project layout before making any major contributions, and especially make sure to send all code changes to the <code>development</code> branch.</p> <p></p>"}, {"location": "contributing/#submission-guidelines", "title": "Submission guidelines", "text": ""}, {"location": "contributing/#submitting-an-issue", "title": "Submitting an issue", "text": "<p>Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists, and the discussion might inform you of workarounds readily available.</p> <p>We want to fix all the issues as soon as possible, but before fixing a bug, we need to reproduce and confirm it. In order to reproduce bugs, we will systematically ask you to provide a minimal reproduction scenario using the custom issue template.</p>"}, {"location": "contributing/#submitting-a-pull-request", "title": "Submitting a pull request", "text": "<p>Before you submit a pull request, please work through this checklist to make sure that you have done the necessary so we can efficiently review and accept your changes.</p> <ul> <li>Update the documentation so all of your changes are reflected there.</li> <li>Adhere to PEP 8 standards.</li> <li>Use a maximum of 99 characters per line. Try to keep docstrings below   80 characters.</li> <li>Update the project unit tests to test your code changes as thoroughly   as possible.</li> <li>Make sure that your code is properly commented with docstrings and   comments explaining your rationale behind non-obvious coding practices.</li> <li>Run pre-commit: <code>pre-commit run --all-files</code> and make sure all   tests pass.</li> </ul> <p>If your contribution requires a new library dependency:</p> <ul> <li>Double-check that the new dependency is easy to install via pip and Anaconda.</li> <li>The library should support Python 3.10, 3.11 and 3.12.</li> <li>Make sure the code works with the latest version of the library.</li> <li>Update the dependencies in the documentation.</li> <li>Add the library with the minimum required version to <code>pyproject.toml</code>.</li> </ul> <p>After submitting your pull request, GitHub will automatically run the tests on your changes and make sure that the updated code builds successfully. The checks run on Python 3.10 and 3.11, on Ubuntu and Windows. We also use services that automatically check code style and test coverage.</p>"}, {"location": "dependencies/", "title": "Dependencies", "text": ""}, {"location": "dependencies/#python-os", "title": "Python &amp; OS", "text": "<p>As of the moment, ATOM supports the following Python versions:</p> <ul> <li>Python 3.10</li> <li>Python 3.11</li> <li>Python 3.12</li> </ul> <p>And operating systems:</p> <ul> <li>Linux (Ubuntu, Fedora, etc...)</li> <li>Windows 8.1+</li> <li>macOS (not tested)</li> </ul> <p></p>"}, {"location": "dependencies/#packages", "title": "Packages", "text": ""}, {"location": "dependencies/#required", "title": "Required", "text": "<p>ATOM is built on top of several existing Python libraries. These packages are necessary for its correct functioning.</p> <ul> <li>beartype (&gt;=0.18.5)</li> <li>category-encoders (&gt;=2.6.3)</li> <li>dill (&gt;=0.3.6)</li> <li>featuretools (&gt;=1.28.0)</li> <li>gplearn (&gt;=0.4.2)</li> <li>imbalanced-learn (&gt;=0.12.3)</li> <li>ipython (&gt;=8.9.0)</li> <li>ipywidgets (&gt;=8.1.1)</li> <li>joblib (&gt;=1.3.1)</li> <li>matplotlib (&gt;=3.7.2)</li> <li>mlflow (&gt;=2.10.2)</li> <li>nltk (&gt;=3.8.1)</li> <li>numpy (&gt;=1.23.0)</li> <li>optuna (&gt;=3.6.0)</li> <li>pandas (&gt;=2.2.2)</li> <li>plotly (&gt;=5.18.0)</li> <li>scikit-learn (&gt;=1.5.0)</li> <li>scipy (&gt;=1.10.1)</li> <li>shap (&gt;=0.43.0)</li> <li>sktime[forecasting] (&gt;=0.30.0)</li> <li>statsmodels (&gt;=0.14.1)</li> <li>zoofs (&gt;=0.1.26)</li> </ul>"}, {"location": "dependencies/#optional", "title": "Optional", "text": "<p>Some specific models, utility methods or plots require the installation of additional libraries. You can install all the optional dependencies using <code>pip install atom-ml[full]</code>. Doing so also installs the following libraries:</p> <ul> <li>botorch (&gt;=0.8.5)</li> <li>catboost (&gt;=1.2)</li> <li>dagshub (&gt;=0.3.8)</li> <li>dask[dataframe,distributed] (&gt;=2024.2.0)</li> <li>explainerdashboard (&gt;=0.4.3)</li> <li>gradio (&gt;=3.44.4)</li> <li>lightgbm (&gt;=4.1.0)</li> <li>modin[ray] (&gt;=0.25.0)</li> <li>optuna-integration (&gt;=3.6.0)</li> <li>polars (&gt;=0.20.7)</li> <li>pyarrow (&gt;=15.0.0)</li> <li>pyspark (&gt;=3.5.0)</li> <li>requests (&gt;=2.31.0)</li> <li>ray[serve] (&gt;=2.9.1)</li> <li>requests (&gt;=2.31.0)</li> <li>scikit-learn-intelex (&gt;=2023.2.1)</li> <li>schemdraw (&gt;=0.16)</li> <li>statsforecast (&gt;=1.7.3)</li> <li>supersmoother (&gt;=0.4)</li> <li>sweetviz (&gt;=2.3.1)</li> <li>wordcloud (&gt;=1.9.2)</li> <li>xgboost (&gt;=2.0.0)</li> </ul>"}, {"location": "dependencies/#development", "title": "Development", "text": "<p>The development dependencies are not installed with the package, and are not required for any of its functionalities. These libraries are only necessary to contribute to the project. Install them running <code>pdm install --dev</code> (remember to install pdm first with <code>pip install -U pdm</code>).</p> <p>Linting</p> <ul> <li>pre-commit (&gt;=3.6.2)</li> </ul> <p>Testing</p> <ul> <li>nbmake (&gt;=1.5.3)</li> <li>pytest (&gt;=8.1.1)</li> <li>pytest-cov (&gt;=4.1.0)</li> <li>pytest-mock (&gt;=3.12.0)</li> <li>pytest-xdist (&gt;=3.5.0)</li> <li>scikeras (&gt;=0.13.0)</li> <li>tensorflow (&gt;=2.16.1)</li> </ul> <p>Documentation</p> <ul> <li>jupyter-contrib-nbextensions (&gt;=0.7.0)</li> <li>kaleido (&gt;=0.2.1)</li> <li>mike (&gt;=2.0.0)</li> <li>mkdocs (&gt;=1.5.3)</li> <li>mkdocs-autorefs (&gt;=1.0.1)</li> <li>mkdocs-git-revision-date-localized-plugin (&gt;=1.2.4)</li> <li>mkdocs-jupyter (&gt;=0.24.6)</li> <li>mkdocs-material (&gt;=9.5.13)</li> <li>mkdocs-material-extensions (&gt;=1.3.1)</li> <li>mkdocs-simple-hooks (&gt;=0.1.5)</li> <li>notebook (==6.4.12)</li> <li>pymdown-extensions (&gt;=10.7.1)</li> <li>pyyaml (&gt;=6.0.1)</li> </ul>"}, {"location": "faq/", "title": "Frequently asked questions", "text": "<p>Here we try to give answers to some questions that have popped up regularly. If you have any other questions, don't hesitate to create a new discussion or post them on the Slack channel!</p> <p>??? faq Is this package related to the Atom text editor?\"     There is, indeed, a text editor with the same name and a similar logo as     this package. Is this a shameless copy? No. When I started the project,     I didn't know about the text editor, and it doesn't require much thinking     to come up with the idea of replacing the letter O of the word atom with     the image of an atom.</p> How does ATOM relate to AutoML? <p>ATOM is not an AutoML tool since it does not automate the search for an optimal pipeline like well-known AutoML tools such as auto-sklearn or EvalML do. Instead, ATOM helps the user find the optimal pipeline himself. One of the goals of this package is to help data scientists produce explainable pipelines, and using an AutoML black box function would impede that.</p> Is it possible to run deep learning models? <p>Yes. Deep learning models can be added as custom models to the pipeline as long as they follow sklearn's API. For more information, see the deep learning section of the user guide.</p> Can I run atom's methods on just a subset of the columns? <p>Yes, all data cleaning and feature engineering methods accept a <code>columns</code> parameter to only transform the selected features. For example, to only impute the numerical columns in the dataset we could type <code>atom.impute(strat_num=\"mean\", columns=atom.numerical)</code>. The parameter accepts column names, column indices, dtypes or a slice object.</p> How can I compare the same model on different datasets? <p>In many occasions you might want to test how a model performs on datasets processed with different pipelines. For this, atom has the branch system. Create a new branch for every new pipeline you want to test and use the plot methods to compare all models, independent of the branch it was trained on.</p> Can I train models through atom using a GPU? <p>Yes. Refer to the user guide to see what algorithms and models have a GPU implementation. Be aware that it could require additional software and hardware dependencies.</p> How are numerical and categorical columns differentiated? <p>The columns are separated using a dataframe's select_dtypes method. Numerical columns are selected using <code>include=\"number\"</code> whereas categorical columns are selected using <code>exclude=\"number\"</code>.</p> Can I run unsupervised learning pipelines? <p>No. As for now, ATOM only supports supervised machine learning pipelines. However, various unsupervised algorithms can be chosen as strategy in the Pruner class to detect and remove outliers from the dataset.</p> Is there a way to plot multiple models in the same shap plot? <p>No. Unfortunately, there is no way to plot multiple models in the same shap plot since the plots are made by the shap package and passed as <code>matplotlib.axes</code> objects to atom. This means that it's not within the reach of this package to implement such a utility.</p> Can I merge a sklearn pipeline with atom? <p>Yes. Like any other transformer, it is possible to add a sklearn pipeline to atom using the add method. Every transformer in the pipeline is merged independently. The pipeline is not allowed to end with a model since atom manages its own models. If that is the case, add the pipeline using <code>atom.add(pipeline[:-1])</code>.</p> Is it possible to initialize atom with an existing train and test set? <p>Yes. If you already have a separated train and test set you can initialize atom in two ways:</p> <ul> <li><code>atom = ATOMClassifier(train, test)</code></li> <li><code>atom = ATOMClassifier((X_train, y_train), (X_test, y_test))</code></li> </ul> <p>Make sure the train and test size have the same number of columns! If atom is initialized in any of these two ways, the <code>test_size</code> parameter is ignored.</p> Can I train the models using cross-validation? <p>Applying cross-validation means transforming every step of the pipeline multiple times, each with different results. Doing this would prevent ATOM from being able to show the transformation results after every pre-processing step, which means losing the ability to inspect how a transformer changed the dataset. For this reason, it is not possible to apply cross-validation until after a model has been trained. After a model has been trained, the pipeline is defined, and cross-validation can be applied using the cross_validate method. See here an example using cross-validation.</p> Is there a way to process datetime features? <p>Yes, the FeatureExtractor class can automatically extract useful features (day, month, year, etc...) from datetime columns. The extracted features are always encoded to numerical values, so they can be fed directly to a model.</p>"}, {"location": "getting_started/", "title": "Getting started", "text": ""}, {"location": "getting_started/#installation", "title": "Installation", "text": "<p>Install ATOM's newest release easily via <code>pip</code>:</p> <pre><code>pip install -U atom-ml\n</code></pre> <p>or via <code>conda</code>:</p> <pre><code>conda install -c conda-forge atom-ml\n</code></pre> <p>Note</p> <p>Since atom was already taken, download the package under the name <code>atom-ml</code>!</p> <p>Warning</p> <p>ATOM makes use of many other ML libraries, making its dependency list quite long. Because of that, the installation may take longer than you are accustomed to. Be patient!</p> <p></p> <p>Optional dependencies</p> <p>Some specific models, utility methods or plots require the installation of additional libraries. To install the optional dependencies, add <code>[full]</code> after the package's name.</p> <pre><code>pip install -U atom-ml[full]\n</code></pre> <p></p> <p>Latest source</p> <p>Sometimes, new features and bug fixes are already implemented in the <code>development</code> branch, but waiting for the next release to be made available. If you can't wait for that, it's possible to install the package directly from git.</p> <pre><code>pip install git+https://github.com/tvdboom/ATOM.git@development#egg=atom-ml\n</code></pre> <p>Don't forget to include <code>#egg=atom-ml</code> to explicitly name the project, this way pip can track metadata for it without having to have run the <code>setup.py</code> script.</p> <p></p> <p>Contributing</p> <p>If you are planning to contribute to the project, you'll need the development dependencies. Install them adding <code>[dev]</code> after the package's name.</p> <pre><code>pip install -U atom-ml[dev]\n</code></pre> <p>Click here for a complete list of package files for all versions published on PyPI.</p> <p></p>"}, {"location": "getting_started/#usage", "title": "Usage", "text": "<p>ATOM contains a variety of classes and functions to perform data cleaning, feature engineering, model training, plotting and much more. The easiest way to use everything ATOM has to offer is through one of the main classes:</p> <ul> <li>ATOMClassifier for classification tasks.</li> <li>ATOMForecaster for forecasting tasks.</li> <li>ATOMRegressor for regression tasks.</li> </ul> <p>Let's walk you through an example. Click on the SageMaker Studio Lab badge on top of this section to run this example yourself.</p> <p>Make the necessary imports and load the data.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from atom import ATOMClassifier\n\n&gt;&gt;&gt; # Load the Australian Weather dataset\n&gt;&gt;&gt; X = pd.read_csv(\"./examples/datasets/weatherAUS.csv\", nrows=100)\n&gt;&gt;&gt; print(X.head())\n\n           Location  MinTemp  MaxTemp  Rainfall  Evaporation  Sunshine WindGustDir  WindGustSpeed WindDir9am WindDir3pm  WindSpeed9am  WindSpeed3pm  Humidity9am  Humidity3pm  Pressure9am  Pressure3pm  Cloud9am  Cloud3pm  Temp9am  Temp3pm RainToday  RainTomorrow\n0  MelbourneAirport     18.0     26.9      21.4          7.0       8.9         SSE           41.0          W        SSE           9.0          20.0         95.0         54.0       1019.5       1017.0       8.0       5.0     18.5     26.0       Yes             0\n1          Adelaide     17.2     23.4       0.0          NaN       NaN           S           41.0          S        WSW          13.0          19.0         59.0         36.0       1015.7       1015.7       NaN       NaN     17.7     21.9        No             0\n2            Cairns     18.6     24.6       7.4          3.0       6.1         SSE           54.0        SSE         SE          26.0          35.0         78.0         57.0       1018.7       1016.6       3.0       3.0     20.8     24.1       Yes             0\n3          Portland     13.6     16.8       4.2          1.2       0.0         ESE           39.0        ESE        ESE          17.0          15.0         76.0         74.0       1021.4       1020.5       7.0       8.0     15.6     16.0       Yes             1\n4           Walpole     16.4     19.9       0.0          NaN       NaN          SE           44.0         SE         SE          19.0          30.0         78.0         70.0       1019.4       1018.9       NaN       NaN     17.4     18.1        No             0\n</code></pre> <p>Initialize the ATOMClassifier or ATOMRegressor class. These two classes are convenient wrappers for the whole machine learning pipeline. Contrary to sklearn's API, they are initialized providing the data you want to manipulate.</p> <pre><code>&gt;&gt;&gt; atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (100, 22)\nTrain set size: 80\nTest set size: 20\n-------------------------------------\nMemory: 17.73 kB\nScaled: False\nMissing values: 193 (8.8%)\nCategorical features: 5 (23.8%)\nOutlier values: 1 (0.1%)\n</code></pre> <p>Data transformations are applied through atom's methods. For example, calling the impute method will initialize an Imputer instance, fit it on the training set and transform the whole dataset. The transformations are applied immediately after calling the method (no fit and transform commands necessary).</p> <pre><code>&gt;&gt;&gt; atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\")\n\nFitting Imputer...\nImputing missing values...\n --&gt; Imputing 1 missing values with median (0.0) in column Rainfall.\n --&gt; Imputing 36 missing values with median (4.8) in column Evaporation.\n --&gt; Imputing 38 missing values with median (8.5) in column Sunshine.\n --&gt; Imputing 8 missing values with most_frequent (SSE) in column WindGustDir.\n --&gt; Imputing 8 missing values with median (41.0) in column WindGustSpeed.\n --&gt; Imputing 7 missing values with most_frequent (ESE) in column WindDir9am.\n --&gt; Imputing 2 missing values with median (13.0) in column WindSpeed9am.\n --&gt; Imputing 1 missing values with median (74.0) in column Humidity9am.\n --&gt; Imputing 6 missing values with median (1017.05) in column Pressure9am.\n --&gt; Imputing 6 missing values with median (1015.25) in column Pressure3pm.\n --&gt; Imputing 38 missing values with median (5.0) in column Cloud9am.\n --&gt; Imputing 40 missing values with median (5.0) in column Cloud3pm.\n --&gt; Imputing 1 missing values with median (17.4) in column Temp9am.\n --&gt; Imputing 1 missing values with most_frequent (No) in column RainToday.\n&gt;&gt;&gt; atom.encode(strategy=\"Target\", max_onehot=8)\n\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Target-encoding feature Location. Contains 42 classes.\n   --&gt; Handling 2 unknown classes.\n --&gt; Target-encoding feature WindGustDir. Contains 16 classes.\n --&gt; Target-encoding feature WindDir9am. Contains 16 classes.\n --&gt; Target-encoding feature WindDir3pm. Contains 16 classes.\n --&gt; Ordinal-encoding feature RainToday. Contains 2 classes.\n</code></pre> <p>Similarly, models are trained and evaluated using the run method. Here, we fit both a LogisticRegression and LinearDiscriminantAnalysis model, and apply hyperparameter tuning.</p> <pre><code>&gt;&gt;&gt; atom.run(models=[\"LR\", \"LDA\"], metric=\"auc\", n_trials=6)\n\n\nTraining ========================= &gt;&gt;\nModels: LR, LDA\nMetric: auc\n\n\nRunning hyperparameter tuning for LogisticRegression...\n| trial | penalty |       C |  solver | max_iter | l1_ratio |     auc | best_auc | time_trial | time_ht |    state |\n| ----- | ------- | ------- | ------- | -------- | -------- | ------- | -------- | ---------- | ------- | -------- |\n| 0     |      l2 |  0.0764 |    saga |      630 |      0.0 |  0.4792 |   0.4792 |     0.109s |  0.109s | COMPLETE |\n| 1     |      l2 |  9.4455 |    saga |      480 |      0.5 |   0.375 |   0.4792 |     0.113s |  0.222s | COMPLETE |\n| 2     |      l2 |  0.4188 |     sag |      950 |      0.9 |  0.7708 |   0.7708 |     0.107s |  0.329s | COMPLETE |\n| 3     |    None |  0.0091 |    saga |      400 |      0.5 |  0.6875 |   0.7708 |     0.113s |  0.442s | COMPLETE |\n| 4     |      l2 |  0.4612 |   lbfgs |      830 |      0.0 |     0.5 |   0.7708 |     0.108s |  0.551s | COMPLETE |\n| 5     |      l2 | 10.3363 | newto.. |      980 |      0.7 |  0.6042 |   0.7708 |     0.110s |  0.661s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 2\nBest parameters:\n --&gt; penalty: l2\n --&gt; C: 0.4188\n --&gt; solver: sag\n --&gt; max_iter: 950\n --&gt; l1_ratio: 0.9\nBest evaluation --&gt; auc: 0.7708\nTime elapsed: 0.661s\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.9957\nTest evaluation --&gt; auc: 0.6267\nTime elapsed: 0.165s\n-------------------------------------------------\nTime: 0.826s\n\n\nRunning hyperparameter tuning for LinearDiscriminantAnalysis...\n| trial |  solver | shrinkage |     auc | best_auc | time_trial | time_ht |    state |\n| ----- | ------- | --------- | ------- | -------- | ---------- | ------- | -------- |\n| 0     |   eigen |       0.5 |  0.8125 |   0.8125 |     0.090s |  0.090s | COMPLETE |\n| 1     |   eigen |      auto |  0.2708 |   0.8125 |     0.088s |  0.178s | COMPLETE |\n| 2     |    lsqr |       0.7 |  0.8333 |   0.8333 |     0.083s |  0.261s | COMPLETE |\n| 3     |   eigen |      None |  0.5625 |   0.8333 |     0.083s |  0.344s | COMPLETE |\n| 4     |     svd |      None |  0.7917 |   0.8333 |     0.083s |  0.427s | COMPLETE |\n| 5     |    lsqr |       0.9 |  0.7083 |   0.8333 |     0.084s |  0.511s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 2\nBest parameters:\n --&gt; solver: lsqr\n --&gt; shrinkage: 0.7\nBest evaluation --&gt; auc: 0.8333\nTime elapsed: 0.511s\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.8654\nTest evaluation --&gt; auc: 0.76\nTime elapsed: 0.020s\n-------------------------------------------------\nTime: 0.531s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.391s\n-------------------------------------\nLogisticRegression         --&gt; auc: 0.6267 ~\nLinearDiscriminantAnalysis --&gt; auc: 0.76 !\n</code></pre> <p>And lastly, analyze the results.</p> <pre><code>&gt;&gt;&gt; atom.results\n</code></pre> auc_ht time_ht auc_train auc_test time_fit time LR 0.895833 0.654592 0.963800 0.520000 0.166152 0.820744 LDA 0.958333 0.423385 0.850700 0.800000 0.020018 0.443403 <pre><code>&gt;&gt;&gt; atom.plot_roc()\n</code></pre>"}, {"location": "license/", "title": "MIT License", "text": "<p>Copyright \u00a9 2019-2024 Mavs</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}, {"location": "api/atom/atomclassifier/", "title": "ATOMClassifier", "text": "class atom.api.ATOMClassifier(*arrays, y=-1, index=False, metadata=None, ignore=None, shuffle=True, stratify=-1, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Main class for classification tasks.</p> <p>Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains.</p> <p>All data cleaning, feature engineering, model training and plotting functionality can be accessed from an instance of this class.</p> <p>Parameters *arrays: sequence of indexables Dataset containing features and target. Allowed formats are: <ul> <li>X</li> <li>X, y</li> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>X, train, test: dataframe-like Feature set with shape=(n_samples, n_features).</p> <p>y: int, str, sequence or dataframe-like Target column(s) corresponding to <code>X</code>.</p> <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> y: int, str, sequence or dataframe-like, default=-1 Target column(s) corresponding to <code>X</code>. <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p>This parameter is ignored if the target column is provided through <code>arrays</code>.</p> <p> index: bool, int, str or sequence, default=False Handle the index in the resulting dataframe. <ul> <li>If False: Reset to RangeIndex.</li> <li>If True: Use the provided index.</li> <li>If int: Position of the column to use as index.</li> <li>If str: Name of the column to use as index.</li> <li>If sequence: Array with shape=(n_samples,) to use as index.</li> </ul> <p> metadata: dict or None, default=None Metadata to route to estimators, scorers, and CV splitters. If None, no metadata is used. If dict, the available keys are: <ul> <li>groups: sequence of shape=(n_samples,)     Group labels for the samples used while splitting the     dataset into train and test sets.</li> <li>sample_weight: sequence of shape=(n_samples,)     Individual weights for each sample.</li> </ul> <p> ignore: int, str, sequence or None, default=None Features in X to ignore during data transformations and model training. The features are still used in the remaining methods. <p> test_size: int or float, default=0.2 <ul> <li>If &lt;=1: Fraction of the dataset to include in the test set.</li> <li>If &gt;1: Number of rows to include in the test set.</li> </ul> <p>This parameter is ignored if the test set is provided through <code>arrays</code>.</p> <p>If 'groups' is provided in the <code>metadata</code> parameter, <code>test_size</code> represents the proportion of groups to include in the test split or the absolute number of test groups.</p> <p> holdout_size: int, float or None, default=None <ul> <li>If None: No holdout data set is kept apart.</li> <li>If &lt;=1: Fraction of the dataset to include in the holdout set.</li> <li>If &gt;1: Number of rows to include in the holdout set.</li> </ul> <p>This parameter is ignored if the holdout set is provided through <code>arrays</code>.</p> <p> shuffle: bool, default=True Whether to shuffle the dataset before splitting the data sets. <p> stratify: int, str or None, default=-1 Handle stratification of the target classes over the data sets. <ul> <li>If None: No stratification is applied.</li> <li>If int: Position of the column to use for stratification.</li> <li>If str: Name of the column to use for stratification.</li> </ul> <p>The stratification column can't contain <code>NaN</code> values.</p> <p>This parameter is ignored if <code>shuffle=False</code> or if the test set is provided through <code>arrays</code>.</p> <p> n_rows: int or float, default=1 Random subsample of the dataset to use. The default value selects all rows. <ul> <li>If &lt;=1: Fraction of the dataset to select.</li> <li>If &gt;1: Exact number of rows to select. Only if <code>arrays</code> is X          or X, y.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMForecaster Main class for forecasting tasks.</p> <p>ATOMRegressor Main class for regression tasks.</p> <p></p>"}, {"location": "api/atom/atomclassifier/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Initialize atom\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 138.97 kB\nScaled: False\nOutlier values: 185 (1.3%)\n\n\n&gt;&gt;&gt; # Apply data cleaning and feature engineering methods\n&gt;&gt;&gt; atom.balance(strategy=\"smote\")\n\nOversampling with SMOTE...\n --&gt; Adding 116 samples to class 0.\n&gt;&gt;&gt; atom.feature_selection(strategy=\"rfe\", solver=\"lr\", n_features=22)\n\nFitting FeatureSelector...\nPerforming feature selection ...\n --&gt; rfe selected 22 features from the dataset.\n   --&gt; Dropping feature mean area (rank 4).\n   --&gt; Dropping feature mean compactness (rank 3).\n   --&gt; Dropping feature mean fractal dimension (rank 7).\n   --&gt; Dropping feature smoothness error (rank 9).\n   --&gt; Dropping feature concave points error (rank 5).\n   --&gt; Dropping feature symmetry error (rank 2).\n   --&gt; Dropping feature fractal dimension error (rank 8).\n   --&gt; Dropping feature worst area (rank 6).\n\n&gt;&gt;&gt; # Train models\n&gt;&gt;&gt; atom.run(models=[\"LR\", \"RF\", \"XGB\"])\n\n\nTraining ========================= &gt;&gt;\nModels: LR, RF, XGB\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9861\nTest evaluation --&gt; f1: 0.971\nTime elapsed: 0.188s\n-------------------------------------------------\nTime: 0.188s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.971\nTime elapsed: 0.180s\n-------------------------------------------------\nTime: 0.180s\n\n\nResults for XGBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.971\nTime elapsed: 0.530s\n-------------------------------------------------\nTime: 0.530s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.908s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.971 !\nRandomForest       --&gt; f1: 0.971 !\nXGBoost            --&gt; f1: 0.971 !\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; atom.results\n</code></pre> f1_train f1_test time_fit time LR 0.986100 0.971000 0.188171 0.188171 RF 1.000000 0.971000 0.180164 0.180164 XGB 1.000000 0.971000 0.530483 0.530483"}, {"location": "api/atom/atomclassifier/#magic-methods", "title": "Magic methods", "text": "<p>The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch.</p> <ul> <li>__repr__: Prints an overview of atom's branches, models, and metrics.</li> <li>__len__: Returns the length of the dataset.</li> <li>__iter__: Iterate over the pipeline's transformers.</li> <li>__contains__: Checks if the provided item is a column in the dataset.</li> <li>__getitem__: Access a branch, model, column or subset of the dataset.</li> </ul> <p></p>"}, {"location": "api/atom/atomclassifier/#attributes", "title": "Attributes", "text": ""}, {"location": "api/atom/atomclassifier/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes pipeline: PipelinePipeline of transformers. <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s).  scaled: boolWhether the feature set is scaled. <p>A data set is considered scaled when it has mean~0 and std~1, or when there is a scaler in the pipeline. Categorical and binary columns (only zeros and ones) are excluded from the calculation. Sparse datasets always return False.  duplicates: intNumber of duplicate rows in the dataset.  nans: pd.SeriesColumns with the number of missing values in them. <p>This property is unavailable for sparse datasets.  n_nans: intNumber of rows containing missing values. <p>This property is unavailable for sparse datasets.  numerical: pd.IndexNames of the numerical features in the dataset.  n_numerical: intNumber of numerical features in the dataset.  categorical: pd.IndexNames of the categorical features in the dataset.  n_categorical: intNumber of categorical features in the dataset.  outliers: pd.SeriesColumns in training set with number of outlier values. <p>This property is unavailable for sparse datasets.  n_outliers: intNumber of samples in the training set containing outliers. <p>This property is unavailable for sparse datasets.  classes: pd.DataFrameDistribution of target classes per data set. <p>This property is only available for classification tasks.  n_classes: int | pd.SeriesNumber of classes in the target column(s). <p>This property is only available for classification tasks. </p> <p></p>"}, {"location": "api/atom/atomclassifier/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes pos_label: bool | int | float | strPositive label for binary/multilabel classification tasks.  metadata: BunchMetadata of the dataset. <p>Read more in the user guide.  ignore: tuple[str, ...]Names of the ignored columns. <p>These columns aren't used in the transformer pipeline nor for model training.  missing: list[Any]Values that are considered \"missing\". <p>These values are used by the clean and impute methods. Default values are: None, NaN, NA, NaT, +inf, -inf, \"\", \"?\", \"NA\", \"nan\", \"NaN\", \"NaT\", \"none\", \"None\", \"inf\", \"-inf\". Note that None, NaN, NA, +inf and -inf are always considered missing since they are incompatible with sklearn estimators.  branch: BranchCurrent active branch. <p>Use the property's <code>@setter</code> to change the branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use <code>_from_</code> to split the new branch from any other existing branch. Read more in the user guide.  models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/atom/atomclassifier/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/atom/atomclassifier/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/atom/atomclassifier/#utility-methods", "title": "Utility methods", "text": "<p>Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline.</p> <p>addAdd a transformer to the pipeline.applyApply a function to the dataset.available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.distributionsGet statistics on column distributions.edaCreate an Exploratory Data Analysis report.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_sample_weightReturn sample weights for a balanced data set.inverse_transformInversely transform new data through the pipeline.loadLoad an atom instance from a pickle file.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.resetReset the instance to it's initial state.reset_aestheticsReset the plot aesthetics to their default values.saveSave the instance to a pickle file.save_dataSave the data in the current branch to a <code>.csv</code> file.shrinkConvert the columns to the smallest possible matching dtype.stackingAdd a Stacking model to the pipeline.statsDisplay basic information about the dataset.statusGet an overview of the branches and models.transformTransform new data through the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method add(transformer, columns=None, train_only=False, feature_names_out=None, **fit_params)[source] <p>Add a transformer to the pipeline.</p> <p>If the transformer is not fitted, it is fitted on the complete training set. Afterward, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom.</p> <p>Warning</p> <ul> <li>The transformer should have fit and/or transform methods   with arguments <code>X</code> (accepting a dataframe-like object of   shape=(n_samples, n_features)) and/or <code>y</code> (accepting a   sequence of shape=(n_samples,)).</li> <li>The transform method should return a feature set as a   dataframe-like object of shape=(n_samples, n_features)   and/or a target column as a sequence of shape=(n_samples,).</li> </ul> <p>Note</p> <p>If the transform method doesn't return a dataframe:</p> <ul> <li>The column naming happens as follows. If the transformer   has a <code>get_feature_names_out</code> method, it is used. If not,   and it returns the same number of columns, the names are   kept equal. If the number of columns changes, old columns   will keep their name (as long as the column is unchanged)   and new columns will receive the name <code>x[N-1]</code>, where N   stands for the n-th feature. This means that a transformer   should only transform, add or drop columns, not   combinations of these.</li> <li>The index remains the same as before the transformation.   This means that the transformer should not add, remove or   shuffle rows unless it returns a dataframe.</li> </ul> <p>Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a <code>transform</code> method. If a class is provided (instead of an instance), and it has the <code>n_jobs</code> and/or <code>random_state</code> parameters, it adopts atom's values. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to transform. Only select features or the target column, not both at the same time (if that happens, the target column is ignored). If None, transform all columns. <p> train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. <p> feature_names_out: \"one-to-one\", callable or None, default=None Determines the list of feature names that will be returned by the <code>get_feature_names_out</code> method. <ul> <li>If None: The <code>get_feature_names_out</code> method is not defined.</li> <li>If \"one-to-one\": The output feature names will be equal to   the input feature names.</li> <li>If callable: Function that takes positional arguments self   and a sequence of input feature names. It must return a   sequence of output feature names.</li> </ul> <p> **fit_params Additional keyword arguments for the transformer's fit method. </p> <p></p> <p></p> method apply(func, inverse_func=None, feature_names_out=None, kw_args=None, inv_kw_args=None, **kwargs)[source] <p>Apply a function to the dataset.</p> <p>This method is useful for stateless transformations such as taking the log, doing custom scaling, etc...</p> <p>Note</p> <p>This approach is preferred over changing the dataset directly through the property's <code>@setter</code> since the transformation is stored in the pipeline.</p> <p>Tip</p> <p>Use <code>atom.apply(lambda df: df.drop(\"column_name\",axis=1))</code> to store the removal of columns in the pipeline.</p> <p>Parameters func: callable Function to apply with signature <code>func(dataframe, **kw_args) -&gt; dataframe-like</code>. <p> inverse_func: callable or None, default=None Inverse function of <code>func</code>. If None, the inverse_transform method returns the input unchanged. <p> feature_names_out: \"one-to-one\", callable or None, default=None Determines the list of feature names that will be returned by the <code>get_feature_names_out</code> method. <ul> <li>If None: The <code>get_feature_names_out</code> method is not defined.</li> <li>If \"one-to-one\": The output feature names will be equal to   the input feature names.</li> <li>If callable: Function that takes positional arguments self   and a sequence of input feature names. It must return a   sequence of output feature names.</li> </ul> <p> kw_args: dict or None, default=None Additional keyword arguments for the function. <p> inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. </p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method distributions(distributions=None, columns=None)[source] <p>Get statistics on column distributions.</p> <p>Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored.</p> <p>Tip</p> <p>Use the plot_distribution method to plot a column's distribution.</p> <p>Parameters distributions: str, sequence or None, default=None Names of the distributions in <code>scipy.stats</code> to get the statistics on. If None, a selection of the most common ones is used. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns on which to perform the test. If None, select all numerical columns. <p>Returns pd.DataFrame Statistic results with multiindex levels: <ul> <li>dist: Name of the distribution.</li> <li> <p>stat: Statistic results:</p> <ul> <li>score: KS-test score.</li> <li>p_value: Corresponding p-value. </li> </ul> </li> </ul> <p></p> <p></p> method eda(rows=\"dataset\", target=0, filename=None)[source] <p>Create an Exploratory Data Analysis report.</p> <p>ATOM uses the sweetviz package for EDA. The report is rendered directly in the notebook. It can also be accessed through the <code>report</code> attribute. It can either report one dataset or compare two datasets against each other.</p> <p>Warning</p> <p>This method can be slow for large datasets.</p> <p>Parameters rows: str, sequence or dict, default=\"dataset\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to report.</li> <li>If sequence: Names of two data sets to compare.</li> <li>If dict: Names of up to two data sets with corresponding   selection of rows to report.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. Only bool and numerical features can be used as target. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the (html) file to save. If None, don't save anything. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_sample_weight(rows=\"train\")[source] <p>Return sample weights for a balanced data set.</p> <p>The returned weights are inversely proportional to the class frequencies in the selected data set. For multioutput tasks, the weights of each column of <code>y</code> will be multiplied.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns pd.Series Sequence of weights with shape=(n_samples,). </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column.</p> <p>Parameters X: Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Transformed target column corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.atom.load(filename, data=None)[source] <p>Load an atom instance from a pickle file.</p> <p>If the instance was saved using <code>save_data=False</code>, it's possible to load new data into it and apply all data transformations.</p> <p>Info</p> <p>The loaded instance's current branch is the same branch as it was when saved.</p> <p>Parameters filename: str or Path Filename or pathlib.Path of the pickle file. <p> data: tuple of indexables or None, default=None Original dataset as it was provided to the instance's constructor. Only use this parameter if the loaded file was saved using <code>save_data=False</code>. Allowed formats are: <ul> <li>X</li> <li>X, y</li> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>X, train, test: dataframe-like Feature set with shape=(n_samples, n_features).</p> <p>y: int, str, sequence or dataframe Target column(s) corresponding to <code>X</code>.</p> <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p>Returns atom Unpickled atom instance. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> method reset(hard=False)[source] <p>Reset the instance to it's initial state.</p> <p>Deletes all branches and models. The dataset is also reset to its form after initialization.</p> <p>Parameters hard: bool, default=False If True, flushes completely the cache. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method save_data(filename=\"auto\", rows=\"dataset\", **kwargs)[source] <p>Save the data in the current branch to a <code>.csv</code> file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> rows: hashable, segment, sequence or dataframe, default=\"dataset\" Selection of rows to save. <p> **kwargs Additional keyword arguments for pandas' to_csv method. </p> <p></p> <p></p> method shrink(int2bool=False, int2uint=False, str2cat=False, dense2sparse=False, columns=None)[source] <p>Convert the columns to the smallest possible matching dtype.</p> <p>Examples are: float64 -&gt; float32, int64 -&gt; int8, etc... Sparse arrays also transform their non-fill value. Use this method for memory optimization before saving the dataset. Note that applying transformers to the data may alter the types again.</p> <p>Parameters int2bool: bool, default=False Whether to convert <code>int</code> columns to <code>bool</code> type. Only if the values in the column are strictly in (0, 1) or (-1, 1). <p> int2uint: bool, default=False Whether to convert <code>int</code> to <code>uint</code> (unsigned integer). Only if the values in the column are strictly positive. <p> str2cat: bool, default=False Whether to convert <code>string</code> to <code>category</code>. Only if the number of categories is less than 30% of the column's length. <p> dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to shrink. If None, transform all columns. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method stats()[source] <p>Display basic information about the dataset.</p> <p></p> <p></p> method status()[source] <p>Get an overview of the branches and models.</p> <p>This method prints the same information as the __repr__ and also saves it to the logger.</p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p> <p></p>"}, {"location": "api/atom/atomclassifier/#data-cleaning", "title": "Data cleaning", "text": "<p>The data cleaning methods can help you scale the data, handle missing values, categorical columns, outliers and unbalanced datasets. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide.</p> <p>Tip</p> <p>Use the eda method to examine the data and help you determine suitable parameters for the data cleaning methods.</p> <p>balanceBalance the number of rows per class in the target column.cleanApply standard data cleaning steps on the dataset.discretizeBin continuous data into intervals.encodePerform encoding of categorical features.imputeHandle missing values in the dataset.normalizeTransform the data to follow a Normal/Gaussian distribution.prunePrune outliers from the training set.scaleScale the data.</p> <p></p> <p></p> method balance(strategy=\"adasyn\", **kwargs)[source] <p>Balance the number of rows per class in the target column.</p> <p>When oversampling, the newly created samples have an increasing integer index for numerical indices, and an index of the form [estimator]_N for non-numerical indices, where N stands for the N-th sample in the data set.</p> <p>See the Balancer class for a description of the parameters.</p> <p>Warning</p> <ul> <li>The balance method does not support multioutput tasks.</li> <li>The balance method does not support <code>sample_weights</code> passed   through metadata routing.</li> <li>This transformation is only applied to the training set   to maintain the original distribution of target classes   in the test set.</li> </ul> <p>Tip</p> <p>Use atom's classes attribute for an overview of the target class distribution per data set.</p> <p></p> <p></p> method clean(convert_dtypes=True, drop_dtypes=None, drop_chars=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs)[source] <p>Apply standard data cleaning steps on the dataset.</p> <p>Use the parameters to choose which transformations to perform. The available steps are:</p> <ul> <li>Convert dtypes to the best possible types.</li> <li>Drop columns with specific data types.</li> <li>Remove characters from column names.</li> <li>Strip categorical features from spaces.</li> <li>Drop duplicate rows.</li> <li>Drop rows with missing values in the target column.</li> <li>Encode the target column (only for classification tasks).</li> </ul> <p>See the Cleaner class for a description of the parameters.</p> <p></p> <p></p> method discretize(strategy=\"quantile\", bins=5, labels=None, **kwargs)[source] <p>Bin continuous data into intervals.</p> <p>For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns.</p> <p>See the Discretizer class for a description of the parameters.</p> <p>Tip</p> <p>Use the plot_distribution method to visualize a column's distribution and decide on the bins.</p> <p></p> <p></p> method encode(strategy=\"Target\", max_onehot=10, ordinal=None, infrequent_to_value=None, value=\"infrequent\", **kwargs)[source] <p>Perform encoding of categorical features.</p> <p>The encoding type depends on the number of classes in the column:</p> <ul> <li>If n_classes=2 or ordinal feature, use Ordinal-encoding.</li> <li>If 2 &lt; n_classes &lt;= <code>max_onehot</code>, use OneHot-encoding.</li> <li>If n_classes &gt; <code>max_onehot</code>, use <code>strategy</code>-encoding.</li> </ul> <p>Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality.</p> <p>See the Encoder class for a description of the parameters.</p> <p>Note</p> <p>This method only encodes the categorical features. It does not encode the target column! Use the clean method for that.</p> <p>Tip</p> <p>Use the categorical attribute for a list of the categorical features in the dataset.</p> <p></p> <p></p> method impute(strat_num=\"mean\", strat_cat=\"most_frequent\", max_nan_rows=None, max_nan_cols=None, **kwargs)[source] <p>Handle missing values in the dataset.</p> <p>Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values.</p> <p>See the Imputer class for a description of the parameters.</p> <p>Tip</p> <ul> <li>Use the nans attribute to check the amount of   missing values per column.</li> <li>Use the <code>missing</code> attribute to customize   what are considered \"missing values\".</li> </ul> <p></p> <p></p> method normalize(strategy=\"yeojohnson\", **kwargs)[source] <p>Transform the data to follow a Normal/Gaussian distribution.</p> <p>This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns.</p> <p>See the Normalizer class for a description of the parameters.</p> <p>Tip</p> <p>Use the plot_distribution method to examine a column's distribution.</p> <p></p> <p></p> method prune(strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs)[source] <p>Prune outliers from the training set.</p> <p>Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns.</p> <p>See the Pruner class for a description of the parameters.</p> <p>Note</p> <p>This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set.</p> <p>Tip</p> <p>Use the outliers attribute to check the number of outliers per column.</p> <p></p> <p></p> method scale(strategy=\"standard\", include_binary=False, **kwargs)[source] <p>Scale the data.</p> <p>Apply one of sklearn's scaling strategies. Categorical columns are ignored.</p> <p>See the Scaler class for a description of the parameters.</p> <p>Tip</p> <p>Use the scaled attribute to check whether the dataset is scaled.</p> <p></p> <p></p>"}, {"location": "api/atom/atomclassifier/#nlp", "title": "NLP", "text": "<p>The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called <code>corpus</code>. Read more in the user guide.</p> <p>textcleanApply standard text cleaning to the corpus.textnormalizeNormalize the corpus.tokenizeTokenize the corpus.vectorizeVectorize the corpus.</p> <p></p> <p></p> method textclean(decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs)[source] <p>Apply standard text cleaning to the corpus.</p> <p>Transformations include normalizing characters and drop noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised.</p> <p>See the TextCleaner class for a description of the parameters.</p> <p></p> <p></p> method textnormalize(stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs)[source] <p>Normalize the corpus.</p> <p>Convert words to a more uniform standard. The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces.</p> <p>See the TextNormalizer class for a description of the parameters.</p> <p></p> <p></p> method tokenize(bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs)[source] <p>Tokenize the corpus.</p> <p>Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g., \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>See the Tokenizer class for a description of the parameters.</p> <p></p> <p></p> method vectorize(strategy=\"bow\", return_sparse=True, **kwargs)[source] <p>Vectorize the corpus.</p> <p>Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix <code>corpus_</code>. If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column.</p> <p>See the Vectorizer class for a description of the parameters.</p> <p></p> <p></p>"}, {"location": "api/atom/atomclassifier/#feature-engineering", "title": "Feature engineering", "text": "<p>To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide.</p> <p>feature_extractionExtract features from datetime columns.feature_generationGenerate new features.feature_groupingExtract statistics from similar features.feature_selectionReduce the number of features in the data.</p> <p></p> <p></p> method feature_extraction(features=('day', 'month', 'year'), fmt=None, encoding_type=\"ordinal\", drop_columns=True, from_index=False, **kwargs)[source] <p>Extract features from datetime columns.</p> <p>Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype <code>datetime64</code> are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used.</p> <p>See the FeatureExtractor class for a description of the parameters.</p> <p></p> <p></p> method feature_generation(strategy=\"dfs\", n_features=None, operators=None, **kwargs)[source] <p>Generate new features.</p> <p>Create new combinations of existing features to capture the non-linear relations between the original features.</p> <p>See the FeatureGenerator class for a description of the parameters.</p> <p></p> <p></p> method feature_grouping(groups, operators=None, drop_columns=True, **kwargs)[source] <p>Extract statistics from similar features.</p> <p>Replace groups of features with related characteristics with new features that summarize statistical properties of the group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the <code>groups</code> method.</p> <p>See the FeatureGrouper class for a description of the parameters.</p> <p>Tip</p> <p>Use a regex pattern with the <code>groups</code> parameter to select groups easier, e.g., <code>atom.feature_grouping({\"group1\": \"var_.+\")</code> to select all features that start with <code>var_</code>.</p> <p></p> <p></p> method feature_selection(strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs)[source] <p>Reduce the number of features in the data.</p> <p>Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low-variance features.</p> <p>See the FeatureSelector class for a description of the parameters.</p> <p>Note</p> <ul> <li>When strategy=\"univariate\" and solver=None, f_classif   or f_regression is used as default solver.</li> <li>When strategy is \"sfs\", \"rfecv\" or any of the   advanced strategies and no scoring is specified,   atom's metric (if it exists) is used as scoring.</li> </ul> <p></p> <p></p>"}, {"location": "api/atom/atomclassifier/#training", "title": "Training", "text": "<p>The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide.</p> <p>runTrain and evaluate the models in a direct fashion.successive_halvingFit the models in a successive halving fashion.train_sizingTrain and evaluate the models in a train sizing fashion.</p> <p></p> <p></p> method run(models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Train and evaluate the models in a direct fashion.</p> <p>Contrary to successive_halving and train_sizing, the direct approach only iterates once over the models, using the full dataset.</p> <p>The following steps are applied to every model:</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the DirectClassifier or DirectRegressor class for a description of the parameters.</p> <p></p> <p></p> method successive_halving(models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Fit the models in a successive halving fashion.</p> <p>The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g., only using tree-based models.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters.</p> <p></p> <p></p> method train_sizing(models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Train and evaluate the models in a train sizing fashion.</p> <p>When training models, there is usually a trade-off between model performance and computation time; that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.</p> <p></p>"}, {"location": "api/atom/atomforecaster/", "title": "ATOMForecaster", "text": "class atom.api.ATOMForecaster(*arrays, y=-1, metadata=None, ignore=None, sp=None, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Main class for forecasting tasks.</p> <p>Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains.</p> <p>All data cleaning, feature engineering, model training and plotting functionality can be accessed from an instance of this class.</p> <p>Parameters *arrays: sequence of indexables Dataset containing exogenous features and time series. Allowed formats are: <ul> <li>X</li> <li>y</li> <li>X, y</li> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>X, train, test: dataframe-like Exogenous feature set corresponding to y, with shape=(n_samples, n_features).</p> <p>y: int, str, sequence or dataframe-like Time series.</p> <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> y: int, str, sequence or dataframe-like, default=-1 Time series. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p>This parameter is ignored if the time series is provided through <code>arrays</code>.</p> <p> metadata: dict or None, default=None Metadata to route to estimators, scorers, and CV splitters. If None, no metadata is used. If dict, the available keys are: <ul> <li>sample_weight: sequence of shape=(n_samples,)     Individual weights for each sample.</li> </ul> <p> ignore: int, str, sequence or None, default=None Exogenous features in X to ignore during data transformations and model training. The features are still used in the remaining methods. <p> sp: int, str, sequence, dict or None, default=None Seasonality of the time series. <ul> <li>If None: No seasonality.</li> <li>If int: Seasonal period, e.g., 7 for weekly data, and 12 for   monthly data. The value must be &gt;=2.</li> <li> <p>If str:</p> <ul> <li>Seasonal period provided as PeriodAlias, e.g., \"M\" for   12 or \"H\" for 24.</li> <li>\"index\": The frequency of the data index is mapped to a   seasonal period.</li> <li>\"infer\": Automatically infer the seasonal period from the   data (calls get_seasonal_period   under the hood, using default parameters).</li> </ul> </li> <li> <p>If sequence: Multiple seasonal periods provided as int or str.</p> </li> <li> <p>If dict: Dictionary with keys:</p> <ul> <li>\"sp\": Seasonal period provided as one of the aforementioned   options.</li> <li>\"seasonal_model\" (optional): \"additive\" or \"multiplicative\".</li> <li>\"trend_model\" (optional): \"additive\" or \"multiplicative\".</li> </ul> </li> </ul> <p> test_size: int or float, default=0.2 <ul> <li>If &lt;=1: Fraction of the dataset to include in the test set.</li> <li>If &gt;1: Number of rows to include in the test set.</li> </ul> <p>This parameter is ignored if the test set is provided through <code>arrays</code>.</p> <p> holdout_size: int, float or None, default=None <ul> <li>If None: No holdout data set is kept apart.</li> <li>If &lt;=1: Fraction of the dataset to include in the holdout set.</li> <li>If &gt;1: Number of rows to include in the holdout set.</li> </ul> <p>This parameter is ignored if the holdout set is provided through <code>arrays</code>.</p> <p> n_rows: int or float, default=1 Subsample of the dataset to use. The cut is made from the head of the dataset (older entries are dropped when sorted by date ascending). The default value selects all rows. <ul> <li>If &lt;=1: Fraction of the dataset to select.</li> <li>If &gt;1: Exact number of rows to select. Only if <code>arrays</code> is X          or X, y.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMClassifier Main class for classification tasks.</p> <p>ATOMRegressor Main class for regression tasks.</p> <p></p>"}, {"location": "api/atom/atomforecaster/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; # Initialize atom\n&gt;&gt;&gt; atom = ATOMForecaster(y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Univariate forecast.\n\nDataset stats ==================== &gt;&gt;\nShape: (144, 1)\nTrain set size: 116\n --&gt; From: 1949-01  To: 1958-08\nTest set size: 28\n --&gt; From: 1958-09  To: 1960-12\n-------------------------------------\nMemory: 6.47 kB\nDuplicates: 26 (18.1%)\n\n\n&gt;&gt;&gt; # Train models\n&gt;&gt;&gt; atom.run(models=[\"NF\", \"ES\", \"ETS\"])\n\n\nTraining ========================= &gt;&gt;\nModels: NF, ES, ETS\nMetric: mape\n\n\nResults for NaiveForecaster:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0858\nTest evaluation --&gt; mape: -0.2305\nTime elapsed: 0.028s\n-------------------------------------------------\nTime: 0.028s\n\n\nResults for ExponentialSmoothing:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0864\nTest evaluation --&gt; mape: -0.2303\nTime elapsed: 0.024s\n-------------------------------------------------\nTime: 0.024s\n\n\nResults for ETS:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0858\nTest evaluation --&gt; mape: -0.2305\nTime elapsed: 0.025s\n-------------------------------------------------\nTime: 0.025s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.081s\n-------------------------------------\nNaiveForecaster      --&gt; mape: -0.2305\nExponentialSmoothing --&gt; mape: -0.2303 !\nETS                  --&gt; mape: -0.2305\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; atom.results\n</code></pre> mape_train mape_test time_fit time NF -0.085800 -0.230500 0.028026 0.028026 ES -0.086400 -0.230300 0.024021 0.024021 ETS -0.085800 -0.230500 0.025023 0.025023"}, {"location": "api/atom/atomforecaster/#magic-methods", "title": "Magic methods", "text": "<p>The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch.</p> <ul> <li>__repr__: Prints an overview of atom's branches, models, and metrics.</li> <li>__len__: Returns the length of the dataset.</li> <li>__iter__: Iterate over the pipeline's transformers.</li> <li>__contains__: Checks if the provided item is a column in the dataset.</li> <li>__getitem__: Access a branch, model, column or subset of the dataset.</li> </ul> <p></p>"}, {"location": "api/atom/atomforecaster/#attributes", "title": "Attributes", "text": ""}, {"location": "api/atom/atomforecaster/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes pipeline: PipelinePipeline of transformers. <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s).  scaled: boolWhether the feature set is scaled. <p>A data set is considered scaled when it has mean~0 and std~1, or when there is a scaler in the pipeline. Categorical and binary columns (only zeros and ones) are excluded from the calculation. Sparse datasets always return False.  duplicates: intNumber of duplicate rows in the dataset.  nans: pd.SeriesColumns with the number of missing values in them. <p>This property is unavailable for sparse datasets.  n_nans: intNumber of rows containing missing values. <p>This property is unavailable for sparse datasets.  numerical: pd.IndexNames of the numerical features in the dataset.  n_numerical: intNumber of numerical features in the dataset.  categorical: pd.IndexNames of the categorical features in the dataset.  n_categorical: intNumber of categorical features in the dataset.  outliers: pd.SeriesColumns in training set with number of outlier values. <p>This property is unavailable for sparse datasets.  n_outliers: intNumber of samples in the training set containing outliers. <p>This property is unavailable for sparse datasets. </p> <p></p>"}, {"location": "api/atom/atomforecaster/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes metadata: BunchMetadata of the dataset. <p>Read more in the user guide.  ignore: tuple[str, ...]Names of the ignored columns. <p>These columns aren't used in the transformer pipeline nor for model training.  missing: list[Any]Values that are considered \"missing\". <p>These values are used by the clean and impute methods. Default values are: None, NaN, NA, NaT, +inf, -inf, \"\", \"?\", \"NA\", \"nan\", \"NaN\", \"NaT\", \"none\", \"None\", \"inf\", \"-inf\". Note that None, NaN, NA, +inf and -inf are always considered missing since they are incompatible with sklearn estimators.  sp: BunchSeasonality of the time series. <p>Read more about seasonality in the user guide.  branch: BranchCurrent active branch. <p>Use the property's <code>@setter</code> to change the branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use <code>_from_</code> to split the new branch from any other existing branch. Read more in the user guide.  models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/atom/atomforecaster/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/atom/atomforecaster/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/atom/atomforecaster/#utility-methods", "title": "Utility methods", "text": "<p>Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline.</p> <p>addAdd a transformer to the pipeline.applyApply a function to the dataset.available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.checksGet statistics on stationarity and white noise.clearReset attributes and clear cache from all models.deleteDelete models.distributionsGet statistics on column distributions.decomposeDetrend and deseasonalize the time series.edaCreate an Exploratory Data Analysis report.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_sample_weightReturn sample weights for a balanced data set.get_seasonal_periodGet the seasonal periods of the time series.inverse_transformInversely transform new data through the pipeline.loadLoad an atom instance from a pickle file.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.resetReset the instance to it's initial state.reset_aestheticsReset the plot aesthetics to their default values.saveSave the instance to a pickle file.save_dataSave the data in the current branch to a <code>.csv</code> file.shrinkConvert the columns to the smallest possible matching dtype.stackingAdd a Stacking model to the pipeline.statsDisplay basic information about the dataset.statusGet an overview of the branches and models.transformTransform new data through the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method add(transformer, columns=None, train_only=False, feature_names_out=None, **fit_params)[source] <p>Add a transformer to the pipeline.</p> <p>If the transformer is not fitted, it is fitted on the complete training set. Afterward, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom.</p> <p>Warning</p> <ul> <li>The transformer should have fit and/or transform methods   with arguments <code>X</code> (accepting a dataframe-like object of   shape=(n_samples, n_features)) and/or <code>y</code> (accepting a   sequence of shape=(n_samples,)).</li> <li>The transform method should return a feature set as a   dataframe-like object of shape=(n_samples, n_features)   and/or a target column as a sequence of shape=(n_samples,).</li> </ul> <p>Note</p> <p>If the transform method doesn't return a dataframe:</p> <ul> <li>The column naming happens as follows. If the transformer   has a <code>get_feature_names_out</code> method, it is used. If not,   and it returns the same number of columns, the names are   kept equal. If the number of columns changes, old columns   will keep their name (as long as the column is unchanged)   and new columns will receive the name <code>x[N-1]</code>, where N   stands for the n-th feature. This means that a transformer   should only transform, add or drop columns, not   combinations of these.</li> <li>The index remains the same as before the transformation.   This means that the transformer should not add, remove or   shuffle rows unless it returns a dataframe.</li> </ul> <p>Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a <code>transform</code> method. If a class is provided (instead of an instance), and it has the <code>n_jobs</code> and/or <code>random_state</code> parameters, it adopts atom's values. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to transform. Only select features or the target column, not both at the same time (if that happens, the target column is ignored). If None, transform all columns. <p> train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. <p> feature_names_out: \"one-to-one\", callable or None, default=None Determines the list of feature names that will be returned by the <code>get_feature_names_out</code> method. <ul> <li>If None: The <code>get_feature_names_out</code> method is not defined.</li> <li>If \"one-to-one\": The output feature names will be equal to   the input feature names.</li> <li>If callable: Function that takes positional arguments self   and a sequence of input feature names. It must return a   sequence of output feature names.</li> </ul> <p> **fit_params Additional keyword arguments for the transformer's fit method. </p> <p></p> <p></p> method apply(func, inverse_func=None, feature_names_out=None, kw_args=None, inv_kw_args=None, **kwargs)[source] <p>Apply a function to the dataset.</p> <p>This method is useful for stateless transformations such as taking the log, doing custom scaling, etc...</p> <p>Note</p> <p>This approach is preferred over changing the dataset directly through the property's <code>@setter</code> since the transformation is stored in the pipeline.</p> <p>Tip</p> <p>Use <code>atom.apply(lambda df: df.drop(\"column_name\",axis=1))</code> to store the removal of columns in the pipeline.</p> <p>Parameters func: callable Function to apply with signature <code>func(dataframe, **kw_args) -&gt; dataframe-like</code>. <p> inverse_func: callable or None, default=None Inverse function of <code>func</code>. If None, the inverse_transform method returns the input unchanged. <p> feature_names_out: \"one-to-one\", callable or None, default=None Determines the list of feature names that will be returned by the <code>get_feature_names_out</code> method. <ul> <li>If None: The <code>get_feature_names_out</code> method is not defined.</li> <li>If \"one-to-one\": The output feature names will be equal to   the input feature names.</li> <li>If callable: Function that takes positional arguments self   and a sequence of input feature names. It must return a   sequence of output feature names.</li> </ul> <p> kw_args: dict or None, default=None Additional keyword arguments for the function. <p> inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. </p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method checks(columns=None)[source] <p>Get statistics on stationarity and white noise.</p> <p>Compute various statistical test to check for stationarity and white noise against a column in the dataset. Only for numerical columns. Missing values are ignored. The performed tests are:</p> <ul> <li>Augmented Dickey-Fuller test (adf) for difference   stationarity.</li> <li>Kwiatkowski-Phillips-Schmidt-Shin test (kpss) for   trend stationarity.</li> <li>Ljung-Box test (lb). The lag in the autocorrelation   function with the minimum p-value is returned. If the p-value   is larger than 0.05, it suggests the data is consistent with   white noise.</li> </ul> <p>Tip</p> <p>Use the plot_acf and plot_acf methods to visually inspect any significant lagged correlations.</p> <p>Parameters columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns on which to perform the tests. If None, it uses the target column. <p>Returns pd.DataFrame Statistic results with multiindex levels: <ul> <li>test: Acronym of the test ('adf', 'kpss' or 'lb').</li> <li> <p>stat: Statistic results:</p> <ul> <li>score: KS-test score.</li> <li>p_value: Corresponding p-value. </li> </ul> </li> </ul> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method distributions(distributions=None, columns=None)[source] <p>Get statistics on column distributions.</p> <p>Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored.</p> <p>Tip</p> <p>Use the plot_distribution method to plot a column's distribution.</p> <p>Parameters distributions: str, sequence or None, default=None Names of the distributions in <code>scipy.stats</code> to get the statistics on. If None, a selection of the most common ones is used. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns on which to perform the test. If None, select all numerical columns. <p>Returns pd.DataFrame Statistic results with multiindex levels: <ul> <li>dist: Name of the distribution.</li> <li> <p>stat: Statistic results:</p> <ul> <li>score: KS-test score.</li> <li>p_value: Corresponding p-value. </li> </ul> </li> </ul> <p></p> <p></p> method decompose(model=None, test_seasonality=True, **kwargs)[source] <p>Detrend and deseasonalize the time series.</p> <p>This class does two things:</p> <ul> <li>Remove the trend from every column, returning the in-sample   residuals of the model's predicted values.</li> <li>Remove the seasonal component from every column, subject to   a seasonaility test.</li> </ul> <p>Categorical columns are ignored.</p> <p>See the Decomposer class for a description of the parameters. ATOM automatically injects the <code>sp</code>, <code>trend_model</code> and <code>seasonal_model</code> parameters of the class. See the seasonality section in the user guide to learn how to adjust these values.</p> <p>Tip</p> <ul> <li>Use the <code>columns</code> parameter to only decompose the target   column, e.g., <code>atom.decompose(columns=atom.target)</code>.</li> <li>Use the plot_decomposition method to visualize the   trend, seasonality and residuals of the time series.</li> </ul> <p></p> <p></p> method eda(rows=\"dataset\", target=0, filename=None)[source] <p>Create an Exploratory Data Analysis report.</p> <p>ATOM uses the sweetviz package for EDA. The report is rendered directly in the notebook. It can also be accessed through the <code>report</code> attribute. It can either report one dataset or compare two datasets against each other.</p> <p>Warning</p> <p>This method can be slow for large datasets.</p> <p>Parameters rows: str, sequence or dict, default=\"dataset\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to report.</li> <li>If sequence: Names of two data sets to compare.</li> <li>If dict: Names of up to two data sets with corresponding   selection of rows to report.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. Only bool and numerical features can be used as target. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the (html) file to save. If None, don't save anything. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_sample_weight(rows=\"train\")[source] <p>Return sample weights for a balanced data set.</p> <p>The returned weights are inversely proportional to the class frequencies in the selected data set. For multioutput tasks, the weights of each column of <code>y</code> will be multiplied.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns pd.Series Sequence of weights with shape=(n_samples,). </p> <p></p> <p></p> method get_seasonal_period(max_sp=None, harmonics=None, target=0)[source] <p>Get the seasonal periods of the time series.</p> <p>Use the data in the training set to calculate the seasonal period. The data is internally differentiated before the seasonality is detected using ACF.</p> <p>Tip</p> <p>Read more about seasonality in the user guide.</p> <p>Parameters max_sp: int or None, default=None Maximum seasonal period to consider. If None, the maximum period is given by <code>(len(y_train) - 1) // 2</code>. <p> harmonics: str or None, default=None Defines the strategy on how to deal with harmonics from the detected seasonal periods. Choose from the following options: <ul> <li>None: The detected seasonal periods are left unchanged   (no harmonic removal).</li> <li>\"drop\": Remove all harmonics.</li> <li>\"raw_strength\": Keep the highest order harmonics, maintaining   the order of significance.</li> <li>\"harmonic_strength\": Replace seasonal periods with their highest   harmonic.</li> </ul> <p>E.g., if the detected seasonal periods in strength order are <code>[2, 3, 4, 7, 8]</code> (note that 4 and 8 are harmonics of 2), then:</p> <ul> <li>If \"drop\", result=[2, 3, 7]</li> <li>If \"raw_strength\", result=[3, 7, 8]</li> <li>If \"harmonic_strength\", result=[8, 3, 7]</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multivariate tasks. <p>Returns int or list of int Seasonal periods, ordered by significance. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column.</p> <p>Parameters X: Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Transformed target column corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.atom.load(filename, data=None)[source] <p>Load an atom instance from a pickle file.</p> <p>If the instance was saved using <code>save_data=False</code>, it's possible to load new data into it and apply all data transformations.</p> <p>Info</p> <p>The loaded instance's current branch is the same branch as it was when saved.</p> <p>Parameters filename: str or Path Filename or pathlib.Path of the pickle file. <p> data: tuple of indexables or None, default=None Original dataset as it was provided to the instance's constructor. Only use this parameter if the loaded file was saved using <code>save_data=False</code>. Allowed formats are: <ul> <li>X</li> <li>X, y</li> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>X, train, test: dataframe-like Feature set with shape=(n_samples, n_features).</p> <p>y: int, str, sequence or dataframe Target column(s) corresponding to <code>X</code>.</p> <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p>Returns atom Unpickled atom instance. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> method reset(hard=False)[source] <p>Reset the instance to it's initial state.</p> <p>Deletes all branches and models. The dataset is also reset to its form after initialization.</p> <p>Parameters hard: bool, default=False If True, flushes completely the cache. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method save_data(filename=\"auto\", rows=\"dataset\", **kwargs)[source] <p>Save the data in the current branch to a <code>.csv</code> file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> rows: hashable, segment, sequence or dataframe, default=\"dataset\" Selection of rows to save. <p> **kwargs Additional keyword arguments for pandas' to_csv method. </p> <p></p> <p></p> method shrink(int2bool=False, int2uint=False, str2cat=False, dense2sparse=False, columns=None)[source] <p>Convert the columns to the smallest possible matching dtype.</p> <p>Examples are: float64 -&gt; float32, int64 -&gt; int8, etc... Sparse arrays also transform their non-fill value. Use this method for memory optimization before saving the dataset. Note that applying transformers to the data may alter the types again.</p> <p>Parameters int2bool: bool, default=False Whether to convert <code>int</code> columns to <code>bool</code> type. Only if the values in the column are strictly in (0, 1) or (-1, 1). <p> int2uint: bool, default=False Whether to convert <code>int</code> to <code>uint</code> (unsigned integer). Only if the values in the column are strictly positive. <p> str2cat: bool, default=False Whether to convert <code>string</code> to <code>category</code>. Only if the number of categories is less than 30% of the column's length. <p> dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to shrink. If None, transform all columns. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method stats()[source] <p>Display basic information about the dataset.</p> <p></p> <p></p> method status()[source] <p>Get an overview of the branches and models.</p> <p>This method prints the same information as the __repr__ and also saves it to the logger.</p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p> <p></p>"}, {"location": "api/atom/atomforecaster/#data-cleaning", "title": "Data cleaning", "text": "<p>The data cleaning methods can help you scale the data, handle missing values, categorical columns and outliers. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide.</p> <p>Tip</p> <p>Use the eda method to examine the data and help you determine suitable parameters for the data cleaning methods.</p> <p>cleanApply standard data cleaning steps on the dataset.discretizeBin continuous data into intervals.encodePerform encoding of categorical features.imputeHandle missing values in the dataset.normalizeTransform the data to follow a Normal/Gaussian distribution.prunePrune outliers from the training set.scaleScale the data.</p> <p></p> <p></p> method clean(convert_dtypes=True, drop_dtypes=None, drop_chars=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs)[source] <p>Apply standard data cleaning steps on the dataset.</p> <p>Use the parameters to choose which transformations to perform. The available steps are:</p> <ul> <li>Convert dtypes to the best possible types.</li> <li>Drop columns with specific data types.</li> <li>Remove characters from column names.</li> <li>Strip categorical features from spaces.</li> <li>Drop duplicate rows.</li> <li>Drop rows with missing values in the target column.</li> <li>Encode the target column (only for classification tasks).</li> </ul> <p>See the Cleaner class for a description of the parameters.</p> <p></p> <p></p> method discretize(strategy=\"quantile\", bins=5, labels=None, **kwargs)[source] <p>Bin continuous data into intervals.</p> <p>For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns.</p> <p>See the Discretizer class for a description of the parameters.</p> <p>Tip</p> <p>Use the plot_distribution method to visualize a column's distribution and decide on the bins.</p> <p></p> <p></p> method encode(strategy=\"Target\", max_onehot=10, ordinal=None, infrequent_to_value=None, value=\"infrequent\", **kwargs)[source] <p>Perform encoding of categorical features.</p> <p>The encoding type depends on the number of classes in the column:</p> <ul> <li>If n_classes=2 or ordinal feature, use Ordinal-encoding.</li> <li>If 2 &lt; n_classes &lt;= <code>max_onehot</code>, use OneHot-encoding.</li> <li>If n_classes &gt; <code>max_onehot</code>, use <code>strategy</code>-encoding.</li> </ul> <p>Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality.</p> <p>See the Encoder class for a description of the parameters.</p> <p>Note</p> <p>This method only encodes the categorical features. It does not encode the target column! Use the clean method for that.</p> <p>Tip</p> <p>Use the categorical attribute for a list of the categorical features in the dataset.</p> <p></p> <p></p> method impute(strat_num=\"mean\", strat_cat=\"most_frequent\", max_nan_rows=None, max_nan_cols=None, **kwargs)[source] <p>Handle missing values in the dataset.</p> <p>Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values.</p> <p>See the Imputer class for a description of the parameters.</p> <p>Tip</p> <ul> <li>Use the nans attribute to check the amount of   missing values per column.</li> <li>Use the <code>missing</code> attribute to customize   what are considered \"missing values\".</li> </ul> <p></p> <p></p> method normalize(strategy=\"yeojohnson\", **kwargs)[source] <p>Transform the data to follow a Normal/Gaussian distribution.</p> <p>This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns.</p> <p>See the Normalizer class for a description of the parameters.</p> <p>Tip</p> <p>Use the plot_distribution method to examine a column's distribution.</p> <p></p> <p></p> method prune(strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs)[source] <p>Prune outliers from the training set.</p> <p>Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns.</p> <p>See the Pruner class for a description of the parameters.</p> <p>Note</p> <p>This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set.</p> <p>Tip</p> <p>Use the outliers attribute to check the number of outliers per column.</p> <p></p> <p></p> method scale(strategy=\"standard\", include_binary=False, **kwargs)[source] <p>Scale the data.</p> <p>Apply one of sklearn's scaling strategies. Categorical columns are ignored.</p> <p>See the Scaler class for a description of the parameters.</p> <p>Tip</p> <p>Use the scaled attribute to check whether the dataset is scaled.</p> <p></p> <p></p>"}, {"location": "api/atom/atomforecaster/#nlp", "title": "NLP", "text": "<p>The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called <code>corpus</code>. Read more in the user guide.</p> <p>textcleanApply standard text cleaning to the corpus.textnormalizeNormalize the corpus.tokenizeTokenize the corpus.vectorizeVectorize the corpus.</p> <p></p> <p></p> method textclean(decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs)[source] <p>Apply standard text cleaning to the corpus.</p> <p>Transformations include normalizing characters and drop noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised.</p> <p>See the TextCleaner class for a description of the parameters.</p> <p></p> <p></p> method textnormalize(stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs)[source] <p>Normalize the corpus.</p> <p>Convert words to a more uniform standard. The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces.</p> <p>See the TextNormalizer class for a description of the parameters.</p> <p></p> <p></p> method tokenize(bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs)[source] <p>Tokenize the corpus.</p> <p>Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g., \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>See the Tokenizer class for a description of the parameters.</p> <p></p> <p></p> method vectorize(strategy=\"bow\", return_sparse=True, **kwargs)[source] <p>Vectorize the corpus.</p> <p>Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix <code>corpus_</code>. If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column.</p> <p>See the Vectorizer class for a description of the parameters.</p> <p></p> <p></p>"}, {"location": "api/atom/atomforecaster/#feature-engineering", "title": "Feature engineering", "text": "<p>To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide.</p> <p>feature_extractionExtract features from datetime columns.feature_generationGenerate new features.feature_groupingExtract statistics from similar features.feature_selectionReduce the number of features in the data.</p> <p></p> <p></p> method feature_extraction(features=('day', 'month', 'year'), fmt=None, encoding_type=\"ordinal\", drop_columns=True, from_index=False, **kwargs)[source] <p>Extract features from datetime columns.</p> <p>Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype <code>datetime64</code> are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used.</p> <p>See the FeatureExtractor class for a description of the parameters.</p> <p></p> <p></p> method feature_generation(strategy=\"dfs\", n_features=None, operators=None, **kwargs)[source] <p>Generate new features.</p> <p>Create new combinations of existing features to capture the non-linear relations between the original features.</p> <p>See the FeatureGenerator class for a description of the parameters.</p> <p></p> <p></p> method feature_grouping(groups, operators=None, drop_columns=True, **kwargs)[source] <p>Extract statistics from similar features.</p> <p>Replace groups of features with related characteristics with new features that summarize statistical properties of the group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the <code>groups</code> method.</p> <p>See the FeatureGrouper class for a description of the parameters.</p> <p>Tip</p> <p>Use a regex pattern with the <code>groups</code> parameter to select groups easier, e.g., <code>atom.feature_grouping({\"group1\": \"var_.+\")</code> to select all features that start with <code>var_</code>.</p> <p></p> <p></p> method feature_selection(strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs)[source] <p>Reduce the number of features in the data.</p> <p>Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low-variance features.</p> <p>See the FeatureSelector class for a description of the parameters.</p> <p>Note</p> <ul> <li>When strategy=\"univariate\" and solver=None, f_classif   or f_regression is used as default solver.</li> <li>When strategy is \"sfs\", \"rfecv\" or any of the   advanced strategies and no scoring is specified,   atom's metric (if it exists) is used as scoring.</li> </ul> <p></p> <p></p>"}, {"location": "api/atom/atomforecaster/#training", "title": "Training", "text": "<p>The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide.</p> <p>runTrain and evaluate the models in a direct fashion.successive_halvingFit the models in a successive halving fashion.train_sizingTrain and evaluate the models in a train sizing fashion.</p> <p></p> <p></p> method run(models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Train and evaluate the models in a direct fashion.</p> <p>Contrary to successive_halving and train_sizing, the direct approach only iterates once over the models, using the full dataset.</p> <p>The following steps are applied to every model:</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the DirectClassifier or DirectRegressor class for a description of the parameters.</p> <p></p> <p></p> method successive_halving(models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Fit the models in a successive halving fashion.</p> <p>The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g., only using tree-based models.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters.</p> <p></p> <p></p> method train_sizing(models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Train and evaluate the models in a train sizing fashion.</p> <p>When training models, there is usually a trade-off between model performance and computation time; that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.</p> <p></p>"}, {"location": "api/atom/atommodel/", "title": "ATOMModel", "text": "function atom.api.ATOMModel(estimator, name=None, acronym=None, needs_scaling=False, native_multilabel=False, native_multioutput=False, validation=None)[source] <p>Convert an estimator to a model that can be ingested by atom.</p> <p>This function adds the relevant tags to the estimator so that they can be used by <code>atom</code>. Note that only estimators that follow sklearn's API are compatible.</p> <p>Read more about custom models in the user guide.</p> <p>Parameters estimator: Predictor Custom estimator. Should implement a <code>fit</code> and <code>predict</code> method. <p> name: str or None, default=None Name for the model. This is the value used to call the model from atom. The value should start with the model's <code>acronym</code> when specified. If None, the capital letters of the estimator's name are used (only if two or more, else it uses the entire name). <p> acronym: str or None, default=None Model's acronym. If None, it uses the model's <code>name</code>. Specify this parameter when you want to train multiple custom models that share the same estimator. <p> needs_scaling: bool, default=False Whether the model should use automated feature scaling. <p> native_multilabel: bool, default=False Whether the model has native support for multilabel tasks. If False and the task is multilabel, a multilabel meta-estimator is wrapper around the estimator. <p> native_multioutput: bool, default=False Whether the model has native support for multioutput tasks. If False and the task is multioutput, a multioutput meta-estimator is wrapped around the estimator. <p> validation: str or None, default=None Whether the model allows in-training validation. <ul> <li>If None: No support for in-training validation.</li> <li>If str: Name of the estimator's parameter that states the   number of iterations, e.g., <code>n_estimators</code> for   RandomForestClassifier.</li> </ul> <p>Returns Predictor Estimator with provided information. Provide this instance to the <code>models</code> parameter of the run method. <p></p>"}, {"location": "api/atom/atommodel/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor, ATOMModel\n&gt;&gt;&gt; from sklearn.datasets import load_diabetes\n&gt;&gt;&gt; from sklearn.linear_model import RANSACRegressor\n\n&gt;&gt;&gt; ransac = ATOMModel(\n...     estimator=RANSACRegressor(),\n...     name=\"RANSAC\",\n...     needs_scaling=False,\n... )\n\n&gt;&gt;&gt; X, y = load_diabetes(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Regression.\n\nDataset stats ==================== &gt;&gt;\nShape: (442, 11)\nTrain set size: 354\nTest set size: 88\n-------------------------------------\nMemory: 39.03 kB\nScaled: False\nOutlier values: 8 (0.2%)\n\n&gt;&gt;&gt; atom.run(ransac)\n\n\nTraining ========================= &gt;&gt;\nModels: RANSAC\nMetric: r2\n\n\nResults for RANSACRegressor:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.3461\nTest evaluation --&gt; r2: 0.2589\nTime elapsed: 0.068s\n-------------------------------------------------\nTime: 0.068s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.069s\n-------------------------------------\nRANSACRegressor --&gt; r2: 0.2589 ~\n</code></pre>"}, {"location": "api/atom/atomregressor/", "title": "ATOMRegressor", "text": "class atom.api.ATOMRegressor(*arrays, y=-1, index=False, metadata=None, ignore=None, shuffle=True, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Main class for regression tasks.</p> <p>Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains.</p> <p>All data cleaning, feature engineering, model training and plotting functionality can be accessed from an instance of this class.</p> <p>Parameters *arrays: sequence of indexables Dataset containing features and target. Allowed formats are: <ul> <li>X</li> <li>X, y</li> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>X, train, test: dataframe-like Feature set with shape=(n_samples, n_features).</p> <p>y: int, str, sequence or dataframe-like Target column(s) corresponding to <code>X</code>.</p> <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> y: int, str, sequence or dataframe-like, default=-1 Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p>This parameter is ignored if the target column is provided through <code>arrays</code>.</p> <p> index: bool, int, str or sequence, default=False Handle the index in the resulting dataframe. <ul> <li>If False: Reset to RangeIndex.</li> <li>If True: Use the provided index.</li> <li>If int: Position of the column to use as index.</li> <li>If str: Name of the column to use as index.</li> <li>If sequence: Array with shape=(n_samples,) to use as index.</li> </ul> <p> metadata: dict or None, default=None Metadata to route to estimators, scorers, and CV splitters. If None, no metadata is used. If dict, the available keys are: <ul> <li>groups: sequence of shape=(n_samples,)     Group labels for the samples used while splitting the     dataset into train and test sets.</li> <li>sample_weight: sequence of shape=(n_samples,)     Individual weights for each sample.</li> </ul> <p> ignore: int, str, sequence or None, default=None Features in X to ignore during data transformations and model training. The features are still used in the remaining methods. <p> test_size: int or float, default=0.2 <ul> <li>If &lt;=1: Fraction of the dataset to include in the test set.</li> <li>If &gt;1: Number of rows to include in the test set.</li> </ul> <p>This parameter is ignored if the test set is provided through <code>arrays</code>.</p> <p>If 'groups' is provided in the <code>metadata</code> parameter, <code>test_size</code> represents the proportion of groups to include in the test split or the absolute number of test groups.</p> <p> holdout_size: int, float or None, default=None <ul> <li>If None: No holdout data set is kept apart.</li> <li>If &lt;=1: Fraction of the dataset to include in the holdout set.</li> <li>If &gt;1: Number of rows to include in the holdout set.</li> </ul> <p>This parameter is ignored if the holdout set is provided through <code>arrays</code>.</p> <p> shuffle: bool, default=True Whether to shuffle the dataset before splitting the data sets. <p> n_rows: int or float, default=1 Random subsample of the dataset to use. The default value selects all rows. <ul> <li>If &lt;=1: Fraction of the dataset to select.</li> <li>If &gt;1: Exact number of rows to select. Only if <code>arrays</code> is X          or X, y.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMClassifier Main class for classification tasks.</p> <p>ATOMForecaster Main class for forecasting tasks.</p> <p></p>"}, {"location": "api/atom/atomregressor/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import load_diabetes\n\n&gt;&gt;&gt; X, y = load_diabetes(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Initialize atom\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Regression.\n\nDataset stats ==================== &gt;&gt;\nShape: (442, 11)\nTrain set size: 354\nTest set size: 88\n-------------------------------------\nMemory: 39.03 kB\nScaled: False\nOutlier values: 12 (0.3%)\n\n\n&gt;&gt;&gt; # Apply data cleaning and feature engineering methods\n&gt;&gt;&gt; atom.scale()\n\nFitting Scaler...\nScaling features...\n&gt;&gt;&gt; atom.feature_selection(strategy=\"rfecv\", solver=\"xgb\", n_features=12)\n\nFitting FeatureSelector...\nPerforming feature selection ...\n --&gt; rfecv selected 10 features from the dataset.\n\n&gt;&gt;&gt; # Train models\n&gt;&gt;&gt; atom.run(models=[\"OLS\", \"RF\", \"XGB\"])\n\n\nTraining ========================= &gt;&gt;\nModels: OLS, RF, XGB\nMetric: r2\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.5187\nTest evaluation --&gt; r2: 0.5\nTime elapsed: 0.024s\n-------------------------------------------------\nTime: 0.024s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.9183\nTest evaluation --&gt; r2: 0.4882\nTime elapsed: 0.247s\n-------------------------------------------------\nTime: 0.247s\n\n\nResults for XGBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 1.0\nTest evaluation --&gt; r2: 0.376\nTime elapsed: 0.205s\n-------------------------------------------------\nTime: 0.205s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.479s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5 !\nRandomForest         --&gt; r2: 0.4882 ~\nXGBoost              --&gt; r2: 0.376 ~\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; atom.results\n</code></pre> r2_train r2_test time_fit time OLS 0.518700 0.500000 0.024022 0.024022 RF 0.918300 0.488200 0.247225 0.247225 XGB 1.000000 0.376000 0.205187 0.205187"}, {"location": "api/atom/atomregressor/#magic-methods", "title": "Magic methods", "text": "<p>The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch.</p> <ul> <li>__repr__: Prints an overview of atom's branches, models, and metrics.</li> <li>__len__: Returns the length of the dataset.</li> <li>__iter__: Iterate over the pipeline's transformers.</li> <li>__contains__: Checks if the provided item is a column in the dataset.</li> <li>__getitem__: Access a branch, model, column or subset of the dataset.</li> </ul> <p></p>"}, {"location": "api/atom/atomregressor/#attributes", "title": "Attributes", "text": ""}, {"location": "api/atom/atomregressor/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes pipeline: PipelinePipeline of transformers. <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s).  scaled: boolWhether the feature set is scaled. <p>A data set is considered scaled when it has mean~0 and std~1, or when there is a scaler in the pipeline. Categorical and binary columns (only zeros and ones) are excluded from the calculation. Sparse datasets always return False.  duplicates: intNumber of duplicate rows in the dataset.  nans: pd.SeriesColumns with the number of missing values in them. <p>This property is unavailable for sparse datasets.  n_nans: intNumber of rows containing missing values. <p>This property is unavailable for sparse datasets.  numerical: pd.IndexNames of the numerical features in the dataset.  n_numerical: intNumber of numerical features in the dataset.  categorical: pd.IndexNames of the categorical features in the dataset.  n_categorical: intNumber of categorical features in the dataset.  outliers: pd.SeriesColumns in training set with number of outlier values. <p>This property is unavailable for sparse datasets.  n_outliers: intNumber of samples in the training set containing outliers. <p>This property is unavailable for sparse datasets. </p> <p></p>"}, {"location": "api/atom/atomregressor/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes metadata: BunchMetadata of the dataset. <p>Read more in the user guide.  ignore: tuple[str, ...]Names of the ignored columns. <p>These columns aren't used in the transformer pipeline nor for model training.  missing: list[Any]Values that are considered \"missing\". <p>These values are used by the clean and impute methods. Default values are: None, NaN, NA, NaT, +inf, -inf, \"\", \"?\", \"NA\", \"nan\", \"NaN\", \"NaT\", \"none\", \"None\", \"inf\", \"-inf\". Note that None, NaN, NA, +inf and -inf are always considered missing since they are incompatible with sklearn estimators.  branch: BranchCurrent active branch. <p>Use the property's <code>@setter</code> to change the branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use <code>_from_</code> to split the new branch from any other existing branch. Read more in the user guide.  models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/atom/atomregressor/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/atom/atomregressor/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/atom/atomregressor/#utility-methods", "title": "Utility methods", "text": "<p>Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline.</p> <p>addAdd a transformer to the pipeline.applyApply a function to the dataset.available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.distributionsGet statistics on column distributions.edaCreate an Exploratory Data Analysis report.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_sample_weightReturn sample weights for a balanced data set.inverse_transformInversely transform new data through the pipeline.loadLoad an atom instance from a pickle file.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.resetReset the instance to it's initial state.reset_aestheticsReset the plot aesthetics to their default values.saveSave the instance to a pickle file.save_dataSave the data in the current branch to a <code>.csv</code> file.shrinkConvert the columns to the smallest possible matching dtype.stackingAdd a Stacking model to the pipeline.statsDisplay basic information about the dataset.statusGet an overview of the branches and models.transformTransform new data through the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method add(transformer, columns=None, train_only=False, feature_names_out=None, **fit_params)[source] <p>Add a transformer to the pipeline.</p> <p>If the transformer is not fitted, it is fitted on the complete training set. Afterward, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom.</p> <p>Warning</p> <ul> <li>The transformer should have fit and/or transform methods   with arguments <code>X</code> (accepting a dataframe-like object of   shape=(n_samples, n_features)) and/or <code>y</code> (accepting a   sequence of shape=(n_samples,)).</li> <li>The transform method should return a feature set as a   dataframe-like object of shape=(n_samples, n_features)   and/or a target column as a sequence of shape=(n_samples,).</li> </ul> <p>Note</p> <p>If the transform method doesn't return a dataframe:</p> <ul> <li>The column naming happens as follows. If the transformer   has a <code>get_feature_names_out</code> method, it is used. If not,   and it returns the same number of columns, the names are   kept equal. If the number of columns changes, old columns   will keep their name (as long as the column is unchanged)   and new columns will receive the name <code>x[N-1]</code>, where N   stands for the n-th feature. This means that a transformer   should only transform, add or drop columns, not   combinations of these.</li> <li>The index remains the same as before the transformation.   This means that the transformer should not add, remove or   shuffle rows unless it returns a dataframe.</li> </ul> <p>Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a <code>transform</code> method. If a class is provided (instead of an instance), and it has the <code>n_jobs</code> and/or <code>random_state</code> parameters, it adopts atom's values. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to transform. Only select features or the target column, not both at the same time (if that happens, the target column is ignored). If None, transform all columns. <p> train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. <p> feature_names_out: \"one-to-one\", callable or None, default=None Determines the list of feature names that will be returned by the <code>get_feature_names_out</code> method. <ul> <li>If None: The <code>get_feature_names_out</code> method is not defined.</li> <li>If \"one-to-one\": The output feature names will be equal to   the input feature names.</li> <li>If callable: Function that takes positional arguments self   and a sequence of input feature names. It must return a   sequence of output feature names.</li> </ul> <p> **fit_params Additional keyword arguments for the transformer's fit method. </p> <p></p> <p></p> method apply(func, inverse_func=None, feature_names_out=None, kw_args=None, inv_kw_args=None, **kwargs)[source] <p>Apply a function to the dataset.</p> <p>This method is useful for stateless transformations such as taking the log, doing custom scaling, etc...</p> <p>Note</p> <p>This approach is preferred over changing the dataset directly through the property's <code>@setter</code> since the transformation is stored in the pipeline.</p> <p>Tip</p> <p>Use <code>atom.apply(lambda df: df.drop(\"column_name\",axis=1))</code> to store the removal of columns in the pipeline.</p> <p>Parameters func: callable Function to apply with signature <code>func(dataframe, **kw_args) -&gt; dataframe-like</code>. <p> inverse_func: callable or None, default=None Inverse function of <code>func</code>. If None, the inverse_transform method returns the input unchanged. <p> feature_names_out: \"one-to-one\", callable or None, default=None Determines the list of feature names that will be returned by the <code>get_feature_names_out</code> method. <ul> <li>If None: The <code>get_feature_names_out</code> method is not defined.</li> <li>If \"one-to-one\": The output feature names will be equal to   the input feature names.</li> <li>If callable: Function that takes positional arguments self   and a sequence of input feature names. It must return a   sequence of output feature names.</li> </ul> <p> kw_args: dict or None, default=None Additional keyword arguments for the function. <p> inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. </p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method distributions(distributions=None, columns=None)[source] <p>Get statistics on column distributions.</p> <p>Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored.</p> <p>Tip</p> <p>Use the plot_distribution method to plot a column's distribution.</p> <p>Parameters distributions: str, sequence or None, default=None Names of the distributions in <code>scipy.stats</code> to get the statistics on. If None, a selection of the most common ones is used. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns on which to perform the test. If None, select all numerical columns. <p>Returns pd.DataFrame Statistic results with multiindex levels: <ul> <li>dist: Name of the distribution.</li> <li> <p>stat: Statistic results:</p> <ul> <li>score: KS-test score.</li> <li>p_value: Corresponding p-value. </li> </ul> </li> </ul> <p></p> <p></p> method eda(rows=\"dataset\", target=0, filename=None)[source] <p>Create an Exploratory Data Analysis report.</p> <p>ATOM uses the sweetviz package for EDA. The report is rendered directly in the notebook. It can also be accessed through the <code>report</code> attribute. It can either report one dataset or compare two datasets against each other.</p> <p>Warning</p> <p>This method can be slow for large datasets.</p> <p>Parameters rows: str, sequence or dict, default=\"dataset\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to report.</li> <li>If sequence: Names of two data sets to compare.</li> <li>If dict: Names of up to two data sets with corresponding   selection of rows to report.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. Only bool and numerical features can be used as target. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the (html) file to save. If None, don't save anything. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_sample_weight(rows=\"train\")[source] <p>Return sample weights for a balanced data set.</p> <p>The returned weights are inversely proportional to the class frequencies in the selected data set. For multioutput tasks, the weights of each column of <code>y</code> will be multiplied.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns pd.Series Sequence of weights with shape=(n_samples,). </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column.</p> <p>Parameters X: Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Transformed target column corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.atom.load(filename, data=None)[source] <p>Load an atom instance from a pickle file.</p> <p>If the instance was saved using <code>save_data=False</code>, it's possible to load new data into it and apply all data transformations.</p> <p>Info</p> <p>The loaded instance's current branch is the same branch as it was when saved.</p> <p>Parameters filename: str or Path Filename or pathlib.Path of the pickle file. <p> data: tuple of indexables or None, default=None Original dataset as it was provided to the instance's constructor. Only use this parameter if the loaded file was saved using <code>save_data=False</code>. Allowed formats are: <ul> <li>X</li> <li>X, y</li> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>X, train, test: dataframe-like Feature set with shape=(n_samples, n_features).</p> <p>y: int, str, sequence or dataframe Target column(s) corresponding to <code>X</code>.</p> <ul> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p>Returns atom Unpickled atom instance. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> method reset(hard=False)[source] <p>Reset the instance to it's initial state.</p> <p>Deletes all branches and models. The dataset is also reset to its form after initialization.</p> <p>Parameters hard: bool, default=False If True, flushes completely the cache. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method save_data(filename=\"auto\", rows=\"dataset\", **kwargs)[source] <p>Save the data in the current branch to a <code>.csv</code> file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> rows: hashable, segment, sequence or dataframe, default=\"dataset\" Selection of rows to save. <p> **kwargs Additional keyword arguments for pandas' to_csv method. </p> <p></p> <p></p> method shrink(int2bool=False, int2uint=False, str2cat=False, dense2sparse=False, columns=None)[source] <p>Convert the columns to the smallest possible matching dtype.</p> <p>Examples are: float64 -&gt; float32, int64 -&gt; int8, etc... Sparse arrays also transform their non-fill value. Use this method for memory optimization before saving the dataset. Note that applying transformers to the data may alter the types again.</p> <p>Parameters int2bool: bool, default=False Whether to convert <code>int</code> columns to <code>bool</code> type. Only if the values in the column are strictly in (0, 1) or (-1, 1). <p> int2uint: bool, default=False Whether to convert <code>int</code> to <code>uint</code> (unsigned integer). Only if the values in the column are strictly positive. <p> str2cat: bool, default=False Whether to convert <code>string</code> to <code>category</code>. Only if the number of categories is less than 30% of the column's length. <p> dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. <p> columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to shrink. If None, transform all columns. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method stats()[source] <p>Display basic information about the dataset.</p> <p></p> <p></p> method status()[source] <p>Get an overview of the branches and models.</p> <p>This method prints the same information as the __repr__ and also saves it to the logger.</p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p> <p></p>"}, {"location": "api/atom/atomregressor/#data-cleaning", "title": "Data cleaning", "text": "<p>The data cleaning methods can help you scale the data, handle missing values, categorical columns and outliers. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide.</p> <p>Tip</p> <p>Use the eda method to examine the data and help you determine suitable parameters for the data cleaning methods.</p> <p>cleanApply standard data cleaning steps on the dataset.discretizeBin continuous data into intervals.encodePerform encoding of categorical features.imputeHandle missing values in the dataset.normalizeTransform the data to follow a Normal/Gaussian distribution.prunePrune outliers from the training set.scaleScale the data.</p> <p></p> <p></p> method clean(convert_dtypes=True, drop_dtypes=None, drop_chars=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs)[source] <p>Apply standard data cleaning steps on the dataset.</p> <p>Use the parameters to choose which transformations to perform. The available steps are:</p> <ul> <li>Convert dtypes to the best possible types.</li> <li>Drop columns with specific data types.</li> <li>Remove characters from column names.</li> <li>Strip categorical features from spaces.</li> <li>Drop duplicate rows.</li> <li>Drop rows with missing values in the target column.</li> <li>Encode the target column (only for classification tasks).</li> </ul> <p>See the Cleaner class for a description of the parameters.</p> <p></p> <p></p> method discretize(strategy=\"quantile\", bins=5, labels=None, **kwargs)[source] <p>Bin continuous data into intervals.</p> <p>For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns.</p> <p>See the Discretizer class for a description of the parameters.</p> <p>Tip</p> <p>Use the plot_distribution method to visualize a column's distribution and decide on the bins.</p> <p></p> <p></p> method encode(strategy=\"Target\", max_onehot=10, ordinal=None, infrequent_to_value=None, value=\"infrequent\", **kwargs)[source] <p>Perform encoding of categorical features.</p> <p>The encoding type depends on the number of classes in the column:</p> <ul> <li>If n_classes=2 or ordinal feature, use Ordinal-encoding.</li> <li>If 2 &lt; n_classes &lt;= <code>max_onehot</code>, use OneHot-encoding.</li> <li>If n_classes &gt; <code>max_onehot</code>, use <code>strategy</code>-encoding.</li> </ul> <p>Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality.</p> <p>See the Encoder class for a description of the parameters.</p> <p>Note</p> <p>This method only encodes the categorical features. It does not encode the target column! Use the clean method for that.</p> <p>Tip</p> <p>Use the categorical attribute for a list of the categorical features in the dataset.</p> <p></p> <p></p> method impute(strat_num=\"mean\", strat_cat=\"most_frequent\", max_nan_rows=None, max_nan_cols=None, **kwargs)[source] <p>Handle missing values in the dataset.</p> <p>Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values.</p> <p>See the Imputer class for a description of the parameters.</p> <p>Tip</p> <ul> <li>Use the nans attribute to check the amount of   missing values per column.</li> <li>Use the <code>missing</code> attribute to customize   what are considered \"missing values\".</li> </ul> <p></p> <p></p> method normalize(strategy=\"yeojohnson\", **kwargs)[source] <p>Transform the data to follow a Normal/Gaussian distribution.</p> <p>This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns.</p> <p>See the Normalizer class for a description of the parameters.</p> <p>Tip</p> <p>Use the plot_distribution method to examine a column's distribution.</p> <p></p> <p></p> method prune(strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs)[source] <p>Prune outliers from the training set.</p> <p>Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns.</p> <p>See the Pruner class for a description of the parameters.</p> <p>Note</p> <p>This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set.</p> <p>Tip</p> <p>Use the outliers attribute to check the number of outliers per column.</p> <p></p> <p></p> method scale(strategy=\"standard\", include_binary=False, **kwargs)[source] <p>Scale the data.</p> <p>Apply one of sklearn's scaling strategies. Categorical columns are ignored.</p> <p>See the Scaler class for a description of the parameters.</p> <p>Tip</p> <p>Use the scaled attribute to check whether the dataset is scaled.</p> <p></p> <p></p>"}, {"location": "api/atom/atomregressor/#nlp", "title": "NLP", "text": "<p>The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called <code>corpus</code>. Read more in the user guide.</p> <p>textcleanApply standard text cleaning to the corpus.textnormalizeNormalize the corpus.tokenizeTokenize the corpus.vectorizeVectorize the corpus.</p> <p></p> <p></p> method textclean(decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs)[source] <p>Apply standard text cleaning to the corpus.</p> <p>Transformations include normalizing characters and drop noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised.</p> <p>See the TextCleaner class for a description of the parameters.</p> <p></p> <p></p> method textnormalize(stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs)[source] <p>Normalize the corpus.</p> <p>Convert words to a more uniform standard. The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces.</p> <p>See the TextNormalizer class for a description of the parameters.</p> <p></p> <p></p> method tokenize(bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs)[source] <p>Tokenize the corpus.</p> <p>Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g., \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>See the Tokenizer class for a description of the parameters.</p> <p></p> <p></p> method vectorize(strategy=\"bow\", return_sparse=True, **kwargs)[source] <p>Vectorize the corpus.</p> <p>Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix <code>corpus_</code>. If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column.</p> <p>See the Vectorizer class for a description of the parameters.</p> <p></p> <p></p>"}, {"location": "api/atom/atomregressor/#feature-engineering", "title": "Feature engineering", "text": "<p>To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide.</p> <p>feature_extractionExtract features from datetime columns.feature_generationGenerate new features.feature_groupingExtract statistics from similar features.feature_selectionReduce the number of features in the data.</p> <p></p> <p></p> method feature_extraction(features=('day', 'month', 'year'), fmt=None, encoding_type=\"ordinal\", drop_columns=True, from_index=False, **kwargs)[source] <p>Extract features from datetime columns.</p> <p>Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype <code>datetime64</code> are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used.</p> <p>See the FeatureExtractor class for a description of the parameters.</p> <p></p> <p></p> method feature_generation(strategy=\"dfs\", n_features=None, operators=None, **kwargs)[source] <p>Generate new features.</p> <p>Create new combinations of existing features to capture the non-linear relations between the original features.</p> <p>See the FeatureGenerator class for a description of the parameters.</p> <p></p> <p></p> method feature_grouping(groups, operators=None, drop_columns=True, **kwargs)[source] <p>Extract statistics from similar features.</p> <p>Replace groups of features with related characteristics with new features that summarize statistical properties of the group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the <code>groups</code> method.</p> <p>See the FeatureGrouper class for a description of the parameters.</p> <p>Tip</p> <p>Use a regex pattern with the <code>groups</code> parameter to select groups easier, e.g., <code>atom.feature_grouping({\"group1\": \"var_.+\")</code> to select all features that start with <code>var_</code>.</p> <p></p> <p></p> method feature_selection(strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs)[source] <p>Reduce the number of features in the data.</p> <p>Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low-variance features.</p> <p>See the FeatureSelector class for a description of the parameters.</p> <p>Note</p> <ul> <li>When strategy=\"univariate\" and solver=None, f_classif   or f_regression is used as default solver.</li> <li>When strategy is \"sfs\", \"rfecv\" or any of the   advanced strategies and no scoring is specified,   atom's metric (if it exists) is used as scoring.</li> </ul> <p></p> <p></p>"}, {"location": "api/atom/atomregressor/#training", "title": "Training", "text": "<p>The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide.</p> <p>runTrain and evaluate the models in a direct fashion.successive_halvingFit the models in a successive halving fashion.train_sizingTrain and evaluate the models in a train sizing fashion.</p> <p></p> <p></p> method run(models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Train and evaluate the models in a direct fashion.</p> <p>Contrary to successive_halving and train_sizing, the direct approach only iterates once over the models, using the full dataset.</p> <p>The following steps are applied to every model:</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the DirectClassifier or DirectRegressor class for a description of the parameters.</p> <p></p> <p></p> method successive_halving(models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Fit the models in a successive halving fashion.</p> <p>The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g., only using tree-based models.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters.</p> <p></p> <p></p> method train_sizing(models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", **kwargs)[source] <p>Train and evaluate the models in a train sizing fashion.</p> <p>When training models, there is usually a trade-off between model performance and computation time; that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test    set (optional).</li> </ol> <p>See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.</p> <p></p>"}, {"location": "api/branch/branch/", "title": "Branch", "text": "class atom.data.branch.Branch(name, data=None, holdout=None, memory=None)[source] <p>Object that contains the data.</p> <p>A branch contains a specific pipeline, the dataset transformed through that pipeline, the models fitted on that dataset, and all data and utility attributes that refer to that dataset. Branches can be created and accessed through atom's <code>branch</code> attribute.</p> <p>All public properties and attributes of the branch can be accessed from the parent.</p> <p>Read more in the user guide.</p> <p>Warning</p> <p>This class should not be called directly. Branches are created internally by the ATOMClassifier, ATOMForecaster and ATOMRegressor classes.</p> <p>Parameters name: str Name of the branch. <p> data: DataContainer or None, default=None Data for the branch. <p> holdout: pd.DataFrame or None, default=None Holdout data set. <p> memory: str, Memory or None, default=None Memory object for pipeline caching and to store the data when the branch is inactive. <p></p> <p></p> <p>See Also</p> <p>BranchManager Object that manages branches.</p> <p></p>"}, {"location": "api/branch/branch/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Initialize atom\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 138.97 kB\nScaled: False\nOutlier values: 161 (1.1%)\n\n\n&gt;&gt;&gt; # Train a model\n&gt;&gt;&gt; atom.run(\"RF\")\n\n\nTraining ========================= &gt;&gt;\nModels: RF\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9595\nTime elapsed: 0.165s\n-------------------------------------------------\nTime: 0.165s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.168s\n-------------------------------------\nRandomForest --&gt; f1: 0.9595\n\n&gt;&gt;&gt; # Change the branch and apply feature scaling\n&gt;&gt;&gt; atom.branch = \"scaled\"\n\nSuccessfully created new branch: scaled.\n\n&gt;&gt;&gt; atom.scale()\n\nFitting Scaler...\nScaling features...\n&gt;&gt;&gt; atom.run(\"RF_scaled\")\n\n\nTraining ========================= &gt;&gt;\nModels: RF_scaled\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9595\nTime elapsed: 0.164s\n-------------------------------------------------\nTime: 0.164s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.167s\n-------------------------------------\nRandomForest --&gt; f1: 0.9595\n\n&gt;&gt;&gt; # Compare the models\n&gt;&gt;&gt; atom.plot_roc()\n</code></pre>"}, {"location": "api/branch/branch/#attributes", "title": "Attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/branch/branch/#methods", "title": "Methods", "text": "<p>check_scalingWhether the feature set is scaled.loadLoad the branch's data from memory.storeStore the branch's data as a pickle in memory.</p> <p></p> <p></p> method check_scaling()[source] <p>Whether the feature set is scaled.</p> <p>A data set is considered scaled when it has mean~0 and std~1, or when there is a scaler in the pipeline. Categorical and binary columns (only zeros and ones) are excluded from the calculation. Sparse datasets always return False.</p> <p>Returns bool Whether the feature set is scaled. </p> <p></p> <p></p> method load(assign=True)[source] <p>Load the branch's data from memory.</p> <p>This method is used to restore the data of inactive branches.</p> <p>Parameters assign: bool, default=True Whether to assign the loaded data to <code>self</code>. <p>Returns DataContainer or None Own data information. Returns None if no data is set. </p> <p></p> <p></p> method store(assign=True)[source] <p>Store the branch's data as a pickle in memory.</p> <p>After storage, the data is deleted, and the branch is no longer usable until load is called. This method is used to store the data for inactive branches.</p> <p>Note</p> <p>This method is skipped silently for branches with no memory allocation.</p> <p>Parameters assign: bool, default=True Whether to assign <code>None</code> to the data in <code>self</code>. </p> <p></p>"}, {"location": "api/branch/branchmanager/", "title": "BranchManager", "text": "class atom.data.branchmanager.BranchManager(memory=None)[source] <p>Object that manages branches.</p> <p>Maintains references to a series of branches and the current active branch. Additionally, always stores an 'original' branch containing the original dataset (previous to any transformations). The branches share a reference to a holdout set, not the instance self. When a memory object is specified, it stores inactive branches in memory.</p> <p>Read more in the user guide.</p> <p>Warning</p> <p>This class should not be called directly. The BranchManager is created internally by the ATOMClassifier, ATOMForecaster and ATOMRegressor classes.</p> <p>Parameters memory: str, Memory or None, default=None Location to store inactive branches. If None, all branches are kept in memory. This memory object is passed to the branches for pipeline caching. <p>Attributes branches: ClassMap Collection of branches. <p> og: Branch Branch containing the original dataset. It can be any branch in <code>branches</code> or an internally made branch called <code>og</code>. <p> current: Branch Current active branch. <p></p> <p></p> <p>See Also</p> <p>Branch Object that contains the data.</p> <p></p>"}, {"location": "api/branch/branchmanager/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Initialize atom\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 138.97 kB\nScaled: False\nOutlier values: 180 (1.3%)\n\n\n&gt;&gt;&gt; # Train a model\n&gt;&gt;&gt; atom.run(\"RF\")\n\n\nTraining ========================= &gt;&gt;\nModels: RF\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.965\nTime elapsed: 0.171s\n-------------------------------------------------\nTime: 0.171s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.174s\n-------------------------------------\nRandomForest --&gt; f1: 0.965\n\n&gt;&gt;&gt; # Change the branch and apply feature scaling\n&gt;&gt;&gt; atom.branch = \"scaled\"\n\nSuccessfully created new branch: scaled.\n\n&gt;&gt;&gt; atom.scale()\n\nFitting Scaler...\nScaling features...\n&gt;&gt;&gt; atom.run(\"RF_scaled\")\n\n\nTraining ========================= &gt;&gt;\nModels: RF_scaled\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9718\nTime elapsed: 0.172s\n-------------------------------------------------\nTime: 0.172s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.175s\n-------------------------------------\nRandomForest --&gt; f1: 0.9718\n\n&gt;&gt;&gt; # Compare the models\n&gt;&gt;&gt; atom.plot_roc()\n</code></pre>"}, {"location": "api/branch/branchmanager/#attributes", "title": "Attributes", "text": "<p>Attributes branches: ClassMap Collection of branches. <p> og: Branch Branch containing the original dataset. It can be any branch in <code>branches</code> or an internally made branch called <code>og</code>. <p> current: Branch Current active branch. <p></p> <p></p>"}, {"location": "api/branch/branchmanager/#methods", "title": "Methods", "text": "<p>addAdd a new branch to the manager.fillFill the current branch with data.resetReset this instance to its initial state.</p> <p></p> <p></p> method add(name, parent=None)[source] <p>Add a new branch to the manager.</p> <p>If the branch is called <code>og</code> (reserved name for the original branch), it's created separately and stored in memory.</p> <p>Parameters name: str Name for the new branch. <p> parent: Branch or None, default=None Parent branch. Data and attributes from the parent are passed to the new branch. </p> <p></p> <p></p> method fill(data, holdout=None)[source] <p>Fill the current branch with data.</p> <p>This call resets the cached holdout calculation.</p> <p>Parameters data: DataContainer New data for the current branch. <p> holdout: dataframe or None, default=None Holdout data set (if any). </p> <p></p> <p></p> method reset(hard=False)[source] <p>Reset this instance to its initial state.</p> <p>The initial state of the BranchManager contains a single branch called <code>main</code> with no data. There's no reference to an original (<code>og</code>) branch.</p> <p>Parameters hard: bool, default=False If True, flushes completely the cache. </p> <p></p>"}, {"location": "api/data_cleaning/balancer/", "title": "Balancer", "text": "class atom.data_cleaning.Balancer(strategy=\"ADASYN\", n_jobs=1, verbose=0, random_state=None, **kwargs)[source] <p>Balance the number of samples per class in the target column.</p> <p>When oversampling, the newly created samples have an increasing integer index for numerical indices, and an index of the form [estimator]_N for non-numerical indices, where N stands for the N-th sample in the data set. Use only for classification tasks.</p> <p>This class can be accessed from atom through the balance method. Read more in the user guide.</p> <p>Warning</p> <ul> <li>The clustercentroids estimator is unavailable because of    incompatibilities of the APIs.</li> <li>The Balancer class does not support multioutput tasks.</li> </ul> <p>Parameters strategy: str or transformer, default=\"ADASYN\" Type of algorithm with which to balance the dataset. Choose from the name of any estimator in the imbalanced-learn package or provide a custom instance of such. <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 - value.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p> **kwargs Additional keyword arguments for the <code>strategy</code> estimator. <p>Attributes{#balancer-[strategy]} [strategy]: imblearn estimator Object (lowercase strategy) used to balance the data, e.g., <code>balancer.adasyn_</code> for the default strategy. <p> mapping_: dict Target values mapped to their respective encoded integers. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> target_names_in_: np.ndarray Names of the target column seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Encoder Perform encoding of categorical features.</p> <p>Imputer Handle missing values in the data.</p> <p>Pruner Prune outliers from the data.</p> <p></p>"}, {"location": "api/data_cleaning/balancer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.train)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630             0.054390         0.1720  ...           107.30       740.4            0.1610            0.42250          0.50300               0.22580          0.2807                  0.10710       0\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690             0.094510         0.1860  ...           142.20      1493.0            0.1492            0.25360          0.37590               0.15100          0.3074                  0.07863       0\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699             0.047440         0.1538  ...           135.10      1320.0            0.1315            0.18060          0.20800               0.11360          0.2504                  0.07948       0\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686             0.027390         0.1852  ...           110.10       931.4            0.1148            0.09866          0.15470               0.06575          0.3233                  0.06165       0\n4           8.95         15.76           58.74      245.2          0.09462           0.12430         0.09263             0.023080         0.1305  ...            63.34       270.0            0.1179            0.18790          0.15440               0.03846          0.1652                  0.07722       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n451        19.73         19.82          130.70     1206.0          0.10620           0.18490         0.24170             0.097400         0.1733  ...           159.80      1933.0            0.1710            0.59550          0.84890               0.25070          0.2749                  0.12970       0\n452        12.72         13.78           81.78      492.1          0.09667           0.08393         0.01288             0.019240         0.1638  ...            88.54       553.7            0.1298            0.14720          0.05233               0.06343          0.2369                  0.06922       1\n453        11.51         23.93           74.52      403.5          0.09261           0.10210         0.11120             0.041050         0.1388  ...            82.28       474.2            0.1298            0.25170          0.36300               0.09653          0.2112                  0.08732       1\n454        10.75         14.97           68.26      355.3          0.07793           0.05139         0.02251             0.007875         0.1399  ...            77.79       441.2            0.1076            0.12230          0.09755               0.03413          0.2300                  0.06769       1\n455        25.22         24.91          171.50     1878.0          0.10630           0.26650         0.33390             0.184500         0.1829  ...           211.70      2562.0            0.1573            0.60760          0.64760               0.28670          0.2355                  0.10510       0\n\n[456 rows x 31 columns]\n\n&gt;&gt;&gt; atom.balance(strategy=\"smote\", verbose=2)\n\nOversampling with SMOTE...\n --&gt; Adding 116 samples to class 0.\n\n&gt;&gt;&gt; # Note that the number of rows has increased\n&gt;&gt;&gt; print(atom.train)\n\n     mean radius  mean texture  mean perimeter    mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter   worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0      13.480000     20.820000       88.400000   559.200000         0.101600          0.125500        0.106300             0.054390       0.172000  ...       107.300000   740.400000          0.161000           0.422500         0.503000              0.225800        0.280700                 0.107100       0\n1      18.310000     20.580000      120.800000  1052.000000         0.106800          0.124800        0.156900             0.094510       0.186000  ...       142.200000  1493.000000          0.149200           0.253600         0.375900              0.151000        0.307400                 0.078630       0\n2      17.930000     24.480000      115.200000   998.900000         0.088550          0.070270        0.056990             0.047440       0.153800  ...       135.100000  1320.000000          0.131500           0.180600         0.208000              0.113600        0.250400                 0.079480       0\n3      15.130000     29.810000       96.710000   719.500000         0.083200          0.046050        0.046860             0.027390       0.185200  ...       110.100000   931.400000          0.114800           0.098660         0.154700              0.065750        0.323300                 0.061650       0\n4       8.950000     15.760000       58.740000   245.200000         0.094620          0.124300        0.092630             0.023080       0.130500  ...        63.340000   270.000000          0.117900           0.187900         0.154400              0.038460        0.165200                 0.077220       1\n..           ...           ...             ...          ...              ...               ...             ...                  ...            ...  ...              ...          ...               ...                ...              ...                   ...             ...                      ...     ...\n567    15.182945     22.486774       98.949465   711.386079         0.092513          0.102732        0.113923             0.069481       0.179224  ...       107.689157   826.276172          0.126730           0.199259         0.295172              0.142325        0.265352                 0.068318       0\n568    19.990378     20.622944      130.491182  1253.735467         0.091583          0.117753        0.117236             0.082771       0.202428  ...       167.456689  1995.896044          0.132457           0.289652         0.332006              0.182989        0.299088                 0.084150       0\n569    18.158121     18.928220      119.907435  1027.331092         0.113149          0.147089        0.171862             0.103942       0.209306  ...       135.286302  1319.270051          0.127029           0.233493         0.260138              0.133851        0.302406                 0.079535       0\n570    23.733233     26.433751      158.185672  1724.145541         0.098008          0.193789        0.231158             0.139527       0.188817  ...       207.483796  2844.559632          0.150495           0.463361         0.599077              0.266433        0.290828                 0.091542       0\n571    17.669575     16.375717      115.468589   968.552411         0.093636          0.109983        0.101005             0.075283       0.174505  ...       133.767576  1227.195245          0.118221           0.264624         0.249798              0.135098        0.268044                 0.076533       0\n\n[572 rows x 31 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Balancer\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst texture  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension\n0          17.99         10.38          122.80     1001.0          0.11840           0.27760         0.30010              0.14710         0.2419  ...          17.33           184.60      2019.0           0.16220            0.66560           0.7119                0.2654          0.4601                  0.11890\n1          20.57         17.77          132.90     1326.0          0.08474           0.07864         0.08690              0.07017         0.1812  ...          23.41           158.80      1956.0           0.12380            0.18660           0.2416                0.1860          0.2750                  0.08902\n2          19.69         21.25          130.00     1203.0          0.10960           0.15990         0.19740              0.12790         0.2069  ...          25.53           152.50      1709.0           0.14440            0.42450           0.4504                0.2430          0.3613                  0.08758\n3          11.42         20.38           77.58      386.1          0.14250           0.28390         0.24140              0.10520         0.2597  ...          26.50            98.87       567.7           0.20980            0.86630           0.6869                0.2575          0.6638                  0.17300\n4          20.29         14.34          135.10     1297.0          0.10030           0.13280         0.19800              0.10430         0.1809  ...          16.67           152.20      1575.0           0.13740            0.20500           0.4000                0.1625          0.2364                  0.07678\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...            ...              ...         ...               ...                ...              ...                   ...             ...                      ...\n564        21.56         22.39          142.00     1479.0          0.11100           0.11590         0.24390              0.13890         0.1726  ...          26.40           166.10      2027.0           0.14100            0.21130           0.4107                0.2216          0.2060                  0.07115\n565        20.13         28.25          131.20     1261.0          0.09780           0.10340         0.14400              0.09791         0.1752  ...          38.25           155.00      1731.0           0.11660            0.19220           0.3215                0.1628          0.2572                  0.06637\n566        16.60         28.08          108.30      858.1          0.08455           0.10230         0.09251              0.05302         0.1590  ...          34.12           126.70      1124.0           0.11390            0.30940           0.3403                0.1418          0.2218                  0.07820\n567        20.60         29.33          140.10     1265.0          0.11780           0.27700         0.35140              0.15200         0.2397  ...          39.42           184.60      1821.0           0.16500            0.86810           0.9387                0.2650          0.4087                  0.12400\n568         7.76         24.54           47.92      181.0          0.05263           0.04362         0.00000              0.00000         0.1587  ...          30.37            59.16       268.6           0.08996            0.06444           0.0000                0.0000          0.2871                  0.07039\n\n[569 rows x 30 columns]\n\n&gt;&gt;&gt; balancer = Balancer(strategy=\"smote\", verbose=2)\n&gt;&gt;&gt; X, y = balancer.fit_transform(X, y)\n\nOversampling with SMOTE...\n --&gt; Adding 145 samples to class 0.\n\n&gt;&gt;&gt; # Note that the number of rows has increased\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter    mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst texture  worst perimeter   worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension\n0      17.990000     10.380000      122.800000  1001.000000         0.118400          0.277600        0.300100             0.147100       0.241900  ...      17.330000       184.600000  2019.000000          0.162200           0.665600         0.711900              0.265400        0.460100                 0.118900\n1      20.570000     17.770000      132.900000  1326.000000         0.084740          0.078640        0.086900             0.070170       0.181200  ...      23.410000       158.800000  1956.000000          0.123800           0.186600         0.241600              0.186000        0.275000                 0.089020\n2      19.690000     21.250000      130.000000  1203.000000         0.109600          0.159900        0.197400             0.127900       0.206900  ...      25.530000       152.500000  1709.000000          0.144400           0.424500         0.450400              0.243000        0.361300                 0.087580\n3      11.420000     20.380000       77.580000   386.100000         0.142500          0.283900        0.241400             0.105200       0.259700  ...      26.500000        98.870000   567.700000          0.209800           0.866300         0.686900              0.257500        0.663800                 0.173000\n4      20.290000     14.340000      135.100000  1297.000000         0.100300          0.132800        0.198000             0.104300       0.180900  ...      16.670000       152.200000  1575.000000          0.137400           0.205000         0.400000              0.162500        0.236400                 0.076780\n..           ...           ...             ...          ...              ...               ...             ...                  ...            ...  ...            ...              ...          ...               ...                ...              ...                   ...             ...                      ...\n709    13.329262     20.382389       86.097972   551.351999         0.095639          0.086063        0.068628             0.042084       0.192509  ...      29.306676       102.623042   776.210985          0.137782           0.291373         0.328302              0.151230        0.336559                 0.090507\n710    20.185334     18.623259      131.879504  1278.482149         0.084117          0.094830        0.131577             0.082529       0.190481  ...      21.790588       150.589752  1641.020163          0.111636           0.163697         0.287766              0.146398        0.292034                 0.062731\n711    18.012313     17.046581      117.494946   988.670929         0.090583          0.125388        0.112866             0.064706       0.173268  ...      22.176153       133.279786  1292.505350          0.127083           0.270805         0.425427              0.153399        0.282285                 0.082004\n712    19.391707     19.145407      126.257114  1164.870937         0.103937          0.120719        0.136540             0.086889       0.181025  ...      25.437103       164.800203  2014.019293          0.152785           0.324601         0.421062              0.202135        0.341738                 0.087907\n713    15.154245     29.379464       97.230905   720.366950         0.085779          0.056406        0.058332             0.031637       0.184869  ...      36.867387       110.658374   929.783653          0.119091           0.127904         0.186762              0.076811        0.321684                 0.064960\n\n[714 rows x 30 columns]\n</code></pre>"}, {"location": "api/data_cleaning/balancer/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformBalance the data.</p> <p></p> <p></p> method fit(X, y)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence Target column corresponding to <code>X</code>. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y)[source] <p>Balance the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence Target column corresponding to <code>X</code>. <p>Returns dataframe Balanced dataframe. <p> series Transformed target column. </p> <p></p>"}, {"location": "api/data_cleaning/cleaner/", "title": "Cleaner", "text": "class atom.data_cleaning.Cleaner(convert_dtypes=True, drop_dtypes=None, drop_chars=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, device=\"cpu\", engine=None, verbose=0)[source] <p>Applies standard data cleaning steps on a dataset.</p> <p>Use the parameters to choose which transformations to perform. The available steps are:</p> <ul> <li>Convert dtypes to the best possible types.</li> <li>Drop columns with specific data types.</li> <li>Remove characters from column names.</li> <li>Strip categorical features from spaces.</li> <li>Drop duplicate rows.</li> <li>Drop rows with missing values in the target column.</li> <li>Encode the target column.</li> </ul> <p>This class can be accessed from atom through the clean method. Read more in the user guide.</p> <p>Parameters convert_dtypes: bool, default=True Convert the column's data types to the best possible types that support <code>pd.NA</code>. <p> drop_dtypes: str, sequence or None, default=None Columns with these data types are dropped from the dataset. <p> drop_chars: str or None, default=None Remove the specified regex pattern from column names, e.g. <code>[^A-Za-z0-9]+</code> to remove all non-alphanumerical characters. <p> strip_categorical: bool, default=True Whether to strip spaces from categorical columns. <p> drop_duplicates: bool, default=False Whether to drop duplicate rows. Only the first occurrence of every duplicated row is kept. <p> drop_missing_target: bool, default=True Whether to drop rows with missing values in the target column. This transformation is ignored if <code>y</code> is not provided. <p> encode_target: bool, default=True Whether to encode the target column(s). This includes converting categorical columns to numerical, and binarizing multilabel columns. This transformation is ignored if <code>y</code> is not provided. <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p>Attributes missing_: list Values that are considered \"missing\". Default values are: None, NaN, NA, NaT, +inf, -inf, \"\", \"?\", \"NA\", \"nan\", \"NaN\", \"NaT\", \"none\", \"None\", \"inf\", \"-inf\". Note that None, NaN, NA, +inf and -inf are always considered missing since they are incompatible with sklearn estimators. <p> mapping_: dict Target values mapped to their respective encoded integers. Only available if encode_target=True. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> target_names_in_: np.ndarray Names of the target column(s) seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Encoder Perform encoding of categorical features.</p> <p>Discretizer Bin continuous data into intervals.</p> <p>Scaler Scale the data.</p> <p></p>"}, {"location": "api/data_cleaning/cleaner/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n&gt;&gt;&gt; y = [\"a\" if i else \"b\" for i in y]\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.y)\n\n0      a\n1      a\n2      a\n3      a\n4      a\n      ..\n564    a\n565    a\n566    a\n567    a\n568    b\nName: target, Length: 569, dtype: object\n\n&gt;&gt;&gt; atom.clean(verbose=2)\n\nFitting Cleaner...\nCleaning the data...\n --&gt; Label-encoding column target.\n\n&gt;&gt;&gt; print(atom.y)\n\n0      0\n1      0\n2      0\n3      0\n4      0\n      ..\n564    0\n565    0\n566    0\n567    0\n568    1\nName: target, Length: 569, dtype: Int64\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Cleaner\n&gt;&gt;&gt; from numpy.random import randint\n\n&gt;&gt;&gt; y = [\"a\" if i else \"b\" for i in range(randint(100))]\n\n&gt;&gt;&gt; cleaner = Cleaner(verbose=2)\n&gt;&gt;&gt; y = cleaner.fit_transform(y=y)\n\nFitting Cleaner...\nCleaning the data...\n --&gt; Label-encoding column target.\n\n&gt;&gt;&gt; print(y)\n\n0     1\n1     0\n2     0\n3     0\n4     0\n5     0\n6     0\n7     0\n8     0\n9     0\n10    0\n11    0\n12    0\n13    0\n14    0\n15    0\n16    0\n17    0\n18    0\n19    0\n20    0\n21    0\n22    0\n23    0\n24    0\n25    0\n26    0\n27    0\n28    0\n29    0\n30    0\n31    0\n32    0\n33    0\n34    0\n35    0\n36    0\nName: target, dtype: Int64\n</code></pre>"}, {"location": "api/data_cleaning/cleaner/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformInversely transform the label encoding.set_outputSet output container.set_paramsSet the parameters of this estimator.transformApply the data cleaning steps to the data.</p> <p></p> <p></p> method fit(X=None, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features: sequence or None, default=None Only used to validate feature names with the names seen in <code>fit</code>. <p>Returns np.ndarray Transformed feature names. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None)[source] <p>Inversely transform the label encoding.</p> <p>This method only inversely transforms the target encoding. The rest of the transformations can't be inverted. If <code>encode_target=False</code>, the data is returned as is.</p> <p>Parameters X: dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns dataframe Unchanged feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X=None, y=None)[source] <p>Apply the data cleaning steps to the data.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p>"}, {"location": "api/data_cleaning/decomposer/", "title": "Decomposer", "text": "class atom.data_cleaning.Decomposer(model=None, trend_model=\"additive\", test_seasonality=True, sp=None, seasonal_model=\"additive\", n_jobs=1, verbose=0, random_state=None)[source] <p>Detrend and deseasonalize the time series.</p> <p>This class does two things:</p> <ul> <li>Remove the trend from every column, returning the in-sample   residuals of the model's predicted values.</li> <li>Remove the seasonal component from every column, subject to   a seasonaility test.</li> </ul> <p>Categorical columns are ignored.</p> <p>This class can be accessed from atom through the decompose method. Read more in the user guide.</p> <p>Note</p> <p>When using this class from atom, the <code>trend_model</code>, <code>sp</code> and <code>seasonal_model</code> parameters are set automatically based on the <code>atom.sp</code> attribute.</p> <p>Parameters model: str, predictor or None, default=None The forecasting model to remove the trend with. It must be a model that supports the forecast task. If None, PolynomialTrend(degree=1) is used. <p> trend_model: str, default=\"additive\" Mode of the trend decomposition. Choose from: <ul> <li>\"additive\": The <code>model.transform</code> subtracts the trend, i.e.,   <code>transform(X)</code> returns <code>X - model.predict(fh=X.index)</code>.</li> <li>\"multiplicative\": The <code>model.transform</code> divides by the trend,   i.e., <code>transform(X)</code> returns <code>X / model.predict(fh=X.index)</code>.</li> </ul> <p> test_seasonality: bool, default=True <ul> <li>If True, it fits a 90% autocorrelation seasonality test, and   if the passed time series has a seasonal component, it   applies seasonal decomposition. If the test is negative,   deseasonalization is skipped.</li> <li>If False, always performs deseasonalization.</li> </ul> <p> sp: int or None, default=None Seasonality period of the time series. If None, there's no seasonality. <p> seasonal_model: str, default=\"additive\" Mode of the seasonal decomposition. Choose from: <ul> <li>\"additive\": Assumes the components have a linear relation,   i.e., y(t) = level + trend + seasonality + noise.</li> <li>\"multiplicative\": Assumes the components have a nonlinear   relation, i.e., y(t) = level * trend * seasonality * noise.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p>Attributes feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Encoder Perform encoding of categorical features.</p> <p>Discretizer Bin continuous data into intervals.</p> <p>Scaler Scale the data.</p> <p></p>"}, {"location": "api/data_cleaning/decomposer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; print(atom.y)\n\nPeriod\n1949-01    112.0\n1949-02    118.0\n1949-03    132.0\n1949-04    129.0\n1949-05    121.0\n           ...  \n1960-08    606.0\n1960-09    508.0\n1960-10    461.0\n1960-11    390.0\n1960-12    432.0\nFreq: M, Name: Number of airline passengers, Length: 144, dtype: float64\n\n&gt;&gt;&gt; atom.decompose(columns=-1, verbose=2)\n\nFitting Decomposer...\nDecomposing the data...\n\n&gt;&gt;&gt; print(atom.y)\n\nPeriod\n1949-01     17.329355\n1949-02     20.763057\n1949-03     32.196759\n1949-04     26.630462\n1949-05     16.064164\n              ...    \n1960-08    154.613985\n1960-09     54.047688\n1960-10      4.481390\n1960-11    -69.084908\n1960-12    -29.651205\nFreq: M, Name: Number of airline passengers, Length: 144, dtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Decomposer\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; X, _ = load_longley()\n\n&gt;&gt;&gt; decomposer = Decomposer(verbose=2)\n&gt;&gt;&gt; X = decomposer.fit_transform(X)\n\nFitting Decomposer...\nDecomposing the data...\n\n&gt;&gt;&gt; print(X)\n\n             TOTEMP\nPeriod             \n1947     379.838235\n1948     462.326471\n1949   -1205.185294\n1950    -905.697059\n1951     411.791176\n1952     113.279412\n1953     746.767647\n1954   -1197.744118\n1955     343.744118\n1956    1465.232353\n1957    1060.720588\n1958   -1311.791176\n1959     113.697059\n1960     306.185294\n1961    -643.326471\n1962    -139.838235\n</code></pre>"}, {"location": "api/data_cleaning/decomposer/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformInversely transform the data.set_outputSet output container.set_paramsSet the parameters of this estimator.transformDecompose the data.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X, y=None)[source] <p>Inversely transform the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Original feature set. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Decompose the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed feature set. </p> <p></p>"}, {"location": "api/data_cleaning/discretizer/", "title": "Discretizer", "text": "class atom.data_cleaning.Discretizer(strategy=\"quantile\", bins=5, labels=None, device=\"cpu\", engine=None, verbose=0, random_state=None)[source] <p>Bin continuous data into intervals.</p> <p>For each feature, the bin edges are computed during fit and, together with the number of bins, they define the intervals. Ignores categorical columns.</p> <p>This class can be accessed from atom through the discretize method. Read more in the user guide.</p> <p>Tip</p> <p>The transformation returns categorical columns. Use the Encoder class to convert them back to numerical types.</p> <p>Parameters strategy: str, default=\"quantile\" Strategy used to define the widths of the bins. Choose from: <ul> <li>\"uniform\": All bins have identical widths.</li> <li>\"quantile\": All bins have the same number of points.</li> <li>\"kmeans\": Values in each bin have the same nearest center of   a 1D k-means cluster.</li> <li>\"custom\": Use custom bin edges provided through <code>bins</code>.</li> </ul> <p> bins: int, sequence or dict, default=5 Bin number or bin edges in which to split every column. <ul> <li>If int: Number of bins to produce for all columns. Only for   strategy!=\"custom\".</li> <li> <p>If sequence:</p> <ul> <li>For strategy!=\"custom\": Number of bins per column. The   n-th value corresponds to the n-th column that is   transformed. Categorical columns are ignored.</li> <li>For strategy=\"custom\": Bin edges with length=n_bins - 1.   The outermost edges are always <code>-inf</code> and <code>+inf</code>, e.g.,   bins <code>[1, 2]</code> indicate <code>(-inf, 1], (1, 2], (2, inf]</code>.</li> </ul> </li> <li> <p>If dict: One of the aforementioned options per column, where   the key is the column's name. Columns that are not in the   dictionary are not transformed.</p> </li> </ul> <p> labels: sequence, dict or None, default=None Label names with which to replace the binned intervals. <ul> <li>If None: Use default labels of the form <code>(min_edge, max_edge]</code>.</li> <li>If sequence: Labels to use for all columns.</li> <li>If dict: Labels per column, where the key is the column's name.   Columns that are not in the dictionary use the default labels.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. Only for strategy=\"quantile\". <p>Attributes feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Encoder Perform encoding of categorical features.</p> <p>Imputer Handle missing values in the data.</p> <p>Normalizer Transform the data to follow a Normal/Gaussian distribution.</p> <p></p>"}, {"location": "api/data_cleaning/discretizer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom[\"mean radius\"])\n\n0      13.48\n1      18.31\n2      17.93\n3      15.13\n4       8.95\n       ...  \n564    14.34\n565    13.17\n566    17.30\n567    17.68\n568    14.80\nName: mean radius, Length: 569, dtype: float64\n\n&gt;&gt;&gt; atom.discretize(\n...     strategy=\"custom\",\n...     bins=[13, 18],\n...     labels=[\"small\", \"medium\", \"large\"],\n...     verbose=2,\n...     columns=\"mean radius\",\n... )\n\nFitting Discretizer...\nBinning the features...\n --&gt; Discretizing feature mean radius in 3 bins.\n\n&gt;&gt;&gt; print(atom[\"mean radius\"])\n\n0      medium\n1       large\n2      medium\n3      medium\n4       small\n        ...  \n564    medium\n565    medium\n566    medium\n567    medium\n568    medium\nName: mean radius, Length: 569, dtype: category\nCategories (3, object): ['small' &lt; 'medium' &lt; 'large']\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Discretizer\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n&gt;&gt;&gt; print(X[\"mean radius\"])\n\n0      17.99\n1      20.57\n2      19.69\n3      11.42\n4      20.29\n       ...  \n564    21.56\n565    20.13\n566    16.60\n567    20.60\n568     7.76\nName: mean radius, Length: 569, dtype: float64\n\n&gt;&gt;&gt; discretizer = Discretizer(\n...     strategy=\"custom\",\n...     bins={\"mean radius\": [13, 18]},\n...     labels=[\"small\", \"medium\", \"large\"],\n...     verbose=2,\n... )\n&gt;&gt;&gt; X = discretizer.fit_transform(X)\n\nFitting Discretizer...\nBinning the features...\n --&gt; Discretizing feature mean radius in 3 bins.\n\n&gt;&gt;&gt; print(X[\"mean radius\"])\n\n0      medium\n1       large\n2       large\n3       small\n4       large\n        ...  \n564     large\n565     large\n566    medium\n567     large\n568     small\nName: mean radius, Length: 569, dtype: category\nCategories (3, object): ['small' &lt; 'medium' &lt; 'large']\n</code></pre>"}, {"location": "api/data_cleaning/discretizer/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformBin the data into intervals.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Bin the data into intervals.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed feature set. </p> <p></p>"}, {"location": "api/data_cleaning/encoder/", "title": "Encoder", "text": "class atom.data_cleaning.Encoder(strategy=\"Target\", max_onehot=10, ordinal=None, infrequent_to_value=None, value=\"infrequent\", n_jobs=1, verbose=0, **kwargs)[source] <p>Perform encoding of categorical features.</p> <p>The encoding type depends on the number of classes in the column:</p> <ul> <li>If n_classes=2 or ordinal feature, use Ordinal-encoding.</li> <li>If 2 &lt; n_classes &lt;= <code>max_onehot</code>, use OneHot-encoding.</li> <li>If n_classes &gt; <code>max_onehot</code>, use <code>strategy</code>-encoding.</li> </ul> <p>Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Infrequent classes can be replaced with a value in order to prevent too high cardinality.</p> <p>This class can be accessed from atom through the encode method. Read more in the user guide.</p> <p>Warning</p> <p>Three category-encoders estimators are unavailable:</p> <ul> <li>OneHotEncoder: Use the max_onehot parameter.</li> <li>HashingEncoder: Incompatibility of APIs.</li> <li>LeaveOneOutEncoder: Incompatibility of APIs.</li> </ul> <p>Parameters strategy: str or transformer, default=\"Target\" Type of encoding to use for high cardinality features. Choose from any of the estimators in the category-encoders package or provide a custom one. <p> max_onehot: int or None, default=10 Maximum number of unique values in a feature to perform one-hot encoding. If None, <code>strategy</code>-encoding is always used for columns with more than two classes. <p> ordinal: dict or None, default=None Order of ordinal features, where the dict key is the feature's name and the value is the class order, e.g., <code>{\"salary\": [\"low\", \"medium\", \"high\"]}</code>. <p> infrequent_to_value: int, float or None, default=None Replaces infrequent class occurrences in categorical columns with the string in parameter <code>value</code>. This transformation is done before the encoding of the column. <ul> <li>If None: Skip this step.</li> <li>If int: Minimum number of occurrences in a class.</li> <li>If float: Minimum fraction of occurrences in a class.</li> </ul> <p> value: str, default=\"infrequent\" Value with which to replace rare classes. This parameter is ignored if <code>infrequent_to_value=None</code>. <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 - value.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> **kwargs Additional keyword arguments for the <code>strategy</code> estimator. <p>Attributes mapping_: dict of dicts Encoded values and their respective mapping. The column name is the key to its mapping dictionary. Only for ordinal encoding. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Cleaner Applies standard data cleaning steps on a dataset.</p> <p>Imputer Handle missing values in the data.</p> <p>Pruner Prune outliers from the data.</p> <p></p>"}, {"location": "api/data_cleaning/encoder/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from numpy.random import randint\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n&gt;&gt;&gt; X[\"cat_feature_1\"] = [f\"x{i}\" for i in randint(0, 2, len(X))]\n&gt;&gt;&gt; X[\"cat_feature_2\"] = [f\"x{i}\" for i in randint(0, 3, len(X))]\n&gt;&gt;&gt; X[\"cat_feature_3\"] = [f\"x{i}\" for i in randint(0, 20, len(X))]\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  cat_feature_1  cat_feature_2  cat_feature_3\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...            0.1610            0.42250           0.5030               0.22580          0.2807                  0.10710             x1             x2            x10\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690              0.09451         0.1860  ...            0.1492            0.25360           0.3759               0.15100          0.3074                  0.07863             x0             x1             x6\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699              0.04744         0.1538  ...            0.1315            0.18060           0.2080               0.11360          0.2504                  0.07948             x0             x2             x9\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686              0.02739         0.1852  ...            0.1148            0.09866           0.1547               0.06575          0.3233                  0.06165             x0             x2            x11\n4           8.95         15.76           58.74      245.2          0.09462           0.12430         0.09263              0.02308         0.1305  ...            0.1179            0.18790           0.1544               0.03846          0.1652                  0.07722             x0             x0             x3\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...               ...                ...              ...                   ...             ...                      ...            ...            ...            ...\n564        14.34         13.47           92.51      641.2          0.09906           0.07624         0.05724              0.04603         0.2075  ...            0.1297            0.15250           0.1632               0.10870          0.3062                  0.06072             x1             x2            x11\n565        13.17         21.81           85.42      531.5          0.09714           0.10470         0.08259              0.05252         0.1746  ...            0.1503            0.39040           0.3728               0.16070          0.3693                  0.09618             x0             x1             x4\n566        17.30         17.08          113.00      928.2          0.10080           0.10410         0.12660              0.08353         0.1813  ...            0.1416            0.24050           0.3378               0.18570          0.3138                  0.08113             x0             x1            x10\n567        17.68         20.74          117.40      963.7          0.11150           0.16650         0.18550              0.10540         0.1971  ...            0.1418            0.34980           0.3583               0.15150          0.2463                  0.07738             x0             x1            x16\n568        14.80         17.66           95.88      674.8          0.09179           0.08890         0.04069              0.02260         0.1893  ...            0.1226            0.18810           0.2060               0.08308          0.3600                  0.07285             x1             x1             x2\n\n[569 rows x 33 columns]\n\n&gt;&gt;&gt; atom.encode(strategy=\"target\", max_onehot=10, verbose=2)\n\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Ordinal-encoding feature cat_feature_1. Contains 2 classes.\n --&gt; OneHot-encoding feature cat_feature_2. Contains 3 classes.\n --&gt; Target-encoding feature cat_feature_3. Contains 20 classes.\n\n&gt;&gt;&gt; # Note the one-hot encoded column with name [feature]_[class]\n&gt;&gt;&gt; print(atom.X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst concavity  worst concave points  worst symmetry  worst fractal dimension  cat_feature_1  cat_feature_2_x2  cat_feature_2_x1  cat_feature_2_x0  cat_feature_3\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...           0.5030               0.22580          0.2807                  0.10710            1.0               1.0               0.0               0.0       0.604275\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690              0.09451         0.1860  ...           0.3759               0.15100          0.3074                  0.07863            0.0               0.0               1.0               0.0       0.495404\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699              0.04744         0.1538  ...           0.2080               0.11360          0.2504                  0.07948            0.0               1.0               0.0               0.0       0.604073\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686              0.02739         0.1852  ...           0.1547               0.06575          0.3233                  0.06165            0.0               1.0               0.0               0.0       0.657228\n4           8.95         15.76           58.74      245.2          0.09462           0.12430         0.09263              0.02308         0.1305  ...           0.1544               0.03846          0.1652                  0.07722            0.0               0.0               0.0               1.0       0.660063\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...                   ...             ...                      ...            ...               ...               ...               ...            ...\n564        14.34         13.47           92.51      641.2          0.09906           0.07624         0.05724              0.04603         0.2075  ...           0.1632               0.10870          0.3062                  0.06072            1.0               1.0               0.0               0.0       0.657228\n565        13.17         21.81           85.42      531.5          0.09714           0.10470         0.08259              0.05252         0.1746  ...           0.3728               0.16070          0.3693                  0.09618            0.0               0.0               1.0               0.0       0.616927\n566        17.30         17.08          113.00      928.2          0.10080           0.10410         0.12660              0.08353         0.1813  ...           0.3378               0.18570          0.3138                  0.08113            0.0               0.0               1.0               0.0       0.604275\n567        17.68         20.74          117.40      963.7          0.11150           0.16650         0.18550              0.10540         0.1971  ...           0.3583               0.15150          0.2463                  0.07738            0.0               0.0               1.0               0.0       0.675771\n568        14.80         17.66           95.88      674.8          0.09179           0.08890         0.04069              0.02260         0.1893  ...           0.2060               0.08308          0.3600                  0.07285            1.0               0.0               1.0               0.0       0.591592\n\n[569 rows x 35 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Encoder\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from numpy.random import randint\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n&gt;&gt;&gt; X[\"cat_feature_1\"] = [f\"x{i}\" for i in randint(0, 2, len(X))]\n&gt;&gt;&gt; X[\"cat_feature_2\"] = [f\"x{i}\" for i in randint(0, 3, len(X))]\n&gt;&gt;&gt; X[\"cat_feature_3\"] = [f\"x{i}\" for i in randint(0, 20, len(X))]\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  cat_feature_1  cat_feature_2  cat_feature_3\n0          17.99         10.38          122.80     1001.0          0.11840           0.27760         0.30010              0.14710         0.2419  ...           0.16220            0.66560           0.7119                0.2654          0.4601                  0.11890             x1             x2             x5\n1          20.57         17.77          132.90     1326.0          0.08474           0.07864         0.08690              0.07017         0.1812  ...           0.12380            0.18660           0.2416                0.1860          0.2750                  0.08902             x1             x2            x13\n2          19.69         21.25          130.00     1203.0          0.10960           0.15990         0.19740              0.12790         0.2069  ...           0.14440            0.42450           0.4504                0.2430          0.3613                  0.08758             x0             x0            x15\n3          11.42         20.38           77.58      386.1          0.14250           0.28390         0.24140              0.10520         0.2597  ...           0.20980            0.86630           0.6869                0.2575          0.6638                  0.17300             x0             x2            x10\n4          20.29         14.34          135.10     1297.0          0.10030           0.13280         0.19800              0.10430         0.1809  ...           0.13740            0.20500           0.4000                0.1625          0.2364                  0.07678             x1             x1            x17\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...               ...                ...              ...                   ...             ...                      ...            ...            ...            ...\n564        21.56         22.39          142.00     1479.0          0.11100           0.11590         0.24390              0.13890         0.1726  ...           0.14100            0.21130           0.4107                0.2216          0.2060                  0.07115             x1             x1            x12\n565        20.13         28.25          131.20     1261.0          0.09780           0.10340         0.14400              0.09791         0.1752  ...           0.11660            0.19220           0.3215                0.1628          0.2572                  0.06637             x0             x2            x14\n566        16.60         28.08          108.30      858.1          0.08455           0.10230         0.09251              0.05302         0.1590  ...           0.11390            0.30940           0.3403                0.1418          0.2218                  0.07820             x0             x1             x3\n567        20.60         29.33          140.10     1265.0          0.11780           0.27700         0.35140              0.15200         0.2397  ...           0.16500            0.86810           0.9387                0.2650          0.4087                  0.12400             x1             x0             x2\n568         7.76         24.54           47.92      181.0          0.05263           0.04362         0.00000              0.00000         0.1587  ...           0.08996            0.06444           0.0000                0.0000          0.2871                  0.07039             x1             x1            x11\n\n[569 rows x 33 columns]\n\n&gt;&gt;&gt; encoder = Encoder(strategy=\"target\", max_onehot=10, verbose=2)\n&gt;&gt;&gt; X = encoder.fit_transform(X, y)\n\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Ordinal-encoding feature cat_feature_1. Contains 2 classes.\n --&gt; OneHot-encoding feature cat_feature_2. Contains 3 classes.\n --&gt; Target-encoding feature cat_feature_3. Contains 20 classes.\n\n&gt;&gt;&gt; # Note the one-hot encoded column with name [feature]_[class]\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst concavity  worst concave points  worst symmetry  worst fractal dimension  cat_feature_1  cat_feature_2_x2  cat_feature_2_x0  cat_feature_2_x1  cat_feature_3\n0          17.99         10.38          122.80     1001.0          0.11840           0.27760         0.30010              0.14710         0.2419  ...           0.7119                0.2654          0.4601                  0.11890            1.0               1.0               0.0               0.0       0.645086\n1          20.57         17.77          132.90     1326.0          0.08474           0.07864         0.08690              0.07017         0.1812  ...           0.2416                0.1860          0.2750                  0.08902            1.0               1.0               0.0               0.0       0.604148\n2          19.69         21.25          130.00     1203.0          0.10960           0.15990         0.19740              0.12790         0.2069  ...           0.4504                0.2430          0.3613                  0.08758            0.0               0.0               1.0               0.0       0.675079\n3          11.42         20.38           77.58      386.1          0.14250           0.28390         0.24140              0.10520         0.2597  ...           0.6869                0.2575          0.6638                  0.17300            0.0               1.0               0.0               0.0       0.706297\n4          20.29         14.34          135.10     1297.0          0.10030           0.13280         0.19800              0.10430         0.1809  ...           0.4000                0.1625          0.2364                  0.07678            1.0               0.0               0.0               1.0       0.716566\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...                   ...             ...                      ...            ...               ...               ...               ...            ...\n564        21.56         22.39          142.00     1479.0          0.11100           0.11590         0.24390              0.13890         0.1726  ...           0.4107                0.2216          0.2060                  0.07115            1.0               0.0               0.0               1.0       0.598024\n565        20.13         28.25          131.20     1261.0          0.09780           0.10340         0.14400              0.09791         0.1752  ...           0.3215                0.1628          0.2572                  0.06637            0.0               1.0               0.0               0.0       0.683185\n566        16.60         28.08          108.30      858.1          0.08455           0.10230         0.09251              0.05302         0.1590  ...           0.3403                0.1418          0.2218                  0.07820            0.0               0.0               0.0               1.0       0.472908\n567        20.60         29.33          140.10     1265.0          0.11780           0.27700         0.35140              0.15200         0.2397  ...           0.9387                0.2650          0.4087                  0.12400            1.0               0.0               1.0               0.0       0.585452\n568         7.76         24.54           47.92      181.0          0.05263           0.04362         0.00000              0.00000         0.1587  ...           0.0000                0.0000          0.2871                  0.07039            1.0               0.0               0.0               1.0       0.516759\n\n[569 rows x 35 columns]\n</code></pre>"}, {"location": "api/data_cleaning/encoder/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformEncode the data.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Note that leaving y=None can lead to errors if the <code>strategy</code> encoder requires target values. For multioutput tasks, only the first target column is used to fit the encoder.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence or dataframe-like Target column(s) corresponding to <code>X</code>. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features: sequence or None, default=None Only used to validate feature names with the names seen in <code>fit</code>. <p>Returns np.ndarray Transformed feature names. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Encode the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Encoded dataframe. </p> <p></p>"}, {"location": "api/data_cleaning/imputer/", "title": "Imputer", "text": "class atom.data_cleaning.Imputer(strat_num=\"mean\", strat_cat=\"most_frequent\", max_nan_rows=None, max_nan_cols=None, n_jobs=1, device=\"cpu\", engine=None, verbose=0, random_state=None)[source] <p>Handle missing values in the data.</p> <p>Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the <code>missing_</code> attribute to customize what are considered \"missing values\".</p> <p>This class can be accessed from atom through the impute method. Read more in the user guide.</p> <p>Parameters strat_num: int, float, str or callable, default=\"mean\" Imputing strategy for numerical columns. Choose from: <ul> <li>\"drop\": Drop rows containing missing values.</li> <li>\"mean\": Impute with mean of column.</li> <li>\"median\": Impute with median of column.</li> <li>\"most_frequent\": Impute with the most frequent value.</li> <li>\"knn\": Impute using a K-Nearest Neighbors approach.</li> <li>\"iterative\": Impute using a multivariate imputer.</li> <li>\"drift\": Impute values using a PolynomialTrend model.</li> <li>\"linear\": Impute using linear interpolation.</li> <li>\"nearest\": Impute with nearest value.</li> <li>\"bfill\": Impute by using the next valid observation to fill    the gap.</li> <li>\"ffill\": Impute by propagating the last valid observation   to next valid.</li> <li>\"random\": Impute with random values between the min and max    of column.</li> <li>int or float: Impute with provided numerical value.</li> <li>callable: Replace missing values using the scalar statistic   returned by running the callable over a dense 1d array   containing non-missing values of each column.</li> </ul> <p> strat_cat: str, default=\"most_frequent\" Imputing strategy for categorical columns. Choose from: <ul> <li>\"drop\": Drop rows containing missing values.</li> <li>\"most_frequent\": Impute with the most frequent value.</li> <li>str: Impute with provided string.</li> </ul> <p> max_nan_rows: int, float or None, default=None Maximum number or fraction of missing values in a row (if more, the row is removed). If None, ignore this step. <p> max_nan_cols: int, float or None, default=None Maximum number or fraction of missing values in a column (if more, the column is removed). If None, ignore this step. <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 - value.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. Only used when strat_num=\"iterative\". <p>Attributes missing_: list Values that are considered \"missing\". Default values are: None, NaN, NA, NaT, +inf, -inf, \"\", \"?\", \"NA\", \"nan\", \"NaN\", \"NaT\", \"none\", \"None\", \"inf\", \"-inf\". Note that None, NaN, NA, +inf and -inf are always considered missing since they are incompatible with sklearn estimators. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Balancer Balance the number of samples per class in the target column.</p> <p>Discretizer Bin continuous data into intervals.</p> <p>Encoder Perform encoding of categorical features.</p> <p></p>"}, {"location": "api/data_cleaning/imputer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from numpy.random import randint\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Add some random missing values to the data\n&gt;&gt;&gt; for i, j in zip(randint(0, X.shape[0], 600), randint(0, 4, 600)):\n...     X.iloc[i, j] = np.NaN\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.nans)\n\nmean radius                130\nmean texture               141\nmean perimeter             124\nmean area                  136\nmean smoothness              0\nmean compactness             0\nmean concavity               0\nmean concave points          0\nmean symmetry                0\nmean fractal dimension       0\nradius error                 0\ntexture error                0\nperimeter error              0\narea error                   0\nsmoothness error             0\ncompactness error            0\nconcavity error              0\nconcave points error         0\nsymmetry error               0\nfractal dimension error      0\nworst radius                 0\nworst texture                0\nworst perimeter              0\nworst area                   0\nworst smoothness             0\nworst compactness            0\nworst concavity              0\nworst concave points         0\nworst symmetry               0\nworst fractal dimension      0\ntarget                       0\ndtype: int64\n\n&gt;&gt;&gt; atom.impute(strat_num=\"median\", max_nan_rows=0.1, verbose=2)\n\nFitting Imputer...\nImputing missing values...\n --&gt; Imputing 130 missing values with median (13.27) in column mean radius.\n --&gt; Imputing 141 missing values with median (18.87) in column mean texture.\n --&gt; Imputing 124 missing values with median (85.66) in column mean perimeter.\n --&gt; Imputing 136 missing values with median (555.1) in column mean area.\n\n&gt;&gt;&gt; print(atom.n_nans)\n\n0\n</code></pre> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom.data_cleaning import Imputer\n&gt;&gt;&gt; from numpy.random import randint\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Add some random missing values to the data\n&gt;&gt;&gt; for i, j in zip(randint(0, X.shape[0], 600), randint(0, 4, 600)):\n...     X.iloc[i, j] = np.nan\n\n&gt;&gt;&gt; imputer = Imputer(strat_num=\"median\", max_nan_rows=0.1, verbose=2)\n&gt;&gt;&gt; X, y = imputer.fit_transform(X, y)\n\nFitting Imputer...\nImputing missing values...\n --&gt; Dropping 2 samples for containing more than 3 missing values.\n --&gt; Imputing 124 missing values with median (13.38) in column mean radius.\n --&gt; Imputing 127 missing values with median (18.87) in column mean texture.\n --&gt; Imputing 137 missing values with median (86.54) in column mean perimeter.\n --&gt; Imputing 134 missing values with median (561.3) in column mean area.\n\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst texture  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension\n0          13.38        10.380         122.800     1001.0          0.11840           0.27760         0.30010              0.14710         0.2419  ...          17.33           184.60      2019.0           0.16220            0.66560           0.7119                0.2654          0.4601                  0.11890\n1          20.57        17.770          86.545      561.3          0.08474           0.07864         0.08690              0.07017         0.1812  ...          23.41           158.80      1956.0           0.12380            0.18660           0.2416                0.1860          0.2750                  0.08902\n2          19.69        21.250         130.000     1203.0          0.10960           0.15990         0.19740              0.12790         0.2069  ...          25.53           152.50      1709.0           0.14440            0.42450           0.4504                0.2430          0.3613                  0.08758\n3          11.42        20.380          77.580      386.1          0.14250           0.28390         0.24140              0.10520         0.2597  ...          26.50            98.87       567.7           0.20980            0.86630           0.6869                0.2575          0.6638                  0.17300\n4          13.38        14.340         135.100     1297.0          0.10030           0.13280         0.19800              0.10430         0.1809  ...          16.67           152.20      1575.0           0.13740            0.20500           0.4000                0.1625          0.2364                  0.07678\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...            ...              ...         ...               ...                ...              ...                   ...             ...                      ...\n564        21.56        22.390          86.545      561.3          0.11100           0.11590         0.24390              0.13890         0.1726  ...          26.40           166.10      2027.0           0.14100            0.21130           0.4107                0.2216          0.2060                  0.07115\n565        20.13        18.865         131.200     1261.0          0.09780           0.10340         0.14400              0.09791         0.1752  ...          38.25           155.00      1731.0           0.11660            0.19220           0.3215                0.1628          0.2572                  0.06637\n566        13.38        28.080          86.545      561.3          0.08455           0.10230         0.09251              0.05302         0.1590  ...          34.12           126.70      1124.0           0.11390            0.30940           0.3403                0.1418          0.2218                  0.07820\n567        20.60        29.330         140.100     1265.0          0.11780           0.27700         0.35140              0.15200         0.2397  ...          39.42           184.60      1821.0           0.16500            0.86810           0.9387                0.2650          0.4087                  0.12400\n568        13.38        24.540          47.920      181.0          0.05263           0.04362         0.00000              0.00000         0.1587  ...          30.37            59.16       268.6           0.08996            0.06444           0.0000                0.0000          0.2871                  0.07039\n\n[567 rows x 30 columns]\n</code></pre>"}, {"location": "api/data_cleaning/imputer/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformImpute the missing values.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features: sequence or None, default=None Only used to validate feature names with the names seen in <code>fit</code>. <p>Returns np.ndarray Transformed feature names. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Impute the missing values.</p> <p>Note that leaving y=None can lead to inconsistencies in data length between X and y if rows are dropped during the transformation.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns dataframe Imputed dataframe. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p>"}, {"location": "api/data_cleaning/normalizer/", "title": "Normalizer", "text": "class atom.data_cleaning.Normalizer(strategy=\"yeojohnson\", device=\"cpu\", engine=None, verbose=0, random_state=None, **kwargs)[source] <p>Transform the data to follow a Normal/Gaussian distribution.</p> <p>This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Categorical columns are ignored.</p> <p>This class can be accessed from atom through the normalize method. Read more in the user guide.</p> <p>Warning</p> <p>The quantile strategy performs a non-linear transformation. This may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable.</p> <p>Note</p> <p>The yeojohnson and boxcox strategies scale the data after transforming. Use the <code>kwargs</code> to change this behavior.</p> <p>Parameters strategy: str, default=\"yeojohnson\" The transforming strategy. Choose from: <ul> <li>\"yeojohnson\"</li> <li>\"boxcox\" (only works with strictly positive values)</li> <li>\"quantile\": Transform features using quantiles information.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> </ul> <p> random_state: int or None, default=None Seed used by the quantile strategy. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p> **kwargs Additional keyword arguments for the <code>strategy</code> estimator. <p>Attributes{#normalizer-[strategy]} [strategy]: sklearn transformer Object with which the data is transformed, e.g., <code>normalizer.yeojohnson</code> for the default strategy. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Cleaner Applies standard data cleaning steps on a dataset.</p> <p>Pruner Prune outliers from the data.</p> <p>Scaler Scale the data.</p> <p></p>"}, {"location": "api/data_cleaning/normalizer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...           107.30       740.4            0.1610            0.42250           0.5030               0.22580          0.2807                  0.10710       0\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690              0.09451         0.1860  ...           142.20      1493.0            0.1492            0.25360           0.3759               0.15100          0.3074                  0.07863       0\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699              0.04744         0.1538  ...           135.10      1320.0            0.1315            0.18060           0.2080               0.11360          0.2504                  0.07948       0\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686              0.02739         0.1852  ...           110.10       931.4            0.1148            0.09866           0.1547               0.06575          0.3233                  0.06165       0\n4           8.95         15.76           58.74      245.2          0.09462           0.12430         0.09263              0.02308         0.1305  ...            63.34       270.0            0.1179            0.18790           0.1544               0.03846          0.1652                  0.07722       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n564        14.34         13.47           92.51      641.2          0.09906           0.07624         0.05724              0.04603         0.2075  ...           110.40       873.2            0.1297            0.15250           0.1632               0.10870          0.3062                  0.06072       1\n565        13.17         21.81           85.42      531.5          0.09714           0.10470         0.08259              0.05252         0.1746  ...           105.50       740.7            0.1503            0.39040           0.3728               0.16070          0.3693                  0.09618       0\n566        17.30         17.08          113.00      928.2          0.10080           0.10410         0.12660              0.08353         0.1813  ...           130.90      1222.0            0.1416            0.24050           0.3378               0.18570          0.3138                  0.08113       0\n567        17.68         20.74          117.40      963.7          0.11150           0.16650         0.18550              0.10540         0.1971  ...           132.90      1302.0            0.1418            0.34980           0.3583               0.15150          0.2463                  0.07738       0\n568        14.80         17.66           95.88      674.8          0.09179           0.08890         0.04069              0.02260         0.1893  ...           105.90       829.5            0.1226            0.18810           0.2060               0.08308          0.3600                  0.07285       1\n\n[569 rows x 31 columns]\n\n&gt;&gt;&gt; atom.plot_distribution(columns=0)\n</code></pre> <pre><code>&gt;&gt;&gt; atom.normalize(verbose=2)\n\nFitting Normalizer...\nNormalizing features...\n\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0      -0.017068      0.464087        0.031104  -0.020222         0.390628          0.620790        0.562136             0.426774      -0.280554  ...         0.251532    0.081524          1.224389           1.206519         1.189835              1.522769       -0.043007                 1.378960       0\n1       1.182066      0.411242        1.183030   1.200556         0.741209          0.608244        1.100342             1.256472       0.256014  ...         1.119375    1.218096          0.759546           0.244492         0.726989              0.650523        0.424017                -0.164104       0\n2       1.105309      1.197684        1.018344   1.106437        -0.552214         -0.652544       -0.230044             0.226950      -1.050816  ...         0.973194    1.037232          0.002307          -0.374986        -0.128679              0.107299       -0.647198                -0.100126       0\n3       0.455144      2.077941        0.379512   0.486019        -0.966587         -1.447057       -0.438308            -0.480189       0.226570  ...         0.337722    0.483003         -0.785100          -1.301043        -0.483292             -0.722786        0.676588                -1.783846       0\n4      -1.898537     -0.815757       -1.745528  -1.873415        -0.102067          0.599235        0.374346            -0.662103      -2.173761  ...        -1.869111   -2.095123         -0.633206          -0.305478        -0.485431             -1.278472       -2.898859                -0.273347       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n564     0.238929     -1.546154        0.209113   0.257899         0.214334         -0.482480       -0.225132             0.183841       0.996371  ...         0.346743    0.373205         -0.079012          -0.660736        -0.423384              0.029761        0.404215                -1.894769       1\n565    -0.115233      0.675396       -0.105672  -0.125511         0.078814          0.213069        0.222118             0.375009      -0.177404  ...         0.194134    0.082260          0.804177           1.061384         0.714032              0.778530        1.315113                 0.913117       0\n566     0.972621     -0.443853        0.950416   0.971288         0.335466          0.200161        0.804757             1.074782       0.080964  ...         0.880583    0.920102          0.443592           0.144776         0.561298              1.086695        0.527842                 0.020173       0\n567     1.053489      0.446545        1.084407   1.040647         1.046541          1.237987        1.321388             1.410770       0.650180  ...         0.925288    1.016604          0.452080           0.855688         0.652219              0.657243       -0.735710                -0.260751       0\n568     0.366875     -0.289945        0.346701   0.359700        -0.309357         -0.150999       -0.574459            -0.683107       0.375972  ...         0.207028    0.284140         -0.407994          -0.303600        -0.141124             -0.402554        1.196110                -0.638106       1\n\n[569 rows x 31 columns]\n\n&gt;&gt;&gt; atom.plot_distribution(columns=0)\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Normalizer\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; normalizer = Normalizer(verbose=2)\n&gt;&gt;&gt; X = normalizer.fit_transform(X)\n\nFitting Normalizer...\nNormalizing features...\n\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst texture  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension\n0       1.134881     -2.678666        1.259822   1.126421         1.504114          2.165938        1.862988             1.848558       1.953067  ...      -1.488367         1.810506    1.652210          1.282792           1.942737         1.730182              1.935654        2.197206                 1.723624\n1       1.619346     -0.264377        1.528723   1.633946        -0.820227         -0.384102        0.291976             0.820609       0.102291  ...      -0.288382         1.430616    1.610022         -0.325080          -0.296580         0.070746              1.101594       -0.121997                 0.537179\n2       1.464796      0.547806        1.454664   1.461645         0.963977          1.163977        1.403673             1.683104       0.985668  ...       0.071406         1.321941    1.425307          0.580301           1.209701         1.005512              1.722744        1.218181                 0.453955\n3      -0.759262      0.357721       -0.514886  -0.836238         2.781494          2.197843        1.642391             1.423004       2.360528  ...       0.228089        -0.039480   -0.436860          2.857821           2.282276         1.675087              1.862378        3.250202                 2.517606\n4       1.571260     -1.233520        1.583340   1.595120         0.343932          0.762392        1.407479             1.410929       0.090964  ...      -1.637882         1.316582    1.309486          0.284367          -0.131829         0.817474              0.807077       -0.943554                -0.279402\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...            ...              ...         ...               ...                ...              ...                   ...             ...                      ...\n564     1.781795      0.785604        1.746492   1.823030         1.052829          0.460810        1.653784             1.783067      -0.232645  ...       0.212151         1.547961    1.657442          0.438013          -0.077871         0.859079              1.503734       -1.721528                -0.751459\n565     1.543335      1.845150        1.485601   1.545430         0.168014          0.207602        0.984746             1.320730      -0.129120  ...       1.832201         1.365939    1.443167         -0.667317          -0.245277         0.480804              0.810995       -0.480093                -1.210527\n566     0.828589      1.817618        0.811329   0.835270        -0.835509          0.183969        0.375105             0.396882      -0.808189  ...       1.320625         0.786129    0.796192         -0.799337           0.626487         0.566826              0.526136       -1.301164                -0.170872\n567     1.624440      2.016299        1.702747   1.551036         1.468642          2.162820        1.994466             1.884414       1.899087  ...       1.968949         1.810506    1.513198          1.387135           2.284642         2.136932              1.931990        1.744693                 1.850944\n568    -2.699432      1.203224       -2.827766  -2.703256        -3.834325         -1.481409       -1.658319            -1.845392      -0.821560  ...       0.810681        -2.231436   -2.149403         -2.064647          -1.731936        -1.819966             -2.131070        0.103122                -0.820663\n\n[569 rows x 30 columns]\n</code></pre>"}, {"location": "api/data_cleaning/normalizer/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformApply the inverse transformation to the data.set_outputSet output container.set_paramsSet the parameters of this estimator.transformApply the transformations to the data.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X, y=None)[source] <p>Apply the inverse transformation to the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Original dataframe. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Apply the transformations to the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Normalized dataframe. </p> <p></p>"}, {"location": "api/data_cleaning/pruner/", "title": "Pruner", "text": "class atom.data_cleaning.Pruner(strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, device=\"cpu\", engine=None, verbose=0, **kwargs)[source] <p>Prune outliers from the data.</p> <p>Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns.</p> <p>This class can be accessed from atom through the prune method. Read more in the user guide.</p> <p>Info</p> <p>The \"sklearnex\" and \"cuml\" engines are only supported for strategy=\"dbscan\".</p> <p>Parameters strategy: str or sequence, default=\"zscore\" Strategy with which to select the outliers. If sequence of strategies, only samples marked as outliers by all chosen strategies are dropped. Choose from: <ul> <li>\"zscore\": Z-score of each data value.</li> <li>\"iforest\": Isolation Forest.</li> <li>\"ee\": Elliptic Envelope.</li> <li>\"lof\": Local Outlier Factor.</li> <li>\"svm\": One-class SVM.</li> <li>\"dbscan\": Density-Based Spatial Clustering.</li> <li>\"hdbscan\": Hierarchical Density-Based Spatial Clustering.</li> <li>\"optics\": DBSCAN-like clustering approach.</li> </ul> <p> method: int, float or str, default=\"drop\" Method to apply on the outliers. Only the zscore strategy accepts another method than \"drop\". Choose from: <ul> <li>\"drop\": Drop any sample with outlier values.</li> <li>\"minmax\": Replace outlier with the min/max of the column.</li> <li>Any numerical value with which to replace the outliers.</li> </ul> <p> max_sigma: int or float, default=3 Maximum allowed standard deviations from the mean of the column. If more, it is considered an outlier. Only if strategy=\"zscore\". <p> include_target: bool, default=False Whether to include the target column in the search for outliers. This can be useful for regression tasks. Only if strategy=\"zscore\". <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> **kwargs Additional keyword arguments for the <code>strategy</code> estimator. If sequence of strategies, the params should be provided in a dict with the strategy's name as key. <p>Attributes{#pruner-[strategy]} [strategy]: sklearn estimator Object used to prune the data, e.g., <code>pruner.iforest</code> for the isolation forest strategy. Not available for strategy=\"zscore\". <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Balancer Balance the number of samples per class in the target column.</p> <p>Normalizer Transform the data to follow a Normal/Gaussian distribution.</p> <p>Scaler Scale the data.</p> <p></p>"}, {"location": "api/data_cleaning/pruner/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...           107.30       740.4            0.1610            0.42250           0.5030               0.22580          0.2807                  0.10710       0\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690              0.09451         0.1860  ...           142.20      1493.0            0.1492            0.25360           0.3759               0.15100          0.3074                  0.07863       0\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699              0.04744         0.1538  ...           135.10      1320.0            0.1315            0.18060           0.2080               0.11360          0.2504                  0.07948       0\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686              0.02739         0.1852  ...           110.10       931.4            0.1148            0.09866           0.1547               0.06575          0.3233                  0.06165       0\n4           8.95         15.76           58.74      245.2          0.09462           0.12430         0.09263              0.02308         0.1305  ...            63.34       270.0            0.1179            0.18790           0.1544               0.03846          0.1652                  0.07722       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n564        14.34         13.47           92.51      641.2          0.09906           0.07624         0.05724              0.04603         0.2075  ...           110.40       873.2            0.1297            0.15250           0.1632               0.10870          0.3062                  0.06072       1\n565        13.17         21.81           85.42      531.5          0.09714           0.10470         0.08259              0.05252         0.1746  ...           105.50       740.7            0.1503            0.39040           0.3728               0.16070          0.3693                  0.09618       0\n566        17.30         17.08          113.00      928.2          0.10080           0.10410         0.12660              0.08353         0.1813  ...           130.90      1222.0            0.1416            0.24050           0.3378               0.18570          0.3138                  0.08113       0\n567        17.68         20.74          117.40      963.7          0.11150           0.16650         0.18550              0.10540         0.1971  ...           132.90      1302.0            0.1418            0.34980           0.3583               0.15150          0.2463                  0.07738       0\n568        14.80         17.66           95.88      674.8          0.09179           0.08890         0.04069              0.02260         0.1893  ...           105.90       829.5            0.1226            0.18810           0.2060               0.08308          0.3600                  0.07285       1\n\n[569 rows x 31 columns]\n\n&gt;&gt;&gt; atom.prune(stratgey=\"iforest\", verbose=2)\n\nFitting Pruner...\nPruning outliers...\n --&gt; Dropping 63 outliers.\n\n&gt;&gt;&gt; # Note the reduced number of rows\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...           107.30       740.4            0.1610            0.42250           0.5030               0.22580          0.2807                  0.10710       0\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690              0.09451         0.1860  ...           142.20      1493.0            0.1492            0.25360           0.3759               0.15100          0.3074                  0.07863       0\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699              0.04744         0.1538  ...           135.10      1320.0            0.1315            0.18060           0.2080               0.11360          0.2504                  0.07948       0\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686              0.02739         0.1852  ...           110.10       931.4            0.1148            0.09866           0.1547               0.06575          0.3233                  0.06165       0\n4          10.26         16.58           65.85      320.8          0.08877           0.08066         0.04358              0.02438         0.1669  ...            71.08       357.4            0.1461            0.22460           0.1783               0.08333          0.2691                  0.09479       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n501        14.34         13.47           92.51      641.2          0.09906           0.07624         0.05724              0.04603         0.2075  ...           110.40       873.2            0.1297            0.15250           0.1632               0.10870          0.3062                  0.06072       1\n502        13.17         21.81           85.42      531.5          0.09714           0.10470         0.08259              0.05252         0.1746  ...           105.50       740.7            0.1503            0.39040           0.3728               0.16070          0.3693                  0.09618       0\n503        17.30         17.08          113.00      928.2          0.10080           0.10410         0.12660              0.08353         0.1813  ...           130.90      1222.0            0.1416            0.24050           0.3378               0.18570          0.3138                  0.08113       0\n504        17.68         20.74          117.40      963.7          0.11150           0.16650         0.18550              0.10540         0.1971  ...           132.90      1302.0            0.1418            0.34980           0.3583               0.15150          0.2463                  0.07738       0\n505        14.80         17.66           95.88      674.8          0.09179           0.08890         0.04069              0.02260         0.1893  ...           105.90       829.5            0.1226            0.18810           0.2060               0.08308          0.3600                  0.07285       1\n\n[506 rows x 31 columns]\n\n&gt;&gt;&gt; atom.plot_distribution(columns=0)\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Normalizer\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; normalizer = Normalizer(verbose=2)\n&gt;&gt;&gt; X = normalizer.fit_transform(X)\n\nFitting Normalizer...\nNormalizing features...\n\n&gt;&gt;&gt; # Note the reduced number of rows\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst texture  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension\n0       1.134881     -2.678666        1.259822   1.126421         1.504114          2.165938        1.862988             1.848558       1.953067  ...      -1.488367         1.810506    1.652210          1.282792           1.942737         1.730182              1.935654        2.197206                 1.723624\n1       1.619346     -0.264377        1.528723   1.633946        -0.820227         -0.384102        0.291976             0.820609       0.102291  ...      -0.288382         1.430616    1.610022         -0.325080          -0.296580         0.070746              1.101594       -0.121997                 0.537179\n2       1.464796      0.547806        1.454664   1.461645         0.963977          1.163977        1.403673             1.683104       0.985668  ...       0.071406         1.321941    1.425307          0.580301           1.209701         1.005512              1.722744        1.218181                 0.453955\n3      -0.759262      0.357721       -0.514886  -0.836238         2.781494          2.197843        1.642391             1.423004       2.360528  ...       0.228089        -0.039480   -0.436860          2.857821           2.282276         1.675087              1.862378        3.250202                 2.517606\n4       1.571260     -1.233520        1.583340   1.595120         0.343932          0.762392        1.407479             1.410929       0.090964  ...      -1.637882         1.316582    1.309486          0.284367          -0.131829         0.817474              0.807077       -0.943554                -0.279402\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...            ...              ...         ...               ...                ...              ...                   ...             ...                      ...\n564     1.781795      0.785604        1.746492   1.823030         1.052829          0.460810        1.653784             1.783067      -0.232645  ...       0.212151         1.547961    1.657442          0.438013          -0.077871         0.859079              1.503734       -1.721528                -0.751459\n565     1.543335      1.845150        1.485601   1.545430         0.168014          0.207602        0.984746             1.320730      -0.129120  ...       1.832201         1.365939    1.443167         -0.667317          -0.245277         0.480804              0.810995       -0.480093                -1.210527\n566     0.828589      1.817618        0.811329   0.835270        -0.835509          0.183969        0.375105             0.396882      -0.808189  ...       1.320625         0.786129    0.796192         -0.799337           0.626487         0.566826              0.526136       -1.301164                -0.170872\n567     1.624440      2.016299        1.702747   1.551036         1.468642          2.162820        1.994466             1.884414       1.899087  ...       1.968949         1.810506    1.513198          1.387135           2.284642         2.136932              1.931990        1.744693                 1.850944\n568    -2.699432      1.203224       -2.827766  -2.703256        -3.834325         -1.481409       -1.658319            -1.845392      -0.821560  ...       0.810681        -2.231436   -2.149403         -2.064647          -1.731936        -1.819966             -2.131070        0.103122                -0.820663\n\n[569 rows x 30 columns]\n</code></pre>"}, {"location": "api/data_cleaning/pruner/#methods", "title": "Methods", "text": "<p>fitDo nothing.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformApply the outlier strategy on the data.</p> <p></p> <p></p> method fit(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Apply the outlier strategy on the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns dataframe Transformed feature set. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p>"}, {"location": "api/data_cleaning/scaler/", "title": "Scaler", "text": "class atom.data_cleaning.Scaler(strategy=\"standard\", include_binary=False, device=\"cpu\", engine=None, verbose=0, **kwargs)[source] <p>Scale the data.</p> <p>Apply one of sklearn's scaling strategies. Categorical columns are ignored.</p> <p>This class can be accessed from atom through the scale method. Read more in the user guide.</p> <p>Parameters strategy: str, default=\"standard\" Strategy with which to scale the data. Choose from: <ul> <li>\"standard\": Remove mean and scale to unit variance.</li> <li>\"minmax\": Scale features to a given range.</li> <li>\"maxabs\": Scale features by their maximum absolute value.</li> <li>\"robust\": Scale using statistics that are robust to outliers.</li> </ul> <p> include_binary: bool, default=False Whether to scale binary columns (only 0s and 1s). <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> </ul> <p> **kwargs Additional keyword arguments for the <code>strategy</code> estimator. <p>Attributes{#scaler-[strategy]} [strategy]: sklearn transformer Object with which the data is scaled, e.g., <code>scaler.standard</code> for the default strategy. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>Balancer Balance the number of samples per class in the target column.</p> <p>Normalizer Transform the data to follow a Normal/Gaussian distribution.</p> <p>Scaler Scale the data.</p> <p></p>"}, {"location": "api/data_cleaning/scaler/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0          13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...           107.30       740.4            0.1610            0.42250           0.5030               0.22580          0.2807                  0.10710       0\n1          18.31         20.58          120.80     1052.0          0.10680           0.12480         0.15690              0.09451         0.1860  ...           142.20      1493.0            0.1492            0.25360           0.3759               0.15100          0.3074                  0.07863       0\n2          17.93         24.48          115.20      998.9          0.08855           0.07027         0.05699              0.04744         0.1538  ...           135.10      1320.0            0.1315            0.18060           0.2080               0.11360          0.2504                  0.07948       0\n3          15.13         29.81           96.71      719.5          0.08320           0.04605         0.04686              0.02739         0.1852  ...           110.10       931.4            0.1148            0.09866           0.1547               0.06575          0.3233                  0.06165       0\n4           8.95         15.76           58.74      245.2          0.09462           0.12430         0.09263              0.02308         0.1305  ...            63.34       270.0            0.1179            0.18790           0.1544               0.03846          0.1652                  0.07722       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n564        14.34         13.47           92.51      641.2          0.09906           0.07624         0.05724              0.04603         0.2075  ...           110.40       873.2            0.1297            0.15250           0.1632               0.10870          0.3062                  0.06072       1\n565        13.17         21.81           85.42      531.5          0.09714           0.10470         0.08259              0.05252         0.1746  ...           105.50       740.7            0.1503            0.39040           0.3728               0.16070          0.3693                  0.09618       0\n566        17.30         17.08          113.00      928.2          0.10080           0.10410         0.12660              0.08353         0.1813  ...           130.90      1222.0            0.1416            0.24050           0.3378               0.18570          0.3138                  0.08113       0\n567        17.68         20.74          117.40      963.7          0.11150           0.16650         0.18550              0.10540         0.1971  ...           132.90      1302.0            0.1418            0.34980           0.3583               0.15150          0.2463                  0.07738       0\n568        14.80         17.66           95.88      674.8          0.09179           0.08890         0.04069              0.02260         0.1893  ...           105.90       829.5            0.1226            0.18810           0.2060               0.08308          0.3600                  0.07285       1\n\n[569 rows x 31 columns]\n\n&gt;&gt;&gt; atom.scale(verbose=2)\n\nFitting Scaler...\nScaling features...\n\n&gt;&gt;&gt; # Note the reduced number of rows\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  target\n0      -0.181875      0.356669       -0.147122  -0.270991         0.340268          0.381628        0.214571             0.125567      -0.345050  ...         0.000933   -0.246244          1.240292           1.077359         1.116229              1.667157       -0.162964                 1.326816       0\n1       1.162216      0.300578        1.159704   1.097856         0.707625          0.368288        0.852572             1.148598       0.172744  ...         1.025723    1.042996          0.719898          -0.011475         0.500961              0.537309        0.280594                -0.308640       0\n2       1.056470      1.212060        0.933833   0.950360        -0.581659         -0.670877       -0.407166            -0.051653      -1.018183  ...         0.817241    0.746639         -0.060694          -0.482078        -0.311813             -0.027615       -0.666328                -0.259812       0\n3       0.277287      2.457753        0.188054   0.174273        -0.959614         -1.132432       -0.534892            -0.562913       0.143156  ...         0.083151    0.080948         -0.797185          -1.010314        -0.569828             -0.750385        0.544735                -1.284055       0\n4      -1.442482     -0.825921       -1.343434  -1.143186        -0.152840          0.358760        0.042209            -0.672815      -1.879941  ...        -1.289891   -1.052061         -0.660471          -0.435018        -0.571280             -1.162598       -2.081728                -0.389638       1\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...     ...\n564     0.057446     -1.361124        0.018651  -0.043220         0.160827         -0.557108       -0.404013            -0.087607       0.967929  ...         0.091960   -0.018751         -0.140077          -0.663228        -0.528681             -0.101629        0.260659                -1.337478       1\n565    -0.268141      0.588045       -0.267318  -0.347933         0.025188         -0.014753       -0.084382             0.077883      -0.248889  ...        -0.051921   -0.245730          0.768409           0.870422         0.485954              0.683827        1.308918                 0.699518       0\n566     0.881154     -0.517419        0.845098   0.753978         0.283751         -0.026187        0.470528             0.868616      -0.001087  ...         0.693914    0.578760          0.384728          -0.095926         0.316526              1.061450        0.386915                -0.165028       0\n567     0.986900      0.337972        1.022568   0.852586         1.039660          1.162956        1.213182             1.426285       0.583281  ...         0.752641    0.715804          0.393548           0.608690         0.415763              0.544861       -0.734440                -0.380446       0\n568     0.185455     -0.381865        0.154577   0.050111        -0.352767         -0.315850       -0.612688            -0.685055       0.294796  ...        -0.040176   -0.093611         -0.453195          -0.433728        -0.321494             -0.488617        1.154420                -0.640672       1\n\n[569 rows x 31 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.data_cleaning import Scaler\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; scaler = Scaler(verbose=2)\n&gt;&gt;&gt; X = scaler.fit_transform(X)\n\nFitting Scaler...\nScaling features...\n\n&gt;&gt;&gt; # Note the reduced number of rows\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst texture  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension\n0       1.097064     -2.073335        1.269934   0.984375         1.568466          3.283515        2.652874             2.532475       2.217515  ...      -1.359293         2.303601    2.001237          1.307686           2.616665         2.109526              2.296076        2.750622                 1.937015\n1       1.829821     -0.353632        1.685955   1.908708        -0.826962         -0.487072       -0.023846             0.548144       0.001392  ...      -0.369203         1.535126    1.890489         -0.375612          -0.430444        -0.146749              1.087084       -0.243890                 0.281190\n2       1.579888      0.456187        1.566503   1.558884         0.942210          1.052926        1.363478             2.037231       0.939685  ...      -0.023974         1.347475    1.456285          0.527407           1.082932         0.854974              1.955000        1.152255                 0.201391\n3      -0.768909      0.253732       -0.592687  -0.764464         3.283553          3.402909        1.915897             1.451707       2.867383  ...       0.133984        -0.249939   -0.550021          3.394275           3.893397         1.989588              2.175786        6.046041                 4.935010\n4       1.750297     -1.151816        1.776573   1.826229         0.280372          0.539340        1.371011             1.428493      -0.009560  ...      -1.466770         1.338539    1.220724          0.220556          -0.313395         0.613179              0.729259       -0.868353                -0.397100\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...            ...              ...         ...               ...                ...              ...                   ...             ...                      ...\n564     2.110995      0.721473        2.060786   2.343856         1.041842          0.219060        1.947285             2.320965      -0.312589  ...       0.117700         1.752563    2.015301          0.378365          -0.273318         0.664512              1.629151       -1.360158                -0.709091\n565     1.704854      2.085134        1.615931   1.723842         0.102458         -0.017833        0.693043             1.263669      -0.217664  ...       2.047399         1.421940    1.494959         -0.691230          -0.394820         0.236573              0.733827       -0.531855                -0.973978\n566     0.702284      2.045574        0.672676   0.577953        -0.840484         -0.038680        0.046588             0.105777      -0.809117  ...       1.374854         0.579001    0.427906         -0.809587           0.350735         0.326767              0.414069       -1.104549                -0.318409\n567     1.838341      2.336457        1.982524   1.735218         1.525767          3.272144        3.296944             2.658866       2.137194  ...       2.237926         2.303601    1.653171          1.430427           3.904848         3.197605              2.289985        1.919083                 2.219635\n568    -1.808401      1.221792       -1.814389  -1.347789        -3.112085         -1.150752       -1.114873            -1.261820      -0.820070  ...       0.764190        -1.432735   -1.075813         -1.859019          -1.207552        -1.305831             -1.745063       -0.048138                -0.751207\n\n[569 rows x 30 columns]\n</code></pre>"}, {"location": "api/data_cleaning/scaler/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_metadata_routingGet metadata routing of this object.get_paramsGet parameters for this estimator.inverse_transformApply the inverse transformation to the data.set_fit_requestRequest metadata passed to the <code>fit</code> method.set_outputSet output container.set_paramsSet the parameters of this estimator.transformPerform standardization by centering and scaling.</p> <p></p> <p></p> method fit(X, y=None, sample_weight=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p> sample_weight: sequence or None, default=None Sample weights with shape=(n_samples,). <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_metadata_routing()[source] <p>Get metadata routing of this object.</p> <p>Returns routing : MetadataRequest A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating routing information. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X, y=None)[source] <p>Apply the inverse transformation to the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Scaled dataframe. </p> <p></p> <p></p> method set_fit_request(sample_weight=\"$UNCHANGED$\")[source] <p>Request metadata passed to the <code>fit</code> method.</p> <p>Parameters sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>sample_weight</code> parameter in <code>fit</code>. <p>Returns self : object The updated object. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Perform standardization by centering and scaling.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Scaled dataframe. </p> <p></p>"}, {"location": "api/feature_engineering/featureextractor/", "title": "FeatureExtractor", "text": "class atom.feature_engineering.FeatureExtractor(features=('year', 'month', 'day'), fmt=None, encoding_type=\"ordinal\", drop_columns=True, from_index=False, verbose=0)[source] <p>Extract features from datetime columns.</p> <p>Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype <code>datetime64</code> are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used.</p> <p>This class can be accessed from atom through the feature_extraction method. Read more in the user guide.</p> <p>Warning</p> <p>Decision trees based algorithms build their split rules according to one feature at a time. This means that they will fail to correctly process cyclic features since the sin/cos features should be considered one single coordinate system.</p> <p>Parameters features: str or sequence, default=(\"year\", \"month\", \"day\") Features to create from the datetime columns. Note that created features with zero variance (e.g., the feature hour in a column that only contains dates) are ignored. Allowed values are datetime attributes from <code>pandas.Series.dt</code>. <p> fmt: str, dict or None, default=None Format (<code>strptime</code>) of the categorical columns that need to be converted to datetime. If dict, use the column's name as key and the format as value. If None, the format is inferred automatically from the first non NaN value. Values that cannot be converted are returned as <code>NaT</code>. <p> encoding_type: str, default=\"ordinal\" Type of encoding to use. Choose from: <ul> <li>\"ordinal\": Encode features in increasing order.</li> <li>\"cyclic\": Encode features using sine and cosine to capture   their cyclic nature. This approach creates two columns for   every feature. Non-cyclic features still use ordinal encoding.</li> </ul> <p> from_index: bool, default=False Whether to use the index as the datetime column to convert. <p> drop_columns: bool, default=True Whether to drop the original columns after transformation. This parameter is ignored if <code>from_index=True</code>. <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p>Attributes feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>FeatureGenerator Generate new features.</p> <p>FeatureGrouper Extract statistics from similar features.</p> <p>FeatureSelector Reduce the number of features in the data.</p> <p></p>"}, {"location": "api/feature_engineering/featureextractor/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Add a datetime column\n&gt;&gt;&gt; X[\"date\"] = pd.date_range(start=\"1/1/2018\", periods=len(X))\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y)\n&gt;&gt;&gt; atom.feature_extraction(features=[\"day\"], fmt=\"%d/%m/%Y\", verbose=2)\n\nFitting FeatureExtractor...\nExtracting datetime features...\n --&gt; Extracting features from column date.\n   --&gt; Creating feature date_day.\n\n&gt;&gt;&gt; # Note the date_day column\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  date_day  target\n0          13.49         22.30           86.91      561.0          0.08752           0.07698         0.04751              0.03384         0.1809  ...       698.8            0.1162            0.17110          0.22820               0.12820          0.2871                  0.06917        19       1\n1          19.27         26.47          127.90     1162.0          0.09401           0.17190         0.16570              0.07593         0.1853  ...      1813.0            0.1509            0.65900          0.60910               0.17850          0.3672                  0.11230         3       0\n2          13.00         25.13           82.61      520.2          0.08369           0.05073         0.01206              0.01762         0.1667  ...       628.5            0.1218            0.10930          0.04462               0.05921          0.2306                  0.06291         4       1\n3          23.29         26.67          158.90     1685.0          0.11410           0.20840         0.35230              0.16200         0.2200  ...      1986.0            0.1536            0.41670          0.78920               0.27330          0.3198                  0.08762        22       0\n4          12.77         22.47           81.72      506.3          0.09055           0.05761         0.04711              0.02704         0.1585  ...       653.6            0.1419            0.15230          0.21770               0.09331          0.2829                  0.08067        16       0\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...         ...               ...                ...              ...                   ...             ...                      ...       ...     ...\n564        12.77         29.43           81.35      507.9          0.08276           0.04234         0.01997              0.01499         0.1539  ...       594.7            0.1234            0.10640          0.08653               0.06498          0.2407                  0.06484         7       1\n565        11.15         13.08           70.87      381.9          0.09754           0.05113         0.01982              0.01786         0.1830  ...       440.8            0.1341            0.08971          0.07116               0.05506          0.2859                  0.06772         3       1\n566        19.17         24.80          132.40     1123.0          0.09740           0.24580         0.20650              0.11180         0.2397  ...      1332.0            0.1037            0.39030          0.36390               0.17670          0.3176                  0.10230        13       0\n567        11.43         15.39           73.06      399.8          0.09639           0.06889         0.03503              0.02875         0.1734  ...       462.0            0.1190            0.16480          0.13990               0.08476          0.2676                  0.06765        18       1\n568        13.48         20.82           88.40      559.2          0.10160           0.12550         0.10630              0.05439         0.1720  ...       740.4            0.1610            0.42250          0.50300               0.22580          0.2807                  0.10710         9       0\n\n[569 rows x 32 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from atom.feature_engineering import FeatureExtractor\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, _ = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Add a datetime column\n&gt;&gt;&gt; X[\"date\"] = pd.date_range(start=\"1/1/2018\", periods=len(X))\n\n&gt;&gt;&gt; fe = FeatureExtractor(features=[\"day\"], fmt=\"%Y-%m-%d\", verbose=2)\n&gt;&gt;&gt; X = fe.transform(X)\n\nExtracting datetime features...\n --&gt; Extracting features from column date.\n   --&gt; Creating feature date_day.\n\n&gt;&gt;&gt; # Note the date_day column\n&gt;&gt;&gt; print(X)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  ...  worst perimeter  worst area  worst smoothness  worst compactness  worst concavity  worst concave points  worst symmetry  worst fractal dimension  date_day\n0          17.99         10.38          122.80     1001.0          0.11840           0.27760         0.30010              0.14710         0.2419  ...           184.60      2019.0           0.16220            0.66560           0.7119                0.2654          0.4601                  0.11890         1\n1          20.57         17.77          132.90     1326.0          0.08474           0.07864         0.08690              0.07017         0.1812  ...           158.80      1956.0           0.12380            0.18660           0.2416                0.1860          0.2750                  0.08902         2\n2          19.69         21.25          130.00     1203.0          0.10960           0.15990         0.19740              0.12790         0.2069  ...           152.50      1709.0           0.14440            0.42450           0.4504                0.2430          0.3613                  0.08758         3\n3          11.42         20.38           77.58      386.1          0.14250           0.28390         0.24140              0.10520         0.2597  ...            98.87       567.7           0.20980            0.86630           0.6869                0.2575          0.6638                  0.17300         4\n4          20.29         14.34          135.10     1297.0          0.10030           0.13280         0.19800              0.10430         0.1809  ...           152.20      1575.0           0.13740            0.20500           0.4000                0.1625          0.2364                  0.07678         5\n..           ...           ...             ...        ...              ...               ...             ...                  ...            ...  ...              ...         ...               ...                ...              ...                   ...             ...                      ...       ...\n564        21.56         22.39          142.00     1479.0          0.11100           0.11590         0.24390              0.13890         0.1726  ...           166.10      2027.0           0.14100            0.21130           0.4107                0.2216          0.2060                  0.07115        19\n565        20.13         28.25          131.20     1261.0          0.09780           0.10340         0.14400              0.09791         0.1752  ...           155.00      1731.0           0.11660            0.19220           0.3215                0.1628          0.2572                  0.06637        20\n566        16.60         28.08          108.30      858.1          0.08455           0.10230         0.09251              0.05302         0.1590  ...           126.70      1124.0           0.11390            0.30940           0.3403                0.1418          0.2218                  0.07820        21\n567        20.60         29.33          140.10     1265.0          0.11780           0.27700         0.35140              0.15200         0.2397  ...           184.60      1821.0           0.16500            0.86810           0.9387                0.2650          0.4087                  0.12400        22\n568         7.76         24.54           47.92      181.0          0.05263           0.04362         0.00000              0.00000         0.1587  ...            59.16       268.6           0.08996            0.06444           0.0000                0.0000          0.2871                  0.07039        23\n\n[569 rows x 31 columns]\n</code></pre>"}, {"location": "api/feature_engineering/featureextractor/#methods", "title": "Methods", "text": "<p>fitDo nothing.fit_transformFit to data, then transform it.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformExtract the new features.</p> <p></p> <p></p> method fit(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Extract the new features.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed feature set. </p> <p></p>"}, {"location": "api/feature_engineering/featuregenerator/", "title": "FeatureGenerator", "text": "class atom.feature_engineering.FeatureGenerator(strategy=\"dfs\", n_features=None, operators=None, n_jobs=1, verbose=0, random_state=None, **kwargs)[source] <p>Generate new features.</p> <p>Create new combinations of existing features to capture the non-linear relations between the original features.</p> <p>This class can be accessed from atom through the feature_generation method. Read more in the user guide.</p> <p>Warning</p> <ul> <li>Using the <code>div</code>, <code>log</code> or <code>sqrt</code> operators can return new   features with <code>inf</code> or <code>NaN</code> values. Check the warnings that   may pop up or use atom's nans attribute.</li> <li>When using dfs with <code>n_jobs&gt;1</code>, make sure to protect your code   with <code>if __name__ == \"__main__\"</code>. Featuretools uses   dask, which uses python multiprocessing   for parallelization. The spawn method on multiprocessing   starts a new python process, which requires it to import the   __main__ module before it can do its task.</li> <li>gfg can be slow for very large populations.</li> </ul> <p>Tip</p> <p>dfs can create many new features and not all of them will be useful. Use the FeatureSelector class to reduce the number of features.</p> <p>Parameters strategy: str, default=\"dfs\" Strategy to crate new features. Choose from: <ul> <li>\"dfs\": Deep Feature Synthesis.</li> <li>\"gfg\": Genetic Feature Generation.</li> </ul> <p> n_features: int or None, default=None Maximum number of newly generated features to add to the dataset. If None, select all created features. <p> operators: str, sequence or None, default=None Mathematical operators to apply on the features. None to use all. Choose from: <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>abs</code>, <code>sqrt</code>, <code>log</code>, <code>inv</code>, <code>sin</code>, <code>cos</code>, <code>tan</code>. <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p> **kwargs Additional keyword arguments for the SymbolicTransformer instance. Only for the gfg strategy. <p>Attributes gfg_: SymbolicTransformer Object used to calculate the genetic features. Only available when strategy=\"gfg\". <p> genetic_features_: pd.DataFrame Information on the newly created non-linear features. Only available when strategy=\"gfg\". Columns include: <ul> <li>name: Name of the feature (generated automatically).</li> <li>description: Operators used to create this feature.</li> <li>fitness: Fitness score.</li> </ul> <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>FeatureExtractor Extract features from datetime columns.</p> <p>FeatureGrouper Extract statistics from similar features.</p> <p>FeatureSelector Reduce the number of features in the data.</p> <p></p>"}, {"location": "api/feature_engineering/featuregenerator/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y)\n&gt;&gt;&gt; atom.feature_generation(strategy=\"dfs\", n_features=5, verbose=2)\n\nFitting FeatureGenerator...\nGenerating new features...\n --&gt; 5 new features were added.\n\n&gt;&gt;&gt; # Note the texture error / worst symmetry column\n&gt;&gt;&gt; print(atom.dataset)\n\n     mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  ...  COSINE(worst area)  concave points error * worst symmetry  concavity error / mean fractal dimension  mean fractal dimension * worst perimeter  mean texture + texture error  target\n0         18.030         16.85          117.50      990.0          0.08947           0.12320  ...           -0.692809                               0.002772                                  0.514706                                  7.704740                       17.4406       0\n1         19.190         15.94          126.30     1157.0          0.08694           0.11850  ...            0.921798                               0.006826                                  0.839258                                  7.588016                       16.5736       0\n2         14.640         15.24           95.77      651.9          0.11320           0.13390  ...            0.797462                               0.005114                                  0.699023                                  6.942524                       15.9772       1\n3          9.738         11.97           61.24      288.5          0.09250           0.04102  ...           -0.893193                               0.000000                                  0.000000                                  4.272557                       12.4660       1\n4         11.890         21.17           76.39      433.8          0.09773           0.08120  ...            0.174282                               0.002852                                  0.259141                                  5.352161                       22.3730       1\n..           ...           ...             ...        ...              ...               ...  ...                 ...                                    ...                                       ...                                       ...                           ...     ...\n564       11.500         18.45           73.28      407.4          0.09345           0.05991  ...            0.999278                               0.002514                                  0.209808                                  4.932341                       19.2929       1\n565       20.580         22.14          134.70     1290.0          0.09090           0.13480  ...           -0.928415                               0.008043                                  1.092556                                  7.952992                       23.6200       0\n566       12.050         14.63           78.04      449.3          0.10310           0.09092  ...           -0.164684                               0.001555                                  0.384246                                  5.431448                       15.3594       1\n567       12.830         22.33           85.26      503.2          0.10880           0.17990  ...           -0.653689                               0.005107                                  0.645575                                  7.638462                       23.3990       0\n568       11.680         16.17           75.49      420.5          0.11280           0.09263  ...           -0.999773                               0.003272                                  0.289174                                  5.541346                       17.3240       1\n\n[569 rows x 36 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.feature_engineering import FeatureGenerator\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; fg = FeatureGenerator(strategy=\"dfs\", n_features=5, verbose=2)\n&gt;&gt;&gt; X = fg.fit_transform(X, y)\n\nFitting FeatureGenerator...\nGenerating new features...\n --&gt; 5 new features were added.\n\n&gt;&gt;&gt; # Note the radius error * worst smoothness column\n&gt;&gt;&gt; print(X)\n\n       mean radius  mean texture  mean perimeter  mean area  mean smoothness  mean compactness  ...  worst fractal dimension  mean concave points - worst fractal dimension  mean concavity * worst smoothness  mean smoothness / mean concave points  perimeter error - radius error  worst symmetry / mean compactness\nindex                                                                                           ...                                                                                                                                                                                                                     \n0            17.99         10.38          122.80     1001.0          0.11840           0.27760  ...                  0.11890                                        0.02820                           0.048676                               0.804895                          7.4940                           1.657421\n1            20.57         17.77          132.90     1326.0          0.08474           0.07864  ...                  0.08902                                       -0.01885                           0.010758                               1.207639                          2.8545                           3.496948\n2            19.69         21.25          130.00     1203.0          0.10960           0.15990  ...                  0.08758                                        0.04032                           0.028505                               0.856919                          3.8394                           2.259537\n3            11.42         20.38           77.58      386.1          0.14250           0.28390  ...                  0.17300                                       -0.06780                           0.050646                               1.354563                          2.9494                           2.338147\n4            20.29         14.34          135.10     1297.0          0.10030           0.13280  ...                  0.07678                                        0.02752                           0.027205                               0.961649                          4.6808                           1.780120\n...            ...           ...             ...        ...              ...               ...  ...                      ...                                            ...                                ...                                    ...                             ...                                ...\n564          21.56         22.39          142.00     1479.0          0.11100           0.11590  ...                  0.07115                                        0.06775                           0.034390                               0.799136                          6.4970                           1.777394\n565          20.13         28.25          131.20     1261.0          0.09780           0.10340  ...                  0.06637                                        0.03154                           0.016790                               0.998877                          4.4375                           2.487427\n566          16.60         28.08          108.30      858.1          0.08455           0.10230  ...                  0.07820                                       -0.02518                           0.010537                               1.594681                          2.9686                           2.168133\n567          20.60         29.33          140.10     1265.0          0.11780           0.27700  ...                  0.12400                                        0.02800                           0.057981                               0.775000                          5.0460                           1.475451\n568           7.76         24.54           47.92      181.0          0.05263           0.04362  ...                  0.07039                                       -0.07039                           0.000000                                    inf                          2.1623                           6.581843\n\n[569 rows x 35 columns]\n</code></pre>"}, {"location": "api/feature_engineering/featuregenerator/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformGenerate new features.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Generate new features.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed feature set. </p> <p></p>"}, {"location": "api/feature_engineering/featuregrouper/", "title": "FeatureGrouper", "text": "class atom.feature_engineering.FeatureGrouper(groups, operators=None, drop_columns=True, verbose=0)[source] <p>Extract statistics from similar features.</p> <p>Replace groups of features with related characteristics with new features that summarize statistical properties of the group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the <code>groups</code> method.</p> <p>This class can be accessed from atom through the feature_grouping method. Read more in the user guide.</p> <p>Parameters groups: dict Group names and features. A feature can belong to multiple groups. <p> operators: str, sequence or None, default=None Statistical operators to apply on the groups. Any operator from <code>numpy</code> or <code>scipy.stats</code> (checked in that order) that is applied on an array can be used. If None, it uses: <code>min</code>, <code>max</code>, <code>mean</code>, <code>median</code>, <code>mode</code> and <code>std</code>. <p> drop_columns: bool, default=True Whether to drop the columns in <code>groups</code> after transformation. <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p>Attributes feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>FeatureExtractor Extract features from datetime columns.</p> <p>FeatureGenerator Generate new features.</p> <p>FeatureSelector Reduce the number of features in the data.</p> <p></p>"}, {"location": "api/feature_engineering/featuregrouper/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y)\n&gt;&gt;&gt; atom.feature_grouping({\"group1\": \"mean.*\"}, verbose=2)\n\nFitting FeatureGrouper...\nGrouping features...\n --&gt; Group group1 successfully created.\n\n&gt;&gt;&gt; print(atom.dataset)\n\n     radius error  texture error  perimeter error  area error  smoothness error  compactness error  concavity error  concave points error  symmetry error  ...  worst symmetry  worst fractal dimension  min(group1)  max(group1)  mean(group1)  median(group1)  mode(group1)  std(group1)  target\n0          0.8191         1.9310            4.493      103.90          0.008074           0.040880         0.053210              0.018340         0.02383  ...          0.3007                  0.08314     0.061320       1110.0    127.523316        0.176850      0.061320   329.486981       0\n1          0.1859         1.9260            1.011       14.47          0.007831           0.008776         0.015560              0.006240         0.03139  ...          0.3200                  0.06576     0.015530        428.9     53.379498        0.136250      0.015530   127.109799       1\n2          0.2810         0.8135            3.369       23.81          0.004929           0.066570         0.076830              0.013680         0.01526  ...          0.2845                  0.12490     0.028330        542.9     66.369889        0.141200      0.028330   160.878141       1\n3          0.1639         1.1400            1.223       14.66          0.005919           0.032700         0.049570              0.010380         0.01208  ...          0.2048                  0.07628     0.028000        553.5     66.981375        0.111560      0.028000   164.121249       1\n4          0.3428         0.3981            2.537       29.06          0.004732           0.015060         0.018550              0.010670         0.02163  ...          0.3109                  0.08187     0.035280        668.7     79.352913        0.120425      0.035280   198.400183       1\n..            ...            ...              ...         ...               ...                ...              ...                   ...             ...  ...             ...                      ...          ...          ...           ...             ...           ...          ...     ...\n564        0.2868         1.1430            2.289       20.56          0.010170           0.014430         0.018610              0.012500         0.03464  ...          0.2227                  0.06777     0.018750        334.2     43.509823        0.135500      0.018750    98.929860       1\n565        0.8529         1.8490            5.632       93.54          0.010750           0.027220         0.050810              0.019110         0.02293  ...          0.2341                  0.07421     0.056990       1094.0    125.561400        0.159350      0.056990   324.783656       0\n566        0.2441         2.0900            1.648       16.80          0.012910           0.022220         0.004174              0.007082         0.02572  ...          0.2262                  0.06742     0.005025        311.7     40.661394        0.139700      0.005025    92.358226       1\n567        0.1998         0.6068            1.443       16.07          0.004413           0.014430         0.015090              0.007369         0.01354  ...          0.3518                  0.08665     0.031520        551.1     67.128030        0.143050      0.031520   163.348717       1\n568        0.2094         0.7636            1.231       17.67          0.008725           0.020030         0.023350              0.011320         0.02625  ...          0.3380                  0.09584     0.033700        513.7     62.632288        0.136750      0.033700   152.314252       1\n\n[569 rows x 27 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.feature_engineering import FeatureGrouper\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, _ = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; fg = FeatureGrouper({\"group1\": [\"mean texture\", \"mean radius\"]}, verbose=2)\n&gt;&gt;&gt; X = fg.transform(X)\n\nGrouping features...\n --&gt; Group group1 successfully created.\n\n&gt;&gt;&gt; print(X)\n\n     mean perimeter  mean area  mean smoothness  mean compactness  mean concavity  mean concave points  mean symmetry  mean fractal dimension  radius error  ...  worst concave points  worst symmetry  worst fractal dimension  min(group1)  max(group1)  mean(group1)  median(group1)  mode(group1)  std(group1)\n0            122.80     1001.0          0.11840           0.27760         0.30010              0.14710         0.2419                 0.07871        1.0950  ...                0.2654          0.4601                  0.11890        10.38        17.99        14.185          14.185         10.38        3.805\n1            132.90     1326.0          0.08474           0.07864         0.08690              0.07017         0.1812                 0.05667        0.5435  ...                0.1860          0.2750                  0.08902        17.77        20.57        19.170          19.170         17.77        1.400\n2            130.00     1203.0          0.10960           0.15990         0.19740              0.12790         0.2069                 0.05999        0.7456  ...                0.2430          0.3613                  0.08758        19.69        21.25        20.470          20.470         19.69        0.780\n3             77.58      386.1          0.14250           0.28390         0.24140              0.10520         0.2597                 0.09744        0.4956  ...                0.2575          0.6638                  0.17300        11.42        20.38        15.900          15.900         11.42        4.480\n4            135.10     1297.0          0.10030           0.13280         0.19800              0.10430         0.1809                 0.05883        0.7572  ...                0.1625          0.2364                  0.07678        14.34        20.29        17.315          17.315         14.34        2.975\n..              ...        ...              ...               ...             ...                  ...            ...                     ...           ...  ...                   ...             ...                      ...          ...          ...           ...             ...           ...          ...\n564          142.00     1479.0          0.11100           0.11590         0.24390              0.13890         0.1726                 0.05623        1.1760  ...                0.2216          0.2060                  0.07115        21.56        22.39        21.975          21.975         21.56        0.415\n565          131.20     1261.0          0.09780           0.10340         0.14400              0.09791         0.1752                 0.05533        0.7655  ...                0.1628          0.2572                  0.06637        20.13        28.25        24.190          24.190         20.13        4.060\n566          108.30      858.1          0.08455           0.10230         0.09251              0.05302         0.1590                 0.05648        0.4564  ...                0.1418          0.2218                  0.07820        16.60        28.08        22.340          22.340         16.60        5.740\n567          140.10     1265.0          0.11780           0.27700         0.35140              0.15200         0.2397                 0.07016        0.7260  ...                0.2650          0.4087                  0.12400        20.60        29.33        24.965          24.965         20.60        4.365\n568           47.92      181.0          0.05263           0.04362         0.00000              0.00000         0.1587                 0.05884        0.3857  ...                0.0000          0.2871                  0.07039         7.76        24.54        16.150          16.150          7.76        8.390\n\n[569 rows x 34 columns]\n</code></pre>"}, {"location": "api/feature_engineering/featuregrouper/#methods", "title": "Methods", "text": "<p>fitDo nothing.fit_transformFit to data, then transform it.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformGroup features.</p> <p></p> <p></p> method fit(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Group features.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed feature set. </p> <p></p>"}, {"location": "api/feature_engineering/featureselector/", "title": "FeatureSelector", "text": "class atom.feature_engineering.FeatureSelector(strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, n_jobs=1, device=\"cpu\", engine=None, verbose=0, random_state=None, **kwargs)[source] <p>Reduce the number of features in the data.</p> <p>Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low-variance features.</p> <p>This class can be accessed from atom through the feature_selection method. Read more in the user guide.</p> <p>Warning</p> <ul> <li>Ties between features with equal scores are broken in an   unspecified way.</li> <li>For strategy=\"rfecv\", the <code>n_features</code> parameter is the   minimum number of features to select, not the actual   number of features that the transformer returns. It may very   well be that it returns more!</li> </ul> <p>Info</p> <ul> <li>The \"sklearnex\" and \"cuml\" engines are only supported for   strategy=\"pca\" with dense datasets.</li> <li>If strategy=\"pca\" and the data is dense and unscaled, it's   scaled to mean=0 and std=1 before fitting the PCA transformer.</li> <li>If strategy=\"pca\" and the provided data is sparse, the used   estimator is TruncatedSVD, which works more efficiently   with sparse matrices.</li> </ul> <p>Tip</p> <ul> <li>Use the plot_pca and plot_components methods to   examine the results after using strategy=\"pca\".</li> <li>Use the plot_rfecv method to examine the results after   using strategy=\"rfecv\".</li> <li>Use the plot_feature_importance method to examine how   much a specific feature contributes to the final predictions.   If the model doesn't have a <code>feature_importances_</code> attribute,   use plot_permutation_importance instead.</li> </ul> <p>Parameters strategy: str or None, default=None Feature selection strategy to use. Choose from: <ul> <li>None: Do not perform any feature selection strategy.</li> <li>\"univariate\": Univariate statistical F-test.</li> <li>\"pca\": Principal Component Analysis.</li> <li>\"sfm\": Select best features according to a model.</li> <li>\"sfs\": Sequential Feature Selection.</li> <li>\"rfe\": Recursive Feature Elimination.</li> <li>\"rfecv\": RFE with cross-validated selection.</li> <li>\"pso\": Particle Swarm Optimization.</li> <li>\"hho\": Harris Hawks Optimization.</li> <li>\"gwo\": Grey Wolf Optimization.</li> <li>\"dfo\": Dragonfly Optimization.</li> <li>\"go\": Genetic Optimization.</li> </ul> <p> solver: str, func, predictor or None, default=None Solver/estimator to use for the feature selection strategy. See the corresponding documentation for an extended description of the choices. If None, the default value is used (only if strategy=\"pca\"). Choose from: <ul> <li> <p>If strategy=\"univariate\":</p> <ul> <li>\"f_classif\"</li> <li>\"f_regression\"</li> <li>\"mutual_info_classif\"</li> <li>\"mutual_info_regression\"</li> <li>\"chi2\"</li> <li>Any function with signature <code>func(X, y) -&gt; tuple[scores, p-values]</code>.</li> </ul> </li> <li> <p>If strategy=\"pca\":</p> <ul> <li> <p>If data is dense:</p> <ul> <li> <p>If engine=\"sklearn\":</p> <ul> <li>\"auto\" (default)</li> <li>\"full\"</li> <li>\"covariance_eigh\"</li> <li>\"arpack\"</li> <li>\"randomized\"</li> </ul> </li> <li> <p>If engine=\"sklearnex\":</p> <ul> <li>\"full\" (default)</li> </ul> </li> <li> <p>If engine=\"cuml\":</p> <ul> <li>\"full\" (default)</li> <li>\"jacobi\"</li> </ul> </li> </ul> </li> <li> <p>If data is sparse:</p> <ul> <li>\"randomized\" (default)</li> <li>\"covariance_eigh\"</li> <li>\"arpack\"</li> </ul> </li> </ul> </li> <li> <p>for the remaining strategies:   The base estimator. For sfm, rfe and rfecv, it should have   either a <code>feature_importances_</code> or <code>coef_</code> attribute after   fitting. You can use one of the predefined models. Add   <code>_class</code> or <code>_reg</code> after the model's  name to specify a   classification or regression task, e.g., <code>solver=\"LGB_reg\"</code>   (not necessary if called from atom). No default option.</p> </li> </ul> <p> n_features: int, float or None, default=None Number of features to select. <ul> <li>If None: Select all features.</li> <li>If &lt;1: Fraction of the total features to select.</li> <li>If &gt;=1: Number of features to select.</li> </ul> <p>If strategy=\"sfm\" and the threshold parameter is not specified, the threshold is automatically set to <code>-inf</code> to select <code>n_features</code> number of features.</p> <p>If strategy=\"rfecv\", <code>n_features</code> is the minimum number of features to select.</p> <p>This parameter is ignored if any of the following strategies is selected: pso, hho, gwo, dfo, go.</p> <p> min_repeated: int, float or None, default=2 Remove categorical features if there isn't any repeated value in at least <code>min_repeated</code> rows. The default is to keep all features with non-maximum variance, i.e., remove the features which number of unique values is equal to the number of rows (usually the case for names, IDs, etc...). <ul> <li>If None: No check for minimum repetition.</li> <li>If &gt;1: Minimum repetition number.</li> <li>If &lt;=1: Minimum repetition fraction.</li> </ul> <p> max_repeated: int, float or None, default=1.0 Remove categorical features with the same value in at least <code>max_repeated</code> rows. The default is to keep all features with non-zero variance, i.e., remove the features that have the same value in all samples. <ul> <li>If None: No check for maximum repetition.</li> <li>If &gt;1: Maximum number of repeated occurences.</li> <li>If &lt;=1: Maximum fraction of repeated occurences.</li> </ul> <p> max_correlation: float or None, default=1.0 Minimum absolute Pearson correlation to identify correlated features. For each group, it removes all except the feature with the highest correlation to <code>y</code> (if provided, else it removes all but the first). The default value removes equal columns. If None, skip this step. <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p> **kwargs Any extra keyword argument for the <code>strategy</code> estimator. See the corresponding documentation for the available options. <p>Attributes collinear_: pd.DataFrame Information on the removed collinear features. Columns include: <ul> <li>drop: Name of the dropped feature.</li> <li>corr_feature: Names of the correlated features.</li> <li>corr_value: Corresponding correlation coefficients.</li> </ul> <p>{#featureselector-[strategy]} [strategy]: sklearn transformer Object used to transform the data, e.g., <code>fs.pca</code> for the pca strategy. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>FeatureExtractor Extract features from datetime columns.</p> <p>FeatureGenerator Generate new features.</p> <p>FeatureGrouper Extract statistics from similar features.</p> <p></p>"}, {"location": "api/feature_engineering/featureselector/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y)\n&gt;&gt;&gt; atom.feature_selection(strategy=\"pca\", n_features=12, verbose=2)\n\nFitting FeatureSelector...\nPerforming feature selection ...\n --&gt; Applying Principal Component Analysis...\n   --&gt; Scaling features...\n   --&gt; Keeping 12 components.\n   --&gt; Explained variance ratio: 0.972\n\n&gt;&gt;&gt; # Note that the column names changed\n&gt;&gt;&gt; print(atom.dataset)\n\n         pca0      pca1      pca2      pca3      pca4      pca5      pca6      pca7      pca8      pca9     pca10     pca11  target\n0   -4.550570 -3.137509 -0.092090 -1.609549  1.058535  0.642739  0.641216  0.149573  0.553681  0.012809  0.250259 -0.076306       1\n1   -1.146323 -1.318056 -0.879402 -1.748581  0.615686  0.708593  0.125549 -0.481384  0.347614 -0.568856 -0.044347 -0.700876       1\n2    4.022389  2.985922 -3.007969  2.528286 -0.074799  0.610755  0.573571 -0.489323 -0.433615  0.372529 -0.055120  0.235854       0\n3    2.354108  4.800756 -1.036847 -0.338138 -2.778482  4.910456 -1.033646  0.196407  0.075153 -0.625668  0.095093 -0.761412       0\n4   -2.907053  0.157141  2.076819 -1.780199  1.288917  2.018880  0.551727 -0.428490 -0.246376 -0.579773 -0.238851 -0.130475       1\n..        ...       ...       ...       ...       ...       ...       ...       ...       ...       ...       ...       ...     ...\n564  0.985404  0.982949 -2.306420  0.314275 -0.470162  0.260210  0.474216 -0.067590 -0.292023 -0.021339 -0.199168 -0.129227       0\n565 -0.952207  0.929797 -0.911746 -1.115508 -0.608486  0.914564 -0.580888 -1.027668  0.331691 -0.142763  0.850646 -0.454396       1\n566  4.679295 -0.876128 -0.128211  0.984446 -0.177509  0.453696  0.081011 -0.789588  0.241801 -0.043042  0.593988  0.289491       0\n567  4.511927 -0.693781 -0.407906 -0.963769  0.110021 -0.956139 -2.317544  0.046630  0.829408 -0.114397  0.283519 -0.946620       0\n568 -0.591290  1.764559  1.380277  0.167142 -1.660975  0.438834 -0.076031 -0.002265 -0.196759 -0.271184  0.003263 -0.383594       1\n\n[569 rows x 13 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.feature_engineering import FeatureSelector\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, _ = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; fs = FeatureSelector(strategy=\"pca\", n_features=12, verbose=2)\n&gt;&gt;&gt; X = fs.fit_transform(X)\n\nFitting FeatureSelector...\nPerforming feature selection ...\n --&gt; Applying Principal Component Analysis...\n   --&gt; Scaling features...\n   --&gt; Keeping 12 components.\n   --&gt; Explained variance ratio: 0.97\n\n&gt;&gt;&gt; # Note that the column names changed\n&gt;&gt;&gt; print(X)\n\n          pca0       pca1      pca2      pca3      pca4      pca5      pca6      pca7      pca8      pca9     pca10     pca11\n0     9.192837   1.948583 -1.123166 -3.633731  1.195110  1.411424  2.159370 -0.398407 -0.157118 -0.877402  0.262955  0.859014\n1     2.387802  -3.768172 -0.529293 -1.118264 -0.621775  0.028656  0.013358  0.240988 -0.711905  1.106995  0.813120 -0.157923\n2     5.733896  -1.075174 -0.551748 -0.912083  0.177086  0.541452 -0.668166  0.097374  0.024066  0.454275 -0.605604 -0.124387\n3     7.122953  10.275589 -3.232790 -0.152547  2.960878  3.053422  1.429911  1.059565 -1.405440 -1.116975 -1.151514 -1.011316\n4     3.935302  -1.948072  1.389767 -2.940639 -0.546747 -1.226495 -0.936213  0.636376 -0.263805  0.377704  0.651360  0.110515\n..         ...        ...       ...       ...       ...       ...       ...       ...       ...       ...       ...       ...\n564   6.439315  -3.576817  2.459487 -1.177314  0.074824 -2.375193 -0.596130 -0.035471  0.987929  0.256989 -0.062651 -0.123342\n565   3.793382  -3.584048  2.088476  2.506028  0.510723 -0.246710 -0.716326 -1.113360 -0.105207 -0.108632  0.244804 -0.222753\n566   1.256179  -1.902297  0.562731  2.089227 -1.809991 -0.534447 -0.192758  0.341887  0.393917  0.520877 -0.840512 -0.096473\n567  10.374794   1.672010 -1.877029  2.356031  0.033742  0.567936  0.223082 -0.280239 -0.542035 -0.089296 -0.178628  0.697461\n568  -5.475243  -0.670637  1.490443  2.299157  0.184703  1.617837  1.698952  1.046354  0.374101 -0.047726 -0.144094  0.179496\n\n[569 rows x 12 columns]\n</code></pre>"}, {"location": "api/feature_engineering/featureselector/#methods", "title": "Methods", "text": "<p>fitFit the feature selector to the data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_metadata_routingGet metadata routing of this object.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformTransform the data.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit the feature selector to the data.</p> <p>The univariate, sfm (when model is not fitted), sfs, rfe and rfecv strategies need a target column. Leaving it None raises an exception.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features: sequence or None, default=None Only used to validate feature names with the names seen in <code>fit</code>. <p>Returns np.ndarray Transformed feature names. </p> <p></p> <p></p> method get_metadata_routing()[source] <p>Get metadata routing of this object.</p> <p>Returns routing : MetadataRequest A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating routing information. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Transform the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed feature set. </p> <p></p>"}, {"location": "api/models/adab/", "title": "AdaBoost", "text": "<p>AdaB accept sparse</p> <p>AdaBoost is a meta-estimator that begins by fitting a classifier/regressor on the original dataset and then fits additional copies of the algorithm on the same dataset but where the weights of instances are adjusted according to the error of the current prediction.</p> <p>Corresponding estimators are:</p> <ul> <li>AdaBoostClassifier for classification tasks.</li> <li>AdaBoostRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>GradientBoostingMachine Gradient Boosting Machine.</p> <p>RandomForest Random Forest.</p> <p>XGBoost Extreme Gradient Boosting.</p> <p></p>"}, {"location": "api/models/adab/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"AdaB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: AdaB\nMetric: f1\n\n\nResults for AdaBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9583\nTime elapsed: 0.157s\n-------------------------------------------------\nTime: 0.157s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.160s\n-------------------------------------\nAdaBoost --&gt; f1: 0.9583\n</code></pre>"}, {"location": "api/models/adab/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=50, step=10) learning_rateFloatDistribution(high=10.0, log=True, low=0.01, step=None)</p> regression <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=50, step=10) learning_rateFloatDistribution(high=10.0, log=True, low=0.01, step=None) lossCategoricalDistribution(choices=('linear', 'square', 'exponential'))</p> <p></p> <p></p>"}, {"location": "api/models/adab/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/adab/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/adab/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/adab/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/ard/", "title": "AutomaticRelevanceDetermination", "text": "<p>ARD needs scaling</p> <p>Automatic Relevance Determination is very similar to BayesianRidge, but can lead to sparser coefficients. Fit the weights of a regression model, using an ARD prior. The weights of the regression model are assumed to be in Gaussian distributions.</p> <p>Corresponding estimators are:</p> <ul> <li>ARDRegression for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>BayesianRidge Bayesian ridge regression.</p> <p>GaussianProcess Gaussian process.</p> <p>LeastAngleRegression Least Angle Regression.</p> <p></p>"}, {"location": "api/models/ard/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"ARD\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ARD\nMetric: r2\n\n\nResults for AutomaticRelevanceDetermination:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6067\nTest evaluation --&gt; r2: 0.6029\nTime elapsed: 0.164s\n-------------------------------------------------\nTime: 0.164s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.165s\n-------------------------------------\nAutomaticRelevanceDetermination --&gt; r2: 0.6029\n</code></pre>"}, {"location": "api/models/ard/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters max_iterIntDistribution(high=1000, log=False, low=100, step=10) alpha_1FloatDistribution(high=1.0, log=True, low=0.0001, step=None) alpha_2FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_1FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_2FloatDistribution(high=1.0, log=True, low=0.0001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/ard/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/ard/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/ard/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/ard/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/arima/", "title": "ARIMA", "text": "<p>ARIMA native multioutput</p> <p>Seasonal ARIMA models and exogenous input is supported, hence this estimator is capable of fitting SARIMA, ARIMAX, and SARIMAX.</p> <p>An ARIMA model is a generalization of an autoregressive moving average (ARMA) model, and is fitted to time-series data in an effort to forecast future points. ARIMA models can be especially efficacious in cases where data shows evidence of non-stationarity.</p> <p>The \"AR\" part of ARIMA indicates that the evolving variable of interest is regressed on its own lagged (i.e., prior observed) values. The \"MA\" part indicates that the regression error is actually a linear combination of error terms whose values occurred contemporaneously and at various times in the past. The \"I\" (for \"integrated\") indicates that the data values have been replaced with the difference between their values and the previous values (and this differencing process may have been performed more than once).</p> <p>Corresponding estimators are:</p> <ul> <li>ARIMA for forecasting tasks.</li> </ul> <p>Note</p> <p>The seasonal components ar removed from hyperparameter tuning if no seasonality is specified.</p> <p>Warning</p> <p>ARIMA often runs into numerical errors when optimizing the hyperparameters. Possible solutions are:</p> <ul> <li>Use the AutoARIMA model instead.</li> <li>Use <code>est_params</code> to specify the   orders manually, e.g., <code>atom.run(\"arima\", n_trials=5,est_params={\"order\": (1, 1, 0)})</code>.</li> <li>Use the <code>catch</code> parameter in <code>ht_params</code>   to avoid raising every exception, e.g., <code>atom.run(\"arima\",n_trials=5, ht_params={\"catch\": (Exception,)})</code>.</li> </ul> <p></p> <p>See Also</p> <p>AutoARIMA Automatic Autoregressive Integrated Moving Average.</p> <p>SARIMAX Seasonal Autoregressive Integrated Moving Average.</p> <p>VARMAX Vector Autoregressive Moving-Average.</p> <p></p>"}, {"location": "api/models/arima/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; _, X = load_longley()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X)\n&gt;&gt;&gt; atom.run(models=\"ARIMA\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ARIMA\nMetric: mape\n\n\nResults for ARIMA:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0131\nTest evaluation --&gt; mape: -0.0364\nTime elapsed: 0.087s\n-------------------------------------------------\nTime: 0.087s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.089s\n-------------------------------------\nARIMA --&gt; mape: -0.0364\n</code></pre>"}, {"location": "api/models/arima/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters pIntDistribution(high=2, log=False, low=0, step=1) dIntDistribution(high=1, log=False, low=0, step=1) qIntDistribution(high=2, log=False, low=0, step=1) methodCategoricalDistribution(choices=('newton', 'nm', 'bfgs', 'lbfgs', 'powell', 'cg', 'ncg', 'basinhopping')) maxiterIntDistribution(high=200, log=False, low=50, step=10) with_interceptCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/arima/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/arima/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/arima/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/arima/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/autoarima/", "title": "AutoARIMA", "text": "<p>AutoARIMA native multioutput</p> <p>ARIMA implementation that includes automated fitting of (S)ARIMA(X) hyperparameters (p, d, q, P, D, Q). The AutoARIMA algorithm seeks to identify the most optimal parameters for an ARIMA model, settling on a single fitted ARIMA model. This process is based on the commonly-used R function.</p> <p>AutoARIMA works by conducting differencing tests (i.e., Kwiatkowski-Phillips-Schmidt-Shin, Augmented Dickey-Fuller or Phillips-Perron) to determine the order of differencing, d, and then fitting models within defined ranges. AutoARIMA also seeks to identify the optimal P and Q hyperparameters after conducting the Canova-Hansen to determine the optimal order of seasonal differencing.</p> <p>Note that due to stationarity issues, AutoARIMA might not find a suitable model that will converge. If this is the case, a ValueError is thrown suggesting stationarity-inducing measures be taken prior to re-fitting or that a new range of order values be selected.</p> <p>Corresponding estimators are:</p> <ul> <li>AutoARIMA for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>ETS Error-Trend-Seasonality model.</p> <p>SARIMAX Seasonal Autoregressive Integrated Moving Average.</p> <p></p>"}, {"location": "api/models/autoarima/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; _, X = load_longley()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"autoarima\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: AutoARIMA\nMetric: mape\n\n\nResults for AutoARIMA:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0131\nTest evaluation --&gt; mape: -0.0359\nTime elapsed: 0.362s\n-------------------------------------------------\nTime: 0.362s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.364s\n-------------------------------------\nAutoARIMA --&gt; mape: -0.0359\n</code></pre>"}, {"location": "api/models/autoarima/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters information_criterionCategoricalDistribution(choices=('aic', 'bic', 'hqic', 'oob')) methodCategoricalDistribution(choices=('newton', 'nm', 'bfgs', 'lbfgs', 'powell', 'cg', 'ncg', 'basinhopping')) maxiterIntDistribution(high=200, log=False, low=50, step=10) with_interceptCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/autoarima/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/autoarima/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/autoarima/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/autoarima/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/autoets/", "title": "AutoETS", "text": "<p>AutoETS native multioutput</p> <p>The ETS models are a family of time series models with an underlying state space model consisting of a level component, a trend component (T), a seasonal component (S), and an error term (E). This implementation automatically tunes the ETS terms.</p> <p>Corresponding estimators are:</p> <ul> <li>AutoETS for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>AutoARIMA Automatic Autoregressive Integrated Moving Average.</p> <p>ETS Error-Trend-Seasonality model.</p> <p>SARIMAX Seasonal Autoregressive Integrated Moving Average.</p> <p></p>"}, {"location": "api/models/autoets/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"ETS\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ETS\nMetric: mape\n\n\nResults for ETS:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0858\nTest evaluation --&gt; mape: -0.2305\nTime elapsed: 0.025s\n-------------------------------------------------\nTime: 0.025s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.026s\n-------------------------------------\nETS --&gt; mape: -0.2305\n</code></pre>"}, {"location": "api/models/autoets/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters information_criterionCategoricalDistribution(choices=('aic', 'bic', 'aicc')) allow_multiplicative_trendCategoricalDistribution(choices=(True, False)) restrictCategoricalDistribution(choices=(True, False)) additive_onlyCategoricalDistribution(choices=(True, False)) ignore_inf_icCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/autoets/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/autoets/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/autoets/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/autoets/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/bag/", "title": "Bagging", "text": "<p>Bag accept sparse</p> <p>Bagging uses an ensemble meta-estimator that fits base predictors on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator by introducing randomization into its construction procedure and then making an ensemble out of it.</p> <p>Corresponding estimators are:</p> <ul> <li>BaggingClassifier for classification tasks.</li> <li>BaggingRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>DecisionTree Single Decision Tree.</p> <p>LogisticRegression Logistic Regression.</p> <p>RandomForest Random Forest.</p> <p></p>"}, {"location": "api/models/bag/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Bag\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Bag\nMetric: f1\n\n\nResults for Bagging:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9982\nTest evaluation --&gt; f1: 0.9444\nTime elapsed: 0.078s\n-------------------------------------------------\nTime: 0.078s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.081s\n-------------------------------------\nBagging --&gt; f1: 0.9444\n</code></pre>"}, {"location": "api/models/bag/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) max_samplesFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) max_featuresFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) bootstrapCategoricalDistribution(choices=(True, False)) bootstrap_featuresCategoricalDistribution(choices=(True, False))</p> regression <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) max_samplesFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) max_featuresFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) bootstrapCategoricalDistribution(choices=(True, False)) bootstrap_featuresCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/bag/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/bag/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/bag/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/bag/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/bats/", "title": "BATS", "text": "<p>BATS native multioutput</p> <p>BATS is acronym for:</p> <ul> <li>Box-Cox transformation</li> <li>ARMA errors</li> <li>Trend</li> <li>Seasonal components</li> </ul> <p>BATS was designed to forecast time series with multiple seasonal periods. For example, daily data may have a weekly pattern as well as an annual pattern. Or hourly data can have three seasonal periods: a daily pattern, a weekly pattern, and an annual pattern.</p> <p>In BATS, a Box-Cox transformation is applied to the original time series, and then this is modeled as a linear combination of an exponentially smoothed trend, a seasonal component and an ARMA component. BATS conducts some hyperparameter tuning (e.g., which of these components to keep and which to discard) using AIC.</p> <p>Corresponding estimators are:</p> <ul> <li>BATS for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>AutoARIMA Automatic Autoregressive Integrated Moving Average.</p> <p>TBATS TBATS forecaster with multiple seasonality.</p> <p></p>"}, {"location": "api/models/bats/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"BATS\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: BATS\nMetric: mape\n\n\nResults for BATS:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0829\nTest evaluation --&gt; mape: -0.1676\nTime elapsed: 17.771s\n-------------------------------------------------\nTime: 17.771s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 17.773s\n-------------------------------------\nBATS --&gt; mape: -0.1676\n</code></pre>"}, {"location": "api/models/bats/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters use_box_coxCategoricalDistribution(choices=(True, False, None)) use_trendCategoricalDistribution(choices=(True, False, None)) use_damped_trendCategoricalDistribution(choices=(True, False, None)) use_arma_errorsCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/bats/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/bats/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/bats/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/bats/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/bnb/", "title": "BernoulliNB", "text": "<p>BNB accept sparse supports acceleration</p> <p>BernoulliNB implements the Naive Bayes algorithm for multivariate Bernoulli models. Like MultinomialNB, this classifier is suitable for discrete data. The difference is that while MNB works with occurrence counts, BNB is designed for binary/boolean features.</p> <p>Corresponding estimators are:</p> <ul> <li>BernoulliNB for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>ComplementNB Complement Naive Bayes.</p> <p>CategoricalNB Categorical Naive Bayes.</p> <p>MultinomialNB Multinomial Naive Bayes.</p> <p></p>"}, {"location": "api/models/bnb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"BNB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: BNB\nMetric: f1\n\n\nResults for BernoulliNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.7709\nTest evaluation --&gt; f1: 0.7717\nTime elapsed: 0.025s\n-------------------------------------------------\nTime: 0.025s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.028s\n-------------------------------------\nBernoulliNB --&gt; f1: 0.7717\n</code></pre>"}, {"location": "api/models/bnb/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> cuml cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#bernoullinb-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/bnb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/bnb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/bnb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/bnb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/br/", "title": "BayesianRidge", "text": "<p>BR needs scaling</p> <p>Bayesian regression techniques can be used to include regularization parameters in the estimation procedure: the regularization parameter is not set in a hard sense but tuned to the data at hand.</p> <p>Corresponding estimators are:</p> <ul> <li>BayesianRidge for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>AutomaticRelevanceDetermination Automatic Relevance Determination.</p> <p>GaussianProcess Gaussian process.</p> <p>LeastAngleRegression Least Angle Regression.</p> <p></p>"}, {"location": "api/models/br/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"BR\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: BR\nMetric: r2\n\n\nResults for BayesianRidge:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6067\nTest evaluation --&gt; r2: 0.6028\nTime elapsed: 0.158s\n-------------------------------------------------\nTime: 0.158s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.159s\n-------------------------------------\nBayesianRidge --&gt; r2: 0.6028\n</code></pre>"}, {"location": "api/models/br/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters max_iterIntDistribution(high=1000, log=False, low=100, step=10) alpha_1FloatDistribution(high=1.0, log=True, low=0.0001, step=None) alpha_2FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_1FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_2FloatDistribution(high=1.0, log=True, low=0.0001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/br/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/br/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/br/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/br/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/catb/", "title": "CatBoost", "text": "<p>CatB needs scaling accept sparse in-training validation supports acceleration</p> <p>CatBoost is a machine learning method based on gradient boosting over decision trees. Main advantages of CatBoost:</p> <ul> <li>Superior quality when compared with other GBDT models on many   datasets.</li> <li>Best in class prediction speed.</li> </ul> <p>Corresponding estimators are:</p> <ul> <li>CatBoostClassifier for classification tasks.</li> <li>CatBoostRegressor for regression tasks.</li> </ul> <p>Read more in CatBoost's documentation.</p> <p>Warning</p> <ul> <li>CatBoost selects the weights achieved by the best evaluation   on the test set after training. This means that, by default,   there is some minor data leakage in the test set. Use the   <code>use_best_model=False</code> parameter to avoid this behavior or use   a holdout set to evaluate the final estimator.</li> <li>In-training validation and pruning are disabled when   <code>device=\"gpu\"</code>.</li> </ul> <p>Note</p> <p>ATOM uses CatBoost's <code>n_estimators</code> parameter instead of <code>iterations</code> to indicate the number of trees to fit. This is done to have consistent naming with the XGBoost and LightGBM models.</p> <p></p> <p>See Also</p> <p>GradientBoostingMachine Gradient Boosting Machine.</p> <p>LightGBM Light Gradient Boosting Machine.</p> <p>XGBoost Extreme Gradient Boosting.</p> <p></p>"}, {"location": "api/models/catb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"CatB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: CatB\nMetric: f1\n\n\nResults for CatBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9722\nTime elapsed: 15.656s\n-------------------------------------------------\nTime: 15.656s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 15.660s\n-------------------------------------\nCatBoost --&gt; f1: 0.9722\n</code></pre>"}, {"location": "api/models/catb/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=20, step=10) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_child_samplesIntDistribution(high=30, log=False, low=1, step=1) bootstrap_typeCategoricalDistribution(choices=('Bayesian', 'Bernoulli')) bagging_temperatureFloatDistribution(high=10.0, log=False, low=0.0, step=None) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) reg_lambdaFloatDistribution(high=100.0, log=True, low=0.001, step=None)</p> regression <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=20, step=10) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_child_samplesIntDistribution(high=30, log=False, low=1, step=1) bootstrap_typeCategoricalDistribution(choices=('Bayesian', 'Bernoulli')) bagging_temperatureFloatDistribution(high=10.0, log=False, low=0.0, step=None) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) reg_lambdaFloatDistribution(high=100.0, log=True, low=0.001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/catb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/catb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/catb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/catb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/catnb/", "title": "CategoricalNB", "text": "<p>CatNB accept sparse supports acceleration</p> <p>Categorical Naive Bayes implements the Naive Bayes algorithm for categorical features.</p> <p>Corresponding estimators are:</p> <ul> <li>CategoricalNB for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>BernoulliNB Bernoulli Naive Bayes.</p> <p>ComplementNB Complement Naive Bayes.</p> <p>GaussianNB Gaussian Naive Bayes.</p> <p></p>"}, {"location": "api/models/catnb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; X = rng.integers(5, size=(100, 100))\n&gt;&gt;&gt; y = rng.integers(2, size=100)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"CatNB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: CatNB\nMetric: f1\n\n\nResults for CategoricalNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9846\nTest evaluation --&gt; f1: 0.4615\nTime elapsed: 0.031s\n-------------------------------------------------\nTime: 0.031s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.034s\n-------------------------------------\nCategoricalNB --&gt; f1: 0.4615 ~\n</code></pre>"}, {"location": "api/models/catnb/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> cuml cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#categoricalnb-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/catnb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/catnb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/catnb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/catnb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/cnb/", "title": "ComplementNB", "text": "<p>CNB accept sparse supports acceleration</p> <p>The Complement Naive Bayes classifier was designed to correct the \"severe assumptions\" made by the standard MultinomialNB classifier. It is particularly suited for imbalanced datasets.</p> <p>Corresponding estimators are:</p> <ul> <li>ComplementNB for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>BernoulliNB Bernoulli Naive Bayes.</p> <p>CategoricalNB Categorical Naive Bayes.</p> <p>MultinomialNB Multinomial Naive Bayes.</p> <p></p>"}, {"location": "api/models/cnb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"CNB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: CNB\nMetric: f1\n\n\nResults for ComplementNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9221\nTest evaluation --&gt; f1: 0.9128\nTime elapsed: 0.024s\n-------------------------------------------------\nTime: 0.024s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.027s\n-------------------------------------\nComplementNB --&gt; f1: 0.9128\n</code></pre>"}, {"location": "api/models/cnb/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False)) normCategoricalDistribution(choices=(True, False))</p> cuml cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False)) normCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#complementnb-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False)) normCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/cnb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/cnb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/cnb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/cnb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/croston/", "title": "Croston", "text": "<p>Croston native multioutput</p> <p>Croston's method is a modification of (vanilla) exponential smoothing to handle intermittent time series. A time series is considered intermittent if many of its values are zero and the gaps between non-zero entries are not periodic.</p> <p>Croston's method will predict a constant value for all future times, so Croston's method essentially provides another notion for the average value of a time series.</p> <p>Corresponding estimators are:</p> <ul> <li>Croston for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ExponentialSmoothing Holt-Winters Exponential Smoothing forecaster.</p> <p>ETS Error-Trend-Seasonality model.</p> <p>NaiveForecaster Naive Forecaster.</p> <p></p>"}, {"location": "api/models/croston/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Croston\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Croston\nMetric: mape\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.8688\nTest evaluation --&gt; mape: -0.1442\nTime elapsed: 0.017s\n-------------------------------------------------\nTime: 0.017s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.018s\n-------------------------------------\nCroston --&gt; mape: -0.1442\n</code></pre>"}, {"location": "api/models/croston/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters smoothingFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <p></p> <p></p>"}, {"location": "api/models/croston/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/croston/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/croston/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/croston/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/df/", "title": "DynamicFactor", "text": "<p>DF native multioutput</p> <p>The DynamicFactor model incorporates dynamic factors to predict future values. In this context, \"dynamic factors\" refer to variables that change over time and impact the variable you are trying to forecast.</p> <p>Warning</p> <p>DynamicFactor only supports multivariate tasks.</p> <p>Corresponding estimators are:</p> <ul> <li>DynamicFactor for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ExponentialSmoothing Holt-Winters Exponential Smoothing forecaster.</p> <p>STL Seasonal-Trend decomposition using LOESS.</p> <p>PolynomialTrend Polynomial Trend forecaster.</p> <p></p>"}, {"location": "api/models/df/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; _, X = load_longley()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X, y=(-1, -2), random_state=1)\n&gt;&gt;&gt; atom.run(models=\"DF\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: DF\nMetric: mape\n\n\nResults for DynamicFactor:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1047\nTest evaluation --&gt; mape: -0.1125\nTime elapsed: 0.064s\n-------------------------------------------------\nTime: 0.064s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.067s\n-------------------------------------\nDynamicFactor --&gt; mape: -0.1125\n</code></pre>"}, {"location": "api/models/df/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters k_factorsIntDistribution(high=10, log=False, low=1, step=1) error_cov_typeCategoricalDistribution(choices=('scalar', 'diagonal', 'unstructured')) error_varCategoricalDistribution(choices=(True, False)) enforce_stationarityCategoricalDistribution(choices=(True, False)) cov_typeCategoricalDistribution(choices=('opg', 'oim', 'approx', 'robust', 'robust_approx', 'none')) methodCategoricalDistribution(choices=('newton', 'nm', 'bfgs', 'lbfgs', 'powell', 'cg', 'ncg', 'basinhopping')) maxiterIntDistribution(high=200, log=False, low=50, step=10)</p> <p></p> <p></p>"}, {"location": "api/models/df/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/df/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/df/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/df/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/dummy/", "title": "Dummy", "text": "<p>Dummy</p> <p>When doing supervised learning, a simple sanity check consists of comparing one's estimator against simple rules of thumb. The prediction methods completely ignore the input data. Do not use this model for real problems. Use it only as a simple baseline to compare with other models.</p> <p>Corresponding estimators are:</p> <ul> <li>DummyClassifier for classification tasks.</li> <li>DummyRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>DecisionTree Single Decision Tree.</p> <p>ExtraTree Extremely Randomized Tree.</p> <p>NaiveForecaster Naive Forecaster.</p> <p></p>"}, {"location": "api/models/dummy/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Dummy\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Dummy\nMetric: f1\n\n\nResults for Dummy:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.7709\nTest evaluation --&gt; f1: 0.7717\nTime elapsed: 0.022s\n-------------------------------------------------\nTime: 0.022s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.025s\n-------------------------------------\nDummy --&gt; f1: 0.7717\n</code></pre>"}, {"location": "api/models/dummy/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>strategyCategoricalDistribution(choices=('most_frequent', 'prior', 'stratified', 'uniform'))</p> regression <p>Parameters <p>strategyCategoricalDistribution(choices=('mean', 'median', 'quantile')) quantileFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <p></p> <p></p>"}, {"location": "api/models/dummy/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/dummy/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/dummy/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/dummy/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/en/", "title": "ElasticNet", "text": "<p>EN needs scaling accept sparse supports acceleration</p> <p>Linear least squares with l1 and l2 regularization.</p> <p>Corresponding estimators are:</p> <ul> <li>ElasticNet for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>Lasso Linear Regression with lasso regularization.</p> <p>OrdinaryLeastSquares Linear Regression.</p> <p>Ridge Linear least squares with l2 regularization.</p> <p></p>"}, {"location": "api/models/en/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"EN\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: EN\nMetric: r2\n\n\nResults for ElasticNet:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.2061\nTest evaluation --&gt; r2: 0.2016\nTime elapsed: 0.159s\n-------------------------------------------------\nTime: 0.159s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.161s\n-------------------------------------\nElasticNet --&gt; r2: 0.2016\n</code></pre>"}, {"location": "api/models/en/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> sklearnex cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#elasticnet-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> cuml cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#elasticnet-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> <p></p> <p></p>"}, {"location": "api/models/en/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/en/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/en/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/en/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/es/", "title": "ExponentialSmoothing", "text": "<p>ES native multioutput</p> <p>ExponentialSmoothing is a forecasting model that extends simple exponential smoothing to handle seasonality and trends in the data. This method is particularly useful for forecasting time series data with a systematic pattern that repeats over time.</p> <p>Corresponding estimators are:</p> <ul> <li>ExponentialSmoothing for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>ETS Error-Trend-Seasonality model.</p> <p>PolynomialTrend Polynomial Trend forecaster.</p> <p></p>"}, {"location": "api/models/es/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"ES\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ES\nMetric: mape\n\n\nResults for ExponentialSmoothing:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0864\nTest evaluation --&gt; mape: -0.2303\nTime elapsed: 0.023s\n-------------------------------------------------\nTime: 0.023s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.025s\n-------------------------------------\nExponentialSmoothing --&gt; mape: -0.2303\n</code></pre>"}, {"location": "api/models/es/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters damped_trendCategoricalDistribution(choices=(True, False)) use_boxcoxCategoricalDistribution(choices=(True, False)) initialization_methodCategoricalDistribution(choices=('estimated', 'heuristic')) methodCategoricalDistribution(choices=('L-BFGS-B', 'TNC', 'SLSQP', 'Powell', 'trust-constr', 'bh', 'ls')) use_bruteCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/es/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/es/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/es/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/es/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/et/", "title": "ExtraTrees", "text": "<p>ET accept sparse native multilabel native multioutput</p> <p>Extra-Trees use a meta estimator that fits a number of randomized decision trees (a.k.a. extra-trees) on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.</p> <p>Corresponding estimators are:</p> <ul> <li>ExtraTreesClassifier for classification tasks.</li> <li>ExtraTreesRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>DecisionTree Single Decision Tree.</p> <p>ExtraTree Extremely Randomized Tree.</p> <p>RandomForest Random Forest.</p> <p></p>"}, {"location": "api/models/et/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"ET\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ET\nMetric: f1\n\n\nResults for ExtraTrees:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9655\nTime elapsed: 0.105s\n-------------------------------------------------\nTime: 0.105s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.108s\n-------------------------------------\nExtraTrees --&gt; f1: 0.9655\n</code></pre>"}, {"location": "api/models/et/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('gini', 'entropy')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> regression <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('squared_error', 'absolute_error')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <p></p> <p></p>"}, {"location": "api/models/et/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/et/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/et/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/et/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/etree/", "title": "ExtraTree", "text": "<p>ETree accept sparse native multilabel native multioutput</p> <p>Extra-trees differ from classic decision trees in the way they are built. When looking for the best split to separate the samples of a node into two groups, random splits are drawn for each of the max_features randomly selected features and the best split among those is chosen. When max_features is set 1, this amounts to building a totally random decision tree.</p> <p>Corresponding estimators are:</p> <ul> <li>ExtraTreeClassifier for classification tasks.</li> <li>ExtraTreeRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>DecisionTree Single Decision Tree.</p> <p>ExtraTrees Extremely Randomized Trees.</p> <p>RandomForest Random Forest.</p> <p></p>"}, {"location": "api/models/etree/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"ETree\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ETree\nMetric: f1\n\n\nResults for ExtraTree:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9241\nTime elapsed: 0.023s\n-------------------------------------------------\nTime: 0.023s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.027s\n-------------------------------------\nExtraTree --&gt; f1: 0.9241\n</code></pre>"}, {"location": "api/models/etree/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>criterionCategoricalDistribution(choices=('gini', 'entropy')) splitterCategoricalDistribution(choices=('random', 'best')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> regression <p>Parameters <p>criterionCategoricalDistribution(choices=('squared_error', 'absolute_error')) splitterCategoricalDistribution(choices=('random', 'best')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <p></p> <p></p>"}, {"location": "api/models/etree/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/etree/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/etree/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/etree/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/ets/", "title": "ETS", "text": "<p>ETS native multioutput</p> <p>The ETS models are a family of time series models with an underlying state space model consisting of a level component, a trend component (T), a seasonal component (S), and an error term (E).</p> <p>Corresponding estimators are:</p> <ul> <li>AutoETS for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>AutoETS ETS model with automatic fitting capabilities.</p> <p>SARIMAX Seasonal Autoregressive Integrated Moving Average.</p> <p></p>"}, {"location": "api/models/ets/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"ETS\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: ETS\nMetric: mape\n\n\nResults for ETS:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0858\nTest evaluation --&gt; mape: -0.2305\nTime elapsed: 0.025s\n-------------------------------------------------\nTime: 0.025s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.026s\n-------------------------------------\nETS --&gt; mape: -0.2305\n</code></pre>"}, {"location": "api/models/ets/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters errorCategoricalDistribution(choices=('add', 'mul')) damped_trendCategoricalDistribution(choices=(True, False)) initialization_methodCategoricalDistribution(choices=('estimated', 'heuristic')) maxiterIntDistribution(high=2000, log=False, low=500, step=100)</p> <p></p> <p></p>"}, {"location": "api/models/ets/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/ets/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/ets/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/ets/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/gbm/", "title": "GradientBoostingMachine", "text": "<p>GBM accept sparse</p> <p>A Gradient Boosting Machine builds an additive model in a forward stage-wise fashion; it allows for the optimization of arbitrary differentiable loss functions. In each stage <code>n_classes_</code> regression trees are fit on the negative gradient of the loss function, e.g. binary or multiclass log loss. Binary classification is a special case where only a single regression tree is induced.</p> <p>Corresponding estimators are:</p> <ul> <li>GradientBoostingClassifier for classification tasks.</li> <li>GradientBoostingRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p>Tip</p> <p>HistGradientBoosting is a much faster variant of this algorithm for intermediate datasets (n_samples &gt;= 10k).</p> <p></p> <p>See Also</p> <p>CatBoost Cat Boosting Machine.</p> <p>HistGradientBoosting Histogram-based Gradient Boosting Machine.</p> <p>LightGBM Light Gradient Boosting Machine.</p> <p></p>"}, {"location": "api/models/gbm/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"GBM\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: GBM\nMetric: f1\n\n\nResults for GradientBoostingMachine:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9589\nTime elapsed: 0.444s\n-------------------------------------------------\nTime: 0.444s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.447s\n-------------------------------------\nGradientBoostingMachine --&gt; f1: 0.9589\n</code></pre>"}, {"location": "api/models/gbm/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>lossCategoricalDistribution(choices=('log_loss', 'exponential')) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) criterionCategoricalDistribution(choices=('friedman_mse', 'squared_error')) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_depthIntDistribution(high=21, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> regression <p>Parameters <p>lossCategoricalDistribution(choices=('squared_error', 'absolute_error', 'huber', 'quantile')) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) criterionCategoricalDistribution(choices=('friedman_mse', 'squared_error')) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_depthIntDistribution(high=21, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005) alphaFloatDistribution(high=0.9, log=False, low=0.1, step=0.1)</p> <p></p> <p></p>"}, {"location": "api/models/gbm/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/gbm/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/gbm/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/gbm/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/gnb/", "title": "GaussianNB", "text": "<p>GNB supports acceleration</p> <p>Gaussian Naive Bayes implements the Naive Bayes algorithm for classification. The likelihood of the features is assumed to be Gaussian.</p> <p>Corresponding estimators are:</p> <ul> <li>GaussianNB for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>BernoulliNB Bernoulli Naive Bayes.</p> <p>CategoricalNB Categorical Naive Bayes.</p> <p>ComplementNB Complement Naive Bayes.</p> <p></p>"}, {"location": "api/models/gnb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"GNB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: GNB\nMetric: f1\n\n\nResults for GaussianNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9553\nTest evaluation --&gt; f1: 0.9371\nTime elapsed: 0.024s\n-------------------------------------------------\nTime: 0.024s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.027s\n-------------------------------------\nGaussianNB --&gt; f1: 0.9371\n</code></pre>"}, {"location": "api/models/gnb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/gnb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/gnb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/gnb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/gp/", "title": "GaussianProcess", "text": "<p>GP</p> <p>Gaussian Processes are a generic supervised learning method designed to solve regression and probabilistic classification problems. The advantages of Gaussian processes are:</p> <ul> <li>The prediction interpolates the observations.</li> <li>The prediction is probabilistic (Gaussian) so that one can compute   empirical confidence intervals and decide based on those if one   should refit (online fitting, adaptive fitting) the prediction in   some region of interest.</li> </ul> <p>The disadvantages of Gaussian processes include:</p> <ul> <li>They are not sparse, i.e., they use the whole samples/features   information to perform the prediction.</li> <li>They lose efficiency in high dimensional spaces, namely when the   number of features exceeds a few dozens.</li> </ul> <p>Corresponding estimators are:</p> <ul> <li>GaussianProcessClassifier for classification tasks.</li> <li>GaussianProcessRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>GaussianNB Gaussian Naive Bayes.</p> <p>LinearDiscriminantAnalysis Linear Discriminant Analysis.</p> <p>PassiveAggressive Passive Aggressive.</p> <p></p>"}, {"location": "api/models/gp/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"GP\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: GP\nMetric: f1\n\n\nResults for GaussianProcess:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9437\nTime elapsed: 0.101s\n-------------------------------------------------\nTime: 0.101s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.104s\n-------------------------------------\nGaussianProcess --&gt; f1: 0.9437\n</code></pre>"}, {"location": "api/models/gp/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/gp/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/gp/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/gp/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/hgbm/", "title": "HistGradientBoosting", "text": "<p>hGBM</p> <p>This Histogram-based Gradient Boosting Machine is much faster than the standard GradientBoostingMachine for big datasets (n_samples&gt;=10k). This variation first bins the input samples into integer-valued bins which tremendously reduces the number of splitting points to consider, and allows the algorithm to leverage integer-based data structures (histograms) instead of relying on sorted continuous values when building the trees.</p> <p>Corresponding estimators are:</p> <ul> <li>HistGradientBoostingClassifier for classification tasks.</li> <li>HistGradientBoostingRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>CatBoost Cat Boosting Machine.</p> <p>GradientBoostingMachine Gradient Boosting Machine.</p> <p>XGBoost Extreme Gradient Boosting.</p> <p></p>"}, {"location": "api/models/hgbm/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"hGBM\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: hGBM\nMetric: f1\n\n\nResults for HistGradientBoosting:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9583\nTime elapsed: 0.168s\n-------------------------------------------------\nTime: 0.168s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.172s\n-------------------------------------\nHistGradientBoosting --&gt; f1: 0.9583\n</code></pre>"}, {"location": "api/models/hgbm/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_iterIntDistribution(high=500, log=False, low=10, step=10) max_leaf_nodesIntDistribution(high=50, log=False, low=10, step=1) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_leafIntDistribution(high=30, log=False, low=10, step=1) l2_regularizationFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> regression <p>Parameters <p>lossCategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson', 'quantile', 'gamma')) quantileFloatDistribution(high=1.0, log=False, low=0.0, step=0.1) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_iterIntDistribution(high=500, log=False, low=10, step=10) max_leaf_nodesIntDistribution(high=50, log=False, low=10, step=1) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_leafIntDistribution(high=30, log=False, low=10, step=1) l2_regularizationFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <p></p> <p></p>"}, {"location": "api/models/hgbm/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/hgbm/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/hgbm/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/hgbm/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/huber/", "title": "HuberRegression", "text": "<p>Huber needs scaling</p> <p>Huber is a linear regression model that is robust to outliers. It makes sure that the loss function is not heavily influenced by the outliers while not completely ignoring their effect.</p> <p>Corresponding estimators are:</p> <ul> <li>HuberRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>AutomaticRelevanceDetermination Automatic Relevance Determination.</p> <p>LeastAngleRegression Least Angle Regression.</p> <p>OrdinaryLeastSquares Linear Regression.</p> <p></p>"}, {"location": "api/models/huber/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Huber\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Huber\nMetric: r2\n\n\nResults for HuberRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.546\nTest evaluation --&gt; r2: 0.5999\nTime elapsed: 0.205s\n-------------------------------------------------\nTime: 0.205s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.207s\n-------------------------------------\nHuberRegression --&gt; r2: 0.5999\n</code></pre>"}, {"location": "api/models/huber/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters epsilonFloatDistribution(high=10.0, log=True, low=1.0, step=None) max_iterIntDistribution(high=500, log=False, low=50, step=10) alphaFloatDistribution(high=1.0, log=True, low=0.0001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/huber/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/huber/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/huber/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/huber/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/knn/", "title": "KNearestNeighbors", "text": "<p>KNN needs scaling accept sparse native multilabel native multioutput supports acceleration</p> <p>K-Nearest Neighbors, as the name clearly indicates, implements the k-nearest neighbors vote. For regression, the target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set.</p> <p>Corresponding estimators are:</p> <ul> <li>KNeighborsClassifier for classification tasks.</li> <li>KNeighborsRegressor for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>LinearDiscriminantAnalysis Linear Discriminant Analysis.</p> <p>QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis.</p> <p>RadiusNearestNeighbors Radius Nearest Neighbors.</p> <p></p>"}, {"location": "api/models/knn/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"KNN\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: KNN\nMetric: f1\n\n\nResults for KNearestNeighbors:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.981\nTest evaluation --&gt; f1: 0.9793\nTime elapsed: 0.269s\n-------------------------------------------------\nTime: 0.269s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.272s\n-------------------------------------\nKNearestNeighbors --&gt; f1: 0.9793\n</code></pre>"}, {"location": "api/models/knn/#hyperparameters", "title": "Hyperparameters", "text": "classification sklearn <p>Parameters <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> regression sklearn <p>Parameters <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#knearestneighbors-n_neighbors}\n</code></pre> <p>n_neighborsIntDistribution(high=100, log=False, low=1, step=1) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <p></p> <p></p>"}, {"location": "api/models/knn/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/knn/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/knn/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/knn/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/lars/", "title": "LeastAngleRegression", "text": "<p>Lars needs scaling</p> <p>Least-Angle Regression is a regression algorithm for high-dimensional data. Lars is similar to forward stepwise regression. At each step, it finds the feature most correlated with the target. When there are multiple features having equal correlation, instead of continuing along the same feature, it proceeds in a direction equiangular between the features.</p> <p>Corresponding estimators are:</p> <ul> <li>Lars for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>BayesianRidge Bayesian ridge regression.</p> <p>HuberRegression Huber regressor.</p> <p>OrdinaryLeastSquares Linear Regression.</p> <p></p>"}, {"location": "api/models/lars/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Lars\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Lars\nMetric: r2\n\n\nResults for LeastAngleRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6067\nTest evaluation --&gt; r2: 0.6028\nTime elapsed: 0.156s\n-------------------------------------------------\nTime: 0.156s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.158s\n-------------------------------------\nLeastAngleRegression --&gt; r2: 0.6028\n</code></pre>"}, {"location": "api/models/lars/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/lars/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/lars/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/lars/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/lasso/", "title": "Lasso", "text": "<p>Lasso needs scaling accept sparse supports acceleration</p> <p>Linear least squares with l1 regularization.</p> <p>Corresponding estimators are:</p> <ul> <li>Lasso for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>ElasticNet Linear Regression with elasticnet regularization.</p> <p>OrdinaryLeastSquares Linear Regression.</p> <p>Ridge Linear least squares with l2 regularization.</p> <p></p>"}, {"location": "api/models/lasso/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Lasso\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Lasso\nMetric: r2\n\n\nResults for Lasso:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.0\nTest evaluation --&gt; r2: -0.0001\nTime elapsed: 0.156s\n-------------------------------------------------\nTime: 0.156s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.157s\n-------------------------------------\nLasso --&gt; r2: -0.0001 ~\n</code></pre>"}, {"location": "api/models/lasso/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> sklearnex cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#lasso-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> cuml cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#lasso-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) selectionCategoricalDistribution(choices=('cyclic', 'random'))</p> <p></p> <p></p>"}, {"location": "api/models/lasso/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/lasso/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/lasso/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/lasso/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/lda/", "title": "LinearDiscriminantAnalysis", "text": "<p>LDA</p> <p>Linear Discriminant Analysis is a classifier with a linear decision boundary, generated by fitting class conditional densities to the data and using Bayes' rule. The model fits a Gaussian density to each class, assuming that all classes share the same covariance matrix.</p> <p>Corresponding estimators are:</p> <ul> <li>LinearDiscriminantAnalysis for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>LogisticRegression Logistic Regression.</p> <p>RadiusNearestNeighbors Radius Nearest Neighbors.</p> <p>QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis.</p> <p></p>"}, {"location": "api/models/lda/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"LDA\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: LDA\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9743\nTest evaluation --&gt; f1: 0.9726\nTime elapsed: 0.027s\n-------------------------------------------------\nTime: 0.027s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.030s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.9726\n</code></pre>"}, {"location": "api/models/lda/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters solverCategoricalDistribution(choices=('svd', 'lsqr', 'eigen')) shrinkageCategoricalDistribution(choices=(None, 'auto', 0.5, 0.6, 0.7, 0.8, 0.9, 1.0))</p> <p></p> <p></p>"}, {"location": "api/models/lda/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/lda/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/lda/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/lda/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/lgb/", "title": "LightGBM", "text": "<p>LGB needs scaling accept sparse in-training validation supports acceleration</p> <p>LightGBM is a gradient boosting model that uses tree-based learning algorithms. It is designed to be distributed and efficient with the following advantages:</p> <ul> <li>Faster training speed and higher efficiency.</li> <li>Lower memory usage.</li> <li>Better accuracy.</li> <li>Capable of handling large-scale data.</li> </ul> <p>Corresponding estimators are:</p> <ul> <li>LGBMClassifier for classification tasks.</li> <li>LGBMRegressor for regression tasks.</li> </ul> <p>Read more in LightGBM's documentation.</p> <p>Info</p> <p>Using LightGBM's GPU acceleration requires additional software dependencies.</p> <p></p> <p>See Also</p> <p>CatBoost Cat Boosting Machine.</p> <p>GradientBoostingMachine Gradient Boosting Machine.</p> <p>XGBoost Extreme Gradient Boosting.</p> <p></p>"}, {"location": "api/models/lgb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"LGB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: LGB\nMetric: f1\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9583\nTime elapsed: 0.581s\n-------------------------------------------------\nTime: 0.581s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.584s\n-------------------------------------\nLightGBM --&gt; f1: 0.9583\n</code></pre>"}, {"location": "api/models/lgb/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=20, step=10) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depthIntDistribution(high=17, log=False, low=-1, step=2) num_leavesIntDistribution(high=40, log=False, low=20, step=1) min_child_weightFloatDistribution(high=100.0, log=True, low=0.0001, step=None) min_child_samplesIntDistribution(high=30, log=False, low=1, step=1) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytreeFloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alphaFloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambdaFloatDistribution(high=100.0, log=True, low=0.0001, step=None)</p> regression <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=20, step=10) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depthIntDistribution(high=17, log=False, low=-1, step=2) num_leavesIntDistribution(high=40, log=False, low=20, step=1) min_child_weightFloatDistribution(high=100.0, log=True, low=0.0001, step=None) min_child_samplesIntDistribution(high=30, log=False, low=1, step=1) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytreeFloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alphaFloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambdaFloatDistribution(high=100.0, log=True, low=0.0001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/lgb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/lgb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/lgb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/lgb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/lr/", "title": "LogisticRegression", "text": "<p>LR needs scaling accept sparse supports acceleration</p> <p>Logistic regression, despite its name, is a linear model for classification rather than regression. Logistic regression is also known in the literature as logit regression, maximum-entropy classification (MaxEnt) or the log-linear classifier. In this model, the probabilities describing the possible outcomes of a single trial are modeled using a logistic function.</p> <p>Corresponding estimators are:</p> <ul> <li>LogisticRegression for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>GaussianProcess Gaussian process.</p> <p>LinearDiscriminantAnalysis Linear Discriminant Analysis.</p> <p>PassiveAggressive Passive Aggressive.</p> <p></p>"}, {"location": "api/models/lr/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"RF\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: RF\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9524\nTime elapsed: 0.172s\n-------------------------------------------------\nTime: 0.172s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.175s\n-------------------------------------\nRandomForest --&gt; f1: 0.9524\n</code></pre>"}, {"location": "api/models/lr/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iterIntDistribution(high=1000, log=False, low=100, step=10) l1_ratioFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> sklearnex cpu <p>Parameters <p>penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iterIntDistribution(high=1000, log=False, low=100, step=10) l1_ratioFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#logisticregression-penalty}\n</code></pre> <p>penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iterIntDistribution(high=1000, log=False, low=100, step=10) l1_ratioFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> cuml cpu <p>Parameters <p>penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iterIntDistribution(high=1000, log=False, low=100, step=10) l1_ratioFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#logisticregression-penalty}\n</code></pre> <p>penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iterIntDistribution(high=1000, log=False, low=100, step=10) l1_ratioFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <p></p> <p></p>"}, {"location": "api/models/lr/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/lr/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/lr/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/lr/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/lsvm/", "title": "LinearSVM", "text": "<p>lSVM needs scaling accept sparse supports acceleration</p> <p>Similar to SupportVectorMachine but with a linear kernel. Implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples.</p> <p>Corresponding estimators are:</p> <ul> <li>LinearSVC for classification tasks.</li> <li>LinearSVR for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>KNearestNeighbors K-Nearest Neighbors.</p> <p>StochasticGradientDescent Stochastic Gradient Descent.</p> <p>SupportVectorMachine Support Vector Machine.</p> <p></p>"}, {"location": "api/models/lsvm/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"lSVM\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: lSVM\nMetric: f1\n\n\nResults for LinearSVM:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.993\nTest evaluation --&gt; f1: 0.9722\nTime elapsed: 0.235s\n-------------------------------------------------\nTime: 0.235s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.238s\n-------------------------------------\nLinearSVM --&gt; f1: 0.9722\n</code></pre>"}, {"location": "api/models/lsvm/#hyperparameters", "title": "Hyperparameters", "text": "classification sklearn <p>Parameters <p>penaltyCategoricalDistribution(choices=('l1', 'l2')) lossCategoricalDistribution(choices=('hinge', 'squared_hinge')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) dualCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#linearsvm-penalty}\n</code></pre> <p>penaltyCategoricalDistribution(choices=('l1', 'l2')) lossCategoricalDistribution(choices=('hinge', 'squared_hinge')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) dualCategoricalDistribution(choices=(True, False))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#linearsvm-penalty}\n</code></pre> <p>penaltyCategoricalDistribution(choices=('l1', 'l2')) lossCategoricalDistribution(choices=('hinge', 'squared_hinge')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) dualCategoricalDistribution(choices=(True, False))</p> regression sklearn <p>Parameters <p>lossCategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) dualCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#linearsvm-loss}\n</code></pre> <p>lossCategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) dualCategoricalDistribution(choices=(True, False))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#linearsvm-loss}\n</code></pre> <p>lossCategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) CFloatDistribution(high=100.0, log=True, low=0.001, step=None) dualCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/lsvm/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/lsvm/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/lsvm/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/lsvm/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/mlp/", "title": "MultiLayerPerceptron", "text": "<p>MLP needs scaling accept sparse native multilabel in-training validation</p> <p>Multi-layer Perceptron is a supervised learning algorithm that learns a function by training on a dataset. Given a set of features and a target, it can learn a non-linear function approximator for either classification or regression. It is different from logistic regression, in that between the input and the output layer, there can be one or more non-linear layers, called hidden layers.</p> <p>Corresponding estimators are:</p> <ul> <li>MLPClassifier for classification tasks.</li> <li>MLPRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>PassiveAggressive Passive Aggressive.</p> <p>Perceptron Linear Perceptron classification.</p> <p>StochasticGradientDescent Stochastic Gradient Descent.</p> <p></p>"}, {"location": "api/models/mlp/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"MLP\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: MLP\nMetric: f1\n\n\nResults for MultiLayerPerceptron:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9965\nTest evaluation --&gt; f1: 0.979\nTime elapsed: 1.931s\n-------------------------------------------------\nTime: 1.931s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.935s\n-------------------------------------\nMultiLayerPerceptron --&gt; f1: 0.979\n</code></pre>"}, {"location": "api/models/mlp/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>hidden_layer_1IntDistribution(high=100, log=False, low=10, step=1) hidden_layer_2IntDistribution(high=100, log=False, low=0, step=1) hidden_layer_3IntDistribution(high=10, log=False, low=0, step=1) activationCategoricalDistribution(choices=('identity', 'logistic', 'tanh', 'relu')) solverCategoricalDistribution(choices=('lbfgs', 'sgd', 'adam')) alphaFloatDistribution(high=0.1, log=True, low=0.0001, step=None) batch_sizeCategoricalDistribution(choices=('auto', 8, 16, 32, 64, 128, 256)) learning_rateCategoricalDistribution(choices=('constant', 'invscaling', 'adaptive')) learning_rate_initFloatDistribution(high=0.1, log=True, low=0.001, step=None) power_tFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iterIntDistribution(high=500, log=False, low=50, step=10)</p> regression <p>Parameters <p>hidden_layer_1IntDistribution(high=100, log=False, low=10, step=1) hidden_layer_2IntDistribution(high=100, log=False, low=0, step=1) hidden_layer_3IntDistribution(high=10, log=False, low=0, step=1) activationCategoricalDistribution(choices=('identity', 'logistic', 'tanh', 'relu')) solverCategoricalDistribution(choices=('lbfgs', 'sgd', 'adam')) alphaFloatDistribution(high=0.1, log=True, low=0.0001, step=None) batch_sizeCategoricalDistribution(choices=('auto', 8, 16, 32, 64, 128, 256)) learning_rateCategoricalDistribution(choices=('constant', 'invscaling', 'adaptive')) learning_rate_initFloatDistribution(high=0.1, log=True, low=0.001, step=None) power_tFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iterIntDistribution(high=500, log=False, low=50, step=10)</p> <p></p> <p></p>"}, {"location": "api/models/mlp/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/mlp/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/mlp/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/mlp/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/mnb/", "title": "MultinomialNB", "text": "<p>MNB accept sparse supports acceleration</p> <p>MultinomialNB implements the Naive Bayes algorithm for multinomially distributed data, and is one of the two classic Naive Bayes variants used in text classification (where the data are typically represented as word vector counts, although tf-idf vectors are also known to work well in practice).</p> <p>Corresponding estimators are:</p> <ul> <li>MultinomialNB for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>BernoulliNB Bernoulli Naive Bayes.</p> <p>ComplementNB Complement Naive Bayes.</p> <p>GaussianNB Gaussian Naive Bayes.</p> <p></p>"}, {"location": "api/models/mnb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"MNB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: MNB\nMetric: f1\n\n\nResults for MultinomialNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9238\nTest evaluation --&gt; f1: 0.9128\nTime elapsed: 0.024s\n-------------------------------------------------\nTime: 0.024s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.027s\n-------------------------------------\nMultinomialNB --&gt; f1: 0.9128\n</code></pre>"}, {"location": "api/models/mnb/#hyperparameters", "title": "Hyperparameters", "text": "sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> cuml cpu <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"gpu\"\n    &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#multinomialnb-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_priorCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/mnb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/mnb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/mnb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/mnb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/mstl/", "title": "MSTL", "text": "<p>MSTL multiple seasonality native multioutput</p> <p>The MSTL model (Multiple Seasonal-Trend decomposition using LOESS) is a method used to decompose a time series into its seasonal, trend and residual components. This approach is based on the use of LOESS (Local Regression Smoothing) to estimate the components of the time series.</p> <p>The MSTL decomposition is an extension of the classic seasonal-trend decomposition method (also known as Holt-Winters decomposition), which is designed to handle situations where multiple seasonal patterns exist in the data. This can occur, for example, when a time series exhibits daily, and yearly patterns simultaneously.</p> <p>Corresponding estimators are:</p> <ul> <li>StatsForecastMSTL for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>Prophet Prophet forecaster by Facebook.</p> <p>STL Seasonal-Trend decomposition using LOESS.</p> <p>TBATS TBATS forecaster with multiple seasonality.</p> <p></p>"}, {"location": "api/models/mstl/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"MSTL\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: MSTL\nMetric: mape\n\n\nResults for MSTL:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -2.3487\nTest evaluation --&gt; mape: -0.3284\nTime elapsed: 16.245s\n-------------------------------------------------\nTime: 16.245s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 16.246s\n-------------------------------------\nMSTL --&gt; mape: -0.3284\n</code></pre>"}, {"location": "api/models/mstl/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters seasonal_degCategoricalDistribution(choices=(0, 1)) trend_degCategoricalDistribution(choices=(0, 1)) low_pass_degCategoricalDistribution(choices=(0, 1)) robustCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/mstl/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/mstl/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/mstl/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/mstl/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/nf/", "title": "NaiveForecaster", "text": "<p>NF native multioutput</p> <p>NaiveForecaster is a dummy forecaster that makes forecasts using simple strategies based on naive assumptions about past trends continuing. When used in multivariate tasks, each column is forecasted with the same strategy.</p> <p>Corresponding estimators are:</p> <ul> <li>NaiveForecaster for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ExponentialSmoothing Holt-Winters Exponential Smoothing forecaster.</p> <p>Dummy Dummy classifier/regressor.</p> <p>PolynomialTrend Polynomial Trend forecaster.</p> <p></p>"}, {"location": "api/models/nf/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"NF\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: NF\nMetric: mape\n\n\nResults for NaiveForecaster:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0858\nTest evaluation --&gt; mape: -0.2305\nTime elapsed: 0.026s\n-------------------------------------------------\nTime: 0.026s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.027s\n-------------------------------------\nNaiveForecaster --&gt; mape: -0.2305\n</code></pre>"}, {"location": "api/models/nf/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters strategyCategoricalDistribution(choices=('last', 'mean', 'drift'))</p> <p></p> <p></p>"}, {"location": "api/models/nf/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/nf/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/nf/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/nf/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/ols/", "title": "OrdinaryLeastSquares", "text": "<p>OLS needs scaling accept sparse supports acceleration</p> <p>Ordinary Least Squares is just linear regression without any regularization. It fits a linear model with coefficients <code>w=(w1,  ..., wp)</code> to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation.</p> <p>Corresponding estimators are:</p> <ul> <li>LinearRegression for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>ElasticNet Linear Regression with elasticnet regularization.</p> <p>Lasso Linear Regression with lasso regularization.</p> <p>Ridge Linear least squares with l2 regularization.</p> <p></p>"}, {"location": "api/models/ols/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"OLS\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: OLS\nMetric: r2\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6067\nTest evaluation --&gt; r2: 0.6028\nTime elapsed: 0.155s\n-------------------------------------------------\nTime: 0.155s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.156s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.6028\n</code></pre>"}, {"location": "api/models/ols/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/ols/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/ols/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/ols/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/omp/", "title": "OrthogonalMatchingPursuit", "text": "<p>OMP needs scaling</p> <p>Orthogonal Matching Pursuit implements the OMP algorithm for approximating the fit of a linear model with constraints imposed on the number of non-zero coefficients.</p> <p>Corresponding estimators are:</p> <ul> <li>OrthogonalMatchingPursuit for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>Lasso Linear Regression with lasso regularization.</p> <p>LeastAngleRegression Least Angle Regression.</p> <p>OrdinaryLeastSquares Linear Regression.</p> <p></p>"}, {"location": "api/models/omp/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"OMP\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: OMP\nMetric: r2\n\n\nResults for OrthogonalMatchingPursuit:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.4751\nTest evaluation --&gt; r2: 0.4668\nTime elapsed: 0.155s\n-------------------------------------------------\nTime: 0.155s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.156s\n-------------------------------------\nOrthogonalMatchingPursuit --&gt; r2: 0.4668\n</code></pre>"}, {"location": "api/models/omp/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/omp/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/omp/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/omp/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/pa/", "title": "PassiveAggressive", "text": "<p>PA needs scaling accept sparse in-training validation</p> <p>The passive-aggressive algorithms are a family of algorithms for large-scale learning. They are similar to the Perceptron in that they do not require a learning rate. However, contrary to the Perceptron, they include a regularization parameter <code>C</code>.</p> <p>Corresponding estimators are:</p> <ul> <li>PassiveAggressiveClassifier for classification tasks.</li> <li>PassiveAggressiveRegressor for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>MultiLayerPerceptron Multi-layer Perceptron.</p> <p>Perceptron Linear Perceptron classification.</p> <p>StochasticGradientDescent Stochastic Gradient Descent.</p> <p></p>"}, {"location": "api/models/pa/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"PA\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: PA\nMetric: f1\n\n\nResults for PassiveAggressive:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9965\nTest evaluation --&gt; f1: 0.9504\nTime elapsed: 5.918s\n-------------------------------------------------\nTime: 5.918s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 5.921s\n-------------------------------------\nPassiveAggressive --&gt; f1: 0.9504\n</code></pre>"}, {"location": "api/models/pa/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) max_iterIntDistribution(high=1500, log=False, low=500, step=50) lossCategoricalDistribution(choices=('hinge', 'squared_hinge')) averageCategoricalDistribution(choices=(True, False))</p> regression <p>Parameters <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) max_iterIntDistribution(high=1500, log=False, low=500, step=50) lossCategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) averageCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/pa/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/pa/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/pa/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/pa/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/perc/", "title": "Perceptron", "text": "<p>Perc needs scaling in-training validation</p> <p>The Perceptron is a simple classification algorithm suitable for large scale learning. By default:</p> <ul> <li>It does not require a learning rate.</li> <li>It is not regularized (penalized).</li> <li>It updates its model only on mistakes.</li> </ul> <p>The last characteristic implies that the Perceptron is slightly faster to train than StochasticGradientDescent with the hinge loss and that the resulting models are sparser.</p> <p>Corresponding estimators are:</p> <ul> <li>Perceptron for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>MultiLayerPerceptron Multi-layer Perceptron.</p> <p>PassiveAggressive Passive Aggressive.</p> <p>StochasticGradientDescent Stochastic Gradient Descent.</p> <p></p>"}, {"location": "api/models/perc/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Perc\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Perc\nMetric: f1\n\n\nResults for Perceptron:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9577\nTime elapsed: 5.924s\n-------------------------------------------------\nTime: 5.924s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 5.927s\n-------------------------------------\nPerceptron --&gt; f1: 0.9577\n</code></pre>"}, {"location": "api/models/perc/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters penaltyCategoricalDistribution(choices=(None, 'l2', 'l1', 'elasticnet')) alphaFloatDistribution(high=10.0, log=True, low=0.0001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iterIntDistribution(high=1500, log=False, low=500, step=50) eta0FloatDistribution(high=10.0, log=True, low=0.01, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/perc/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/perc/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/perc/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/perc/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/prophet/", "title": "Prophet", "text": "<p>Prophet multiple seasonality native multioutput</p> <p>Prophet is designed to handle time series data with strong seasonal patterns, holidays, and missing data. Prophet is particularly useful for business applications where time series data may exhibit irregularities and is not always perfectly regular.</p> <p>Corresponding estimators are:</p> <ul> <li>Prophet for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>DynamicFactor Dynamic Factor.</p> <p>MSTL Multiple Seasonal-Trend decomposition using LOESS.</p> <p>VARMAX Vector Autoregressive Moving-Average.</p> <p></p>"}, {"location": "api/models/prophet/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Prophet\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Prophet\nMetric: mape\n\n\nResults for Prophet:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.061\nTest evaluation --&gt; mape: -0.0805\nTime elapsed: 0.150s\n-------------------------------------------------\nTime: 0.150s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.153s\n-------------------------------------\nProphet --&gt; mape: -0.0805\n</code></pre>"}, {"location": "api/models/prophet/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters changepoint_prior_scaleFloatDistribution(high=0.5, log=True, low=0.001, step=None) seasonality_prior_scaleFloatDistribution(high=10.0, log=True, low=0.001, step=None) holidays_prior_scaleFloatDistribution(high=10.0, log=True, low=0.001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/prophet/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/prophet/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/prophet/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/prophet/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/pt/", "title": "PolynomialTrend", "text": "<p>PT native multioutput</p> <p>Forecast time series data with a polynomial trend, using a sklearn LinearRegression class to regress values of time series on index, after extraction of polynomial features.</p> <p>Corresponding estimators are:</p> <ul> <li>PolynomialTrendForecaster for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>ETS Error-Trend-Seasonality model.</p> <p>NaiveForecaster Naive Forecaster.</p> <p></p>"}, {"location": "api/models/pt/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"PT\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: PT\nMetric: mape\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1196\nTest evaluation --&gt; mape: -0.1181\nTime elapsed: 0.019s\n-------------------------------------------------\nTime: 0.019s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.020s\n-------------------------------------\nPolynomialTrend --&gt; mape: -0.1181\n</code></pre>"}, {"location": "api/models/pt/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters degreeIntDistribution(high=5, log=False, low=1, step=1) with_interceptCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/pt/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/pt/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/pt/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/pt/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/qda/", "title": "QuadraticDiscriminantAnalysis", "text": "<p>QDA</p> <p>Quadratic Discriminant Analysis is a classifier with a quadratic decision boundary, generated by fitting class conditional densities to the data and using Bayes' rule. The model fits a Gaussian density to each class, assuming that all classes share the same covariance matrix.</p> <p>Corresponding estimators are:</p> <ul> <li>QuadraticDiscriminantAnalysis for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>LinearDiscriminantAnalysis Linear Discriminant Analysis.</p> <p>LogisticRegression Logistic Regression.</p> <p>RadiusNearestNeighbors Radius Nearest Neighbors.</p> <p></p>"}, {"location": "api/models/qda/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"QDA\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: QDA\nMetric: f1\n\n\nResults for QuadraticDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9809\nTest evaluation --&gt; f1: 0.9504\nTime elapsed: 0.026s\n-------------------------------------------------\nTime: 0.026s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.031s\n-------------------------------------\nQuadraticDiscriminantAnalysis --&gt; f1: 0.9504\n</code></pre>"}, {"location": "api/models/qda/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters reg_paramFloatDistribution(high=1.0, log=False, low=0.0, step=0.1)</p> <p></p> <p></p>"}, {"location": "api/models/qda/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/qda/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/qda/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/qda/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/rf/", "title": "RandomForest", "text": "<p>RF accept sparse native multilabel native multioutput supports acceleration</p> <p>Random forests are an ensemble learning method that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random forests correct for decision trees' habit of overfitting to their training set.</p> <p>Corresponding estimators are:</p> <ul> <li>RandomForestClassifier for classification tasks.</li> <li>RandomForestRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p>Warning</p> <p>cuML's implementation of RandomForestClassifier only supports predictions on dtype <code>float32</code>. Convert all dtypes before calling atom's run method to avoid exceptions.</p> <p></p> <p>See Also</p> <p>DecisionTree Single Decision Tree.</p> <p>ExtraTrees Extremely Randomized Trees.</p> <p>HistGradientBoosting Histogram-based Gradient Boosting Machine.</p> <p></p>"}, {"location": "api/models/rf/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"RF\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: RF\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9524\nTime elapsed: 0.168s\n-------------------------------------------------\nTime: 0.168s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.171s\n-------------------------------------\nRandomForest --&gt; f1: 0.9524\n</code></pre>"}, {"location": "api/models/rf/#hyperparameters", "title": "Hyperparameters", "text": "classification sklearn <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('gini', 'entropy')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('gini', 'entropy')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('gini', 'entropy')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('gini', 'entropy')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('gini', 'entropy')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> regression sklearn <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#randomforest-n_estimators}\n</code></pre> <p>n_estimatorsIntDistribution(high=500, log=False, low=10, step=10) criterionCategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrapCategoricalDistribution(choices=(True, False)) max_samplesCategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <p></p> <p></p>"}, {"location": "api/models/rf/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/rf/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/rf/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/rf/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/ridge/", "title": "Ridge", "text": "<p>Ridge needs scaling accept sparse native multilabel supports acceleration</p> <p>If classifier, it first converts the target values into {-1, 1} and then treats the problem as a regression task.</p> <p>Corresponding estimators are:</p> <ul> <li>RidgeClassifier for classification tasks.</li> <li>Ridge for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p>Warning</p> <p>Engines <code>sklearnex</code> and <code>cuml</code> are only available for regression tasks.</p> <p></p> <p>See Also</p> <p>BayesianRidge Bayesian ridge regression.</p> <p>ElasticNet Linear Regression with elasticnet regularization.</p> <p>Lasso Linear Regression with lasso regularization.</p> <p></p>"}, {"location": "api/models/ridge/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import fetch_california_housing\n\n&gt;&gt;&gt; X, y = fetch_california_housing(return_X_y=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Ridge\", metric=\"r2\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Ridge\nMetric: r2\n\n\nResults for Ridge:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6067\nTest evaluation --&gt; r2: 0.6028\nTime elapsed: 0.155s\n-------------------------------------------------\nTime: 0.155s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.156s\n-------------------------------------\nRidge --&gt; r2: 0.6028\n</code></pre>"}, {"location": "api/models/ridge/#hyperparameters", "title": "Hyperparameters", "text": "classification sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> regression sklearn <p>Parameters <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#ridge-alpha}\n</code></pre> <p>alphaFloatDistribution(high=10.0, log=True, low=0.001, step=None) solverCategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'))</p> <p></p> <p></p>"}, {"location": "api/models/ridge/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/ridge/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/ridge/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/ridge/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/rnn/", "title": "RadiusNearestNeighbors", "text": "<p>RNN needs scaling accept sparse native multilabel native multioutput</p> <p>Radius Nearest Neighbors implements the nearest neighbors vote, where the neighbors are selected from within a given radius. For regression, the target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set.</p> <p>Warning</p> <ul> <li>The <code>radius</code> parameter should be tuned to the data at hand or   the model will perform poorly.</li> <li>If outliers are detected, the estimator raises an exception   unless <code>est_params={\"outlier_label\": \"most_frequent\"}</code> is used.</li> </ul> <p>Corresponding estimators are:</p> <ul> <li>RadiusNeighborsClassifier for classification tasks.</li> <li>RadiusNeighborsRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>KNearestNeighbors K-Nearest Neighbors.</p> <p>LinearDiscriminantAnalysis Linear Discriminant Analysis.</p> <p>QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis.</p> <p></p>"}, {"location": "api/models/rnn/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\n...     models=\"RNN\",\n...     metric=\"f1\",\n...     est_params={\"outlier_label\": \"most_frequent\"},\n...     verbose=2,\n... )\n\n\nTraining ========================= &gt;&gt;\nModels: RNN\nMetric: f1\n\n\nResults for RadiusNearestNeighbors:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.7717\nTime elapsed: 0.256s\n-------------------------------------------------\nTime: 0.256s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.259s\n-------------------------------------\nRadiusNearestNeighbors --&gt; f1: 0.7717 ~\n</code></pre>"}, {"location": "api/models/rnn/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>radiusFloatDistribution(high=100.0, log=False, low=0.01, step=None) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> regression <p>Parameters <p>radiusFloatDistribution(high=100.0, log=False, low=0.01, step=None) weightsCategoricalDistribution(choices=('uniform', 'distance')) algorithmCategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_sizeIntDistribution(high=40, log=False, low=20, step=1) pIntDistribution(high=2, log=False, low=1, step=1)</p> <p></p> <p></p>"}, {"location": "api/models/rnn/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/rnn/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/rnn/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/rnn/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/sarimax/", "title": "SARIMAX", "text": "<p>SARIMAX native multioutput</p> <p>SARIMAX stands for Seasonal Autoregressive Integrated Moving Average with eXogenous factors. It extends ARIMA by incorporating seasonal components and exogenous variables. Note that the ARIMA model is also capable of fitting SARIMAX.</p> <p>Corresponding estimators are:</p> <ul> <li>SARIMAX for forecasting tasks.</li> </ul> <p>Note</p> <p>The seasonal components ar removed from hyperparameter tuning if no seasonality is specified.</p> <p>Warning</p> <p>SARIMAX often runs into numerical errors when optimizing the hyperparameters. Possible solutions are:</p> <ul> <li>Use the AutoARIMA model instead.</li> <li>Use <code>est_params</code> to specify the   orders manually, e.g., <code>atom.run(\"sarimax\", n_trials=5,est_params={\"order\": (1, 1, 0)})</code>.</li> <li>Use the <code>catch</code> parameter in <code>ht_params</code>   to avoid raising every exception, e.g., <code>atom.run(\"sarimax\",n_trials=5, ht_params={\"catch\": (Exception,)})</code>.</li> </ul> <p></p> <p>See Also</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>AutoARIMA Automatic Autoregressive Integrated Moving Average.</p> <p>VARMAX Vector Autoregressive Moving-Average.</p> <p></p>"}, {"location": "api/models/sarimax/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; _, X = load_longley()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X)\n&gt;&gt;&gt; atom.run(models=\"SARIMAX\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: SARIMAX\nMetric: mape\n\n\nResults for SARIMAX:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0131\nTest evaluation --&gt; mape: -0.0364\nTime elapsed: 0.076s\n-------------------------------------------------\nTime: 0.076s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.077s\n-------------------------------------\nSARIMAX --&gt; mape: -0.0364\n</code></pre>"}, {"location": "api/models/sarimax/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters pIntDistribution(high=2, log=False, low=0, step=1) dIntDistribution(high=1, log=False, low=0, step=1) qIntDistribution(high=2, log=False, low=0, step=1) trendCategoricalDistribution(choices=('n', 'c', 't', 'ct')) measurement_errorCategoricalDistribution(choices=(True, False)) time_varying_regressionCategoricalDistribution(choices=(True, False)) mle_regressionCategoricalDistribution(choices=(True, False)) simple_differencingCategoricalDistribution(choices=(True, False)) enforce_stationarityCategoricalDistribution(choices=(True, False)) enforce_invertibilityCategoricalDistribution(choices=(True, False)) hamilton_representationCategoricalDistribution(choices=(True, False)) concentrate_scaleCategoricalDistribution(choices=(True, False)) use_exact_diffuseCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/sarimax/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/sarimax/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/sarimax/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/sarimax/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/sgd/", "title": "StochasticGradientDescent", "text": "<p>SGD needs scaling accept sparse in-training validation</p> <p>Stochastic Gradient Descent is a simple yet very efficient approach to fitting linear classifiers and regressors under convex loss functions. Even though SGD has been around in the machine learning community for a long time, it has received a considerable amount of attention just recently in the context of large-scale learning.</p> <p>Corresponding estimators are:</p> <ul> <li>SGDClassifier for classification tasks.</li> <li>SGDRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>MultiLayerPerceptron Multi-layer Perceptron.</p> <p>PassiveAggressive Passive Aggressive.</p> <p>SupportVectorMachine Support Vector Machine.</p> <p></p>"}, {"location": "api/models/sgd/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"SGD\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: SGD\nMetric: f1\n\n\nResults for StochasticGradientDescent:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9948\nTest evaluation --&gt; f1: 0.9722\nTime elapsed: 5.897s\n-------------------------------------------------\nTime: 5.897s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 5.900s\n-------------------------------------\nStochasticGradientDescent --&gt; f1: 0.9722\n</code></pre>"}, {"location": "api/models/sgd/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>lossCategoricalDistribution(choices=('hinge', 'log_loss', 'modified_huber', 'squared_hinge', 'perceptron', 'squared_error', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive')) penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) alphaFloatDistribution(high=1.0, log=True, low=0.0001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iterIntDistribution(high=1500, log=False, low=500, step=50) epsilonFloatDistribution(high=1.0, log=True, low=0.0001, step=None) learning_rateCategoricalDistribution(choices=('constant', 'invscaling', 'optimal', 'adaptive')) eta0FloatDistribution(high=10.0, log=True, low=0.01, step=None) power_tFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) averageCategoricalDistribution(choices=(True, False))</p> regression <p>Parameters <p>lossCategoricalDistribution(choices=('squared_error', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive')) penaltyCategoricalDistribution(choices=(None, 'l1', 'l2', 'elasticnet')) alphaFloatDistribution(high=1.0, log=True, low=0.0001, step=None) l1_ratioFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iterIntDistribution(high=1500, log=False, low=500, step=50) epsilonFloatDistribution(high=1.0, log=True, low=0.0001, step=None) learning_rateCategoricalDistribution(choices=('constant', 'invscaling', 'optimal', 'adaptive')) eta0FloatDistribution(high=10.0, log=True, low=0.01, step=None) power_tFloatDistribution(high=0.9, log=False, low=0.1, step=0.1) averageCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/sgd/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/sgd/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/sgd/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/sgd/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/stl/", "title": "STL", "text": "<p>STL native multioutput</p> <p>STL is a technique commonly used for decomposing time series data into components like trend, seasonality, and residuals.</p> <p>Corresponding estimators are:</p> <ul> <li>STLForecaster for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>Croston Croston's method for forecasting.</p> <p>ETS Error-Trend-Seasonality model.</p> <p>Theta Theta method for forecasting.</p> <p></p>"}, {"location": "api/models/stl/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"STL\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: STL\nMetric: mape\n\n\nResults for STL:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0713\nTest evaluation --&gt; mape: -0.3396\nTime elapsed: 1.768s\n-------------------------------------------------\nTime: 1.768s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.769s\n-------------------------------------\nSTL --&gt; mape: -0.3396\n</code></pre>"}, {"location": "api/models/stl/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters seasonalIntDistribution(high=11, log=False, low=3, step=2) seasonal_degCategoricalDistribution(choices=(0, 1)) low_pass_degCategoricalDistribution(choices=(0, 1)) robustCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/stl/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/stl/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/stl/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/stl/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/svm/", "title": "SupportVectorMachine", "text": "<p>SVM needs scaling accept sparse supports acceleration</p> <p>The implementation of the Support Vector Machine is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples. For large datasets consider using a LinearSVM or a StochasticGradientDescent model instead.</p> <p>Corresponding estimators are:</p> <ul> <li>SVC for classification tasks.</li> <li>SVR for classification tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>LinearSVM Linear Support Vector Machine.</p> <p>MultiLayerPerceptron Multi-layer Perceptron.</p> <p>StochasticGradientDescent Stochastic Gradient Descent.</p> <p></p>"}, {"location": "api/models/svm/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"SVM\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: SVM\nMetric: f1\n\n\nResults for SupportVectorMachine:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9913\nTest evaluation --&gt; f1: 0.979\nTime elapsed: 0.241s\n-------------------------------------------------\nTime: 0.241s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.244s\n-------------------------------------\nSupportVectorMachine --&gt; f1: 0.979\n</code></pre>"}, {"location": "api/models/svm/#hyperparameters", "title": "Hyperparameters", "text": "classification sklearn <p>Parameters <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> regression sklearn <p>Parameters <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilonFloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"sklearnex\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilonFloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilonFloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>=== \"cuml\"\n\n    === \"cpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilonFloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <pre><code>    === \"gpu\"\n        &lt;table markdown class='table_params'&gt;&lt;tr&gt;&lt;td class='td_title'&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/td&gt;&lt;td class='td_params'&gt;[](){#supportvectormachine-C}\n</code></pre> <p>CFloatDistribution(high=100.0, log=True, low=0.001, step=None) kernelCategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degreeIntDistribution(high=5, log=False, low=2, step=1) gammaCategoricalDistribution(choices=('scale', 'auto')) coef0FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilonFloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinkingCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/svm/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/svm/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/svm/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/svm/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/tbats/", "title": "TBATS", "text": "<p>TBATS multiple seasonality native multioutput</p> <p>TBATS is acronym for:</p> <ul> <li>Trigonometric seasonality</li> <li>Box-Cox transformation</li> <li>ARMA errors</li> <li>Trend</li> <li>Seasonal components</li> </ul> <p>TBATS was designed to forecast time series with multiple seasonal periods. For example, daily data may have a weekly pattern as well as an annual pattern. Or hourly data can have three seasonal periods: a daily pattern, a weekly pattern, and an annual pattern.</p> <p>In BATS, a Box-Cox transformation is applied to the original time series, and then this is modeled as a linear combination of an exponentially smoothed trend, a seasonal component and an ARMA component. The seasonal components are modeled by trigonometric functions via Fourier series. TBATS conducts some hyper-parameter tuning (e.g. which of these components to keep and which to discard) using AIC.</p> <p>Corresponding estimators are:</p> <ul> <li>TBATS for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>BATS BATS forecaster with multiple seasonality.</p> <p>ARIMA Autoregressive Integrated Moving Average.</p> <p>AutoARIMA Automatic Autoregressive Integrated Moving Average.</p> <p></p>"}, {"location": "api/models/tbats/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"TBATS\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: TBATS\nMetric: mape\n\n\nResults for TBATS:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0829\nTest evaluation --&gt; mape: -0.1676\nTime elapsed: 35.672s\n-------------------------------------------------\nTime: 35.672s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 35.674s\n-------------------------------------\nTBATS --&gt; mape: -0.1676\n</code></pre>"}, {"location": "api/models/tbats/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters use_box_coxCategoricalDistribution(choices=(True, False, None)) use_trendCategoricalDistribution(choices=(True, False, None)) use_damped_trendCategoricalDistribution(choices=(True, False, None)) use_arma_errorsCategoricalDistribution(choices=(True, False))</p> <p></p> <p></p>"}, {"location": "api/models/tbats/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/tbats/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/tbats/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/tbats/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/theta/", "title": "Theta", "text": "<p>Theta native multioutput</p> <p>The theta method is equivalent to simple ExponentialSmoothing with drift. The series is tested for seasonality, and, if deemed seasonal, the series is seasonally adjusted using a classical multiplicative decomposition before applying the theta method. The resulting forecasts are then reseasonalised.</p> <p>In cases where ExponentialSmoothing results in a constant forecast, the theta forecaster will revert to predicting the SES constant plus a linear trend derived from the training data.</p> <p>Prediction intervals are computed using the underlying state space model.</p> <p>Corresponding estimators are:</p> <ul> <li>ThetaForecaster for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>Croston Croston's method for forecasting.</p> <p>ExponentialSmoothing Holt-Winters Exponential Smoothing forecaster.</p> <p>PolynomialTrend Polynomial Trend forecaster.</p> <p></p>"}, {"location": "api/models/theta/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Theta\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Theta\nMetric: mape\n\n\nResults for Theta:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.4388\nTest evaluation --&gt; mape: -0.2589\nTime elapsed: 0.031s\n-------------------------------------------------\nTime: 0.031s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.032s\n-------------------------------------\nTheta --&gt; mape: -0.2589\n</code></pre>"}, {"location": "api/models/theta/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters deseasonalizeCategoricalDistribution(choices=(False, True))</p> <p></p> <p></p>"}, {"location": "api/models/theta/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/theta/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/theta/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/theta/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/tree/", "title": "DecisionTree", "text": "<p>Tree accept sparse native multilabel native multioutput</p> <p>A single decision tree classifier/regressor.</p> <p>Corresponding estimators are:</p> <ul> <li>DecisionTreeClassifier for classification tasks.</li> <li>DecisionTreeRegressor for regression tasks.</li> </ul> <p>Read more in sklearn's documentation.</p> <p></p> <p>See Also</p> <p>ExtraTree Extremely Randomized Tree.</p> <p>ExtraTrees Extremely Randomized Trees.</p> <p>RandomForest Random Forest.</p> <p></p>"}, {"location": "api/models/tree/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"Tree\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: Tree\nMetric: f1\n\n\nResults for DecisionTree:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9589\nTime elapsed: 0.029s\n-------------------------------------------------\nTime: 0.029s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.032s\n-------------------------------------\nDecisionTree --&gt; f1: 0.9589\n</code></pre>"}, {"location": "api/models/tree/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>criterionCategoricalDistribution(choices=('gini', 'entropy')) splitterCategoricalDistribution(choices=('best', 'random')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> regression <p>Parameters <p>criterionCategoricalDistribution(choices=('squared_error', 'absolute_error', 'friedman_mse', 'poisson')) splitterCategoricalDistribution(choices=('best', 'random')) max_depthCategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_splitIntDistribution(high=20, log=False, low=2, step=1) min_samples_leafIntDistribution(high=20, log=False, low=1, step=1) max_featuresCategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alphaFloatDistribution(high=0.035, log=False, low=0.0, step=0.005)</p> <p></p> <p></p>"}, {"location": "api/models/tree/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/tree/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/tree/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/tree/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/var/", "title": "VAR", "text": "<p>VAR native multioutput</p> <p>The Vector Autoregressive (VAR) model is a type of multivariate time series model used for analyzing and forecasting the joint behavior of multiple time series variables. In a VAR model, each variable in the system is modeled as a linear combination of its past values as well as the past values of all other variables in the system. This allows for capturing the interdependencies and dynamic relationships among the variables over time.</p> <p>Warning</p> <p>VAR only supports multivariate tasks.</p> <p>Corresponding estimators are:</p> <ul> <li>VAR for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>MSTL Multiple Seasonal-Trend decomposition using LOESS.</p> <p>Prophet Prophet forecaster by Facebook.</p> <p>VARMAX Vector Autoregressive Moving-Average.</p> <p></p>"}, {"location": "api/models/var/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; _, X = load_longley()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X, y=(-1, -2), random_state=1)\n&gt;&gt;&gt; atom.run(models=\"VAR\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: VAR\nMetric: mape\n\n\nResults for VAR:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0584\nTest evaluation --&gt; mape: -0.0559\nTime elapsed: 0.037s\n-------------------------------------------------\nTime: 0.037s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.040s\n-------------------------------------\nVAR --&gt; mape: -0.0559\n</code></pre>"}, {"location": "api/models/var/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters trendCategoricalDistribution(choices=('c', 'ct', 'ctt', 'n')) icCategoricalDistribution(choices=('aic', 'fpe', 'hqic', 'bic'))</p> <p></p> <p></p>"}, {"location": "api/models/var/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/var/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/var/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/var/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/varmax/", "title": "VARMAX", "text": "<p>VARMAX native multioutput</p> <p>VARMAX is an extension of the VAR model that incorporates not only lagged values of the endogenous variables, but also includes exogenous variables. This allows VARMAX models to capture both the interdependencies among multiple time series variables and the influence of external factors.</p> <p>Warning</p> <p>VARMAX only supports multivariate tasks.</p> <p>Corresponding estimators are:</p> <ul> <li>VARMAX for forecasting tasks.</li> </ul> <p></p> <p>See Also</p> <p>MSTL Multiple Seasonal-Trend decomposition using LOESS.</p> <p>Prophet Prophet forecaster by Facebook.</p> <p>VAR Vector Autoregressive.</p> <p></p>"}, {"location": "api/models/varmax/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_longley\n\n&gt;&gt;&gt; _, X = load_longley()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X, y=(-1, -2), random_state=1)\n&gt;&gt;&gt; atom.run(models=\"VARMAX\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: VARMAX\nMetric: mape\n\n\nResults for VARMAX:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0722\nTest evaluation --&gt; mape: -0.0465\nTime elapsed: 0.277s\n-------------------------------------------------\nTime: 0.277s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.280s\n-------------------------------------\nVARMAX --&gt; mape: -0.0465\n</code></pre>"}, {"location": "api/models/varmax/#hyperparameters", "title": "Hyperparameters", "text": "<p>Parameters pIntDistribution(high=2, log=False, low=0, step=1) qIntDistribution(high=2, log=False, low=0, step=1) trendCategoricalDistribution(choices=('c', 'ct', 'ctt', 'n')) error_cov_typeCategoricalDistribution(choices=('diagonal', 'unstructured')) measurement_errorCategoricalDistribution(choices=(True, False)) enforce_stationarityCategoricalDistribution(choices=(True, False)) enforce_invertibilityCategoricalDistribution(choices=(True, False)) cov_typeCategoricalDistribution(choices=('opg', 'oim', 'approx', 'robust', 'robust_approx')) methodCategoricalDistribution(choices=('newton', 'nm', 'bfgs', 'lbfgs', 'powell', 'cg', 'ncg', 'basinhopping')) maxiterIntDistribution(high=200, log=False, low=50, step=10)</p> <p></p> <p></p>"}, {"location": "api/models/varmax/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/varmax/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/varmax/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/varmax/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_residualsGet residuals of forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(fh, X=None, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9, inverse=True, verbose=None)[source] <p>Get prediction intervals on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_interval</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_proba(fh, X=None, marginal=True, verbose=None)[source] <p>Get probabilistic forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns{#predict_proba-sktime.proba.Normal} sktime.proba.Normal Distribution object. </p> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95), verbose=None)[source] <p>Get quantile forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_quantiles</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None, verbose=None)[source] <p>Get residuals of forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_residuals</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters y: hashable, segment, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. This parameter is ignored outif <code>y</code> is a selection of rows in the dataset. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False, verbose=None)[source] <p>Get variance forecasts on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_var</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters fh: hashable, segment, sequence, dataframe or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: hashable, segment, sequence, dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(y, X=None, fh=None, metric=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric used by sktime's score method for estimators.</p> <p>Parameters y: int, str, sequence or dataframe-like Selection of rows or ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>y</code> is a selection of rows in the dataset. <p> fh: hashable, segment, sequence, dataframe, ForecastingHorizon or None, default=None Do nothing. The forecast horizon is taken from the index of <code>y</code>. Implemented for continuity of sktime's API. <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of <code>y</code> with respect to a ground truth. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/models/xgb/", "title": "XGBoost", "text": "<p>XGB needs scaling accept sparse in-training validation supports acceleration</p> <p>XGBoost is an optimized distributed gradient boosting model designed to be highly efficient, flexible and portable. XGBoost provides a parallel tree boosting that solve many data science problems in a fast and accurate way.</p> <p>Corresponding estimators are:</p> <ul> <li>XGBClassifier for classification tasks.</li> <li>XGBRegressor for regression tasks.</li> </ul> <p>Read more in XGBoost's documentation.</p> <p></p> <p>See Also</p> <p>CatBoost Cat Boosting Machine.</p> <p>GradientBoostingMachine Gradient Boosting Machine.</p> <p>LightGBM Light Gradient Boosting Machine.</p> <p></p>"}, {"location": "api/models/xgb/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(models=\"XGB\", metric=\"f1\", verbose=2)\n\n\nTraining ========================= &gt;&gt;\nModels: XGB\nMetric: f1\n\n\nResults for XGBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9583\nTime elapsed: 0.578s\n-------------------------------------------------\nTime: 0.578s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.582s\n-------------------------------------\nXGBoost --&gt; f1: 0.9583\n</code></pre>"}, {"location": "api/models/xgb/#hyperparameters", "title": "Hyperparameters", "text": "classification <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=20, step=10) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depthIntDistribution(high=20, log=False, low=1, step=1) gammaFloatDistribution(high=1.0, log=False, low=0.0, step=None) min_child_weightIntDistribution(high=10, log=False, low=1, step=1) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytreeFloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alphaFloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambdaFloatDistribution(high=100.0, log=True, low=0.0001, step=None)</p> regression <p>Parameters <p>n_estimatorsIntDistribution(high=500, log=False, low=20, step=10) learning_rateFloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depthIntDistribution(high=20, log=False, low=1, step=1) gammaFloatDistribution(high=1.0, log=False, low=0.0, step=None) min_child_weightIntDistribution(high=10, log=False, low=1, step=1) subsampleFloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytreeFloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alphaFloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambdaFloatDistribution(high=100.0, log=True, low=0.0001, step=None)</p> <p></p> <p></p>"}, {"location": "api/models/xgb/#attributes", "title": "Attributes", "text": ""}, {"location": "api/models/xgb/#data-attributes", "title": "Data attributes", "text": "<p>Attributes pipeline: PipelinePipeline of transformers. <p>Models that used automated feature scaling have the scaler added.</p> <p>Tip</p> <p>Use the plot_pipeline method to visualize the pipeline.</p> <p> mapping: dict[str, dict[str, int | float]]Encoded values and their respective mapped values. <p>The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g., Ordinal, Leave-one-out, etc...).  dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  X_holdout: pd.DataFrame | NoneFeatures of the holdout set.  y_holdout: pd.Series | pd.DataFrame | NoneTarget column of the holdout set.  shape: tuple[Int, Int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/models/xgb/#utility-attributes", "title": "Utility attributes", "text": "<p>Attributes name: strName of the model. <p>Use the property's <code>@setter</code> to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow, the name of the corresponding run also changes.  run: RunMlflow run corresponding to this model. <p>This property is only available for models that with mlflow tracking enabled.  study: StudyOptuna study used for hyperparameter tuning. <p>This property is only available for models that ran hyperparameter tuning.  trials: pd.DataFrameOverview of the trials' results. <p>This property is only available for models that ran hyperparameter tuning. All durations are in seconds. Columns include:</p> <ul> <li>[param_name]: Parameter value used in this trial.</li> <li>estimator: Estimator used in this trial.</li> <li>[metric_name]: Metric score of the trial.</li> <li>[best_metric_name]: Best score so far in this study.</li> <li>time_trial: Duration of the trial.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>state: Trial's state (COMPLETE, PRUNED, FAIL).  best_trial: FrozenTrialTrial that returned the highest score. <p>For multi-metric runs, the best trial is the trial that performed best on the main metric. Use the property's <code>@setter</code> to change the best trial. See here an example. This property is only available for models that ran hyperparameter tuning.  best_params: dict[str, Any]Estimator's parameters in the best trial. <p>This property is only available for models that ran hyperparameter tuning.  estimator: PredictorEstimator fitted on the training set.  evals: dict[str, list[Float]]Scores obtained per iteration of the training. <p>Only the scores of the main metric are tracked. Included keys are: train and test. This property is only available for models with in-training-validation.  bootstrap: pd.DataFrameOverview of the bootstrapping scores. <p>The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using <code>atom.bootstrap.mean()</code> yields the same values as <code>[metric]_bootstrap</code>. This property is only available for models that ran bootstrapping.  results: pd.SeriesOverview of the model results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.  feature_importance: pd.SeriesNormalized feature importance scores. <p>The sum of importances for all features is 1. The scores are extracted from the estimator's <code>scores_</code>, <code>coef_</code> or <code>feature_importances_</code> attribute, checked in that order. This property is only available for estimators with at least one of those attributes. </p> <p></p>"}, {"location": "api/models/xgb/#methods", "title": "Methods", "text": "<p>The plots can be called directly from the model. The remaining utility methods can be found hereunder.</p> <p>bootstrappingApply a bootstrap algorithm.calibrateCalibrate and retrain the model.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from the model.create_appCreate an interactive app to test model predictions.create_dashboardCreate an interactive dashboard to analyze the model.cross_validateEvaluate the model using cross-validation.decision_functionGet confidence scores on new data or existing rows.evaluateGet the model's scores for the provided metrics.export_pipelineExport the transformer pipeline with final estimator.fitFit and validate the model.full_trainTrain the estimator on the complete dataset.get_best_thresholdGet the threshold that maximizes a metric.get_tagsGet the model's tags.hyperparameter_tuningRun the hyperparameter tuning algorithm.inverse_transformInversely transform new data through the pipeline.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.registerRegister the model in mlflow's model registry.reset_aestheticsReset the plot aesthetics to their default values.save_estimatorSave the estimator to a pickle file.scoreGet a metric score on new data.serveServe the model as rest API endpoint for inference.set_thresholdSet the binary threshold of the estimator.transformTransform new data through the pipeline.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.</p> <p></p> <p></p> method bootstrapping(n_bootstrap, reset=False)[source] <p>Apply a bootstrap algorithm.</p> <p>Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results.</p> <p>Parameters n_bootstrap: int umber of bootstrapped samples to fit on. <p> reset: bool, default=False Whether to start a new run or continue the existing one. </p> <p></p> <p></p> method calibrate(method=\"sigmoid\", train_on_test=False)[source] <p>Calibrate and retrain the model.</p> <p>Uses sklearn's CalibratedClassifierCV to apply probability calibration on the model. The new classifier replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_calibrate</code>. Since the estimator changed, the model is cleared. Only for classifiers.</p> <p>Note</p> <p>By default, the calibration is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for calibration, but only if there is another, independent set for testing (holdout set).</p> <p>Parameters method: str, default=\"sigmoid\" The method to use for calibration. Choose from: <ul> <li>\"sigmoid\": Corresponds to Platt's method   (i.e., a logistic regression model).</li> <li>\"isotonic\": Non-parametric approach. It's not advised   to use this calibration method with too few samples (&lt;1000)   since it tends to overfit.</li> </ul> <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. </p> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from the model.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Cached predictions.</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method create_app(**kwargs)[source] <p>Create an interactive app to test model predictions.</p> <p>Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the <code>app</code> attribute.</p> <p>Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. </p> <p></p> <p></p> method create_dashboard(rows=\"test\", filename=None, **kwargs)[source] <p>Create an interactive dashboard to analyze the model.</p> <p>ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees.</p> <p>By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the <code>mode=\"inline\"</code> parameter. The created ExplainerDashboard instance can be accessed through the <code>dashboard</code> attribute. This method is not available for multioutput tasks.</p> <p>Note</p> <p>Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to get the report from. <p> filename: str, Path or None, default=None Filename or pathlib.Path of the file to save. None to not save anything. <p> **kwargs Additional keyword arguments for the ExplainerDashboard instance. </p> <p></p> <p></p> method cross_validate(include_holdout=False, **kwargs)[source] <p>Evaluate the model using cross-validation.</p> <p>This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the model's performance. If the scoring method is not specified in <code>kwargs</code>, it uses atom's metric. The results of the cross-validation are stored in the model's <code>cv</code> attribute.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the cross-validation. <p> **kwargs Additional keyword arguments for one of these functions. <ul> <li>For forecast tasks: evaluate.</li> <li>Else: cross_validate.</li> </ul> <p>Returns{#cross_validate-Styler} Styler Overview of the results. </p> <p></p> <p></p> method decision_function(X, verbose=None)[source] <p>Get confidence scores on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>decision_function</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get the model's scores for the provided metrics.</p> <p>Tip</p> <p>Use the get_best_threshold or plot_threshold method to determine a suitable threshold for a binary classifier.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task is used. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns pd.Series Scores of the model. </p> <p></p> <p></p> method export_pipeline()[source] <p>Export the transformer pipeline with final estimator.</p> <p>The returned pipeline is already fitted on the training set. Note that if the model used automated feature scaling, the Scaler is added to the pipeline.</p> <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method fit(X=None, y=None, prefit=False)[source] <p>Fit and validate the model.</p> <p>The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study.</p> <p>Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, <code>self.X_train</code> is used. <p> y: pd.Series, pd.DataFrame or None Target column(s) corresponding to <code>X</code>. If None, <code>self.y_train</code> is used. <p> prefit: bool, default=False Whether the estimator is already fitted. If True, only evaluate the model. </p> <p></p> <p></p> method full_train(include_holdout=False)[source] <p>Train the estimator on the complete dataset.</p> <p>In some cases, it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started with the name <code>[model_name]_full_train</code>. Since the estimator changed, the model is cleared.</p> <p>Warning</p> <p>Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: <code>pipeline = atom.export_pipeline().fit(atom.X, atom.y)</code>.</p> <p>Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. </p> <p></p> <p></p> method get_best_threshold(metric=None, train_on_test=False)[source] <p>Get the threshold that maximizes a metric.</p> <p>Uses sklearn's TunedThresholdClassifierCV to post-tune the decision threshold (cut-off point) that is used for converting posterior probability estimates (i.e., output of <code>predict_proba</code>) or decision scores (i.e., output of <code>decision_function</code>) into a class label. The tuning is done by optimizing one of atom's metrics. The tuning estimator is stored under the <code>tuned_threshold</code> attribute. Only available for binary classifiers.</p> <p>Note</p> <p>By default, the threshold is optimized using the training set (which is already used for the initial training). This approach is subject to undesired overfitting. It's preferred to use <code>train_on_test=True</code>, which uses the test set for tuning, but only if there is another, independent set for testing (holdout set).</p> <p>Tip</p> <p>Use the plot_threshold method to visualize the effect of different thresholds on a metric.</p> <p>Parameters metric: int, str or None, default=None Metric to optimize on. If None, the main metric is used. <p> train_on_test: bool, default=False Whether to train the calibrator on the test set. <p>Returns float Optimized threshold value. </p> <p></p> <p></p> method get_tags()[source] <p>Get the model's tags.</p> <p>Return class parameters that provide general information about the model's characteristics.</p> <p>Returns dict Model's tags. </p> <p></p> <p></p> method hyperparameter_tuning(n_trials, reset=False)[source] <p>Run the hyperparameter tuning algorithm.</p> <p>Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization.</p> <p>Parameters n_trials: int Number of trials for the hyperparameter tuning. <p> reset: bool, default=False Whether to start a new study or continue the existing one. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, verbose=None)[source] <p>Inversely transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. The rest should all implement an <code>inverse_transform</code> method. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inverted as well.</p> <p>Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Original feature set. Only returned if provided. <p> series or dataframe Original target column. Only returned if provided. </p> <p></p> <p></p> method predict(X, inverse=True, verbose=None)[source] <p>Get predictions on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_log_proba(X, verbose=None)[source] <p>Get class log-probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_log_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class log-probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X, verbose=None)[source] <p>Get class probabilities on new data or existing rows.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a <code>predict_proba</code> method.</p> <p>Read more in the user guide.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Predicted class probabilities with shape=(n_samples, n_classes) or shape=(n_samples * n_classes, n_targets) with a multiindex format for multioutput tasks. </p> <p></p> <p></p> method register(name=None, stage=\"None\", archive_existing_versions=False)[source] <p>Register the model in mlflow's model registry.</p> <p>This method is only available when model tracking is enabled using one of the following URI schemes: databricks, http, https, postgresql, mysql, sqlite, mssql.</p> <p>Parameters name: str or None, default=None Name for the registered model. If None, the model's full name is used. If the name of the model already exists, a new model version is created. <p> stage: str, default=\"None\" New desired stage for the model. <p> archive_existing_versions: bool, default=False Whether all existing model versions in the <code>stage</code> will be moved to the \"Archived\" stage. Only valid when <code>stage</code> is \"Staging\" or \"Production\", otherwise an error will be raised. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method save_estimator(filename=\"auto\")[source] <p>Save the estimator to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. </p> <p></p> <p></p> method score(X, y=None, metric=None, sample_weight=None, verbose=None)[source] <p>Get a metric score on new data.</p> <p>New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped.</p> <p>Read more in the user guide.</p> <p>Info</p> <p>If the <code>metric</code> parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators.</p> <p>Parameters X: hashable, segment, sequence or dataframe-like Selection of rows or feature set with shape=(n_samples, n_features) to make predictions on. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>X</code> must be a selection of rows in the dataset.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput   tasks.</li> <li>If dataframe: Target columns for multioutput tasks.</li> </ul> <p> metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred) -&gt; score</code> or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs). <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code>. <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns float Metric score of X with respect to y. </p> <p></p> <p></p> method serve(method=\"predict\")[source] <p>Serve the model as rest API endpoint for inference.</p> <p>The complete pipeline is served with the model. The inference data must be supplied as json to the HTTP request, e.g. <code>requests.get(\"http://127.0.0.1:8000/\", json=X.to_json())</code>. The deployment is done on a ray cluster. The default <code>host</code> and <code>port</code> parameters deploy to localhost.</p> <p>Tip</p> <p>Use <code>import ray; ray.serve.shutdown()</code> to close the endpoint after finishing.</p> <p>Parameters method: str, default=\"predict\" Estimator's method to do inference on. </p> <p></p> <p></p> method set_threshold(threshold)[source] <p>Set the binary threshold of the estimator.</p> <p>A new classifier using the new threshold replaces the <code>estimator</code> attribute. If there is an active mlflow experiment, a new run is started using the name <code>[model_name]_threshold_X</code>. Since the estimator changed, the model is cleared. Only for binary classifiers.</p> <p>Tip</p> <p>Use the get_best_threshold method to find the optimal threshold for a specific metric.</p> <p>Parameters threshold: float Binary threshold to classify the positive class. </p> <p></p> <p></p> method transform(X=None, y=None, verbose=None)[source] <p>Transform new data through the pipeline.</p> <p>Transformers that are only applied on the training set are skipped. If only <code>X</code> or only <code>y</code> is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. If None, <code>X</code> is ignored in the transformers. <p> y: int, str, sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <ul> <li>If None: <code>y</code> is ignored.</li> <li>If int: Position of the target column in <code>X</code>.</li> <li>If str: Name of the target column in <code>X</code>.</li> <li>If sequence: Target column with shape=(n_samples,) or   sequence of column names or positions for multioutput tasks.</li> <li>If dataframe-like: Target columns for multioutput tasks.</li> </ul> <p> verbose: int or None, default=None Verbosity level for the transformers in the pipeline. If None, it uses the pipeline's verbosity. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p>"}, {"location": "api/nlp/textcleaner/", "title": "TextCleaner", "text": "class atom.nlp.TextCleaner(decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, verbose=0)[source] <p>Applies standard text cleaning to the corpus.</p> <p>Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised.</p> <p>This class can be accessed from atom through the textclean method. Read more in the user guide.</p> <p>Parameters decode: bool, default=True Whether to decode unicode characters to their ascii representations. <p> lower_case: bool, default=True Whether to convert all characters to lower case. <p> drop_email: bool, default=True Whether to drop email addresses from the text. <p> regex_email: str, default=None Regex used to search for email addresses. If None, it uses <code>r\"[\\w.-]+@[\\w-]+\\.[\\w.-]+\"</code>. <p> drop_url: bool, default=True Whether to drop URL links from the text. <p> regex_url: str, default=None Regex used to search for URLs. If None, it uses <code>r\"https?://\\S+|www\\.\\S+\"</code>. <p> drop_html: bool, default=True Whether to drop HTML tags from the text. This option is particularly useful if the data was scraped from a website. <p> regex_html: str, default=None Regex used to search for html tags. If None, it uses <code>r\"&lt;.*?&gt;\"</code>. <p> drop_emoji: bool, default=True Whether to drop emojis from the text. <p> regex_emoji: str, default=None Regex used to search for emojis. If None, it uses <code>r\":[a-z_]+:\"</code>. <p> drop_number: bool, default=True Whether to drop numbers from the text. <p> regex_number: str, default=None Regex used to search for numbers. If None, it uses <code>r\"\\b\\d+\\b\".</code> Note that numbers adjacent to letters are not removed. <p> drop_punctuation: bool, default=True Whether to drop punctuations from the text. Characters considered punctuation are <code>!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_</code>~`. <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p></p> <p></p> <p>See Also</p> <p>TextNormalizer Normalize the corpus.</p> <p>Tokenizer Tokenize the corpus.</p> <p>Vectorizer Vectorize text data.</p> <p></p>"}, {"location": "api/nlp/textcleaner/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import fetch_20newsgroups\n\n&gt;&gt;&gt; X, y = fetch_20newsgroups(\n...     return_X_y=True,\n...     categories=[\"alt.atheism\", \"sci.med\", \"comp.windows.x\"],\n...     shuffle=True,\n...     random_state=1,\n... )\n&gt;&gt;&gt; X = np.array(X).reshape(-1, 1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n                                                 corpus  target\n0     From: fabian@vivian.w.open.de (Fabian Hoppe)\\n...       1\n1     From: nyeda@cnsvax.uwec.edu (David Nye)\\nSubje...       0\n2     From: urathi@net4.ICS.UCI.EDU (Unmesh Rathi)\\n...       1\n3     From: inoue@crd.yokogawa.co.jp (Inoue Takeshi)...       1\n4     From: sandvik@newton.apple.com (Kent Sandvik)\\...       0\n...                                                 ...     ...\n1662  From: kutluk@ccl.umist.ac.uk (Kutluk Ozguven)\\...       0\n1663  From: dmp1@ukc.ac.uk (D.M.Procida)\\nSubject: R...       2\n1664  From: tdunbar@vtaix.cc.vt.edu (Thomas Dunbar)\\...       1\n1665  From: dmp@fig.citib.com (Donna M. Paino)\\nSubj...       2\n1666  From: cdm@pmafire.inel.gov (Dale Cook)\\nSubjec...       2\n\n[1667 rows x 2 columns]\n\n&gt;&gt;&gt; atom.textclean(verbose=2)\n\nFitting TextCleaner...\nCleaning the corpus...\n --&gt; Decoding unicode characters to ascii.\n --&gt; Converting text to lower case.\n --&gt; Dropping emails from documents.\n --&gt; Dropping URL links from documents.\n --&gt; Dropping HTML tags from documents.\n --&gt; Dropping emojis from documents.\n --&gt; Dropping numbers from documents.\n --&gt; Dropping punctuation from the text.\n\n&gt;&gt;&gt; print(atom.dataset)\n\n                                                 corpus  target\n0     from  fabian hoppe\\nsubject searching cadsoftw...       1\n1     from  david nye\\nsubject re after  years can w...       0\n2     from  unmesh rathi\\nsubject motif and intervie...       1\n3     from  inoue takeshi\\nsubject how to see charac...       1\n4     from  kent sandvik\\nsubject re slavery was re ...       0\n...                                                 ...     ...\n1662  from  kutluk ozguven\\nsubject re jewish settle...       0\n1663  from  dmprocida\\nsubject re homeopathy a respe...       2\n1664  from  thomas dunbar\\nsubject re x toolkits\\nsu...       1\n1665  from  donna m paino\\nsubject psoriatic arthrit...       2\n1666  from  dale cook\\nsubject re morbus meniere  is...       2\n\n[1667 rows x 2 columns]\n</code></pre> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom.nlp import TextCleaner\n&gt;&gt;&gt; from sklearn.datasets import fetch_20newsgroups\n\n&gt;&gt;&gt; X, y = fetch_20newsgroups(\n...     return_X_y=True,\n...     categories=[\"alt.atheism\", \"sci.med\", \"comp.windows.x\"],\n...     shuffle=True,\n...     random_state=1,\n... )\n&gt;&gt;&gt; X = np.array(X).reshape(-1, 1)\n\n&gt;&gt;&gt; textcleaner = TextCleaner(verbose=2)\n&gt;&gt;&gt; X = textcleaner.transform(X)\n\nCleaning the corpus...\n --&gt; Decoding unicode characters to ascii.\n --&gt; Converting text to lower case.\n --&gt; Dropping emails from documents.\n --&gt; Dropping URL links from documents.\n --&gt; Dropping HTML tags from documents.\n --&gt; Dropping emojis from documents.\n --&gt; Dropping numbers from documents.\n --&gt; Dropping punctuation from the text.\n\n&gt;&gt;&gt; print(X)\n\n                                                 corpus\n0     from  mark a deloura\\nsubject looking for x wi...\n1     from  der mouse\\nsubject re creating  bit wind...\n2     from  keith m ryan\\nsubject re where are they ...\n3     from  steven grimm\\nsubject re opinions on all...\n4     from  peter kaminski\\nsubject re krillean phot...\n...                                                 ...\n1662  from donald mackie \\nsubject re seeking advice...\n1663  from  gordon banks\\nsubject re update help was...\n1664  from  keith m ryan\\nsubject re political athei...\n1665  from  benedikt rosenau\\nsubject re biblical ra...\n1666  from derrick j brashear \\nsubject mouseless op...\n\n[1667 rows x 1 columns]\n</code></pre>"}, {"location": "api/nlp/textcleaner/#methods", "title": "Methods", "text": "<p>fitDo nothing.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformApply the transformations to the data.</p> <p></p> <p></p> method fit(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Apply the transformations to the data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a dataframe, it should be composed of a single feature containing the text documents. <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed corpus. </p> <p></p>"}, {"location": "api/nlp/textnormalizer/", "title": "TextNormalizer", "text": "class atom.nlp.TextNormalizer(stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, verbose=0)[source] <p>Normalize the corpus.</p> <p>Convert words to a more uniform standard. The transformations are applied on the column named <code>corpus</code>, in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces.</p> <p>This class can be accessed from atom through the textnormalize method. Read more in the user guide.</p> <p>Parameters stopwords: bool or str, default=True Whether to remove a predefined dictionary of stopwords. <ul> <li>If False: Don't remove any predefined stopwords.</li> <li>If True: Drop predefined english stopwords from the text.</li> <li>If str: Language from <code>nltk.corpus.stopwords.words</code>.</li> </ul> <p> custom_stopwords: sequence or None, default=None Custom stopwords to remove from the text. <p> stem: bool or str, default=False Whether to apply stemming using SnowballStemmer. <ul> <li>If False: Don't apply stemming.</li> <li>If True: Apply stemmer based on the english language.</li> <li>If str: Language from <code>SnowballStemmer.languages</code>.</li> </ul> <p> lemmatize: bool, default=True Whether to apply lemmatization using WordNetLemmatizer. <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p>Attributes feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>TextCleaner Applies standard text cleaning to the corpus.</p> <p>Tokenizer Tokenize the corpus.</p> <p>Vectorizer Vectorize text data.</p> <p></p>"}, {"location": "api/nlp/textnormalizer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n\n&gt;&gt;&gt; X = [\n...    [\"I \u00e0m in ne'w york\"],\n...    [\"New york is nice\"],\n...    [\"new york\"],\n...    [\"hi there this is a test!\"],\n...    [\"another line...\"],\n...    [\"new york is larger than washington\"],\n...    [\"running the test\"],\n...    [\"this is a test\"],\n... ]\n&gt;&gt;&gt; y = [1, 0, 0, 1, 1, 1, 0, 0]\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, test_size=2, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n                               corpus  target\n0                            new york       0\n1                     another line...       1\n2                    New york is nice       0\n3  new york is larger than washington       1\n4                    running the test       0\n5                   I \u00e0m in ne'w york       1\n6                      this is a test       0\n7            hi there this is a test!       1\n\n&gt;&gt;&gt; atom.textnormalize(stopwords=\"english\", lemmatize=True, verbose=2)\n\nFitting TextNormalizer...\nNormalizing the corpus...\n --&gt; Dropping stopwords.\n --&gt; Applying lemmatization.\n\n&gt;&gt;&gt; print(atom.dataset)\n\n                           corpus  target\n0                     [new, york]       0\n1              [another, line...]       1\n2               [New, york, nice]       0\n3  [new, york, large, washington]       1\n4                     [run, test]       0\n5             [I, \u00e0m, ne'w, york]       1\n6                          [test]       0\n7                     [hi, test!]       1\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.nlp import TextNormalizer\n\n&gt;&gt;&gt; X = [\n...    [\"I \u00e0m in ne'w york\"],\n...    [\"New york is nice\"],\n...    [\"new york\"],\n...    [\"hi there this is a test!\"],\n...    [\"another line...\"],\n...    [\"new york is larger than washington\"],\n...    [\"running the test\"],\n...    [\"this is a test\"],\n... ]\n\n&gt;&gt;&gt; textnormalizer = TextNormalizer(\n...     stopwords=\"english\",\n...     lemmatize=True,\n...     verbose=2,\n... )\n&gt;&gt;&gt; X = textnormalizer.transform(X)\n\nNormalizing the corpus...\n --&gt; Dropping stopwords.\n --&gt; Applying lemmatization.\n\n&gt;&gt;&gt; print(X)\n\n                           corpus\n0             [I, \u00e0m, ne'w, york]\n1               [New, york, nice]\n2                     [new, york]\n3                     [hi, test!]\n4              [another, line...]\n5  [new, york, large, washington]\n6                     [run, test]\n7                          [test]\n</code></pre>"}, {"location": "api/nlp/textnormalizer/#methods", "title": "Methods", "text": "<p>fitDo nothing.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformNormalize the text.</p> <p></p> <p></p> method fit(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Normalize the text.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a dataframe, it should be composed of a single feature containing the text documents. <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed corpus. </p> <p></p>"}, {"location": "api/nlp/tokenizer/", "title": "Tokenizer", "text": "class atom.nlp.Tokenizer(bigram_freq=None, trigram_freq=None, quadgram_freq=None, verbose=0)[source] <p>Tokenize the corpus.</p> <p>Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g., \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>This class can be accessed from atom through the tokenize method. Read more in the user guide.</p> <p>Parameters bigram_freq: int, float or None, default=None Frequency threshold for bigram creation. <ul> <li>If None: Don't create any bigrams.</li> <li>If int: Minimum number of occurrences to make a bigram.</li> <li>If float: Minimum frequency fraction to make a bigram.</li> </ul> <p> trigram_freq: int, float or None, default=None Frequency threshold for trigram creation. <ul> <li>If None: Don't create any trigrams.</li> <li>If int: Minimum number of occurrences to make a trigram.</li> <li>If float: Minimum frequency fraction to make a trigram.</li> </ul> <p> quadgram_freq: int, float or None, default=None Frequency threshold for quadgram creation. <ul> <li>If None: Don't create any quadgrams.</li> <li>If int: Minimum number of occurrences to make a quadgram.</li> <li>If float: Minimum frequency fraction to make a quadgram.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p>Attributes bigrams_: pd.DataFrame Created bigrams and their frequencies. <p> trigrams_: pd.DataFrame Created trigrams and their frequencies. <p> quadgrams_: pd.DataFrame Created quadgrams and their frequencies. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>TextCleaner Applies standard text cleaning to the corpus.</p> <p>TextNormalizer Normalize the corpus.</p> <p>Vectorizer Vectorize text data.</p> <p></p>"}, {"location": "api/nlp/tokenizer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n\n&gt;&gt;&gt; X = [\n...    [\"I \u00e0m in ne'w york\"],\n...    [\"New york is nice\"],\n...    [\"new york\"],\n...    [\"hi there this is a test!\"],\n...    [\"another line...\"],\n...    [\"new york is larger than washington\"],\n...    [\"running the test\"],\n...    [\"this is a test\"],\n... ]\n&gt;&gt;&gt; y = [1, 0, 0, 1, 1, 1, 0, 0]\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, test_size=2, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n                               corpus  target\n0                            new york       0\n1                     another line...       1\n2                    New york is nice       0\n3  new york is larger than washington       1\n4                    running the test       0\n5                   I \u00e0m in ne'w york       1\n6                      this is a test       0\n7            hi there this is a test!       1\n\n&gt;&gt;&gt; atom.tokenize(verbose=2)\n\nFitting Tokenizer...\nTokenizing the corpus...\n\n&gt;&gt;&gt; print(atom.dataset)\n\n                                      corpus  target\n0                                [new, york]       0\n1                       [another, line, ...]       1\n2                      [New, york, is, nice]       0\n3  [new, york, is, larger, than, washington]       1\n4                       [running, the, test]       0\n5                [I, \u00e0m, in, ne, ', w, york]       1\n6                        [this, is, a, test]       0\n7          [hi, there, this, is, a, test, !]       1\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.nlp import Tokenizer\n\n&gt;&gt;&gt; X = [\n...    [\"I \u00e0m in ne'w york\"],\n...    [\"New york is nice\"],\n...    [\"new york\"],\n...    [\"hi there this is a test!\"],\n...    [\"another line...\"],\n...    [\"new york is larger than washington\"],\n...    [\"running the test\"],\n...    [\"this is a test\"],\n... ]\n\n&gt;&gt;&gt; tokenizer = Tokenizer(bigram_freq=2, verbose=2)\n&gt;&gt;&gt; X = tokenizer.transform(X)\n\nTokenizing the corpus...\n --&gt; Creating 5 bigrams on 10 locations.\n\n&gt;&gt;&gt; print(X)\n\n                                     corpus\n0               [I, \u00e0m, in, ne, ', w, york]\n1                      [New, york_is, nice]\n2                                [new_york]\n3           [hi, there, this_is, a_test, !]\n4                      [another, line, ...]\n5  [new, york_is, larger, than, washington]\n6                      [running, the, test]\n7                         [this_is, a_test]\n</code></pre>"}, {"location": "api/nlp/tokenizer/#methods", "title": "Methods", "text": "<p>fitDo nothing.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformTokenize the text.</p> <p></p> <p></p> method fit(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <ul> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is   used as feature names in. If <code>feature_names_in_</code> is not defined,   then the following input feature names are generated:   <code>[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must   match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> <p>Returns feature_names_out : ndarray of str objects Same as input features. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Tokenize the text.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a dataframe, it should be composed of a single feature containing the text documents. <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed corpus. </p> <p></p>"}, {"location": "api/nlp/vectorizer/", "title": "Vectorizer", "text": "class atom.nlp.Vectorizer(strategy=\"bow\", return_sparse=True, device=\"cpu\", engine=None, verbose=0, **kwargs)[source] <p>Vectorize text data.</p> <p>Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix <code>corpus_</code>. If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column.</p> <p>This class can be accessed from atom through the vectorize method. Read more in the user guide.</p> <p>Parameters strategy: str, default=\"bow\" Strategy with which to vectorize the text. Choose from: <ul> <li>\"bow\": Bag of Words.</li> <li>\"tfidf\": Term Frequency - Inverse Document Frequency.</li> <li>\"hashing\": Vectorize to a matrix of token occurrences.</li> </ul> <p> return_sparse: bool, default=True Whether to return the transformation output as a dataframe of sparse arrays. Must be False when there are other columns in X (besides <code>corpus</code>) that are non-sparse. <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str or None, default=None Execution engine to use for estimators. If None, the default value is used. Choose from: <ul> <li>\"sklearn\" (default)</li> <li>\"cuml\"</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> **kwargs Additional keyword arguments for the <code>strategy</code> estimator. <p>Attributes{#vectorizer-[strategy]} [strategy]: sklearn transformer Estimator instance (lowercase strategy) used to vectorize the corpus, e.g., <code>vectorizer.tfidf</code> for the tfidf strategy. <p> feature_names_in_: np.ndarray Names of features seen during <code>fit</code>. <p> n_features_in_: int Number of features seen during <code>fit</code>. <p></p> <p></p> <p>See Also</p> <p>TextCleaner Applies standard text cleaning to the corpus.</p> <p>TextNormalizer Normalize the corpus.</p> <p>Tokenizer Tokenize the corpus.</p> <p></p>"}, {"location": "api/nlp/vectorizer/#example", "title": "Example", "text": "atomstand-alone <pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n\n&gt;&gt;&gt; X = [\n...    [\"I \u00e0m in ne'w york\"],\n...    [\"New york is nice\"],\n...    [\"new york\"],\n...    [\"hi there this is a test!\"],\n...    [\"another line...\"],\n...    [\"new york is larger than washington\"],\n...    [\"running the test\"],\n...    [\"this is a test\"],\n... ]\n&gt;&gt;&gt; y = [1, 0, 0, 1, 1, 1, 0, 0]\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, test_size=2, random_state=1)\n&gt;&gt;&gt; print(atom.dataset)\n\n                               corpus  target\n0                            new york       0\n1                     another line...       1\n2                    New york is nice       0\n3  new york is larger than washington       1\n4                    running the test       0\n5                   I \u00e0m in ne'w york       1\n6                      this is a test       0\n7            hi there this is a test!       1\n\n&gt;&gt;&gt; atom.vectorize(strategy=\"tfidf\", verbose=2)\n\nFitting Vectorizer...\nVectorizing the corpus...\n\n&gt;&gt;&gt; print(atom.dataset)\n\n   corpus_another  corpus_in  corpus_is  corpus_larger  corpus_line  corpus_ne  corpus_new  corpus_nice  corpus_running  corpus_test  corpus_than  corpus_the  corpus_washington  corpus_york  corpus_\u00e0m  target\n0               0          0          0              0            0          0    0.759339            0               0            0            0           0                  0     0.650696          0       0\n1        0.707107          0          0              0     0.707107          0           0            0               0            0            0           0                  0            0          0       1\n2               0          0   0.518242              0            0          0    0.437535     0.631991               0            0            0           0                  0     0.374934          0       0\n3               0          0   0.386401       0.471212            0          0    0.326226            0               0            0     0.471212           0           0.471212     0.279551          0       1\n4               0          0          0              0            0          0           0            0         0.57735      0.57735            0     0.57735                  0            0          0       0\n5               0   0.546199          0              0            0   0.546199           0            0               0            0            0           0                  0     0.324037   0.546199       1\n6               0          0   0.634086              0            0          0           0            0               0     0.773262            0           0                  0            0          0       0\n7               0          0   0.634086              0            0          0           0            0               0     0.773262            0           0                  0            0          0       1\n</code></pre> <pre><code>&gt;&gt;&gt; from atom.nlp import Vectorizer\n\n&gt;&gt;&gt; X = [\n...    [\"I \u00e0m in ne'w york\"],\n...    [\"New york is nice\"],\n...    [\"new york\"],\n...    [\"hi there this is a test!\"],\n...    [\"another line...\"],\n...    [\"new york is larger than washington\"],\n...    [\"running the test\"],\n...    [\"this is a test\"],\n... ]\n\n&gt;&gt;&gt; vectorizer = Vectorizer(strategy=\"tfidf\", verbose=2)\n&gt;&gt;&gt; X = vectorizer.fit_transform(X)\n\nFitting Vectorizer...\nVectorizing the corpus...\n\n&gt;&gt;&gt; print(X)\n\n   corpus_another  corpus_hi  corpus_in  corpus_is  corpus_larger  corpus_line  corpus_ne  corpus_new  corpus_nice  corpus_running  corpus_test  corpus_than  corpus_the  corpus_there  corpus_this  corpus_washington  corpus_york  corpus_\u00e0m\n0               0          0   0.542162          0              0            0   0.542162           0            0               0            0            0           0             0            0                  0     0.343774   0.542162\n1               0          0          0   0.415657              0            0          0    0.474072     0.655527               0            0            0           0             0            0                  0     0.415657          0\n2               0          0          0          0              0            0          0    0.751913            0               0            0            0           0             0            0                  0     0.659262          0\n3               0   0.525049          0   0.332923              0            0          0           0            0               0     0.379712            0           0      0.525049     0.440032                  0            0          0\n4        0.707107          0          0          0              0     0.707107          0           0            0               0            0            0           0             0            0                  0            0          0\n5               0          0          0   0.304821       0.480729            0          0     0.34766            0               0            0     0.480729           0             0            0           0.480729     0.304821          0\n6               0          0          0          0              0            0          0           0            0        0.629565     0.455297            0    0.629565             0            0                  0            0          0\n7               0          0          0   0.497041              0            0          0           0            0               0     0.566893            0           0             0     0.656949                  0            0          0\n</code></pre>"}, {"location": "api/nlp/vectorizer/#methods", "title": "Methods", "text": "<p>fitFit to data.fit_transformFit to data, then transform it.get_feature_names_outGet output feature names for transformation.get_paramsGet parameters for this estimator.inverse_transformDo nothing.set_outputSet output container.set_paramsSet the parameters of this estimator.transformVectorize the text.</p> <p></p> <p></p> method fit(X, y=None)[source] <p>Fit to data.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a dataframe, it should be composed of a single feature containing the text documents. <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns Self Estimator instance. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **fit_params)[source] <p>Fit to data, then transform it.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p> **fit_params Additional keyword arguments for the fit method. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features: sequence or None, default=None Only used to validate feature names with the names seen in <code>fit</code>. <p>Returns np.ndarray Transformed feature names. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, **fit_params)[source] <p>Do nothing.</p> <p>Returns the input unchanged. Implemented for continuity of the API.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. If None, <code>y</code> is ignored. <p>Returns dataframe Feature set. Only returned if provided. <p> series or dataframe Target column(s). Only returned if provided. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method transform(X, y=None)[source] <p>Vectorize the text.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a dataframe, it should be composed of a single feature containing the text documents. <p> y: sequence, dataframe-like or None, default=None Do nothing. Implemented for continuity of the API. <p>Returns dataframe Transformed corpus. </p> <p></p>"}, {"location": "api/pipeline/pipeline/", "title": "Pipeline", "text": "class atom.pipeline.Pipeline(steps, memory=None, verbose=0)[source] <p>Pipeline of transforms with a final estimator.</p> <p>Sequentially apply a list of transforms and a final estimator. Intermediate steps of the pipeline must be transformsers, that is, they must implement <code>fit</code> and <code>transform</code> methods. The final estimator only needs to implement <code>fit</code>. The transformers in the pipeline can be cached using the <code>memory</code> parameter.</p> <p>A step's estimator may be replaced entirely by setting the parameter with its name to another estimator, or a transformer removed by setting it to <code>passthrough</code> or <code>None</code>.</p> <p>Read more in sklearn's the user guide.</p> <p>Info</p> <p>This class behaves similarly to sklearn's pipeline, and additionally:</p> <ul> <li>Can initialize with an empty pipeline.</li> <li>Always returns 'pandas' objects.</li> <li>Accepts transformers that drop rows.</li> <li>Accepts transformers that only are fitted on a subset of the   provided dataset.</li> <li>Accepts transformers that apply only on the target column.</li> <li>Uses transformers that are only applied on the training set   to fit the pipeline, not to make predictions on new data.</li> <li>The instance is considered fitted at initialization if all   the underlying transformers/estimator in the pipeline are.</li> <li>It returns attributes from the final estimator if they are   not of the Pipeline.</li> <li>The last estimator is also cached.</li> <li>Supports time series models following sktime's API.</li> </ul> <p>Warning</p> <p>This Pipeline only works with estimators whose parameters for fit, transform, predict, etc... are named <code>X</code> and/or <code>y</code>.</p> <p>Parameters steps: list of tuple List of (name, transform) tuples (implementing <code>fit</code>/<code>transform</code>) that are chained in sequential order. <p> memory: str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. Enabling caching triggers a clone of the transformers before fitting. Therefore, the transformer instance given to the pipeline cannot be inspected directly. Use the attribute <code>named_steps</code> or <code>steps</code> to inspect estimators within the pipeline. Caching the transformers is advantageous when fitting is time-consuming. <p> verbose: int or None, default=0 Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. If &gt;0, the time elapsed while fitting each step is printed. Note this is not the same as sklearn's <code>verbose</code> parameter. Use the pipeline's verbose attribute to modify that one (defaults to False). <p>Attributes named_steps: Bunch Dictionary-like object, with the following attributes. Read-only attribute to access any step parameter by user given name. Keys are step names and values are steps parameters. <p> classes_: np.ndarray of shape (n_classes,) The class' labels. Only exist if the last step of the pipeline is a classifier. <p> feature_names_in_: np.ndarray Names of features seen during first step <code>fit</code> method. <p> n_features_in_: int Number of features seen during first step <code>fit</code> method. <p></p> <p></p>"}, {"location": "api/pipeline/pipeline/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Initialize atom\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, verbose=2)\n\n&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 138.97 kB\nScaled: False\nOutlier values: 172 (1.2%)\n\n\n&gt;&gt;&gt; # Apply data cleaning and feature engineering methods\n&gt;&gt;&gt; atom.scale()\n\nFitting Scaler...\nScaling features...\n&gt;&gt;&gt; atom.balance(strategy=\"smote\")\n\nOversampling with SMOTE...\n --&gt; Adding 116 samples to class 0.\n&gt;&gt;&gt; atom.feature_selection(strategy=\"rfe\", solver=\"lr\", n_features=22)\n\nFitting FeatureSelector...\nPerforming feature selection ...\n --&gt; rfe selected 22 features from the dataset.\n   --&gt; Dropping feature mean smoothness (rank 9).\n   --&gt; Dropping feature mean symmetry (rank 7).\n   --&gt; Dropping feature texture error (rank 5).\n   --&gt; Dropping feature smoothness error (rank 4).\n   --&gt; Dropping feature concavity error (rank 3).\n   --&gt; Dropping feature concave points error (rank 2).\n   --&gt; Dropping feature symmetry error (rank 8).\n   --&gt; Dropping feature worst compactness (rank 6).\n\n&gt;&gt;&gt; # Train models\n&gt;&gt;&gt; atom.run(models=\"LR\")\n\n\nTraining ========================= &gt;&gt;\nModels: LR\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9861\nTest evaluation --&gt; f1: 0.9793\nTime elapsed: 0.030s\n-------------------------------------------------\nTime: 0.030s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.033s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9793\n\n&gt;&gt;&gt; # Get the pipeline object\n&gt;&gt;&gt; pipeline = atom.lr.export_pipeline()\n&gt;&gt;&gt; print(pipeline)\n\nPipeline(memory=Memory(location=None),\n         steps=[('scaler',\n                 Scaler(engine={'data': 'pandas', 'estimator': 'sklearn'}, verbose=2)),\n                ('balancer', Balancer(strategy='smote', verbose=2)),\n                ('featureselector',\n                 FeatureSelector(engine={'data': 'pandas', 'estimator': 'sklearn'}, n_features=22, solver='lr_class', strategy='rfe', verbose=2)),\n                ('LogisticRegression', LogisticRegression(n_jobs=1))],\n         verbose=False)\n</code></pre>"}, {"location": "api/pipeline/pipeline/#methods", "title": "Methods", "text": "<p>decision_functionTransform, then decision_function of the final estimator.fitFit the pipeline.fit_transformFit the pipeline and transform the data.get_feature_names_outGet output feature names for transformation.get_metadata_routingGet metadata routing of this object.get_paramsGet parameters for this estimator.inverse_transformInverse transform for each step in a reverse order.predictTransform, then predict of the final estimator.predict_intervalTransform, then predict_quantiles of the final estimator.predict_log_probaTransform, then predict_log_proba of the final estimator.predict_probaTransform, then predict_proba of the final estimator.predict_quantilesTransform, then predict_quantiles of the final estimator.predict_residualsTransform, then predict_residuals of the final estimator.predict_varTransform, then predict_var of the final estimator.scoreTransform, then score of the final estimator.set_inverse_transform_requestRequest metadata passed to the <code>inverse_transform</code> method.set_outputSet output container.set_paramsSet the parameters of this estimator.set_predict_proba_requestRequest metadata passed to the <code>predict_proba</code> method.set_predict_requestRequest metadata passed to the <code>predict</code> method.set_score_requestRequest metadata passed to the <code>score</code> method.set_transform_requestRequest metadata passed to the <code>transform</code> method.transformTransform the data.</p> <p></p> <p></p> method decision_function(X, **params)[source] <p>Transform, then decision_function of the final estimator.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns np.ndarray Predicted confidence scores with shape=(n_samples,) for binary classification tasks (log likelihood ratio of the positive class) or shape=(n_samples, n_classes) for multiclass classification tasks. </p> <p></p> <p></p> method fit(X=None, y=None, **params)[source] <p>Fit the pipeline.</p> <p>Fit all the transformers one after the other and sequentially transform the data. Finally, fit the transformed data using the final estimator.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns self Pipeline with fitted steps. </p> <p></p> <p></p> method fit_transform(X=None, y=None, **params)[source] <p>Fit the pipeline and transform the data.</p> <p>Call <code>fit</code> followed by <code>transform</code> on each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls the <code>transform</code> method. Only valid if the final estimator implements <code>transform</code>. This also works when the final estimator is <code>None</code>, in which case all prior transformations are applied.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. None if the estimator only uses y. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method get_feature_names_out(input_features=None)[source] <p>Get output feature names for transformation.</p> <p>Parameters input_features : array-like of str or None, default=None Input features. <p>Returns feature_names_out : ndarray of str objects Transformed feature names. </p> <p></p> <p></p> method get_metadata_routing()[source] <p>Get metadata routing of this object.</p> <p>Check sklearn's documentation on how the routing mechanism works.</p> <p>Returns MetadataRouter A MetadataRouter encapsulating routing information. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : mapping of string to any Parameter names mapped to their values. </p> <p></p> <p></p> method inverse_transform(X=None, y=None, filter_train_only=True, **params)[source] <p>Inverse transform for each step in a reverse order.</p> <p>All estimators in the pipeline must implement the <code>inverse_transform</code> method.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. None if the pipeline only uses y. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p> filter_train_only: bool, default=True Whether to exclude transformers that should only be used on the training set. <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p> <p></p> method predict(X=None, fh=None, **params)[source] <p>Transform, then predict of the final estimator.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). Can only be <code>None</code> for forecast tasks. <p> fh: int, sequence or ForecastingHorizon or None, default=None The forecasting horizon encoding the time stamps to forecast at. Only for forecast tasks. <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. Note that while this may be used to return uncertainties from some models with <code>return_std</code> or <code>return_cov</code>, uncertainties that are generated by the transformations in the pipeline are not propagated to the final estimator. <p>Returns np.ndarray, series or dataframe Predictions with shape=(n_samples,) or shape=(n_samples, n_targets) for multioutput tasks. </p> <p></p> <p></p> method predict_interval(fh, X=None, coverage=0.9)[source] <p>Transform, then predict_quantiles of the final estimator.</p> <p>Parameters fh: int, sequence or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> coverage: float or sequence, default=0.9 Nominal coverage(s) of predictive interval(s). <p>Returns dataframe Computed interval forecasts. </p> <p></p> <p></p> method predict_log_proba(X, **params)[source] <p>Transform, then predict_log_proba of the final estimator.</p> <p>Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns list or np.ndarray Predicted class log-probabilities with shape=(n_samples, n_classes) or a list of arrays for multioutput tasks. </p> <p></p> <p></p> method predict_proba(X=None, fh=None, marginal=True, **params)[source] <p>Transform, then predict_proba of the final estimator.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). Can only be <code>None</code> for forecast tasks. <p> fh: int, sequence, ForecastingHorizon or None, default=None The forecasting horizon encoding the time stamps to forecast at. Only for forecast tasks. <p> marginal: bool, default=True Whether returned distribution is marginal by time index. Only for forecast tasks. <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns{#predict_proba-list, np.ndarray or sktime.proba.Normal} list, np.ndarray or sktime.proba.Normal <ul> <li>For classification tasks: Predicted class probabilities   with shape=(n_samples, n_classes).</li> <li>For multioutput tasks: A list of arrays with   shape=(n_samples, n_classes).</li> <li>For forecast tasks: Distribution object. </li> </ul> <p></p> <p></p> method predict_quantiles(fh, X=None, alpha=(0.05, 0.95))[source] <p>Transform, then predict_quantiles of the final estimator.</p> <p>Parameters fh: int, sequence or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> alpha: float or sequence, default=(0.05, 0.95) A probability or list of, at which quantile forecasts are computed. <p>Returns dataframe Computed quantile forecasts. </p> <p></p> <p></p> method predict_residuals(y, X=None)[source] <p>Transform, then predict_residuals of the final estimator.</p> <p>Parameters y: sequence or dataframe Ground truth observations. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>y</code>. <p>Returns series or dataframe Residuals with shape=(n_samples,) or shape=(n_samples, n_targets) for multivariate tasks. </p> <p></p> <p></p> method predict_var(fh, X=None, cov=False)[source] <p>Transform, then predict_var of the final estimator.</p> <p>Parameters fh: int, sequence or ForecastingHorizon The forecasting horizon encoding the time stamps to forecast at. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. <p> cov: bool, default=False Whether to compute covariance matrix forecast or marginal variance forecasts. <p>Returns dataframe Computed variance forecasts. </p> <p></p> <p></p> method score(X=None, y=None, fh=None, sample_weight=None, **params)[source] <p>Transform, then score of the final estimator.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). Can only be <code>None</code> for forecast tasks. <p> y: sequence, dataframe-like or None, default=None Target values corresponding to <code>X</code>. <p> fh: int, sequence, ForecastingHorizon or None, default=None The forecasting horizon encoding the time stamps to score. <p> sample_weight: sequence or None, default=None Sample weights corresponding to <code>y</code> passed to the <code>score</code> method of the final estimator. If None, no sampling weight is performed. Only for non-forecast tasks. <p>Returns float Mean accuracy, r2 or mape of self.predict(X) with respect to <code>y</code> (depending on the task). </p> <p></p> <p></p> method set_inverse_transform_request(filter_train_only=\"$UNCHANGED$\")[source] <p>Request metadata passed to the <code>inverse_transform</code> method.</p> <p>Parameters filter_train_only : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>filter_train_only</code> parameter in <code>inverse_transform</code>. <p>Returns self : object The updated object. </p> <p></p> <p></p> method set_output(transform=None)[source] <p>Set output container.</p> <p>See sklearn's user guide on how to use the <code>set_output</code> API. See here a description of the choices.</p> <p>Parameters transform: str or None, default=None Configure the output of the <code>transform</code>, <code>fit_transform</code>, and <code>inverse_transform</code> method. If None, the configuration is not changed. Choose from: <ul> <li>\"numpy\"</li> <li>\"pandas\" (default)</li> <li>\"pandas-pyarrow\"</li> <li>\"polars\"</li> <li>\"polars-lazy\"</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> <li>\"dask\"</li> <li>\"pyspark\"</li> <li>\"pyspark-pandas\"</li> </ul> <p>Returns Self Estimator instance. </p> <p></p> <p></p> method set_params(**kwargs)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **kwargs : dict Parameters of this estimator or parameters of estimators contained in <code>steps</code>. Parameters of the steps may be set using its name and the parameter name separated by a '__'. <p>Returns self : object Pipeline class instance. </p> <p></p> <p></p> method set_predict_proba_request(fh=\"$UNCHANGED$\", marginal=\"$UNCHANGED$\")[source] <p>Request metadata passed to the <code>predict_proba</code> method.</p> <p>Parameters fh : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>fh</code> parameter in <code>predict_proba</code>. <p> marginal : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>marginal</code> parameter in <code>predict_proba</code>. <p>Returns self : object The updated object. </p> <p></p> <p></p> method set_predict_request(fh=\"$UNCHANGED$\")[source] <p>Request metadata passed to the <code>predict</code> method.</p> <p>Parameters fh : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>fh</code> parameter in <code>predict</code>. <p>Returns self : object The updated object. </p> <p></p> <p></p> method set_score_request(fh=\"$UNCHANGED$\", sample_weight=\"$UNCHANGED$\")[source] <p>Request metadata passed to the <code>score</code> method.</p> <p>Parameters fh : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>fh</code> parameter in <code>score</code>. <p> sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>sample_weight</code> parameter in <code>score</code>. <p>Returns self : object The updated object. </p> <p></p> <p></p> method set_transform_request(filter_train_only=\"$UNCHANGED$\")[source] <p>Request metadata passed to the <code>transform</code> method.</p> <p>Parameters filter_train_only : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED Metadata routing for <code>filter_train_only</code> parameter in <code>transform</code>. <p>Returns self : object The updated object. </p> <p></p> <p></p> method transform(X=None, y=None, filter_train_only=True, **params)[source] <p>Transform the data.</p> <p>Call <code>transform</code> on each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls the <code>transform</code> method. Only valid if the final estimator implements <code>transform</code>. This also works when the final estimator is <code>None</code>, in which case all prior transformations are applied.</p> <p>Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, <code>X</code> is ignored. None if the pipeline only uses y. <p> y: sequence, dataframe-like or None, default=None Target column(s) corresponding to <code>X</code>. <p> filter_train_only: bool, default=True Whether to exclude transformers that should only be used on the training set. <p> **params Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them. <p>Returns dataframe Transformed feature set. Only returned if provided. <p> series or dataframe Transformed target column. Only returned if provided. </p> <p></p>"}, {"location": "api/plots/plot_acf/", "title": "plot_acf", "text": "method plot_acf(columns=None, nlags=None, plot_interval=True, title=None, legend=\"upper right\", figsize=None, filename=None, display=True)[source] <p>Plot the autocorrelation function.</p> <p>The autocorrelation function (ACF) measures the correlation between a time series and lagged versions of itself. ACF can help to identify the order of the moving average (MA) process in a time series model. This plot is only available for forecast tasks.</p> <p>Parameters columns: int, str, segment, sequence, dataframe or None, default=None Columns to plot the acf from. If None, it selects the target column. <p> nlags: int or None, default=None Number of lags to return autocorrelation for. If None, it uses <code>min(10 * np.log10(len(y)), len(y) // 2 - 1)</code>. The returned value includes lag 0 (i.e., 1), so the size of the vector is <code>(nlags + 1,)</code>. <p> plot_interval: bool, default=True Whether to plot the 95% confidence interval. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of lags shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_acf-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_series Plot a data series.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_pacf Plot the partial autocorrelation function.</p> <p></p>"}, {"location": "api/plots/plot_acf/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.plot_acf()\n</code></pre>"}, {"location": "api/plots/plot_bootstrap/", "title": "plot_bootstrap", "text": "method plot_bootstrap(models=None, metric=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True)[source] <p>Plot the bootstrapping scores.</p> <p>If all models applied bootstrap, it shows a boxplot of the results. If only some models applied bootstrap, the plot is a barplot, where the standard deviation of the bootstrapped results is shown as a black line on top of the bar. Models are ordered based on their score from the top down.</p> <p>Tip</p> <p>Use the plot_results method to compare the model's scores on any metric.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> metric: int, str, sequence or None, default=None Metric to plot. Use a sequence or add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of models. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_bootstrap-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_learning_curve Plot the learning curve: score vs number of training samples.</p> <p>plot_results Compare metric results of the models.</p> <p>plot_threshold Plot metric performances against threshold values.</p> <p></p>"}, {"location": "api/plots/plot_bootstrap/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"GNB\", \"LR\"], metric=[\"f1\", \"recall\"], n_bootstrap=5)\n&gt;&gt;&gt; atom.plot_bootstrap()\n</code></pre> <pre><code>&gt;&gt;&gt; # Add another model without bootstrap\n&gt;&gt;&gt; atom.run(\"LDA\")\n&gt;&gt;&gt; atom.plot_bootstrap()\n</code></pre>"}, {"location": "api/plots/plot_calibration/", "title": "plot_calibration", "text": "method plot_calibration(models=None, rows=\"test\", n_bins=10, target=0, title=None, legend=\"upper left\", figsize=(900, 900), filename=None, display=True)[source] <p>Plot the calibration curve for a binary classifier.</p> <p>Well-calibrated classifiers are probabilistic classifiers for which the output of the <code>predict_proba</code> method can be directly interpreted as a confidence level. For instance, a calibrated (binary) classifier should classify the samples such that among the samples to which it gave a <code>predict_proba</code> value close to 0.8, approx. 80% actually belong to the positive class. Read more in sklearn's documentation.</p> <p>This figure shows two plots: the calibration curve, where the x-axis represents the average predicted probability in each bin and the y-axis is the fraction of positives, i.e., the proportion of samples whose class is the positive class (in each bin); and a distribution of all predicted probabilities of the classifier. This plot is available only for models with a <code>predict_proba</code> method in a binary or multilabel classification task.</p> <p>Tip</p> <p>Use the calibrate method to calibrate the winning model.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> n_bins: int, default=10 Number of bins used for calibration. Minimum of 5 required. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_calibration-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_lift Plot the lift curve.</p> <p>plot_prc Plot the precision-recall curve.</p> <p>plot_roc Plot the Receiver Operating Characteristics curve.</p> <p></p>"}, {"location": "api/plots/plot_calibration/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"RF\", \"LGB\"])\n&gt;&gt;&gt; atom.plot_calibration()\n</code></pre>"}, {"location": "api/plots/plot_ccf/", "title": "plot_ccf", "text": "method plot_ccf(columns=0, target=0, nlags=None, plot_interval=False, title=None, legend=\"upper right\", figsize=None, filename=None, display=True)[source] <p>Plot the cross-correlation between two time series.</p> <p>The Cross-Correlation Function (CCF) plot measures the similarity between features and the target column as a function of the displacement of one series relative to the other. It's similar to the acf plot, where the correlation is plotted against lagged versions of itself. The transparent band represents the 95% confidence interval. This plot is only available for forecast tasks.</p> <p>Parameters columns: int, str, segment, sequence or dataframe, default=0 Columns to plot the periodogram from. If None, it selects all numerical features. <p> target: int or str, default=0 Target column against which to calculate the correlations. Only for multivariate tasks. <p> nlags: int or None, default=None Number of lags to return autocorrelation for. If None, it uses <code>min(10 * np.log10(len(y)), len(y) // 2 - 1)</code>. The returned value includes lag 0 (i.e., 1), so the size of the vector is <code>(nlags + 1,)</code>. <p> plot_interval: bool, default=False Whether to plot the 95% confidence interval. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of lags shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_ccf-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_series Plot a data series.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_periodogram Plot the spectral density of a time series.</p> <p></p>"}, {"location": "api/plots/plot_ccf/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_macroeconomic\n\n&gt;&gt;&gt; X = load_macroeconomic()\n\n&gt;&gt;&gt; atom = ATOMForecaster(X, random_state=1)\n&gt;&gt;&gt; atom.plot_ccf()\n</code></pre>"}, {"location": "api/plots/plot_components/", "title": "plot_components", "text": "method plot_components(show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True)[source] <p>Plot the explained variance ratio per component.</p> <p>Kept components are colored and discarded components are transparent. This plot is available only when feature selection was applied with strategy=\"pca\".</p> <p>Parameters show: int or None, default=None Number of components to show. None to show all. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of components shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_components-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_pca Plot the explained variance ratio vs number of components.</p> <p>plot_rfecv Plot the rfecv results.</p> <p></p>"}, {"location": "api/plots/plot_components/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.feature_selection(\"pca\", n_features=5)\n&gt;&gt;&gt; atom.plot_components(show=10)\n</code></pre>"}, {"location": "api/plots/plot_confusion_matrix/", "title": "plot_confusion_matrix", "text": "method plot_confusion_matrix(models=None, rows=\"test\", target=0, threshold=0.5, title=None, legend=\"upper right\", figsize=None, filename=None, display=True)[source] <p>Plot a model's confusion matrix.</p> <p>For one model, the plot shows a heatmap. For multiple models, it compares TP, FP, FN and TN in a barplot (not implemented for multiclass classification tasks). This plot is available only for classification tasks.</p> <p>Tip</p> <p>Fill the <code>threshold</code> parameter with the result from the model's <code>get_best_threshold</code> method to optimize the results.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: hashable, segment or sequence, default=\"test\" Selection of rows on which to calculate the confusion matrix. <p> target: int or str, default=0 Target column to look at. Only for multioutput tasks. <p> threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only for binary classification tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the plot's type. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_confusion_matrix-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_calibration Plot the calibration curve for a binary classifier.</p> <p>plot_threshold Plot metric performances against threshold values.</p> <p></p>"}, {"location": "api/plots/plot_confusion_matrix/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=100, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, test_size=0.4)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.lr.plot_confusion_matrix()  # For one model\n</code></pre> <pre><code>&gt;&gt;&gt; atom.plot_confusion_matrix()  # For multiple models\n</code></pre>"}, {"location": "api/plots/plot_correlation/", "title": "plot_correlation", "text": "method plot_correlation(columns=None, method=\"pearson\", title=None, legend=None, figsize=(800, 700), filename=None, display=True)[source] <p>Plot a correlation matrix.</p> <p>Displays a heatmap showing the correlation between columns in the dataset. The colors red, blue and white stand for positive, negative, and no correlation respectively.</p> <p>Parameters columns: segment, sequence, dataframe or None, default=None Columns to plot. If None, plot all columns in the dataset. Selected categorical columns are ignored. <p> method: str, default=\"pearson\" Method of correlation. Choose from: pearson, kendall or spearman. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple, default=(800, 700) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_correlation-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_distribution Plot column distributions.</p> <p>plot_qq Plot a quantile-quantile plot.</p> <p>plot_relationships Plot pairwise relationships in a dataset.</p> <p></p>"}, {"location": "api/plots/plot_correlation/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.plot_correlation()\n</code></pre>"}, {"location": "api/plots/plot_cv_splits/", "title": "plot_cv_splits", "text": "method plot_cv_splits(models=None, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Visualize the cross-validation splits.</p> <p>Plots the train and test splits for each cross-validation iteration of the <code>cv</code> object. The x-axis shows the number of rows, where every point corresponds to the n-th sample. The top bar shows the original train/test split. Additionally, class labels and groups are plotted when relevant.</p> <p>Warning</p> <p>This plot is only available for models that ran cross-validation using the cross_validate method.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_cv_splits()</code>. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_cv_splits-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_data_splits Visualize the data splits.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_relationships Plot pairwise relationships in a dataset.</p> <p></p>"}, {"location": "api/plots/plot_cv_splits/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier, ATOMForecaster\n&gt;&gt;&gt; from random import choices\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Without groups\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, shuffle=False, n_rows=0.2, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\", metric=[\"f1\", \"auc\"])\n&gt;&gt;&gt; atom.lr.cross_validate(cv=4)\n</code></pre> train_f1 test_f1 train_auc test_auc time 0 0.983051 0.962963 1.000000 1.000000 0.021019 1 0.991150 0.937500 1.000000 0.994872 0.021019 2 0.980000 0.976744 1.000000 1.000000 0.021019 3 0.990099 0.976744 0.999429 0.993197 0.022020 mean 0.986075 0.963488 0.999857 0.997017 0.021270 <pre><code>&gt;&gt;&gt; atom.plot_cv_splits()\n</code></pre> <pre><code>&gt;&gt;&gt; # With groups\n&gt;&gt;&gt; groups = choices([\"A\", \"B\", \"C\", \"D\"], k=X.shape[0])\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, metadata={\"groups\": groups}, n_rows=0.2, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\", metric=[\"f1\", \"auc\"])\n&gt;&gt;&gt; atom.lr.cross_validate(cv=4)\n</code></pre> train_f1 test_f1 train_auc test_auc time 0 1.000000 0.947368 1.000000 0.981481 0.022021 1 0.990476 0.972973 1.000000 1.000000 0.021019 2 0.981481 0.941176 1.000000 1.000000 0.021019 3 0.982143 0.937500 0.999449 0.993056 0.021019 mean 0.988525 0.949754 0.999862 0.993634 0.021270 <pre><code>&gt;&gt;&gt; atom.plot_cv_splits()\n</code></pre> <pre><code>&gt;&gt;&gt; # For forecast models\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(\"Croston\", metric=[\"mape\", \"mse\", \"mae\"])\n&gt;&gt;&gt; atom.croston.cross_validate(cv=4)\n</code></pre> test_mape test_mse test_mae time 0 0.263562 4248.686875 57.152766 0.001885 1 0.170446 3539.682857 47.622303 0.001879 2 0.218499 10212.231474 85.077206 0.001953 3 0.144202 8875.839953 69.594088 0.001915 mean 0.199177 6719.110290 64.861591 0.001908 <pre><code>&gt;&gt;&gt; atom.plot_cv_splits()\n</code></pre>"}, {"location": "api/plots/plot_data_splits/", "title": "plot_data_splits", "text": "method plot_data_splits(title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Visualize the data splits.</p> <p>Plots the train/test/holdout splits. The x-axis shows the number of rows, where every point corresponds to the n-th sample.  Additionally, class labels and groups are plotted when relevant.</p> <p>Parameters title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_data_splits-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_cv_splits Visualize the cross-validation splits.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_relationships Plot pairwise relationships in a dataset.</p> <p></p>"}, {"location": "api/plots/plot_data_splits/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier, ATOMForecaster\n&gt;&gt;&gt; from random import choices\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; groups = choices([\"A\", \"B\", \"C\", \"D\"], k=X.shape[0])\n\n&gt;&gt;&gt; atom = ATOMClassifier(\n...     X,\n...     y=y,\n...     metadata={\"groups\": groups},\n...     n_rows=0.2,\n...     holdout_size=0.1,\n...     random_state=1,\n... )\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_data_splits()\n</code></pre>"}, {"location": "api/plots/plot_decomposition/", "title": "plot_decomposition", "text": "method plot_decomposition(columns=None, title=None, legend=\"upper left\", figsize=(900, 900), filename=None, display=True)[source] <p>Plot the trend, seasonality and residuals of a time series.</p> <p>This plot is only available for forecast tasks.</p> <p>Tip</p> <p>Use atom's decompose method to remove trend and seasonality from the data.</p> <p>Parameters columns: int, str, segment, sequence, dataframe or None, default=None Selection of columns to plot. If None, the target column is selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_decomposition-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_acf Plot the autocorrelation function.</p> <p>plot_pacf Plot the partial autocorrelation function.</p> <p>plot_series Plot a data series.</p> <p></p>"}, {"location": "api/plots/plot_decomposition/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.plot_decomposition()\n</code></pre>"}, {"location": "api/plots/plot_det/", "title": "plot_det", "text": "method plot_det(models=None, rows=\"test\", target=0, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the Detection Error Tradeoff curve.</p> <p>Read more about DET in sklearn's documentation. Only available for binary classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_det-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_gains Plot the cumulative gains curve.</p> <p>plot_roc Plot the Receiver Operating Characteristics curve.</p> <p>plot_prc Plot the precision-recall curve.</p> <p></p>"}, {"location": "api/plots/plot_det/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_det()\n</code></pre>"}, {"location": "api/plots/plot_distribution/", "title": "plot_distribution", "text": "method plot_distribution(columns=0, distributions=\"kde\", show=None, title=None, legend=\"upper right\", figsize=None, filename=None, display=True)[source] <p>Plot column distributions.</p> <ul> <li>For numerical columns, plot the probability density   distribution. Additionally, it's possible to plot any of   <code>scipy.stats</code> distributions fitted to the column.</li> <li>For categorical columns, plot the class distribution.   Only one categorical column can be plotted at the same time.</li> </ul> <p>Tip</p> <p>Use atom's distributions method to check which distribution fits the column best.</p> <p>Parameters columns: int, str, slice or sequence, default=0 Columns to plot. It's only possible to plot one categorical column. If more than one categorical column is selected, all categorical columns are ignored. <p> distributions: str, sequence or None, default=\"kde\" Distributions to fit. Only for numerical columns. <ul> <li>If None: No distribution is fit.</li> <li>If \"kde\": Fit a Gaussian kde distribution.</li> <li>Else: Name of a <code>scipy.stats</code> distribution.</li> </ul> <p> show: int or None, default=None Number of classes (ordered by number of occurrences) to show in the plot. If None, it shows all classes. Only for categorical columns. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None: No title is shown.</li> <li>If str: Text for the title.</li> <li>If dict: title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the plot's type. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_distribution-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_correlation Plot a correlation matrix.</p> <p>plot_qq Plot a quantile-quantile plot.</p> <p>plot_relationships Plot pairwise relationships in a dataset.</p> <p></p>"}, {"location": "api/plots/plot_distribution/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; # Add a categorical feature\n&gt;&gt;&gt; animals = [\"cat\", \"dog\", \"bird\", \"lion\", \"zebra\"]\n&gt;&gt;&gt; probabilities = [0.001, 0.1, 0.2, 0.3, 0.399]\n&gt;&gt;&gt; X[\"animals\"] = np.random.choice(animals, size=len(X), p=probabilities)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.plot_distribution(columns=[0, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; atom.plot_distribution(columns=0, distributions=[\"norm\", \"invgauss\"])\n</code></pre> <pre><code>&gt;&gt;&gt; atom.plot_distribution(columns=\"animals\")\n</code></pre>"}, {"location": "api/plots/plot_edf/", "title": "plot_edf", "text": "method plot_edf(models=None, metric=None, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the Empirical Distribution Function of a study.</p> <p>Use this plot to analyze and improve hyperparameter search spaces. The EDF assumes that the value of the objective function is in accordance with the uniform distribution over the objective space. This plot is only available for models that ran hyperparameter tuning.</p> <p>Note</p> <p>Only complete trials are considered when plotting the EDF.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. <p> metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). If str, add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_edf-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_hyperparameters Plot hyperparameter relationships in a study.</p> <p>plot_trials Plot the hyperparameter tuning trials.</p> <p></p>"}, {"location": "api/plots/plot_edf/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from optuna.distributions import IntDistribution\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n\n&gt;&gt;&gt; # Run three models with different search spaces\n&gt;&gt;&gt; atom.run(\n...     models=\"RF_1\",\n...     n_trials=20,\n...     ht_params={\"distributions\": {\"n_estimators\": IntDistribution(6, 10)}},\n... )\n&gt;&gt;&gt; atom.run(\n...     models=\"RF_2\",\n...     n_trials=20,\n...     ht_params={\"distributions\": {\"n_estimators\": IntDistribution(11, 15)}},\n... )\n&gt;&gt;&gt; atom.run(\n...     models=\"RF_3\",\n...     n_trials=20,\n...     ht_params={\"distributions\": {\"n_estimators\": IntDistribution(16, 20)}},\n... )\n\n&gt;&gt;&gt; atom.plot_edf()\n</code></pre>"}, {"location": "api/plots/plot_errors/", "title": "plot_errors", "text": "method plot_errors(models=None, rows=\"test\", target=0, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot a model's prediction errors.</p> <p>Plot the actual targets from a set against the predicted values generated by the regressor. A linear fit is made on the data. This plot can be useful to detect noise or heteroscedasticity along a range of the target domain. This plot is unavailable for classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multioutput tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_errors-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_residuals Plot a model's residuals.</p> <p></p>"}, {"location": "api/plots/plot_errors/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import load_diabetes\n\n&gt;&gt;&gt; X, y = load_diabetes(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y)\n&gt;&gt;&gt; atom.run([\"OLS\", \"LGB\"])\n&gt;&gt;&gt; atom.plot_errors()\n</code></pre>"}, {"location": "api/plots/plot_evals/", "title": "plot_evals", "text": "method plot_evals(models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot evaluation curves.</p> <p>The evaluation curves are the main metric scores achieved by the models at every iteration of the training process. This plot is available only for models that allow in-training validation.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> dataset: str, default=\"test\" Data set for which to plot the evaluation curves. Use <code>+</code> between options to select more than one. Choose from: \"train\", \"test\". <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_evals-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_trials Plot the hyperparameter tuning trials.</p> <p></p>"}, {"location": "api/plots/plot_evals/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"XGB\", \"LGB\"])\n&gt;&gt;&gt; atom.plot_evals()\n</code></pre>"}, {"location": "api/plots/plot_feature_importance/", "title": "plot_feature_importance", "text": "method plot_feature_importance(models=None, show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True)[source] <p>Plot a model's feature importance.</p> <p>The sum of importances for all features (per model) is 1. This plot is available only for models whose estimator has a <code>scores_</code>, <code>feature_importances_</code> or <code>coef</code> attribute.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_feature_importance-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_parshap Plot the partial correlation of shap values.</p> <p>plot_partial_dependence Plot the partial dependence of features.</p> <p>plot_permutation_importance Plot the feature permutation importance of models.</p> <p></p>"}, {"location": "api/plots/plot_feature_importance/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_feature_importance(show=10)\n</code></pre>"}, {"location": "api/plots/plot_fft/", "title": "plot_fft", "text": "method plot_fft(columns=None, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the fourier transformation of a time series.</p> <p>A Fast Fourier Transformer (FFT) plot visualizes the frequency domain representation of a signal by transforming it from the time domain to the frequency domain using the FFT algorithm. The x-axis shows the frequencies, normalized to the Nyquist frequency, and the y-axis shows the power spectral density or squared amplitude per frequency unit on a logarithmic scale. This plot is only available for forecast tasks.</p> <p>Tip</p> <ul> <li>If the plot peaks at f~0, it can indicate the wandering   behavior characteristic of a random walk   that needs to be differentiated. It could also be indicative   of a stationary ARMA process with a high positive phi   value.</li> <li>Peaking at a frequency and its multiples is indicative of   seasonality. The lowest frequency in this case is called   the fundamental frequency, and the inverse of this   frequency is the seasonal period of the data.</li> </ul> <p>Parameters columns: int, str, segment, sequence, dataframe or None, default=None Columns to plot the periodogram from. If None, it selects the target column. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_fft-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_series Plot a data series.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_periodogram Plot the spectral density of a time series.</p> <p></p>"}, {"location": "api/plots/plot_fft/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.plot_fft()\n</code></pre>"}, {"location": "api/plots/plot_forecast/", "title": "plot_forecast", "text": "method plot_forecast(models=None, fh=\"dataset\", X=None, target=0, plot_insample=False, plot_interval=True, inverse=True, title=None, legend=\"upper left\", figsize=(900, 900), filename=None, display=True)[source] <p>Plot model forecasts for the target time series.</p> <p>This figure shows two plots: the upper plot shows the predicted values, where the gray, intersected line shows the target time series; and the lower plot, that shows the prediction residuals. This plot is only available for forecast tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> fh: hashable, segment, sequence, dataframe or ForecastingHorizon, default=\"dataset\" The forecasting horizon for which to plot the predictions. <p> X: dataframe-like or None, default=None Exogenous time series corresponding to <code>fh</code>. This parameter is ignored if <code>fh</code> is part of the dataset. The data is transformed through the model's pipeline before using it for predictions. <p> target: int or str, default=0 Target column to look at. Only for multivariate tasks. <p> plot_insample: bool, default=False Whether to draw in-sample predictions (predictions on the training set). Models that do not support this feature are silently skipped. <p> plot_interval: bool, default=True Whether to plot prediction intervals together with the exact predicted values. Models wihtout a <code>predict_interval</code> method are skipped silently. <p> inverse: bool, default=True Whether to inversely transform the output through the pipeline. This doesn't affect the predictions if there are no transformers in the pipeline or if the transformers have no <code>inverse_transform</code> method or don't apply to <code>y</code>. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_forecast-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_distribution Plot column distributions.</p> <p>plot_series Plot a data series.</p> <p>plot_errors Plot a model's prediction errors.</p> <p></p>"}, {"location": "api/plots/plot_forecast/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n&gt;&gt;&gt; from sktime.forecasting.base import ForecastingHorizon\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.run(\n...     models=\"arima\",\n...     est_params={\"order\": (1, 1, 0), \"seasonal_order\": (0, 1, 0, 12)},\n... )\n&gt;&gt;&gt; atom.plot_forecast()\n</code></pre> <pre><code>&gt;&gt;&gt; atom.plot_forecast(fh=\"train+test\", plot_interval=False)\n</code></pre> <pre><code>&gt;&gt;&gt; # Forecast the next 4 years starting from the test set\n&gt;&gt;&gt; atom.plot_forecast(fh=ForecastingHorizon(range(48)))\n</code></pre>"}, {"location": "api/plots/plot_gains/", "title": "plot_gains", "text": "method plot_gains(models=None, rows=\"test\", target=0, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the cumulative gains curve.</p> <p>This plot is available only for binary and multilabel classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_gains-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_det Plot the Detection Error Tradeoff curve.</p> <p>plot_lift Plot the lift curve.</p> <p>plot_roc Plot the Receiver Operating Characteristics curve.</p> <p></p>"}, {"location": "api/plots/plot_gains/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_gains()\n</code></pre>"}, {"location": "api/plots/plot_hyperparameter_importance/", "title": "plot_hyperparameter_importance", "text": "method plot_hyperparameter_importance(models=None, metric=0, show=None, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot a model's hyperparameter importance.</p> <p>The hyperparameter importances are calculated using the fANOVA importance evaluator. The sum of all importances for all parameters (per model) is 1. This plot is only available for models that ran hyperparameter tuning.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. <p> metric: int or str, default=0 Metric to plot (only for multi-metric runs). <p> show: int or None, default=None Number of hyperparameters (ordered by importance) to show. None to show all. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_hyperparameter_importance-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_feature_importance Plot a model's feature importance.</p> <p>plot_hyperparameters Plot hyperparameter relationships in a study.</p> <p>plot_trials Plot the hyperparameter tuning trials.</p> <p></p>"}, {"location": "api/plots/plot_hyperparameter_importance/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"ET\", \"RF\"], n_trials=10)\n&gt;&gt;&gt; atom.plot_hyperparameter_importance()\n</code></pre>"}, {"location": "api/plots/plot_hyperparameters/", "title": "plot_hyperparameters", "text": "method plot_hyperparameters(models=None, params=(0, 1), metric=0, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot hyperparameter relationships in a study.</p> <p>A model's hyperparameters are plotted against each other. The corresponding metric scores are displayed in a contour plot. The markers are the trials in the study. This plot is only available for models that ran hyperparameter tuning.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_hyperparameters()</code>. <p> params: str, segment or sequence, default=(0, 1) Hyperparameters to plot. Use a sequence or add <code>+</code> between options to select more than one. <p> metric: int or str, default=0 Metric to plot (only for multi-metric runs). <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_hyperparameters-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_hyperparameter_importance Plot a model's hyperparameter importance.</p> <p>plot_parallel_coordinate Plot high-dimensional parameter relationships in a study.</p> <p>plot_trials Plot the hyperparameter tuning trials.</p> <p></p>"}, {"location": "api/plots/plot_hyperparameters/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\", n_trials=15)\n&gt;&gt;&gt; atom.plot_hyperparameters(params=(0, 1, 2))\n</code></pre>"}, {"location": "api/plots/plot_learning_curve/", "title": "plot_learning_curve", "text": "method plot_learning_curve(models=None, metric=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the learning curve: score vs number of training samples.</p> <p>This plot is available only for models fitted using train sizing. Ensembles are ignored.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Use a sequence or add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_learning_curve-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_results Compare metric results of the models.</p> <p>plot_successive_halving Plot scores per iteration of the successive halving.</p> <p></p>"}, {"location": "api/plots/plot_learning_curve/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.train_sizing([\"LR\", \"RF\"], n_bootstrap=5)\n&gt;&gt;&gt; atom.plot_learning_curve()\n</code></pre>"}, {"location": "api/plots/plot_lift/", "title": "plot_lift", "text": "method plot_lift(models=None, rows=\"test\", target=0, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the lift curve.</p> <p>Only available for binary classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_lift-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_det Plot the Detection Error Tradeoff curve.</p> <p>plot_gains Plot the cumulative gains curve.</p> <p>plot_prc Plot the precision-recall curve.</p> <p></p>"}, {"location": "api/plots/plot_lift/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_lift()\n</code></pre>"}, {"location": "api/plots/plot_ngrams/", "title": "plot_ngrams", "text": "method plot_ngrams(ngram=\"bigram\", rows=\"dataset\", show=10, title=None, legend=\"lower right\", figsize=None, filename=None, display=True)[source] <p>Plot n-gram frequencies.</p> <p>The text for the plot is extracted from the column named <code>corpus</code>. If there is no column with that name, an exception is raised. If the documents are not tokenized, the words are separated by spaces.</p> <p>Tip</p> <p>Use atom's tokenize method to separate the words creating n-grams based on their frequency in the corpus.</p> <p>Parameters ngram: str or int, default=\"bigram\" Number of contiguous words to search for (size of n-gram). Choose from: word (1), bigram (2), trigram (3), quadgram (4). <p> rows: hashable, segment, sequence or dataframe, default=\"dataset\" Selection of rows in the corpus to include in the search. <p> show: int or None, default=10 Number of n-grams (ordered by number of occurrences) to show in the plot. If none, show all n-grams (up to 200). <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of n-grams shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_ngrams-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_wordcloud Plot a wordcloud from the corpus.</p> <p></p>"}, {"location": "api/plots/plot_ngrams/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import fetch_20newsgroups\n\n&gt;&gt;&gt; X, y = fetch_20newsgroups(\n...     return_X_y=True,\n...     categories=[\"alt.atheism\", \"sci.med\", \"comp.windows.x\"],\n...     shuffle=True,\n...     random_state=1,\n... )\n&gt;&gt;&gt; X = np.array(X).reshape(-1, 1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.textclean()\n&gt;&gt;&gt; atom.textnormalize()\n&gt;&gt;&gt; atom.plot_ngrams()\n</code></pre>"}, {"location": "api/plots/plot_pacf/", "title": "plot_pacf", "text": "method plot_pacf(columns=None, nlags=None, method=\"ywadjusted\", plot_interval=True, title=None, legend=\"upper right\", figsize=None, filename=None, display=True)[source] <p>Plot the partial autocorrelation function.</p> <p>The partial autocorrelation function (PACF) measures the correlation between a time series and lagged versions of itself, after removing the effects of shorter lagged values. In other words, it represents the correlation between two variables while controlling for the influence of other variables. PACF can help to identify the order of the autoregressive (AR) process in a time series model. This plot is only available for forecast tasks.</p> <p>Parameters columns: int, str, segment, sequence, dataframe or None, default=None Columns to plot the pacf from. If None, it selects the target column. <p> nlags: int or None, default=None Number of lags to return autocorrelation for. If None, it uses <code>min(10 * np.log10(len(y)), len(y) // 2 - 1)</code>. The returned value includes lag 0 (i.e., 1), so the size of the vector is <code>(nlags + 1,)</code>. <p> method : str, default=\"ywadjusted\" Specifies which method to use for the calculations. <ul> <li>\"yw\" or \"ywadjusted\": Yule-Walker with sample-size   adjustment in denominator for acovf.</li> <li>\"ywm\" or \"ywmle\": Yule-Walker without an adjustment.</li> <li>\"ols\": Regression of time series on lags of it and on   constant.</li> <li>\"ols-inefficient\": Regression of time series on lags using   a single common sample to estimate all pacf coefficients.</li> <li>\"ols-adjusted\": Regression of time series on lags with a   bias adjustment.</li> <li>\"ld\" or \"ldadjusted\": Levinson-Durbin recursion with bias   correction.</li> <li>\"ldb\" or \"ldbiased\": Levinson-Durbin recursion without bias   correction.</li> <li>\"burg\": Burg\"s partial autocorrelation estimator.</li> </ul> <p> plot_interval: bool, default=True Whether to plot the 95% confidence interval. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of lags shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_pacf-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_acf Plot the autocorrelation function.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_series Plot a data series.</p> <p></p>"}, {"location": "api/plots/plot_pacf/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.plot_pacf()\n</code></pre>"}, {"location": "api/plots/plot_parallel_coordinate/", "title": "plot_parallel_coordinate", "text": "method plot_parallel_coordinate(models=None, params=None, metric=0, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot high-dimensional parameter relationships in a study.</p> <p>Every line of the plot represents one trial. This plot is only available for models that ran hyperparameter tuning.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_parallel_coordinate()</code>. <p> params: str, segment, sequence or None, default=None Hyperparameters to plot. Use a sequence or add <code>+</code> between options to select more than one. If None, all the model's hyperparameters are selected. <p> metric: int or str, default=0 Metric to plot (only for multi-metric runs). <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_parallel_coordinate-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_edf Plot the Empirical Distribution Function of a study.</p> <p>plot_hyperparameter_importance Plot a model's hyperparameter importance.</p> <p>plot_hyperparameters Plot hyperparameter relationships in a study.</p> <p></p>"}, {"location": "api/plots/plot_parallel_coordinate/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"RF\", n_trials=15)\n&gt;&gt;&gt; atom.plot_parallel_coordinate(params=slice(1, 5))\n</code></pre>"}, {"location": "api/plots/plot_pareto_front/", "title": "plot_pareto_front", "text": "method plot_pareto_front(models=None, metric=None, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot the Pareto front of a study.</p> <p>Shows the trial scores plotted against each other. The marker's colors indicate the trial number. This plot is only available for models with multi-metric runs and hyperparameter tuning.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_pareto_front()</code>. <p> metric: str, sequence or None, default=None Metrics to plot.  Use a sequence or add <code>+</code> between options to select more than one. If None, the metrics used to run the pipeline are selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of metrics shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_pareto_front-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_edf Plot the Empirical Distribution Function of a study.</p> <p>plot_slice Plot the parameter relationship in a study.</p> <p>plot_trials Plot the hyperparameter tuning trials.</p> <p></p>"}, {"location": "api/plots/plot_pareto_front/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\n...     models=\"RF\",\n...     metric=[\"f1\", \"accuracy\", \"recall\"],\n...     n_trials=15,\n...  )\n&gt;&gt;&gt; atom.plot_pareto_front()\n</code></pre>"}, {"location": "api/plots/plot_parshap/", "title": "plot_parshap", "text": "method plot_parshap(models=None, columns=None, target=1, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the partial correlation of shap values.</p> <p>Plots the train and test correlation between the shap value of every feature with its target value, after removing the effect of all other features (partial correlation). This plot is useful to identify the features that are contributing most to overfitting. Features that lie below the bisector (diagonal line) performed worse on the test set than on the training set. If the estimator has a <code>scores_</code>, <code>feature_importances_</code> or <code>coef_</code> attribute, its normalized values are shown in a color map. This plot is not available for forecast tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> columns: int, str, segment, sequence, dataframe or None, default=None Feature set to plot. If None, it selects all features. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_parshap-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_feature_importance Plot a model's feature importance.</p> <p>plot_partial_dependence Plot the partial dependence of features.</p> <p>plot_permutation_importance Plot the feature permutation importance of models.</p> <p></p>"}, {"location": "api/plots/plot_parshap/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"GNB\", \"RF\"])\n&gt;&gt;&gt; atom.rf.plot_parshap(legend=None)\n</code></pre> <pre><code>&gt;&gt;&gt; atom.plot_parshap(columns=slice(5, 10))\n</code></pre>"}, {"location": "api/plots/plot_partial_dependence/", "title": "plot_partial_dependence", "text": "method plot_partial_dependence(models=None, columns=(0, 1, 2), kind=\"average\", pair=None, target=1, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the partial dependence of features.</p> <p>The partial dependence of a feature (or a set of features) corresponds to the response of the model for each possible value of the feature. The plot can take two forms:</p> <ul> <li>If <code>pair</code> is None: Single feature partial dependence lines.   The deciles of the feature values are shown with tick marks   on the bottom.</li> <li>If <code>pair</code> is defined: Two-way partial dependence plots are   plotted as contour plots (only allowed for a single model).</li> </ul> <p>Read more about partial dependence on sklearn's documentation. This plot is not available for multilabel nor multiclass-multioutput classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> columns: int, str, segment, sequence or dataframe, default=(0, 1, 2) Feature set to get the partial dependence from. <p> kind: str or sequence, default=\"average\" Kind of dependence to plot. Use a sequence or add <code>+</code> between options to select more than one. Choose from: <ul> <li>\"average\": Partial dependence averaged across all samples   in the dataset.</li> <li>\"individual\": Partial dependence for up to 50 random   samples (Individual Conditional Expectation).</li> </ul> <p>This parameter is ignored when plotting feature pairs.</p> <p> pair: int, str or None, default=None Feature with which to pair the features selected by <code>columns</code>. If specified, the resulting figure displays contour plots. Only allowed when plotting a single model. If None, the plots show the partial dependence of single features. <p> target: int or str, default=1 Class in the target column to look at (only for multiclass classification tasks). <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_partial_dependence-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_feature_importance Plot a model's feature importance.</p> <p>plot_parshap Plot the partial correlation of shap values.</p> <p>plot_permutation_importance Plot the feature permutation importance of models.</p> <p></p>"}, {"location": "api/plots/plot_partial_dependence/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_partial_dependence(kind=\"average+individual\", legend=\"upper left\")\n</code></pre> <pre><code>&gt;&gt;&gt; atom.rf.plot_partial_dependence(columns=(3, 4), pair=2)\n</code></pre>"}, {"location": "api/plots/plot_pca/", "title": "plot_pca", "text": "method plot_pca(title=None, legend=None, figsize=(900, 600), filename=None, display=True)[source] <p>Plot the explained variance ratio vs number of components.</p> <p>If the underlying estimator is PCA (for dense datasets), all possible components are plotted. If the underlying estimator is TruncatedSVD (for sparse datasets), it only shows the selected components. The star marks the number of components selected by the user. This plot is available only when feature selection was applied with strategy=\"pca\".</p> <p>Parameters title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_pca-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_components Plot the explained variance ratio per component.</p> <p>plot_rfecv Plot the rfecv results.</p> <p></p>"}, {"location": "api/plots/plot_pca/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.feature_selection(\"pca\", n_features=5)\n&gt;&gt;&gt; atom.plot_pca()\n</code></pre>"}, {"location": "api/plots/plot_periodogram/", "title": "plot_periodogram", "text": "method plot_periodogram(columns=None, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the spectral density of a time series.</p> <p>A periodogram plot is used to visualize the frequency content of a time series signal. It's particularly useful in time series analysis for identifying dominant frequencies, periodic patterns, and overall spectral characteristics of the data. The x-axis shows the frequencies, normalized to the Nyquist frequency, and the y-axis shows the power spectral density or squared amplitude per frequency unit on a logarithmic scale. This plot is only available for forecast tasks.</p> <p>Tip</p> <ul> <li>If the plot peaks at f~0, it can indicate the wandering   behavior characteristic of a random walk   that needs to be differentiated. It could also be indicative   of a stationary ARMA process with a high positive phi   value.</li> <li>Peaking at a frequency and its multiples is indicative of   seasonality. The lowest frequency in this case is called   the fundamental frequency, and the inverse of this   frequency is the seasonal period of the data.</li> </ul> <p>Parameters columns: int, str, segment, sequence, dataframe or None, default=None Columns to plot the periodogram from. If None, it selects the target column. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_periodogram-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_series Plot a data series.</p> <p>plot_decomposition Plot the trend, seasonality and residuals of a time series.</p> <p>plot_fft Plot the fourier transformation of a time series.</p> <p></p>"}, {"location": "api/plots/plot_periodogram/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.plot_periodogram()\n</code></pre>"}, {"location": "api/plots/plot_permutation_importance/", "title": "plot_permutation_importance", "text": "method plot_permutation_importance(models=None, show=None, n_repeats=10, title=None, legend=\"lower right\", figsize=None, filename=None, display=True)[source] <p>Plot the feature permutation importance of models.</p> <p>Warning</p> <p>This method can be slow. Results are cached to fasten repeated calls.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> n_repeats: int, default=10 Number of times to permute each feature. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_permutation_importance-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_feature_importance Plot a model's feature importance.</p> <p>plot_partial_dependence Plot the partial dependence of features.</p> <p>plot_parshap Plot the partial correlation of shap values.</p> <p></p>"}, {"location": "api/plots/plot_permutation_importance/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_permutation_importance(show=10, n_repeats=7)\n</code></pre>"}, {"location": "api/plots/plot_pipeline/", "title": "plot_pipeline", "text": "method plot_pipeline(models=None, draw_hyperparameter_tuning=True, color_branches=None, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot a diagram of the pipeline.</p> <p>Warning</p> <p>This plot uses the schemdraw package, which is incompatible with plotly. The returned plot is therefore a matplotlib figure.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models for which to draw the pipeline. If None, all pipelines are plotted. <p> draw_hyperparameter_tuning: bool, default=True Whether to draw if the models used Hyperparameter Tuning. <p> color_branches: bool or None, default=None Whether to draw every branch in a different color. If None, branches are colored when there is more than one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the pipeline drawn. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_pipeline-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_wordcloud Plot a wordcloud from the corpus.</p> <p></p>"}, {"location": "api/plots/plot_pipeline/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"GNB\", \"RNN\", \"SGD\", \"MLP\"])\n&gt;&gt;&gt; atom.voting(models=atom.winners[:2])\n&gt;&gt;&gt; atom.plot_pipeline()\n</code></pre><pre><code>&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.scale()\n&gt;&gt;&gt; atom.prune()\n&gt;&gt;&gt; atom.run(\"RF\", n_trials=30)\n\n&gt;&gt;&gt; atom.branch = \"undersample\"\n&gt;&gt;&gt; atom.balance(\"nearmiss\")\n&gt;&gt;&gt; atom.run(\"RF_undersample\")\n\n&gt;&gt;&gt; atom.branch = \"oversample_from_main\"\n&gt;&gt;&gt; atom.balance(\"smote\")\n&gt;&gt;&gt; atom.run(\"RF_oversample\")\n\n&gt;&gt;&gt; atom.plot_pipeline()\n</code></pre>"}, {"location": "api/plots/plot_prc/", "title": "plot_prc", "text": "method plot_prc(models=None, rows=\"test\", target=0, title=None, legend=\"lower left\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the precision-recall curve.</p> <p>Read more about PRC in sklearn's documentation. Only available for binary classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_prc-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_det Plot the Detection Error Tradeoff curve.</p> <p>plot_lift Plot the lift curve.</p> <p>plot_roc Plot the Receiver Operating Characteristics curve.</p> <p></p>"}, {"location": "api/plots/plot_prc/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_prc()\n</code></pre>"}, {"location": "api/plots/plot_probabilities/", "title": "plot_probabilities", "text": "method plot_probabilities(models=None, rows=\"test\", target=1, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the probability distribution of the target classes.</p> <p>This plot is available only for models with a <code>predict_proba</code> method in classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: hashable, segment or sequence, default=\"test\" Selection of rows on which to calculate the metric. <p> target: int, str or tuple, default=1 Probability of being that class in the target column. For multioutput tasks, the value should be a tuple of the form (column, class). <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_probabilities-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_confusion_matrix Plot a model's confusion matrix.</p> <p>plot_results Compare metric results of the models.</p> <p>plot_threshold Plot metric performances against threshold values.</p> <p></p>"}, {"location": "api/plots/plot_probabilities/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_probabilities()\n</code></pre>"}, {"location": "api/plots/plot_qq/", "title": "plot_qq", "text": "method plot_qq(columns=0, distributions=\"norm\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot a quantile-quantile plot.</p> <p>Columns are distinguished by color and the distributions are distinguished by marker type. Missing values are ignored.</p> <p>Parameters columns: int, str, segment, sequence or dataframe, default=0 Columns to plot. Selected categorical columns are ignored. <p> distributions: str or sequence, default=\"norm\" Names of the <code>scipy.stats</code> distributions to fit to the columns. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_qq-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_correlation Plot a correlation matrix.</p> <p>plot_distribution Plot column distributions.</p> <p>plot_relationships Plot pairwise relationships in a dataset.</p> <p></p>"}, {"location": "api/plots/plot_qq/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.plot_qq(columns=[5, 6])\n</code></pre> <pre><code>&gt;&gt;&gt; atom.plot_qq(columns=0, distributions=[\"norm\", \"invgauss\", \"triang\"])\n</code></pre>"}, {"location": "api/plots/plot_relationships/", "title": "plot_relationships", "text": "method plot_relationships(columns=(0, 1, 2), title=None, legend=None, figsize=(900, 900), filename=None, display=True)[source] <p>Plot pairwise relationships in a dataset.</p> <p>Creates a grid of axes such that each numerical column appears once on the x-axes and once on the y-axes. The bottom triangle contains scatter plots (max 250 random samples), the diagonal plots contain column distributions, and the upper triangle contains contour histograms for all samples in the columns.</p> <p>Parameters columns: segment, sequence or dataframe, default=(0, 1, 2) Columns to plot. Selected categorical columns are ignored. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_relationships-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_correlation Plot a correlation matrix.</p> <p>plot_distribution Plot column distributions.</p> <p>plot_qq Plot a quantile-quantile plot.</p> <p></p>"}, {"location": "api/plots/plot_relationships/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.plot_relationships(columns=[0, 4, 5])\n</code></pre>"}, {"location": "api/plots/plot_residuals/", "title": "plot_residuals", "text": "method plot_residuals(models=None, rows=\"test\", target=0, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot a model's residuals.</p> <p>The plot shows the residuals (difference between the predicted and the true value) on the vertical axis and the independent variable on the horizontal axis. This plot can be useful to analyze the variance of the regressor's errors. If the points are randomly dispersed around the horizontal axis, a linear regression model is appropriate for the data; otherwise, a non-linear model is more appropriate. This plot is unavailable for classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multioutput tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_residuals-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_errors Plot a model's prediction errors.</p> <p></p>"}, {"location": "api/plots/plot_residuals/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMRegressor\n&gt;&gt;&gt; from sklearn.datasets import load_diabetes\n\n&gt;&gt;&gt; X, y = load_diabetes(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMRegressor(X, y)\n&gt;&gt;&gt; atom.run([\"OLS\", \"LGB\"])\n&gt;&gt;&gt; atom.plot_residuals()\n</code></pre>"}, {"location": "api/plots/plot_results/", "title": "plot_results", "text": "method plot_results(models=None, metric=None, rows=\"test\", title=None, legend=\"lower right\", figsize=None, filename=None, display=True)[source] <p>Compare metric results of the models.</p> <p>Shows a barplot of the metric scores. Models are ordered based on their score from the top down.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> metric: int, str, sequence or None, default=None Metric to plot. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred, **kwargs)</code> or a scorer object. Use a sequence or add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. Other available options are: \"time_bo\", \"time_fit\", \"time_bootstrap\", \"time\". <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows on which to calculate the metric. This parameter is ignored if <code>metric</code> is a time metric. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of models. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_results-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_bootstrap Plot the bootstrapping scores.</p> <p>plot_probabilities Plot the probability distribution of the target classes.</p> <p>plot_threshold Plot metric performances against threshold values.</p> <p></p>"}, {"location": "api/plots/plot_results/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"GNB\", \"LR\"], metric=[\"f1\", \"recall\"])\n&gt;&gt;&gt; atom.plot_results()\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot the time it took to fit the models\n&gt;&gt;&gt; atom.plot_results(metric=\"time_fit+time\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot a different metric\n&gt;&gt;&gt; atom.plot_results(metric=\"accuracy\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot the results on the training set\n&gt;&gt;&gt; atom.plot_results(metric=\"f1\", rows=\"train\")\n</code></pre>"}, {"location": "api/plots/plot_rfecv/", "title": "plot_rfecv", "text": "method plot_rfecv(plot_interval=True, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the rfecv results.</p> <p>Plot the scores obtained by the estimator fitted on every subset of the dataset. Only available when feature selection was applied with strategy=\"rfecv\".</p> <p>Parameters plot_interval: bool, default=True Whether to plot the 1-sigma confidence interval. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_rfecv-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_components Plot the explained variance ratio per component.</p> <p>plot_pca Plot the explained variance ratio vs number of components.</p> <p></p>"}, {"location": "api/plots/plot_rfecv/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.feature_selection(\"rfecv\", solver=\"Tree\")\n&gt;&gt;&gt; atom.plot_rfecv()\n</code></pre>"}, {"location": "api/plots/plot_roc/", "title": "plot_roc", "text": "method plot_roc(models=None, rows=\"test\", target=0, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the Receiver Operating Characteristics curve.</p> <p>Read more about ROC in sklearn's documentation. Only available for classification tasks.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> rows: str, sequence or dict, default=\"test\" Selection of rows on which to calculate the metric. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_roc-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_gains Plot the cumulative gains curve.</p> <p>plot_lift Plot the lift curve.</p> <p>plot_prc Plot the precision-recall curve.</p> <p></p>"}, {"location": "api/plots/plot_roc/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_roc()\n</code></pre>"}, {"location": "api/plots/plot_series/", "title": "plot_series", "text": "method plot_series(rows=('train', 'test'), columns=None, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot a data series.</p> <p>This plot is only available for forecast tasks.</p> <p>Parameters rows: str, sequence or dict, default=(\"train\", \"test\") Selection of rows to plot. <ul> <li>If str: Name of the data set to plot.</li> <li>If sequence: Names of the data sets to plot.</li> <li>If dict: Names of the sets with corresponding   selection of rows as values.</li> </ul> <p> columns: int, str, segment, sequence, dataframe or None, default=None Columns to plot. If None, all target columns are selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_series-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_distribution Plot column distributions.</p> <p>plot_relationships Plot pairwise relationships in a dataset.</p> <p>plot_qq Plot a quantile-quantile plot.</p> <p></p>"}, {"location": "api/plots/plot_series/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; atom = ATOMForecaster(y, random_state=1)\n&gt;&gt;&gt; atom.plot_series()\n</code></pre>"}, {"location": "api/plots/plot_shap_bar/", "title": "plot_shap_bar", "text": "method plot_shap_bar(models=None, rows=\"test\", show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot SHAP's bar plot.</p> <p>Create a bar plot of a set of SHAP values. If a single sample is passed, then the SHAP values are plotted. If many samples are passed, then the mean absolute value for each feature column is plotted. Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_bar()</code>. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to plot. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_shap_bar-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_parshap Plot the partial correlation of shap values.</p> <p>plot_shap_beeswarm Plot SHAP's beeswarm plot.</p> <p>plot_shap_scatter Plot SHAP's scatter plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_bar/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_bar(show=10)\n</code></pre>"}, {"location": "api/plots/plot_shap_beeswarm/", "title": "plot_shap_beeswarm", "text": "method plot_shap_beeswarm(models=None, rows=\"test\", show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot SHAP's beeswarm plot.</p> <p>The plot is colored by feature values. Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_beeswarm()</code>. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to plot. The plot_shap_beeswarm method does not support plotting a single sample. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_shap_beeswarm-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_parshap Plot the partial correlation of shap values.</p> <p>plot_shap_bar Plot SHAP's bar plot.</p> <p>plot_shap_scatter Plot SHAP's scatter plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_beeswarm/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_beeswarm(show=10)\n</code></pre>"}, {"location": "api/plots/plot_shap_decision/", "title": "plot_shap_decision", "text": "method plot_shap_decision(models=None, rows=\"test\", show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot SHAP's decision plot.</p> <p>Visualize model decisions using cumulative SHAP values. Each plotted line explains a single model prediction. If a single prediction is plotted, feature values are printed in the plot (if supplied). If multiple predictions are plotted together, feature values will not be printed. Plotting too many predictions together will make the plot unintelligible. Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_decision()</code>. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to plot. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_shap_decision-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_shap_bar Plot SHAP's bar plot.</p> <p>plot_shap_beeswarm Plot SHAP's beeswarm plot.</p> <p>plot_shap_force Plot SHAP's force plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_decision/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_decision(show=10)\n</code></pre><pre><code>&gt;&gt;&gt; atom.plot_shap_decision(rows=-1, show=10)\n</code></pre>"}, {"location": "api/plots/plot_shap_force/", "title": "plot_shap_force", "text": "method plot_shap_force(models=None, rows=\"test\", target=1, title=None, legend=None, figsize=(900, 300), filename=None, display=True, **kwargs)[source] <p>Plot SHAP's force plot.</p> <p>Visualize the given SHAP values with an additive force layout. Note that by default this plot will render using javascript. For a regular figure use <code>matplotlib=True</code> (this option is only available when only a single sample is plotted). Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_force()</code>. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to plot. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=(900, 300) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure (only if <code>matplotlib=True</code> in <code>kwargs</code>). <p> **kwargs Additional keyword arguments for shap.plots.force. <p>Returns{#plot_shap_force-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_shap_beeswarm Plot SHAP's beeswarm plot.</p> <p>plot_shap_scatter Plot SHAP's scatter plot.</p> <p>plot_shap_decision Plot SHAP's decision plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_force/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_force(rows=-2, matplotlib=True, figsize=(1800, 300))\n</code></pre>"}, {"location": "api/plots/plot_shap_heatmap/", "title": "plot_shap_heatmap", "text": "method plot_shap_heatmap(models=None, rows=\"test\", show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot SHAP's heatmap plot.</p> <p>This plot is designed to show the population substructure of a dataset using supervised clustering and a heatmap. Supervised clustering involves clustering data points not by their original feature values but by their explanations. Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_heatmap()</code>. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to plot. The plot_shap_heatmap method does not support plotting a single sample. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_shap_heatmap-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_shap_decision Plot SHAP's decision plot.</p> <p>plot_shap_force Plot SHAP's force plot.</p> <p>plot_shap_waterfall Plot SHAP's waterfall plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_heatmap/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_heatmap(show=10)\n</code></pre>"}, {"location": "api/plots/plot_shap_scatter/", "title": "plot_shap_scatter", "text": "method plot_shap_scatter(models=None, rows=\"test\", columns=0, target=1, title=None, legend=None, figsize=(900, 600), filename=None, display=True)[source] <p>Plot SHAP's scatter plot.</p> <p>Plots the value of the feature on the x-axis and the SHAP value of the same feature on the y-axis. This shows how the model depends on the given feature, and is like a richer extension of the classical partial dependence plots. Vertical dispersion of the data points represents interaction effects. Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_scatter()</code>. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to plot. The plot_shap_scatter method does not support plotting a single sample. <p> columns: int, str, segment, sequence or dataframe, default=0 Feature to plot. Only a single feature can be selected. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_shap_scatter-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_shap_beeswarm Plot SHAP's beeswarm plot.</p> <p>plot_shap_decision Plot SHAP's decision plot.</p> <p>plot_shap_force Plot SHAP's force plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_scatter/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_scatter(columns=\"symmetry error\")\n</code></pre>"}, {"location": "api/plots/plot_shap_waterfall/", "title": "plot_shap_waterfall", "text": "method plot_shap_waterfall(models=None, rows=0, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot SHAP's waterfall plot.</p> <p>The SHAP value of a feature represents the impact of the evidence provided by that feature on the model's output. The waterfall plot is designed to visually display how the SHAP values (evidence) of each feature move the model output from our prior expectation under the background data distribution, to the final model prediction given the evidence of all the features. Features are sorted by the magnitude of their SHAP values with the smallest magnitude features grouped together at the bottom of the plot when the number of features in the models exceeds the <code>show</code> parameter. Read more about SHAP plots in the user guide.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_waterfall()</code>. <p> rows: int or str, default=0 Selection of rows to plot. The plot_shap_waterfall method does not support plotting multiple samples. <p> show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. <p> target: int, str or tuple, default=1 Class in the target column to target. For multioutput tasks, the value should be a tuple of the form (column, class). Note that for binary and multilabel tasks, the selected class is always the positive one. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as png. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_shap_waterfall-plt.Figure or None} plt.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_shap_bar Plot SHAP's bar plot.</p> <p>plot_shap_beeswarm Plot SHAP's beeswarm plot.</p> <p>plot_shap_heatmap Plot SHAP's heatmap plot.</p> <p></p>"}, {"location": "api/plots/plot_shap_waterfall/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"LR\")\n&gt;&gt;&gt; atom.plot_shap_waterfall(show=10)\n</code></pre>"}, {"location": "api/plots/plot_slice/", "title": "plot_slice", "text": "method plot_slice(models=None, params=None, metric=None, title=None, legend=None, figsize=None, filename=None, display=True)[source] <p>Plot the parameter relationship in a study.</p> <p>The color of the markers indicates the trial. This plot is only available for models that ran hyperparameter tuning.</p> <p>Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g., <code>atom.lr.plot_slice()</code>. <p> params: str, segment, sequence or None, default=None Hyperparameters to plot. Use a sequence or add <code>+</code> between options to select more than one. If None, all the model's hyperparameters are selected. <p> metric: int or str, default=None Metric to plot (only for multi-metric runs). If str, add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_slice-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_edf Plot the Empirical Distribution Function of a study.</p> <p>plot_hyperparameters Plot hyperparameter relationships in a study.</p> <p>plot_parallel_coordinate Plot high-dimensional parameter relationships in a study.</p> <p></p>"}, {"location": "api/plots/plot_slice/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\n...     models=\"RF\",\n...     metric=[\"f1\", \"recall\"],\n...     n_trials=15,\n... )\n&gt;&gt;&gt; atom.plot_slice(params=(0, 1, 2))\n</code></pre>"}, {"location": "api/plots/plot_successive_halving/", "title": "plot_successive_halving", "text": "method plot_successive_halving(models=None, metric=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot scores per iteration of the successive halving.</p> <p>Only use with models fitted using successive halving. Ensembles are ignored.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Use a sequence or add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_successive_halving-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_learning_curve Plot the learning curve: score vs number of training samples.</p> <p>plot_results Compare metric results of the models.</p> <p></p>"}, {"location": "api/plots/plot_successive_halving/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.successive_halving([\"Tree\", \"Bag\", \"RF\", \"LGB\"], n_bootstrap=5)\n&gt;&gt;&gt; atom.plot_successive_halving()\n</code></pre>"}, {"location": "api/plots/plot_terminator_improvement/", "title": "plot_terminator_improvement", "text": "method plot_terminator_improvement(models=None, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the potentials for future objective improvement.</p> <p>This function visualizes the objective improvement potentials. It helps to determine whether you should continue the optimization or not. The evaluated error is also plotted. Note that this function may take some time to compute the improvement potentials. This plot is only available for models that ran hyperparameter tuning.</p> <p>Warning</p> <ul> <li>The plot_terminator_improvement method is only available   for models that ran hyperparameter tuning using   cross-validation, e.g., using <code>ht_params={'cv': 5}</code>.</li> <li>This method does not support   [multi-objective optimizations][multi-metric runs].</li> <li>The calculation of the improvement can be slow. Set the   <code>memory</code> parameter to cache the   results and speed up repeated calls.</li> </ul> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y) <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_terminator_improvement-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_pareto_front Plot the Pareto front of a study.</p> <p>plot_timeline Plot the timeline of a study.</p> <p>plot_trials Plot the hyperparameter tuning trials.</p> <p></p>"}, {"location": "api/plots/plot_terminator_improvement/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=100, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\"RF\", n_trials=10, ht_params={\"cv\": 5})\n&gt;&gt;&gt; atom.plot_terminator_improvement()\n</code></pre>"}, {"location": "api/plots/plot_threshold/", "title": "plot_threshold", "text": "method plot_threshold(models=None, metric=None, rows=\"test\", target=0, steps=100, title=None, legend=\"lower left\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot metric performances against threshold values.</p> <p>This plot is available only for models with a <code>predict_proba</code> method in a binary or multilabel classification task.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models are selected. <p> metric: str, func, scorer, sequence or None, default=None Metric to plot. Choose from any of sklearn's scorers, a function with signature <code>metric(y_true, y_pred, **kwargs)</code> or a scorer object. Use a sequence or add <code>+</code> between options to select more than one. If None, the metric used to run the pipeline is selected. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows on which to calculate the metric. <p> target: int or str, default=0 Target column to look at. Only for multilabel tasks. <p> steps: int, default=100 Number of thresholds measured. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_threshold-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_calibration Plot the calibration curve for a binary classifier.</p> <p>plot_confusion_matrix Plot a model's confusion matrix.</p> <p>plot_probabilities Plot the probability distribution of the target classes.</p> <p></p>"}, {"location": "api/plots/plot_threshold/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"LR\", \"RF\"])\n&gt;&gt;&gt; atom.plot_threshold()\n</code></pre>"}, {"location": "api/plots/plot_timeline/", "title": "plot_timeline", "text": "method plot_timeline(models=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True)[source] <p>Plot the timeline of a study.</p> <p>This plot is only available for models that ran hyperparameter tuning.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y) <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_timeline-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_edf Plot the Empirical Distribution Function of a study.</p> <p>plot_slice Plot the parameter relationship in a study.</p> <p>plot_terminator_improvement Plot the potentials for future objective improvement.</p> <p></p>"}, {"location": "api/plots/plot_timeline/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from optuna.pruners import PatientPruner\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run(\n...     models=\"LGB\",\n...     n_trials=15,\n...     ht_params={\"pruner\": PatientPruner(None, patience=2)},\n... )\n&gt;&gt;&gt; atom.plot_timeline()\n</code></pre>"}, {"location": "api/plots/plot_trials/", "title": "plot_trials", "text": "method plot_trials(models=None, metric=None, title=None, legend=\"upper left\", figsize=(900, 800), filename=None, display=True)[source] <p>Plot the hyperparameter tuning trials.</p> <p>Creates a figure with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. The best trial is indicated with a star. This is the same plot as produced by <code>ht_params={\"plot\": True}</code>. This plot is only available for models that ran hyperparameter tuning.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. <p> metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Add <code>+</code> between options to select more than one. If None, all metrics are selected. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple, default=(900, 800) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p>Returns{#plot_trials-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_evals Plot evaluation curves.</p> <p>plot_hyperparameters Plot hyperparameter relationships in a study.</p> <p>plot_results Compare metric results of the models.</p> <p></p>"}, {"location": "api/plots/plot_trials/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import make_classification\n\n&gt;&gt;&gt; X, y = make_classification(n_samples=100, flip_y=0.2, random_state=1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.run([\"ET\", \"RF\"], n_trials=15)\n&gt;&gt;&gt; atom.plot_trials()\n</code></pre>"}, {"location": "api/plots/plot_wordcloud/", "title": "plot_wordcloud", "text": "method plot_wordcloud(rows=\"dataset\", title=None, legend=None, figsize=(900, 600), filename=None, display=True, **kwargs)[source] <p>Plot a wordcloud from the corpus.</p> <p>The text for the plot is extracted from the column named <code>corpus</code>. If there is no column with that name, an exception is raised.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"dataset\" Selection of rows in the corpus to include in the wordcloud. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: str, dict or None, default=None Do nothing. Implemented for continuity of the API. <p> figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool or None, default=True Whether to render the plot. If None, it returns the figure. <p> **kwargs Additional keyword arguments for the Wordcloud object. <p>Returns{#plot_wordcloud-go.Figure or None} go.Figure or None Plot object. Only returned if <code>display=None</code>. <p></p> <p></p> <p>See Also</p> <p>plot_ngrams Plot n-gram frequencies.</p> <p>plot_pipeline Plot a diagram of the pipeline.</p> <p></p>"}, {"location": "api/plots/plot_wordcloud/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from atom import ATOMClassifier\n&gt;&gt;&gt; from sklearn.datasets import fetch_20newsgroups\n\n&gt;&gt;&gt; X, y = fetch_20newsgroups(\n...     return_X_y=True,\n...     categories=[\"alt.atheism\", \"sci.med\", \"comp.windows.x\"],\n...     shuffle=True,\n...     random_state=1,\n... )\n&gt;&gt;&gt; X = np.array(X).reshape(-1, 1)\n\n&gt;&gt;&gt; atom = ATOMClassifier(X, y, random_state=1)\n&gt;&gt;&gt; atom.textclean()\n&gt;&gt;&gt; atom.textnormalize()\n&gt;&gt;&gt; atom.plot_wordcloud()\n</code></pre>"}, {"location": "api/training/directclassifier/", "title": "DirectClassifier", "text": "class atom.training.DirectClassifier(models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a direct fashion.</p> <p>The following steps are applied to every model:</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, a default metric is selected for every task: <ul> <li>\"f1\" for binary classification</li> <li>\"f1_weighted\" for multiclass(-multioutput) classification</li> <li>\"average_precision\" for multilabel classification</li> </ul> <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMClassifier Main class for classification tasks.</p> <p>SuccessiveHalvingClassifier Train and evaluate the models in a successive halving fashion.</p> <p>TrainSizingClassifier Train and evaluate the models in a train sizing fashion.</p> <p></p>"}, {"location": "api/training/directclassifier/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import DirectClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from sklearn.model_selection import train_test_split\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; train, test = train_test_split(\n...     X.merge(y.to_frame(), left_index=True, right_index=True),\n...     test_size=0.3,\n... )\n\n&gt;&gt;&gt; runner = DirectClassifier(models=[\"LR\", \"RF\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nModels: LR, RF\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.992\nTest evaluation --&gt; f1: 0.9767\nTime elapsed: 0.248s\n-------------------------------------------------\nTime: 0.248s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9585\nTime elapsed: 0.156s\n-------------------------------------------------\nTime: 0.156s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.411s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9767 !\nRandomForest       --&gt; f1: 0.9585\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> f1_train f1_test time_fit time LR 0.992000 0.976700 0.248226 0.248226 RF 1.000000 0.958500 0.156143 0.156143"}, {"location": "api/training/directclassifier/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/directclassifier/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/directclassifier/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/directclassifier/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/directclassifier/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/directclassifier/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/directforecaster/", "title": "DirectForecaster", "text": "class atom.training.DirectForecaster(models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a direct fashion.</p> <p>The following steps are applied to every model:</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, the default metric <code>mean_absolute_percentage_error</code> is selected. <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMForecaster Main class for forecasting tasks.</p> <p>SuccessiveHalvingForecaster Train and evaluate the models in a successive halving fashion.</p> <p>TrainSizingForecaster Train and evaluate the models in a train sizing fashion.</p> <p></p>"}, {"location": "api/training/directforecaster/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import DirectForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n&gt;&gt;&gt; from sktime.split import temporal_train_test_split\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; train, test = temporal_train_test_split(y, test_size=0.2)\n\n&gt;&gt;&gt; runner = DirectForecaster(models=[\"ES\", \"ETS\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nModels: ES, ETS\nMetric: mape\n\n\nResults for ExponentialSmoothing:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0868\nTest evaluation --&gt; mape: -0.2018\nTime elapsed: 0.024s\n-------------------------------------------------\nTime: 0.024s\n\n\nResults for ETS:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.0863\nTest evaluation --&gt; mape: -0.202\nTime elapsed: 0.025s\n-------------------------------------------------\nTime: 0.025s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.052s\n-------------------------------------\nExponentialSmoothing --&gt; mape: -0.2018 !\nETS                  --&gt; mape: -0.202\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> mape_train mape_test time_fit time ES -0.086800 -0.201800 0.024022 0.024022 ETS -0.086300 -0.202000 0.025024 0.025024"}, {"location": "api/training/directforecaster/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/directforecaster/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/directforecaster/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/directforecaster/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/directforecaster/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/directforecaster/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/directregressor/", "title": "DirectRegressor", "text": "class atom.training.DirectRegressor(models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a direct fashion.</p> <p>The following steps are applied to every model:</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, the default metric <code>r2</code> is selected. <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMRegressor Main class for regression tasks.</p> <p>SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion.</p> <p>TrainSizingRegressor Train and evaluate the models in a train sizing fashion.</p> <p></p>"}, {"location": "api/training/directregressor/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import DirectRegressor\n&gt;&gt;&gt; from sklearn.datasets import load_digits\n&gt;&gt;&gt; from sklearn.model_selection import train_test_split\n\n&gt;&gt;&gt; X, y = load_digits(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; train, test = train_test_split(\n...     X.merge(y.to_frame(), left_index=True, right_index=True),\n...     test_size=0.3,\n... )\n\n&gt;&gt;&gt; runner = DirectRegressor(models=[\"OLS\", \"RF\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nModels: OLS, RF\nMetric: r2\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.5993\nTest evaluation --&gt; r2: 0.5645\nTime elapsed: 0.423s\n-------------------------------------------------\nTime: 0.423s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.9782\nTest evaluation --&gt; r2: 0.8468\nTime elapsed: 0.955s\n-------------------------------------------------\nTime: 0.955s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.380s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5645\nRandomForest         --&gt; r2: 0.8468 !\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> r2_train r2_test time_fit time OLS 0.599300 0.564500 0.423366 0.423366 RF 0.978200 0.846800 0.954871 0.954871"}, {"location": "api/training/directregressor/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/directregressor/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/directregressor/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/directregressor/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/directregressor/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/directregressor/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/successivehalvingclassifier/", "title": "SuccessiveHalvingClassifier", "text": "class atom.training.SuccessiveHalvingClassifier(models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a successive halving fashion.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, a default metric is selected for every task: <ul> <li>\"f1\" for binary classification</li> <li>\"f1_weighted\" for multiclass(-multioutput) classification</li> <li>\"average_precision\" for multilabel classification</li> </ul> <p> skip_runs: int, default=0 Skip last <code>skip_runs</code> runs of the successive halving. <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMClassifier Main class for classification tasks.</p> <p>DirectClassifier Train and evaluate the models in a direct fashion.</p> <p>TrainSizingClassifier Train and evaluate the models in a train sizing fashion.</p> <p></p>"}, {"location": "api/training/successivehalvingclassifier/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import SuccessiveHalvingClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from sklearn.model_selection import train_test_split\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; train, test = train_test_split(\n...     X.merge(y.to_frame(), left_index=True, right_index=True),\n...     test_size=0.3,\n... )\n\n&gt;&gt;&gt; runner = SuccessiveHalvingClassifier([\"LR\", \"RF\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nMetric: f1\n\n\nRun: 0 =========================== &gt;&gt;\nModels: LR2, RF2\nSize of training set: 398 (50%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.992\nTest evaluation --&gt; f1: 0.9828\nTime elapsed: 0.234s\n-------------------------------------------------\nTime: 0.234s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9697\nTime elapsed: 0.128s\n-------------------------------------------------\nTime: 0.128s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.368s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9828 !\nRandomForest       --&gt; f1: 0.9697\n\n\nRun: 1 =========================== &gt;&gt;\nModels: LR1\nSize of training set: 398 (100%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9959\nTest evaluation --&gt; f1: 0.9784\nTime elapsed: 0.247s\n-------------------------------------------------\nTime: 0.247s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.250s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9784\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> f1_train f1_test time_fit time frac model 0.500000 LR2 0.992000 0.982800 0.234213 0.234213 RF2 1.000000 0.969700 0.128118 0.128118 1.000000 LR1 0.995900 0.978400 0.247224 0.247224"}, {"location": "api/training/successivehalvingclassifier/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/successivehalvingclassifier/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/successivehalvingclassifier/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/successivehalvingclassifier/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/successivehalvingclassifier/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/successivehalvingclassifier/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/successivehalvingforecaster/", "title": "SuccessiveHalvingForecaster", "text": "class atom.training.SuccessiveHalvingForecaster(models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a successive halving fashion.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, the default metric <code>mean_absolute_percentage_error</code> is selected. <p> skip_runs: int, default=0 Skip last <code>skip_runs</code> runs of the successive halving. <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMForecaster Main class for forecasting tasks.</p> <p>DirectForecaster Train and evaluate the models in a direct fashion.</p> <p>TrainSizingForecaster Train and evaluate the models in a train sizing fashion.</p> <p></p>"}, {"location": "api/training/successivehalvingforecaster/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import SuccessiveHalvingForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n&gt;&gt;&gt; from sktime.split import temporal_train_test_split\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; train, test = temporal_train_test_split(y, test_size=0.2)\n\n&gt;&gt;&gt; runner = SuccessiveHalvingForecaster([\"Croston\", \"PT\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nMetric: mape\n\n\nRun: 0 =========================== &gt;&gt;\nModels: Croston2, PT2\nSize of training set: 115 (50%)\nSize of test set: 29\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.3097\nTest evaluation --&gt; mape: -0.1625\nTime elapsed: 0.016s\n-------------------------------------------------\nTime: 0.016s\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1129\nTest evaluation --&gt; mape: -0.1453\nTime elapsed: 0.018s\n-------------------------------------------------\nTime: 0.018s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.038s\n-------------------------------------\nCroston         --&gt; mape: -0.1625\nPolynomialTrend --&gt; mape: -0.1453 !\n\n\nRun: 1 =========================== &gt;&gt;\nModels: PT1\nSize of training set: 115 (100%)\nSize of test set: 29\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1165\nTest evaluation --&gt; mape: -0.1207\nTime elapsed: 0.019s\n-------------------------------------------------\nTime: 0.019s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.020s\n-------------------------------------\nPolynomialTrend --&gt; mape: -0.1207\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> mape_train mape_test time_fit time frac model 0.500000 Croston2 -0.309700 -0.162500 0.016015 0.016015 PT2 -0.112900 -0.145300 0.018017 0.018017 1.000000 PT1 -0.116500 -0.120700 0.019018 0.019018"}, {"location": "api/training/successivehalvingforecaster/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/successivehalvingforecaster/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/successivehalvingforecaster/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/successivehalvingforecaster/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/successivehalvingforecaster/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/successivehalvingforecaster/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/successivehalvingregressor/", "title": "SuccessiveHalvingRegressor", "text": "class atom.training.SuccessiveHalvingRegressor(models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a successive halving fashion.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, the default metric <code>r2</code> is selected. <p> skip_runs: int, default=0 Skip last <code>skip_runs</code> runs of the successive halving. <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMRegressor Main class for regression tasks.</p> <p>DirectRegressor Train and evaluate the models in a direct fashion.</p> <p>TrainSizingRegressor Train and evaluate the models in a train sizing fashion.</p> <p></p>"}, {"location": "api/training/successivehalvingregressor/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import SuccessiveHalvingRegressor\n&gt;&gt;&gt; from sklearn.datasets import load_digits\n&gt;&gt;&gt; from sklearn.model_selection import train_test_split\n\n&gt;&gt;&gt; X, y = load_digits(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; train, test = train_test_split(\n...     X.merge(y.to_frame(), left_index=True, right_index=True),\n...     test_size=0.3,\n... )\n\n&gt;&gt;&gt; runner = SuccessiveHalvingRegressor([\"OLS\", \"RF\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nMetric: r2\n\n\nRun: 0 =========================== &gt;&gt;\nModels: OLS2, RF2\nSize of training set: 1257 (50%)\nSize of test set: 540\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.634\nTest evaluation --&gt; r2: 0.5649\nTime elapsed: 0.422s\n-------------------------------------------------\nTime: 0.422s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.9687\nTest evaluation --&gt; r2: 0.7986\nTime elapsed: 0.536s\n-------------------------------------------------\nTime: 0.536s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.961s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5649\nRandomForest         --&gt; r2: 0.7986 !\n\n\nRun: 1 =========================== &gt;&gt;\nModels: RF1\nSize of training set: 1257 (100%)\nSize of test set: 540\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.979\nTest evaluation --&gt; r2: 0.8561\nTime elapsed: 0.962s\n-------------------------------------------------\nTime: 0.962s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.963s\n-------------------------------------\nRandomForest --&gt; r2: 0.8561\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> r2_train r2_test time_fit time frac model 0.500000 OLS2 0.634000 0.564900 0.422387 0.422387 RF2 0.968700 0.798600 0.536488 0.536488 1.000000 RF1 0.979000 0.856100 0.961875 0.961875"}, {"location": "api/training/successivehalvingregressor/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/successivehalvingregressor/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/successivehalvingregressor/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/successivehalvingregressor/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/successivehalvingregressor/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/successivehalvingregressor/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/trainsizingclassifier/", "title": "TrainSizingClassifier", "text": "class atom.training.TrainSizingClassifier(models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a train sizing fashion.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, a default metric is selected for every task: <ul> <li>\"f1\" for binary classification</li> <li>\"f1_weighted\" for multiclass(-multioutput) classification</li> <li>\"average_precision\" for multilabel classification</li> </ul> <p> train_sizes: int or sequence, default=5 Training set sizes used to run the trainings. <ul> <li>If int: Number of equally distributed splits, i.e., for a   value <code>N</code>, it's equal to <code>np.linspace(1.0/N, 1.0, N)</code>.</li> <li>If sequence: Fraction of the training set when &lt;=1, else   total number of samples.</li> </ul> <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMRegressor Main class for regression tasks.</p> <p>DirectRegressor Train and evaluate the models in a direct fashion.</p> <p>SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion.</p> <p></p>"}, {"location": "api/training/trainsizingclassifier/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import TrainSizingClassifier\n&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer\n&gt;&gt;&gt; from sklearn.model_selection import train_test_split\n\n&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; train, test = train_test_split(\n...     X.merge(y.to_frame(), left_index=True, right_index=True),\n...     test_size=0.3,\n... )\n\n&gt;&gt;&gt; runner = TrainSizingClassifier(models=\"LR\", verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nMetric: f1\n\n\nRun: 0 =========================== &gt;&gt;\nModels: LR02\nSize of training set: 79 (20%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9714\nTime elapsed: 0.239s\n-------------------------------------------------\nTime: 0.239s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.242s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9714\n\n\nRun: 1 =========================== &gt;&gt;\nModels: LR04\nSize of training set: 159 (40%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9894\nTest evaluation --&gt; f1: 0.9907\nTime elapsed: 0.230s\n-------------------------------------------------\nTime: 0.230s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.234s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9907\n\n\nRun: 2 =========================== &gt;&gt;\nModels: LR06\nSize of training set: 238 (60%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9898\nTest evaluation --&gt; f1: 0.9815\nTime elapsed: 0.234s\n-------------------------------------------------\nTime: 0.234s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.237s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9815\n\n\nRun: 3 =========================== &gt;&gt;\nModels: LR08\nSize of training set: 318 (80%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9925\nTest evaluation --&gt; f1: 0.9815\nTime elapsed: 0.238s\n-------------------------------------------------\nTime: 0.238s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.242s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9815\n\n\nRun: 4 =========================== &gt;&gt;\nModels: LR10\nSize of training set: 398 (100%)\nSize of test set: 171\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9921\nTest evaluation --&gt; f1: 0.986\nTime elapsed: 0.237s\n-------------------------------------------------\nTime: 0.237s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.240s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.986\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> f1_train f1_test time_fit time frac model 0.200000 LR02 1.000000 0.971400 0.239218 0.239218 0.400000 LR04 0.989400 0.990700 0.230210 0.230210 0.600000 LR06 0.989800 0.981500 0.234213 0.234213 0.800000 LR08 0.992500 0.981500 0.238216 0.238216 1.000000 LR10 0.992100 0.986000 0.237216 0.237216"}, {"location": "api/training/trainsizingclassifier/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/trainsizingclassifier/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/trainsizingclassifier/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/trainsizingclassifier/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/trainsizingclassifier/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/trainsizingclassifier/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/trainsizingforecaster/", "title": "TrainSizingForecaster", "text": "class atom.training.TrainSizingForecaster(models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a train sizing fashion.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, the default metric <code>mean_absolute_percentage_error</code> is selected. <p> train_sizes: int or sequence, default=5 Training set sizes used to run the trainings. <ul> <li>If int: Number of equally distributed splits, i.e., for a   value <code>N</code>, it's equal to <code>np.linspace(1.0/N, 1.0, N)</code>.</li> <li>If sequence: Fraction of the training set when &lt;=1, else   total number of samples.</li> </ul> <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMForecaster Main class for forecasting tasks.</p> <p>DirectForecaster Train and evaluate the models in a direct fashion.</p> <p>SuccessiveHalvingForecaster Train and evaluate the models in a successive halving fashion.</p> <p></p>"}, {"location": "api/training/trainsizingforecaster/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import TrainSizingForecaster\n&gt;&gt;&gt; from sktime.datasets import load_airline\n&gt;&gt;&gt; from sktime.split import temporal_train_test_split\n\n&gt;&gt;&gt; y = load_airline()\n\n&gt;&gt;&gt; train, test = temporal_train_test_split(y, test_size=0.2)\n\n&gt;&gt;&gt; runner = TrainSizingForecaster([\"Croston\", \"PT\"], verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nMetric: mape\n\n\nRun: 0 =========================== &gt;&gt;\nModels: Croston02, PT02\nSize of training set: 23 (20%)\nSize of test set: 29\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1463\nTest evaluation --&gt; mape: -0.1584\nTime elapsed: 0.016s\n-------------------------------------------------\nTime: 0.016s\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.117\nTest evaluation --&gt; mape: -0.1491\nTime elapsed: 0.019s\n-------------------------------------------------\nTime: 0.019s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.037s\n-------------------------------------\nCroston         --&gt; mape: -0.1584\nPolynomialTrend --&gt; mape: -0.1491 !\n\n\nRun: 1 =========================== &gt;&gt;\nModels: Croston04, PT04\nSize of training set: 46 (40%)\nSize of test set: 29\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.2336\nTest evaluation --&gt; mape: -0.1625\nTime elapsed: 0.016s\n-------------------------------------------------\nTime: 0.016s\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1145\nTest evaluation --&gt; mape: -0.1462\nTime elapsed: 0.018s\n-------------------------------------------------\nTime: 0.018s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.037s\n-------------------------------------\nCroston         --&gt; mape: -0.1625\nPolynomialTrend --&gt; mape: -0.1462 !\n\n\nRun: 2 =========================== &gt;&gt;\nModels: Croston06, PT06\nSize of training set: 69 (60%)\nSize of test set: 29\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.3769\nTest evaluation --&gt; mape: -0.1624\nTime elapsed: 0.016s\n-------------------------------------------------\nTime: 0.016s\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1155\nTest evaluation --&gt; mape: -0.1319\nTime elapsed: 0.019s\n-------------------------------------------------\nTime: 0.019s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.037s\n-------------------------------------\nCroston         --&gt; mape: -0.1624\nPolynomialTrend --&gt; mape: -0.1319 !\n\n\nRun: 3 =========================== &gt;&gt;\nModels: Croston08, PT08\nSize of training set: 92 (80%)\nSize of test set: 29\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.5556\nTest evaluation --&gt; mape: -0.1624\nTime elapsed: 0.015s\n-------------------------------------------------\nTime: 0.015s\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1108\nTest evaluation --&gt; mape: -0.1237\nTime elapsed: 0.018s\n-------------------------------------------------\nTime: 0.018s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.036s\n-------------------------------------\nCroston         --&gt; mape: -0.1624\nPolynomialTrend --&gt; mape: -0.1237 !\n\n\nRun: 4 =========================== &gt;&gt;\nModels: Croston10, PT10\nSize of training set: 115 (100%)\nSize of test set: 29\n\n\nResults for Croston:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.8149\nTest evaluation --&gt; mape: -0.1624\nTime elapsed: 0.016s\n-------------------------------------------------\nTime: 0.016s\n\n\nResults for PolynomialTrend:\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -0.1165\nTest evaluation --&gt; mape: -0.1207\nTime elapsed: 0.019s\n-------------------------------------------------\nTime: 0.019s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.037s\n-------------------------------------\nCroston         --&gt; mape: -0.1624\nPolynomialTrend --&gt; mape: -0.1207 !\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> mape_train mape_test time_fit time frac model 0.200000 Croston02 -0.146300 -0.158400 0.016015 0.016015 PT02 -0.117000 -0.149100 0.019016 0.019016 0.400000 Croston04 -0.233600 -0.162500 0.016015 0.016015 PT04 -0.114500 -0.146200 0.018016 0.018016 0.600000 Croston06 -0.376900 -0.162400 0.016014 0.016014 PT06 -0.115500 -0.131900 0.019017 0.019017 0.800000 Croston08 -0.555600 -0.162400 0.015014 0.015014 PT08 -0.110800 -0.123700 0.018016 0.018016 1.000000 Croston10 -0.814900 -0.162400 0.016015 0.016015 PT10 -0.116500 -0.120700 0.019019 0.019019"}, {"location": "api/training/trainsizingforecaster/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/trainsizingforecaster/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/trainsizingforecaster/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/trainsizingforecaster/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/trainsizingforecaster/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/trainsizingforecaster/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "api/training/trainsizingregressor/", "title": "TrainSizingRegressor", "text": "class atom.training.TrainSizingRegressor(models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, parallel=False, errors=\"skip\", n_jobs=1, device=\"cpu\", engine=None, backend=\"loky\", memory=False, verbose=0, warnings=False, logger=None, experiment=None, random_state=None)[source] <p>Train and evaluate the models in a train sizing fashion.</p> <p>The following steps are applied to every model (per iteration):</p> <ol> <li>Apply hyperparameter tuning (optional).</li> <li>Fit the model on the training set using the best combination    of hyperparameters found.</li> <li>Evaluate the model on the test set.</li> <li>Train the estimator on various bootstrapped    samples of the training set and evaluate again on the test set    (optional).</li> </ol> <p>Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models, an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. <p> metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers, a function with signature <code>function(y_true, y_pred, **kwargs) -&gt; score</code>, a scorer object or a sequence of these. If None, the default metric <code>r2</code> is selected. <p> train_sizes: int or sequence, default=5 Training set sizes used to run the trainings. <ul> <li>If int: Number of equally distributed splits, i.e., for a   value <code>N</code>, it's equal to <code>np.linspace(1.0/N, 1.0, N)</code>.</li> <li>If sequence: Fraction of the training set when &lt;=1, else   total number of samples.</li> </ul> <p> n_trials: int, dict or sequence, default=0 Maximum number of iterations for the hyperparameter tuning. If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. <p> est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add <code>_fit</code> to the parameter's name to pass it to the estimator's fit method instead of the constructor. <p> ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: <ul> <li>cv: int, cv-generator, dict or sequence, default=1   Cross-validation object or number of splits. If 1, the   data is randomly split in a subtrain and validation set.</li> <li>plot: bool, dict or sequence, default=False   Whether to plot the optimization's progress as it runs.   Creates a canvas with two plots: the first plot shows the   score of every trial and the second shows the distance between   the last consecutive steps. See the plot_trials method.</li> <li>distributions: dict, sequence or None, default=None   Custom hyperparameter distributions. If None, it uses the   model's predefined distributions. Read more in the   user guide.</li> <li>tags: dict, sequence or None, default=None   Custom tags for the model's trial and mlflow run.</li> <li>**kwargs   Additional Keyword arguments for the constructor of the   study class or the optimize method.</li> </ul> <p> n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping. If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. <p> parallel: bool, default=False Whether to train the models in a parallel or sequential fashion. Using <code>parallel=True</code> turns off the verbosity of the models during training. Note that many models also have build-in parallelizations (often when the estimator has the <code>n_jobs</code> parameter). <p> errors: str, default=\"skip\" How to handle exceptions encountered during model training. Choose from: <ul> <li>\"raise\": Raise any encountered exception.</li> <li>\"skip\": Skip a failed model. This model is not accessible   after training.</li> <li>\"keep\": Keep the model in its state at failure. Note that   this model can break down many other methods after training.   This option is useful to be able to rerun hyperparameter   optimization after failure without losing previous successful   trials.</li> </ul> <p> n_jobs: int, default=1 Number of cores to use for parallel processing. <ul> <li>If &gt;0: Number of cores to use.</li> <li>If -1: Use all available cores.</li> <li>If &lt;-1: Use number of cores - 1 + <code>n_jobs</code>.</li> </ul> <p> device: str, default=\"cpu\" Device on which to run the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. <code>device=\"gpu\"</code> to use the GPU. Read more in the user guide. <p> engine: str, dict or None, default=None Execution engine to use for data and estimators. The value should be one of the possible values to change one of the two engines, or a dictionary with keys <code>data</code> and <code>estimator</code>, with their corresponding choice as values to change both engines. If None, the default values are used. Choose from: <ul> <li> <p>\"data\":</p> <ul> <li>\"pandas\" (default)</li> <li>\"pyarrow\"</li> <li>\"modin\"</li> </ul> </li> <li> <p>\"estimator\":</p> <ul> <li>\"sklearn\" (default)</li> <li>\"sklearnex\"</li> <li>\"cuml\"</li> </ul> </li> </ul> <p> backend: str, default=\"loky\" Parallelization backend. Read more in the user guide. Choose from: <ul> <li>\"loky\": Single-node, process-based parallelism.</li> <li>\"multiprocessing\": Legacy single-node, process-based   parallelism. Less robust than <code>loky</code>.</li> <li>\"threading\": Single-node, thread-based parallelism.</li> <li>\"ray\": Multi-node, process-based parallelism.</li> <li>\"dask\": Multi-node, process-based parallelism.</li> </ul> <p> memory: bool, str, Path or Memory, default=False Enables caching for memory optimization. Read more in the user guide. <ul> <li>If False: No caching is performed.</li> <li>If True: A default temp directory is used.</li> <li>If str: Path to the caching directory.</li> <li>If Path: A pathlib.Path to the caching directory.</li> <li>If Memory: Object with the joblib.Memory interface.</li> </ul> <p> verbose: int, default=0 Verbosity level of the class. Choose from: <ul> <li>0 to not print anything.</li> <li>1 to print basic information.</li> <li>2 to print detailed information.</li> </ul> <p> warnings: bool or str, default=False <ul> <li>If True: Default warning action (equal to \"once\").</li> <li>If False: Suppress all warnings (equal to \"ignore\").</li> <li>If str: One of python's warnings filters.</li> </ul> <p>Changing this parameter affects the <code>PYTHONWarnings</code> environment. ATOM can't manage warnings that go from C/C++ code to stdout.</p> <p> logger: str, Logger or None, default=None <ul> <li>If None: Logging isn't used.</li> <li>If str: Name of the log file. Use \"auto\" for automatic name.</li> <li>If Path: A pathlib.Path to the log file.</li> <li>Else: Python <code>logging.Logger</code> instance.</li> </ul> <p> experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. <p> random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the <code>RandomState</code> used by <code>np.random</code>. <p></p> <p></p> <p>See Also</p> <p>ATOMRegressor Main class for regression tasks.</p> <p>DirectRegressor Train and evaluate the models in a direct fashion.</p> <p>SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion.</p> <p></p>"}, {"location": "api/training/trainsizingregressor/#example", "title": "Example", "text": "<pre><code>&gt;&gt;&gt; from atom.training import TrainSizingRegressor\n&gt;&gt;&gt; from sklearn.datasets import load_digits\n&gt;&gt;&gt; from sklearn.model_selection import train_test_split\n\n&gt;&gt;&gt; X, y = load_digits(return_X_y=True, as_frame=True)\n\n&gt;&gt;&gt; train, test = train_test_split(\n...     X.merge(y.to_frame(), left_index=True, right_index=True),\n...     test_size=0.3,\n... )\n\n&gt;&gt;&gt; runner = TrainSizingRegressor(models=\"OLS\", verbose=2)\n&gt;&gt;&gt; runner.run(train, test)\n\n\nTraining ========================= &gt;&gt;\nMetric: r2\n\n\nRun: 0 =========================== &gt;&gt;\nModels: OLS02\nSize of training set: 251 (20%)\nSize of test set: 540\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6693\nTest evaluation --&gt; r2: -2.253939285866036e+25\nTime elapsed: 0.421s\n-------------------------------------------------\nTime: 0.421s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.422s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: -2.253939285866036e+25 ~\n\n\nRun: 1 =========================== &gt;&gt;\nModels: OLS04\nSize of training set: 502 (40%)\nSize of test set: 540\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.5876\nTest evaluation --&gt; r2: 0.5775\nTime elapsed: 0.422s\n-------------------------------------------------\nTime: 0.422s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.423s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5775\n\n\nRun: 2 =========================== &gt;&gt;\nModels: OLS06\nSize of training set: 754 (60%)\nSize of test set: 540\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.5981\nTest evaluation --&gt; r2: 0.5703\nTime elapsed: 0.436s\n-------------------------------------------------\nTime: 0.436s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.437s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5703\n\n\nRun: 3 =========================== &gt;&gt;\nModels: OLS08\nSize of training set: 1005 (80%)\nSize of test set: 540\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.6127\nTest evaluation --&gt; r2: 0.5806\nTime elapsed: 0.443s\n-------------------------------------------------\nTime: 0.443s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.445s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5806\n\n\nRun: 4 =========================== &gt;&gt;\nModels: OLS10\nSize of training set: 1257 (100%)\nSize of test set: 540\n\n\nResults for OrdinaryLeastSquares:\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.5962\nTest evaluation --&gt; r2: 0.5876\nTime elapsed: 0.428s\n-------------------------------------------------\nTime: 0.428s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.430s\n-------------------------------------\nOrdinaryLeastSquares --&gt; r2: 0.5876\n\n&gt;&gt;&gt; # Analyze the results\n&gt;&gt;&gt; runner.results\n</code></pre> r2_train r2_test time_fit time frac model 0.200000 OLS02 0.669300 -22539392858660359219707904.000000 0.421384 0.421384 0.400000 OLS04 0.587600 0.577500 0.422385 0.422385 0.600000 OLS06 0.598100 0.570300 0.436396 0.436396 0.800000 OLS08 0.612700 0.580600 0.443404 0.443404 1.000000 OLS10 0.596200 0.587600 0.428391 0.428391"}, {"location": "api/training/trainsizingregressor/#attributes", "title": "Attributes", "text": ""}, {"location": "api/training/trainsizingregressor/#data-attributes", "title": "Data attributes", "text": "<p>The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly.</p> <p>Attributes dataset: pd.DataFrameComplete data set.  train: pd.DataFrameTraining set.  test: pd.DataFrameTest set.  X: pd.DataFrameFeature set.  y: pd.Series | pd.DataFrameTarget column(s).  holdout: pd.DataFrame | NoneHoldout set. <p>This data set is untransformed by the pipeline. Read more in the user guide.  X_train: pd.DataFrameFeatures of the training set.  y_train: pd.Series | pd.DataFrameTarget column(s) of the training set.  X_test: pd.DataFrameFeatures of the test set.  y_test: pd.Series | pd.DataFrameTarget column(s) of the test set.  shape: tuple[int, int]Shape of the dataset (n_rows, n_columns).  columns: pd.IndexName of all the columns.  n_columns: intNumber of columns.  features: pd.IndexName of the features.  n_features: intNumber of features.  target: str | list[str]Name of the target column(s). </p> <p></p>"}, {"location": "api/training/trainsizingregressor/#utility-attributes", "title": "Utility attributes", "text": "<p>The utility attributes are used to access information about the models in the instance after training.</p> <p>Attributes models: str | list[str] | NoneName of the model(s).  metric: str | list[str] | NoneName of the metric(s).  winners: list[model] | NoneModels ordered by performance. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  winner: model | NoneBest performing model. <p>Performance is measured as the highest score on the model's <code>[main_metric]_bootstrap</code> or <code>[main_metric]_test</code>, checked in that order. Ties are resolved looking at the lowest <code>time_fit</code>.  results: StylerOverview of the training results. <p>All durations are in seconds. Possible values include:</p> <ul> <li>[metric]_ht: Score obtained by the hyperparameter tuning.</li> <li>time_ht: Duration of the hyperparameter tuning.</li> <li>[metric]_train: Metric score on the train set.</li> <li>[metric]_test: Metric score on the test set.</li> <li>time_fit: Duration of the model fitting on the train set.</li> <li>[metric]_bootstrap: Mean score on the bootstrapped samples.</li> <li>time_bootstrap: Duration of the bootstrapping.</li> <li>time: Total duration of the run.</li> </ul> <p>Tip</p> <p>This attribute returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p></p> <p></p>"}, {"location": "api/training/trainsizingregressor/#tracking-attributes", "title": "Tracking attributes", "text": "<p>The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide.</p> <p>Attributes log_ht: boolWhether to track every trial of the hyperparameter tuning.  log_plots: boolWhether to save plots as artifacts.  log_data: boolWhether to save the train and test sets.  log_pipeline: boolWhether to save the model's pipeline. </p> <p></p>"}, {"location": "api/training/trainsizingregressor/#plot-attributes", "title": "Plot attributes", "text": "<p>The plot attributes are used to customize the plot's aesthetics. Read more in the user guide.</p> <p>Attributes palette: str | Sequence[str]Color palette. <p>Specify one of plotly's built-in palettes or create a custom one, e.g., <code>atom.palette = [\"red\", \"green\", \"blue\"]</code>.  title_fontsize: int | floatFontsize for the plot's title.  label_fontsize: int | floatFontsize for the labels, legend and hover information.  tick_fontsize: int | floatFontsize for the ticks along the plot's axes.  line_width: int | floatWidth of the line plots.  marker_size: int | floatSize of the markers. </p> <p></p>"}, {"location": "api/training/trainsizingregressor/#methods", "title": "Methods", "text": "<p>Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline.</p> <p>available_modelsGive an overview of the available predefined models.canvasCreate a figure with multiple plots.clearReset attributes and clear cache from all models.deleteDelete models.evaluateGet all models' scores for the provided metrics.export_pipelineExport the internal pipeline.get_class_weightReturn class weights for a balanced data set.get_paramsGet parameters for this estimator.mergeMerge another instance of the same class into this one.update_layoutUpdate the properties of the plot's layout.update_tracesUpdate the properties of the plot's traces.reset_aestheticsReset the plot aesthetics to their default values.runTrain and evaluate the models.saveSave the instance to a pickle file.set_paramsSet the parameters of this estimator.stackingAdd a Stacking model to the pipeline.votingAdd a Voting model to the pipeline.</p> <p></p> <p></p> method available_models(**kwargs)[source] <p>Give an overview of the available predefined models.</p> <p>Parameters **kwargs Filter the returned models providing any of the column as keyword arguments, where the value is the desired filter, e.g., <code>accepts_sparse=True</code>, to get all models that accept sparse input or <code>supports_engines=\"cuml\"</code> to get all models that support the cuML engine. <p>Returns pd.DataFrame Tags of the available predefined models. The columns depend on the task, but can include: <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing   values without preprocessing. If False, consider using the   Imputer class before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling.   If True, automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than   one seasonality period.</li> <li>native_multilabel: Whether the model has native support   for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support   for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model. </li> </ul> <p></p> <p></p> method canvas(rows=1, cols=2, sharex=False, sharey=False, hspace=0.05, vspace=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True)[source] <p>Create a figure with multiple plots.</p> <p>This <code>@contextmanager</code> allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example.</p> <p>Parameters rows: int, default=1 Number of plots in length. <p> cols: int, default=2 Number of plots in width. <p> sharex: bool, default=False If True, hide the label and ticks from non-border subplots on the x-axis. <p> sharey: bool, default=False If True, hide the label and ticks from non-border subplots on the y-axis. <p> hspace: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. <p> vspace: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. <p> title: str, dict or None, default=None Title for the plot. <ul> <li>If None, no title is shown.</li> <li>If str, text for the title.</li> <li>If dict, title configuration.</li> </ul> <p> legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. <ul> <li>If None: No legend is shown.</li> <li>If str: Position to display the legend.</li> <li>If dict: Legend configuration.</li> </ul> <p> figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. <p> filename: str, Path or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If <code>filename</code> has no file type, the plot is saved as html. If None, the plot is not saved. <p> display: bool, default=True Whether to render the plot. <p>Yields{#canvas-go.Figure} go.Figure Plot object. </p> <p></p> <p></p> method clear()[source] <p>Reset attributes and clear cache from all models.</p> <p>Reset certain model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The affected attributes are:</p> <ul> <li>In-training validation scores</li> <li>Shap values</li> <li>App instance</li> <li>Dashboard instance</li> <li>Calculated holdout data sets</li> </ul> <p></p> <p></p> method delete(models=None)[source] <p>Delete models.</p> <p>If all models are removed, the metric is reset. Use this method to drop unwanted or to free some memory before saving. Deleted models are not removed from any active mlflow experiment.</p> <p>Parameters models: int, str, Model, segment, sequence or None, default=None Models to delete. If None, all models are deleted. </p> <p></p> <p></p> method evaluate(metric=None, rows=\"test\")[source] <p>Get all models' scores for the provided metrics.</p> <p>Tip</p> <p>This method returns a pandas' Styler object. Convert the result back to a regular dataframe using its <code>data</code> attribute.</p> <p>Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. <p> rows: hashable, segment, sequence or dataframe, default=\"test\" Selection of rows to calculate metric on. <p>Returns{#evaluate-Styler} Styler Scores of the models. </p> <p></p> <p></p> method export_pipeline(model=None)[source] <p>Export the internal pipeline.</p> <p>This method returns a deepcopy of the branch's pipeline. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set.</p> <p>Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling, the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported (without any model). <p>Returns{#export_pipeline-Pipeline} Pipeline Current branch as a sklearn-like Pipeline object. </p> <p></p> <p></p> method get_class_weight(rows=\"train\")[source] <p>Return class weights for a balanced data set.</p> <p>Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected rows.</p> <p>Parameters rows: hashable, segment, sequence or dataframe, default=\"train\" Selection of rows for which to get the weights. <p>Returns dict Classes with the corresponding weights. A dict of dicts is returned for multioutput tasks. </p> <p></p> <p></p> method get_params(deep=True)[source] <p>Get parameters for this estimator.</p> <p>Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. <p>Returns params : dict Parameter names mapped to their values. </p> <p></p> <p></p> method merge(other, suffix=\"2\")[source] <p>Merge another instance of the same class into this one.</p> <p>Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the <code>suffix</code> parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric.</p> <p>Parameters other: Runner Instance with which to merge. Should be of the same class as self. <p> suffix: str, default=\"2\" Branches and models with conflicting names are merged adding <code>suffix</code> to the end of their names. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_layout(**kwargs)[source] <p>Update the properties of the plot's layout.</p> <p>Recursively update the structure of the original layout with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_layout method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.update_traces(**kwargs)[source] <p>Update the properties of the plot's traces.</p> <p>Recursively update the structure of the original traces with the values in the arguments.</p> <p>Parameters **kwargs Keyword arguments for the figure's update_traces method. </p> <p></p> <p></p> classmethod atom.plots.baseplot.reset_aesthetics()[source] <p>Reset the plot aesthetics to their default values.</p> <p></p> <p></p> method run(*arrays)[source] <p>Train and evaluate the models.</p> <p>Read more in the user guide.</p> <p>Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: <ul> <li>train, test</li> <li>X_train, X_test, y_train, y_test</li> <li>(X_train, y_train), (X_test, y_test) </li> </ul> <p></p> <p></p> method save(filename=\"auto\", save_data=True)[source] <p>Save the instance to a pickle file.</p> <p>Parameters filename: str or Path, default=\"auto\" Filename or pathlib.Path of the file to save. Use \"auto\" for automatic naming. <p> save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, add the data to the load method to reload the instance. </p> <p></p> <p></p> method set_params(**params)[source] <p>Set the parameters of this estimator.</p> <p>Parameters **params : dict Estimator parameters. <p>Returns self : estimator instance Estimator instance. </p> <p></p> <p></p> method stacking(models=None, name=\"Stack\", train_on_test=False, **kwargs)[source] <p>Add a Stacking model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: <code>Stack</code>. <p> train_on_test: bool, default=False Whether to train the final estimator of the stacking model on the test set instead of the training set. Note that training it on the training set (default option) means there is a high risk of overfitting. It's recommended to use this option if you have another, independent set for testing (holdout set). <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: StackingClassifier.</li> <li>For regression tasks: StackingRegressor.</li> <li>For forecast tasks: StackingForecaster.</li> </ul> <p>Tip</p> <p>The model's acronyms can be used for the <code>final_estimator</code> parameter, e.g., <code>atom.stacking(final_estimator=\"LR\")</code>.</p> <p></p> <p></p> <p></p> method voting(models=None, name=\"Vote\", **kwargs)[source] <p>Add a Voting model to the pipeline.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p> <p>Parameters models: segment, sequence or None, default=None Models that feed the stacking estimator. The models must have been fitted on the current branch. <p> name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: <code>Vote</code>. <p> **kwargs Additional keyword arguments for one of these estimators. <ul> <li>For classification tasks: VotingClassifier.</li> <li>For regression tasks: VotingRegressor.</li> <li>For forecast tasks: EnsembleForecaster. </li> </ul> <p></p>"}, {"location": "changelog/v4.x.x/", "title": "Release history", "text": ""}, {"location": "changelog/v4.x.x/#version-4141", "title": "Version 4.14.1", "text": "<ul> <li>Fixed an installation issue with <code>conda</code>.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-4140", "title": "Version 4.14.0", "text": "<ul> <li>Refactor of the Cleaner and Vectorizer classes.</li> <li>Refactor of the cross_validate method.</li> <li>The plot_pipeline method now supports drawing multiple pipelines.</li> <li>Renamed the <code>Normalizer</code> class to <code>TextNormalizer</code>.</li> <li>Renamed the <code>Gauss</code> class to <code>Normalizer</code>.</li> <li>Added the <code>inverse_transform</code> method to the Scaler, Normalizer   and Cleaner classes.</li> <li>Added the <code>winners</code> property to the trainers (note the extra <code>s</code>).</li> <li>Added the <code>feature_names_in_</code> and <code>n_features_in_</code> attributes to transformers.</li> <li>The default value of the <code>warnings</code> parameter is set to False.</li> <li>Improvements for multicollinearity removal in FeatureSelector.</li> <li>Renamed default feature names to <code>x0</code>, <code>x1</code>, etc... for consistency with   sklearn's API.</li> <li>Renamed component names in FeatureSelector   to <code>pca0</code>, <code>pca1</code>, etc... for consistency with sklearn's API.</li> <li>Significant speed up in pipeline transformations.</li> <li>Fixed a bug where mlflow runs could be ended unexpectedly.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-4131", "title": "Version 4.13.1", "text": "<ul> <li>Fixed an installation issue.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-4130", "title": "Version 4.13.0", "text": "<ul> <li>Added GPU support. Read more in the user guide.</li> <li>Added advanced feature selection strategies.</li> <li>Added the <code>return_sparse</code> parameter to the Vectorizer class.</li> <li>Added the <code>quantile</code> hyperparameter to the Dummy model.</li> <li>The data attributes now return pandas objects where possible.</li> <li>Fixed a bug where the BO could crash after balancing   the data.</li> <li>Fixed a bug where saving the FeatureGenerator   class could fail for certain operators.</li> <li>Fixed a bug where the FeatureSelector   class displayed the wrong output.</li> <li>Fixed a bug where the <code>mapping</code> attribute was not reordered.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-4120", "title": "Version 4.12.0", "text": "<ul> <li>Support for Python 3.10.</li> <li>New Discretizer class to bin numerical features.</li> <li>Refactor of the FeatureGenerator class.</li> <li>The <code>mapping</code> attribute now shows all encoded features.</li> <li>Added the <code>sample_weight</code> parameter to the evaluate method.</li> <li>ATOMClassifier has now a <code>stratify</code> parameter   to split the data sets in a stratified fashion.</li> <li>Possibility to exclude hyperparameters from the BO adding <code>!</code> before the name.</li> <li>Added memory usage to the stats method.</li> <li>Fixed a bug where plot_shap_decision could fail when only one row was plotted.</li> <li>Added versioning to the documentation.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-4110", "title": "Version 4.11.0", "text": "<ul> <li>Full support for sparse matrices. Read more in the user guide.</li> <li>The shrink method now also handles sparse features.</li> <li>Refactor of the distributions method.</li> <li>Added three new linear models: Lars, Huber and Perc.</li> <li>Dimensions can be shared across models using the key 'all' in <code>ht_params[\"dimensions\"]</code>.</li> <li>Assign hyperparameters to tune using the predefined dimensions.</li> <li>It's now possible to tune a custom number of layers for the MLP   model.</li> <li>If multiple BO calls share the best score, the one with the shortest   training time is selected as winner (instead of the first).</li> <li>Fixed a bug where the BO could fail when custom dimensions where defined.</li> <li>Fixed a bug where FeatureSelector   could fail after repeated calls to fit.</li> <li>Fixed a bug where FeatureGenerator   didn't pass the correct data indices to its output.</li> <li>Performance improvements for the custom pipeline.</li> <li>Minor documentation fixes.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-4100", "title": "Version 4.10.0", "text": "<ul> <li>Added the <code>holdout</code> data set to have an extra way of assessing a   model's performance on a completely independent dataset. Read more   in the user_guide.</li> <li>Complete rework of the ensemble models.</li> <li>Support for dataframe indexing. Read more in the user guide.</li> <li>New plot_parshap plot to detect overfitting   features.</li> <li>The new create_dashboard method makes analyzing   the models even easier using a dashboard app.</li> <li>The plot_feature_importance   plot now also accepts estimators with coefficients.</li> <li>Added the transform method for models.</li> <li>Added the <code>threshold</code> parameter to the evaluate method.</li> <li>The <code>reset_predictions</code> method is deprecated in favour of the new   clear method.</li> <li>Refactor of the model's full_train method.</li> <li>The merge method is available for all trainers.</li> <li>Improvements in the trainer's pipeline.</li> <li>Training scores are now also saved to the mlflow run.</li> <li>Trying to change the data in a branch after fitting a model with it now   raises an exception.</li> <li>Fixed a bug where the columns of array inputs were not ordered correctly.</li> <li>Fixed a bug where branches did not correctly act case-insensitive.</li> <li>Fixed a bug where the export_pipeline   method for models would not export the transformers in the correct branch.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-491", "title": "Version 4.9.1", "text": "<ul> <li>Changed the default cross-validation for hyperparameter tuning   from 5 to 1 to avoid errors with deep learning models.</li> <li>Added clearer exception messages when a model's run failed.</li> <li>Fixed a bug where custom dimensions didn't show during   hyperparameter tuning.</li> <li>Documentation improvements.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-490", "title": "Version 4.9.0", "text": "<ul> <li>Drop support of Python 3.6.</li> <li>Added the HistGBM model.</li> <li>Improved print layout for hyperparameter tuning.</li> <li>The new available_models method returns an overview of   the available predefined models.</li> <li>The calibrate and cross_validate   methods can no longer be accessed from the trainers.</li> <li>The <code>pipeline</code> parameter for the prediction methods is deprecated.</li> <li>Improved visualization of the plot_rfecv, plot_successive_halving and   plot_learning_curve methods.</li> <li>Sparse matrices are now accepted as input.</li> <li>Duplicate BO calls are no longer calculated.</li> <li>Improvement in performance of the RNN model.</li> <li>Refactor of the model's <code>bo</code> attribute.</li> <li>Predefined hyperparameters have been updated to be consistent with sklearn's API.</li> <li>Fixed a bug where custom scalers were ignored by the models.</li> <li>Fixed a bug where the BO of certain models would crash with custom hyperparameters.</li> <li>Fixed a bug where duplicate column names could be generated from a custom transformer.</li> <li>Documentation improvements.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-480", "title": "Version 4.8.0", "text": "<ul> <li>The Encoder class now directly handles   unknown categories encountered during fitting.</li> <li>The Balancerand Encoder classes now accept custom estimators for   the <code>strategy</code> parameter.</li> <li>The new merge method enables the user to merge   multiple atom instances into one.</li> <li>The dtype shrinking is moved from atom's initializers to the   shrink method.</li> <li>ATOM's custom pipeline now handles transformers fitted on a   subset of the dataset.</li> <li>The <code>column</code> parameter in the distributions   method is renamed to <code>columns</code> for continuity of the API.</li> <li>The <code>mae</code> criterion for the GBM model hyperparameter tuning is deprecated   to be consistent with sklearn's API.</li> <li>Branches are now case-insensitive.</li> <li>Renaming a branch using an existing name now raises an exception.</li> <li>Fixed a bug where columns of type <code>category</code> broke the Imputer class.</li> <li>Fixed a bug where predictions of the Stacking ensemble crashed for   branches with multiple transformers.</li> <li>The tables in the documentation now adapt to dark mode.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-473", "title": "Version 4.7.3", "text": "<ul> <li>Fixed a bug where the conda-forge recipe couldn't install properly.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-472", "title": "Version 4.7.2", "text": "<ul> <li>Fixed a bug where the pipeline failed for custom transformers that   returned sparse matrices.</li> <li>Package requirements files are added to the installer.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-471", "title": "Version 4.7.1", "text": "<ul> <li>Fixed a bug where the pip installer failed.</li> <li>Fixed a bug where categorical columns also selected datetime columns.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-470", "title": "Version 4.7.0", "text": "<ul> <li>Launched our new slack channel!</li> <li>The new FeatureExtractor class extracts useful features from datetime columns.</li> <li>The new plot_det method plots a binary classifier's detection error tradeoff curve.</li> <li>The plot_partial_dependence is able to draw Individual Conditional Expectation (ICE) lines.</li> <li>The full traceback of exceptions encountered during training are now   saved to the logger.</li> <li>ATOMClassifier and ATOMRegressor now convert the dtypes of the input   data to the minimal allowed type for memory efficiency.</li> <li>The scoring method is renamed to evaluate to clarify its purpose.</li> <li>The <code>column</code> parameter in the apply method   is renamed to <code>columns</code> for continuity of the API.</li> <li>Minor documentation improvements.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-460", "title": "Version 4.6.0", "text": "<ul> <li>Added the full_train method to retrieve an estimator trained   on the complete dataset.</li> <li>The <code>score</code> method is now also able to calculate custom metrics on new data.</li> <li>Refactor of the Imputer class.</li> <li>Refactor of the Encoder class to avoid errors for unknown classes and allow   the input of missing values.</li> <li>The clean method no longer automatically   encodes the target column for regression tasks.</li> <li>Creating a branch using a models' acronym as name now raises an exception.</li> <li>Fixed a bug where CatBoost failed when <code>early_stopping</code> &lt; 1.</li> <li>Fixed a bug where created pipelines had duplicated names.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-450", "title": "Version 4.5.0", "text": "<ul> <li>Support of NLP pipelines. Read more in the user guide.</li> <li>Integration of mlflow to track all models in the   pipeline. Read more in the user guide.</li> <li>The new Normalizer class transforms features to a more Gaussian-like distribution.</li> <li>New cross_validate method to evaluate the robustness   of a pipeline using cross_validation.</li> <li>New reset method to go back to atom's initial state.</li> <li>Added the Dummy model to compare other models with a simple baseline.</li> <li>New plot_wordcloud and plot_ngrams methods for text visualization.</li> <li>Plots now can return the figure object when <code>display=None</code>.</li> <li>The Pruner class can now able to drop outliers   based on the selection of multiple strategies.</li> <li>The new <code>shuffle</code> parameter in atom's initializer determines whether to   shuffle the dataset.</li> <li>The trainers no longer require you to specify a model using the <code>models</code>   parameter. If left to default, all predefined models for that task are used.</li> <li>The apply method now accepts args and kwargs for the function.</li> <li>Refactor of the evaluate method.</li> <li>Refactor of the export_pipeline method.</li> <li>The parameters in the Cleaner class have been refactored to better describe   their function.</li> <li>The <code>train_sizes</code> parameter in train_sizing now accepts integer   values to automatically create equally distributed splits in the training set.</li> <li>Refactor of plot_pipeline to show models in the diagram as well.</li> <li>Refactor of the <code>bagging</code> parameter to the (more appropriate) name <code>n_bootstrap</code>.</li> <li>New option to exclude columns from a transformer adding <code>!</code> before their name.</li> <li>Fixed a bug where the Pruner class failed if there were categorical columns   in the dataset.</li> <li>Completely reworked documentation website.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-440", "title": "Version 4.4.0", "text": "<ul> <li>New apply method to perform data transformations   as function to the pipeline</li> <li>Added the status method to save an overview of   atom's branches and models to the logger.</li> <li>Improved the output messages for the Imputer class.</li> <li>The dataset's columns can now be called directly from atom.</li> <li>The distributions and plot_distribution   methods now ignore missing values.</li> <li>Fixed a bug where transformations could fail when columns were added to the   dataset after initializing the pipeline.</li> <li>Fixed a bug where the Cleaner class didn't drop   columns consisting entirely of missing values when <code>drop_min_cardinality=True</code>.</li> <li>Fixed a bug where the winning model wasn't displayed correctly.</li> <li>Refactored the way transformers are added or removed from predicting methods.</li> <li>Improved documentation.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-430", "title": "Version 4.3.0", "text": "<ul> <li>Possibility to add custom transformers to the pipeline.</li> <li>The export_pipeline utility method exports   atom's current pipeline to a sklearn object.</li> <li>New magic methods makes atom behave similarly to sklearn's Pipeline.</li> <li>All training approaches can now be combined in the same atom instance.</li> <li>New plot_relationships, plot_distribution and plot_qq plots for data inspection.</li> <li>Complete rework of all the shap plots to be consistent with their new API.</li> <li>Improvements for the Scaler and [Pruner]([] classes.</li> <li>The acronym for custom models now defaults to the capital letters in the class' __name__.</li> <li>Possibility to apply transformations on only a subset of the columns.</li> <li>Plots and methods now accept <code>winner</code> as model name.</li> <li>Fixed a bug where custom metrics didn't show the correct name.</li> <li>Fixed a bug where timers were not displayed correctly.</li> <li>Further compatibility with deep learning datasets.</li> <li>Large refactoring for performance optimization.</li> <li>Cleaner output of messages to the logger.</li> <li>Plots no longer show a default title.</li> <li>Minor bug fixes.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-421", "title": "Version 4.2.1", "text": "<ul> <li>Bug fix where there was memory leakage in successive halving   and train sizing pipelines.</li> <li>Improved documentation.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-420", "title": "Version 4.2.0", "text": "<ul> <li>Possibility to add custom models to the pipeline using ATOMModel.</li> <li>Compatibility with deep learning models.</li> <li>New branch system for different data pipelines. Read more in the user guide.</li> <li>Use the canvas contextmanager to draw multiple plots in one figure.</li> <li>New voting and stacking ensemble techniques.</li> <li>New get_class_weight utility method.</li> <li>New Sequential Feature Selection strategy for the FeatureSelector.</li> <li>Added the <code>sample_weight</code> parameter to the <code>score</code> method.</li> <li>New ways to initialize the data in the <code>training</code> instances.</li> <li>The <code>test_size</code> parameter now also allows integer values.</li> <li>Renamed categories to classes to be consistent with sklearn's API.</li> <li>The class property now returns a pd.DataFrame of the number of rows per target class   in the train, test and complete dataset.</li> <li>Possibility to add custom parameters to an estimator's fit method through <code>est_params</code>.</li> <li>The successive halving and train sizing approaches now both allow subsequent   runs from atom without losing the information from previous runs.</li> <li>Bug fix where ATOMLoader wouldn't encode the target column during transformation.</li> <li>Added the Deep learning, Ensembles   and Utilities example notebooks.</li> <li>Support for python 3.9.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-410", "title": "Version 4.1.0", "text": "<ul> <li>New <code>est_params</code> parameter to customize the parameters in every model's estimator.</li> <li>Following skopt's API, the <code>n_random_starts</code> parameter to specify the number   of random trials is deprecated in favour of <code>n_initial_points</code>.</li> <li>The Balancer class now allows you to use any of the   strategies from imblearn.</li> <li>New utility attributes to inspect the dataset.</li> <li>Four new models: CatNB, CNB, ARD and RNN.</li> <li>Added the models section to the documentation.</li> <li>Small changes in log outputs.</li> <li>Bug fixes and performance improvements.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-401", "title": "Version 4.0.1", "text": "<ul> <li>Bug fix where the FeatureGenerator was not deterministic for a fixed random state.</li> <li>Bug fix where subsequent runs with the same metric failed.</li> <li>Added the license file to the package's installer.</li> <li>Typo fixes in documentation.</li> </ul>"}, {"location": "changelog/v4.x.x/#version-400", "title": "Version 4.0.0", "text": "<ul> <li>Bayesian optimization package changed from GpyOpt   to skopt.</li> <li>Complete revision of the model's hyperparameters.</li> <li>Four SHAP plots can now be called directly from an ATOM pipeline.</li> <li>Two new plots for regression tasks.</li> <li>New plot_pipeline and <code>pipeline</code> attribute to access all transformers.</li> <li>Possibility to determine transformer parameters per method.</li> <li>New calibrate and plot_calibration methods.</li> <li>Metrics can now be added as scorers or functions with signature metric(y, y_pred, **kwargs).</li> <li>Implementation of multi-metric runs.</li> <li>Possibility to choose which metric to plot.</li> <li>Early stopping for models that allow in-training validation.</li> <li>Added the <code>ATOMLoader</code> function to load any saved pickle instance.</li> <li>The \"remove\" strategy in the data cleaning parameters is deprecated in favour of \"drop\".</li> <li>Implemented the dfs strategy in FeatureGenerator.</li> <li>All training classes now inherit from BaseEstimator.</li> <li>Added multiple new example notebooks.</li> <li>Tests coverage up to 100%.</li> <li>Completely new documentation page.</li> <li>Bug fixes and performance improvements.</li> </ul>"}, {"location": "changelog/v5.x.x/", "title": "Release history", "text": ""}, {"location": "changelog/v5.x.x/#version-520", "title": "Version 5.2.0", "text": "<p> New features</p> <ul> <li>Two new plot methods: plot_terminator_improvement and plot_timeline.</li> </ul> <p> Enhancements</p> <ul> <li>Data splits in every trial are now properly stratified according to the   selected strategy.</li> <li>Performance optimization for multiple methods using smart caching.</li> <li>Improved visualizations for plots with logarithmic hyperparameters.</li> </ul> <p> Bug fixes</p> <ul> <li>Fixed a bug where parameters in a trial would not match with those displayed.</li> </ul> <p></p>"}, {"location": "changelog/v5.x.x/#version-512", "title": "Version 5.1.2", "text": "<p> API changes</p> <ul> <li>The default <code>strategy</code> for the <code>encode</code> method has   changed from \"LeaveOneOut\" to \"Target\"-encoding. LeaveOneOut is no longer a   supported strategy.</li> </ul> <p> Bug fixes</p> <ul> <li>Fixed a bug where stratification failed for datasets where the target column was   not placed last.</li> <li>Fixed a bug where transformers with no <code>get_feature_names_out</code> method could fail.</li> <li>Fixed a bug where the FeatureSelector class could fail when transforming a   dataset with different column order than seen at fit time.</li> </ul> <p></p>"}, {"location": "changelog/v5.x.x/#version-511", "title": "Version 5.1.1", "text": "<p> API changes</p> <ul> <li>The <code>infrequent_to_value</code> parameter in the Encoder class is replaced with   <code>infrequent_to_value</code> to be consistent with sklearn's naming convention.</li> </ul> <p> Enhancements</p> <ul> <li>Added the <code>kwargs</code> parameter to the save_data method.</li> </ul> <p> Bug fixes</p> <ul> <li>Fixed an installation issue for systems without an x86 architecture.</li> <li>Fixed a bug where Voting would fail for certain metrics.</li> <li>Fixed a bug where the time metric in mlflow was always zero.</li> <li>Fixed a bug where shap plots wouldn't display the full column names.</li> <li>Fixed a bug where column names where not properly propagated during   transformation.</li> </ul> <p></p>"}, {"location": "changelog/v5.x.x/#version-510", "title": "Version 5.1.0", "text": "<p> New features</p> <ul> <li>Support for multilabel classification, multiclass-multilabel classification   and multioutput regression tasks. Read more in the user guide.</li> <li>New backend parameter to choose a parallel execution   backend.</li> <li>New <code>parallel</code> parameter to train multiple models   simultaneously.</li> <li>Integration with DAGsHub to store your mlflow experiments.   Read more in the user guide.</li> <li>New serve method to deploy models to a rest API endpoint.</li> <li>New get_best_threshold method to calculate the   optimal threshold for binary and multilabel tasks.</li> <li>New get_sample_weight method to calculate   the sample weights for a balanced data set.</li> </ul> <p> API changes</p> <ul> <li>The <code>ATOMLoader</code> class is deprecated in favor of the load method.</li> <li>The <code>errors</code> attribute for runners is deprecated.</li> </ul> <p> Enhancements</p> <ul> <li>Added three new notebook examples.</li> <li>Added the <code>drop_chars</code> parameter to the Cleaner class.</li> <li>Added the <code>errors</code> parameter to the trainers.</li> <li>Rework of the dependencies, making the base package more lightweight.</li> <li>The logging entries for external libraries are redirected to atom's   file handler.</li> </ul> <p> Bug fixes</p> <ul> <li>Fixed multiple errors that appeared after sklearn's 1.2 update.</li> <li>Fixed a bug where hyperparameter tuning could fail for multi-metric runs.</li> <li>Fixed a bug where trials would try to report multiple times the same step.</li> <li>Fixed a bug where custom models could skip in-training validation.</li> <li>Fixed an issue where the bootstrapping estimators were trained using   <code>partial_fit</code>.</li> </ul> <p></p>"}, {"location": "changelog/v5.x.x/#version-501", "title": "Version 5.0.1", "text": "<p> Bug fixes</p> <ul> <li>Fixed installation issue.</li> <li>Updated package dependencies.</li> </ul> <p></p>"}, {"location": "changelog/v5.x.x/#version-500", "title": "Version 5.0.0", "text": "<p> New features</p> <ul> <li>Completely new hyperparameter tuning process.</li> <li>Completely reworked plotting interface.</li> <li>Accelerate your pipelines with sklearnex.</li> <li>New FeatureGrouper class to extract statistical features from   similar groups.</li> <li>New create_app method to create a nice front-end   for model predictions.</li> <li>New inverse_transform method for   atom and models.</li> <li>New linear model: OrthogonalMatchingPursuit.</li> <li>The plot_results method now accepts time metrics.</li> </ul> <p> API changes</p> <ul> <li>The <code>gpu</code> parameter is deprecated in favor of <code>device</code>   and <code>engine</code>.</li> <li>Refactor of the Cleaner, Discretizer, Encoder and FeatureSelector   classes.</li> <li>Refactor of all shap plots.</li> <li>Refactor of the apply method.</li> <li>The <code>plot_scatter_matrix</code> method is renamed to plot_relationships.</li> <li>The <code>kSVM</code> model is renamed to SVM.</li> <li>Multidimensional datasets are no longer supported. Check the deep learning   section of the user guide for guidance with such datasets.</li> <li>The <code>greater_is_better</code>, <code>needs_proba</code> and <code>needs_threshold</code> parameters are   deprecated. Metric functions are now created using make_scorer's   default parameters.</li> <li>The <code>drop</code> method is removed from atom. Use the reworked apply   method instead.</li> <li>The prediction methods can no longer be called from atom.</li> <li>The dashboard method for models is now called create_dashboard.</li> </ul> <p> Enhancements</p> <ul> <li>New examples for plotting, automated feature scaling,   pruning and advanced hyperparameter tuning.</li> <li>The Normalizer class can now be accelerated with GPU.</li> <li>The Scaler class now ignores binary columns (only 0s and 1s).</li> <li>The <code>models</code> parameter in plot and utility methods now accepts model indices.</li> <li>The transform method now also transforms   only <code>y</code> when <code>X</code> has a default value.</li> <li>The prediction methods now return pandas objects.</li> <li>Dependency versions are checked with originals after unpickling.</li> <li>Automatic generation of documentation from docstrings.</li> <li>Improvements in documentation display for mobile phones.</li> <li>New <code>feature_importance</code> attribute for models.</li> <li>Added a visualization for automated feature scaling to plot_pipeline.</li> </ul> <p> Bug fixes</p> <ul> <li>The FeatureExtractor class no longer raises a warning for highly   fragmented dataframes.</li> <li>Fixed a bug where models could not call the <code>score</code> function.</li> <li>The Encoder class no longer fails when the user provides ordinal   values that are not present during fitting.</li> <li>Fixed a bug with the <code>max_nan_rows</code> parameter in the Imputer class.</li> <li>Fixed a bug where Tokenizer could fail when no ngrams were found.</li> </ul>"}, {"location": "changelog/v6.x.x/", "title": "Release history", "text": ""}, {"location": "changelog/v6.x.x/#version-610", "title": "Version 6.1.0", "text": "<p> New features</p> <ul> <li>Support for metadata routing, to pass data such as   <code>sample_weight</code> to estimators, scorers, and CV splitters. Read more in   the user guide.</li> <li>Two new plots: plot_data_splits and plot_cv_splits.</li> <li>New set_threshold method to change the   threshold of a binary classifier.</li> <li>New <code>pos_label</code> attribute to specify the   positive label for binary and multilabel classification tasks.</li> </ul> <p> API changes</p> <ul> <li>The <code>threshold</code> parameter in the evaluate method   is deprecated in favour of the set_threshold   method.</li> <li>Stratification over multiple columns is no longer possible.</li> </ul> <p> Enhancements</p> <ul> <li>The Imputer class now supports custom strategies for numerical columns   by passing a function in place of a strategy name.</li> <li>Refactor of the cross-validation splitting strategy.</li> <li>Documentation improvements.</li> </ul> <p> Bug fixes</p> <ul> <li>Fix a bug in <code>conda</code> dependencies for Windows and macOS.</li> </ul> <p></p>"}, {"location": "changelog/v6.x.x/#version-601", "title": "Version 6.0.1", "text": "<p> New features</p> <ul> <li>Support for Python 3.12.</li> </ul> <p> Enhancements</p> <ul> <li>Packaging license file.</li> </ul> <p></p>"}, {"location": "changelog/v6.x.x/#version-600", "title": "Version 6.0.0", "text": "<p> New features</p> <ul> <li>Completely new module for time series. Read more in the user guide.</li> <li>Support for Python 3.11 and drop support for Python 3.8   and Python 3.9.</li> <li>New data engines. Read more in the user guide.</li> <li>Added the <code>dask</code> parallelization backend.</li> <li>Improved memory optimizations. Read more in the user guide.</li> <li>Added the <code>iterative</code> strategy for numerical imputation.</li> <li>Added the <code>hdbscan</code> strategy to the Pruner class.</li> <li>Use the <code>ignore</code> parameter to ignore columns in the dataset.</li> <li>New update_traces method to further customize your plots.</li> </ul> <p> API changes</p> <ul> <li>The plot_results method is divided into plot_results and plot_bootstrap   and accepts any metric.</li> <li>The FeatureGrouper class no longer accepts a <code>name</code> parameter. Provide   the group names directly through the <code>group</code> parameter as dict.</li> <li>Rework of the register method.</li> <li>The <code>multioutput</code> attribute is deprecated. Multioutput meta-estimators are   now assigned automatically.</li> <li>Model tags have to be separated from the acronym by an underscore.</li> <li>The <code>engine</code> parameter is now a dict.</li> <li>The <code>automl</code> method is deprecated.</li> </ul> <p> Enhancements</p> <ul> <li>Transformations only on <code>y</code> are now accepted, e.g., <code>atom.scale(columns=-1)</code>.</li> <li>The Imputer class has many more strategies for numerical columns designed   for time series.</li> <li>The evaluate method highlights the highest score   per metric.</li> <li>Full support for pandas nullable dtypes.</li> <li>The dataset can now be provided as callable.</li> <li>The FeatureExtractor class can extract features from the dataset's index.</li> <li>Subplots can now share axes on the canvas.</li> <li>The save and save_data   methods now accept pathlib.Path objects as <code>filename</code>.</li> <li>Cleaner representation on hover for the plot_timeline method.</li> <li>The <code>cv</code> key in <code>ht_params</code> now accepts a custom cross-validation generator.</li> <li>Improved error message for incorrect stratification of multioutput datasets.</li> <li>Rework of the shrink method.</li> </ul> <p> Bug fixes</p> <ul> <li>Fixed a bug where the cross_validate method could   fail for pipelines that changed the number of rows.</li> <li>Fixed a bug where the Pruner class didn't drop all outlier clusters.</li> <li>Fixed a bug where the pipeline could fail for transformers that returned a   series.</li> <li>Fixed a bug where the pipeline could fail for transformers that reset its   internal attributes during fitting.</li> <li>Fixed a bug where the register method failed in Databricks.</li> <li>Fixed a bug where tuning hyperparameter for a <code>base_estimator</code> inside a custom   meta-estimator would fail.</li> <li>Fixed a bug where the data properties' <code>@setter</code> could fail for numpy arrays.</li> <li>Fixed a bug where reference lines for some plots didn't lie exactly on the unity line.</li> </ul>"}, {"location": "examples/accelerating_cuml/", "title": "Accelerating cuml", "text": "In\u00a0[1]: Copied! <pre>from atom import ATOMClassifier\nfrom sklearn.datasets import make_classification\n\n# Create a dummy dataset\nX, y = make_classification(n_samples=100000, n_features=40)\n</pre> from atom import ATOMClassifier from sklearn.datasets import make_classification  # Create a dummy dataset X, y = make_classification(n_samples=100000, n_features=40) In\u00a0[2]: Copied! <pre>atom = ATOMClassifier(X, y, device=\"gpu\", engine=\"cuml\", verbose=2)\n</pre> atom = ATOMClassifier(X, y, device=\"gpu\", engine=\"cuml\", verbose=2) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\nAlgorithm task: binary classification.\nGPU training enabled.\nBackend engine: cuml.\n\nDataset stats ==================== &gt;&gt;\nShape: (100000, 41)\nMemory: 32.80 MB\nScaled: True\nOutlier values: 8127 (0.2%)\n-------------------------------------\nTrain set size: 80000\nTest set size: 20000\n-------------------------------------\n|   |       dataset |         train |          test |\n| - | ------------- | ------------- | ------------- |\n| 0 |   50006 (1.0) |   40005 (1.0) |   10001 (1.0) |\n| 1 |   49994 (1.0) |   39995 (1.0) |    9999 (1.0) |\n\n</pre> In\u00a0[3]: Copied! <pre>atom.scale()\n</pre> atom.scale() <pre>Fitting Scaler...\nScaling features...\n</pre> In\u00a0[13]: Copied! <pre>atom.dataset\n</pre> atom.dataset Out[13]: x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 ... x31 x32 x33 x34 x35 x36 x37 x38 x39 target 0 2.021646 -0.634557 -0.867811 1.103642 1.559011 0.122284 -0.864821 1.411657 0.147997 -2.269082 ... -0.489864 1.861048 -0.353861 0.720823 -1.522117 -0.737707 -1.573936 -0.832174 0.203154 0 1 -0.019885 0.846568 -0.364059 -1.091604 -1.336692 0.186689 -0.274142 0.020563 0.693235 -1.908658 ... -1.610058 -0.365231 0.284908 0.170156 -0.236553 -0.573761 -0.107317 -2.480178 0.420341 0 2 0.516618 -0.013420 -0.753879 -0.488243 0.560051 0.395817 -0.522523 -1.083503 -0.073398 0.383061 ... 0.966283 1.405546 -0.658654 0.339090 -1.615997 -1.312444 0.984578 0.602858 -1.110684 1 3 0.111861 -0.966334 0.208509 0.494328 -0.766835 -0.003399 -0.500449 -0.530622 -0.481663 -1.146132 ... -0.304896 2.030211 -1.189488 -1.238600 1.658765 -0.255644 0.572194 0.195496 0.617734 1 4 0.160135 -0.873517 0.719142 -2.020767 0.421435 -1.941230 0.835615 -1.178845 0.235273 -0.328574 ... 1.633662 -0.631118 1.814046 1.031754 0.328665 1.704483 2.153710 -1.430552 -0.543915 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 99995 1.100240 0.092581 -0.346265 0.234024 0.590199 0.755019 -1.688456 -1.031070 -0.620193 -0.283336 ... 0.356480 1.346821 -0.299087 2.343587 -2.003646 -0.933179 0.764255 -0.233526 -1.462311 1 99996 -1.142596 0.321843 -0.974006 0.390418 0.404722 -0.324256 -0.288176 1.009458 0.860912 -0.191313 ... 0.044618 -2.030135 1.448640 -0.854798 1.441451 1.347461 -0.937607 0.572504 -0.787673 0 99997 1.658252 0.303637 -0.020324 0.225917 0.154092 -1.208507 -0.199919 1.063016 -0.395696 -0.060886 ... 1.563345 -1.261853 -0.810122 -0.503823 1.565602 -1.264792 -0.591644 1.588397 0.601721 0 99998 -0.288042 -1.139792 1.548338 0.501413 0.361604 -0.315720 -0.564607 1.500870 0.501768 0.649079 ... 0.344663 1.734476 0.660177 0.767554 1.461940 0.310189 -1.469978 0.900132 1.114330 0 99999 -3.093351 -0.636463 -0.449575 1.169980 -1.041870 -0.257173 2.072777 -0.101111 -0.956916 -0.251162 ... 2.250647 0.746250 -0.610311 0.445467 -0.636288 -0.187444 0.226108 -0.186927 -1.024960 1 <p>100000 rows \u00d7 41 columns</p> In\u00a0[4]: Copied! <pre>print(f\"Scaler used: {atom.standard}\")\nprint(f\"Scaler's module: {atom.standard.__class__.__module__}\")\n</pre> print(f\"Scaler used: {atom.standard}\") print(f\"Scaler's module: {atom.standard.__class__.__module__}\") <pre>Scaler used: StandardScaler()\nScaler's module: cuml._thirdparty.sklearn.preprocessing._data\n</pre> In\u00a0[5]: Copied! <pre>atom.run(models=[\"RF\", \"SGD\", \"XGB\"])\n</pre> atom.run(models=[\"RF\", \"SGD\", \"XGB\"]) <pre>\nTraining ========================= &gt;&gt;\nModels: RF, SGD, XGB\nMetric: f1\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9726\nTest evaluation --&gt; f1: 0.9431\nTime elapsed: 1.935s\n-------------------------------------------------\nTotal time: 1.935s\n\n\nResults for StochasticGradientDescent:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9236\nTest evaluation --&gt; f1: 0.9219\nTime elapsed: 02m:16s\n-------------------------------------------------\nTotal time: 02m:16s\n\n\nResults for XGBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9749\nTest evaluation --&gt; f1: 0.9437\nTime elapsed: 6.394s\n-------------------------------------------------\nTotal time: 6.394s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 02m:24s\n-------------------------------------\nRandomForest              --&gt; f1: 0.9431\nStochasticGradientDescent --&gt; f1: 0.9219\nXGBoost                   --&gt; f1: 0.9437 !\n</pre> In\u00a0[6]: Copied! <pre>atom.results\n</pre> atom.results Out[6]: score_train score_test time_fit time RF 0.9726 0.9431 1.934512 1.934512 SGD 0.9236 0.9219 135.871493 135.871493 XGB 0.9749 0.9437 6.394416 6.394416 In\u00a0[7]: Copied! <pre>for m in atom.models:\n    print(f\"{m}'s module: {atom[m].estimator.__class__.__module__}\")\n</pre> for m in atom.models:     print(f\"{m}'s module: {atom[m].estimator.__class__.__module__}\") <pre>RF's module: cuml.ensemble.randomforestclassifier\nSGD's module: sklearn.linear_model._stochastic_gradient\nXGB's module: xgboost.sklearn\n</pre> In\u00a0[8]: Copied! <pre>atom.evaluate()\n</pre> atom.evaluate() Out[8]: accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc RF 0.9429 0.9741 0.9429 0.9431 0.8924 0.8858 0.9391 0.9472 0.9792 SGD 0.9217 0.9635 0.9218 0.9219 0.8551 0.8435 0.9203 0.9235 0.9676 XGB 0.9434 0.9753 0.9434 0.9437 0.8933 0.8868 0.9385 0.9489 0.9798"}, {"location": "examples/accelerating_cuml/#example-accelerating-pipelines-on-gpu", "title": "Example: Accelerating pipelines on GPU\u00b6", "text": "<p>This example shows how to accelerate a pipeline on GPU using cuML.</p> <p>The data used is a synthetic dataset created using sklearn's make_classification function.</p>"}, {"location": "examples/accelerating_sklearnex/", "title": "Accelerating sklearnex", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[2]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X, \"RainTomorrow\", verbose=2)\n</pre> atom = ATOMClassifier(X, \"RainTomorrow\", verbose=2) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.03 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n\n</pre> In\u00a0[4]: Copied! <pre># Impute missing values and encode categorical columns\natom.impute()\natom.encode()\n</pre> # Impute missing values and encode categorical columns atom.impute() atom.encode() <pre>Fitting Imputer...\nImputing missing values...\n --&gt; Imputing 637 missing values with mean (12.18) in column MinTemp.\n --&gt; Imputing 322 missing values with mean (23.22) in column MaxTemp.\n --&gt; Imputing 1406 missing values with mean (2.37) in column Rainfall.\n --&gt; Imputing 60843 missing values with mean (5.46) in column Evaporation.\n --&gt; Imputing 67816 missing values with mean (7.62) in column Sunshine.\n --&gt; Imputing 9330 missing values with most_frequent (W) in column WindGustDir.\n --&gt; Imputing 9270 missing values with mean (39.96) in column WindGustSpeed.\n --&gt; Imputing 10013 missing values with most_frequent (N) in column WindDir9am.\n --&gt; Imputing 3778 missing values with most_frequent (SE) in column WindDir3pm.\n --&gt; Imputing 1348 missing values with mean (13.99) in column WindSpeed9am.\n --&gt; Imputing 2630 missing values with mean (18.62) in column WindSpeed3pm.\n --&gt; Imputing 1774 missing values with mean (68.86) in column Humidity9am.\n --&gt; Imputing 3610 missing values with mean (51.48) in column Humidity3pm.\n --&gt; Imputing 14014 missing values with mean (1017.64) in column Pressure9am.\n --&gt; Imputing 13981 missing values with mean (1015.24) in column Pressure3pm.\n --&gt; Imputing 53657 missing values with mean (4.44) in column Cloud9am.\n --&gt; Imputing 57094 missing values with mean (4.5) in column Cloud3pm.\n --&gt; Imputing 904 missing values with mean (16.98) in column Temp9am.\n --&gt; Imputing 2726 missing values with mean (21.68) in column Temp3pm.\n --&gt; Imputing 1406 missing values with most_frequent (No) in column RainToday.\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Target-encoding feature Location. Contains 49 classes.\n --&gt; Target-encoding feature WindGustDir. Contains 16 classes.\n --&gt; Target-encoding feature WindDir9am. Contains 16 classes.\n --&gt; Target-encoding feature WindDir3pm. Contains 16 classes.\n --&gt; Ordinal-encoding feature RainToday. Contains 2 classes.\n</pre> In\u00a0[5]: Copied! <pre># Train a K-Nearest Neighbors model (using default sklearn)\natom.run(models=\"KNN\", metric=\"f1\")\n</pre> # Train a K-Nearest Neighbors model (using default sklearn) atom.run(models=\"KNN\", metric=\"f1\") <pre>\nTraining ========================= &gt;&gt;\nModels: KNN\nMetric: f1\n\n\nResults for KNearestNeighbors:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.6962\nTest evaluation --&gt; f1: 0.5818\nTime elapsed: 16.214s\n-------------------------------------------------\nTime: 16.214s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 16.249s\n-------------------------------------\nKNearestNeighbors --&gt; f1: 0.5818\n</pre> In\u00a0[6]: Copied! <pre># Now, we train an accelerated KNN using engine=\"sklearnex\"\n# Note the diffrence in training speed!!\natom.run(models=\"KNN_acc\", metric=\"f1\", engine=\"sklearnex\")\n</pre> # Now, we train an accelerated KNN using engine=\"sklearnex\" # Note the diffrence in training speed!! atom.run(models=\"KNN_acc\", metric=\"f1\", engine=\"sklearnex\") <pre>\nTraining ========================= &gt;&gt;\nModels: KNN_acc\nMetric: f1\n\n\nResults for KNearestNeighbors:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.6962\nTest evaluation --&gt; f1: 0.5818\nTime elapsed: 5.443s\n-------------------------------------------------\nTime: 5.443s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 5.477s\n-------------------------------------\nKNearestNeighbors --&gt; f1: 0.5818\n</pre> In\u00a0[7]: Copied! <pre>atom.results\n</pre> atom.results Out[7]: f1_train f1_test time_fit time KNN 0.6962 0.5818 16.213961 16.213961 KNN_acc 0.6962 0.5818 5.442855 5.442855 In\u00a0[8]: Copied! <pre># Note how the underlying estimators might look the same...\nprint(atom.knn.estimator)\nprint(atom.knn_acc.estimator)\n\n# ... but are using different implementations\nprint(atom.knn.estimator.__module__)\nprint(atom.knn_acc.estimator.__module__)\n</pre> # Note how the underlying estimators might look the same... print(atom.knn.estimator) print(atom.knn_acc.estimator)  # ... but are using different implementations print(atom.knn.estimator.__module__) print(atom.knn_acc.estimator.__module__) <pre>KNeighborsClassifier(n_jobs=1)\nKNeighborsClassifier(n_jobs=1)\nsklearn.neighbors._classification\nsklearnex.neighbors.knn_classification\n</pre> In\u00a0[9]: Copied! <pre>with atom.canvas(1, 2, title=\"Timing engines: sklearn vs sklearnex\"):\n    atom.plot_results(metric=\"time_fit\", title=\"Training\")\n    atom.plot_results(metric=\"time\", title=\"Total\")\n</pre> with atom.canvas(1, 2, title=\"Timing engines: sklearn vs sklearnex\"):     atom.plot_results(metric=\"time_fit\", title=\"Training\")     atom.plot_results(metric=\"time\", title=\"Total\")"}, {"location": "examples/accelerating_sklearnex/#example-accelerating-pipelines", "title": "Example: Accelerating pipelines\u00b6", "text": "<p>This example shows how to accelerate your models on cpu using sklearnex.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/accelerating_sklearnex/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/accelerating_sklearnex/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/accelerating_sklearnex/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/advanced_plotting/", "title": "Advanced plotting", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[2]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=1)\natom.impute()\natom.encode()\n</pre> atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=1) atom.impute() atom.encode() <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.03 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n\nFitting Imputer...\nImputing missing values...\nFitting Encoder...\nEncoding categorical columns...\n</pre> In\u00a0[4]: Copied! <pre># Let's see how the default aesthetics looks like\natom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")\n</pre> # Let's see how the default aesthetics looks like atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") In\u00a0[5]: Copied! <pre># Change the color palette using color names or their hex codes\natom.palette = [\"red\", \"#00f\"]\n</pre> # Change the color palette using color names or their hex codes atom.palette = [\"red\", \"#00f\"] In\u00a0[6]: Copied! <pre>atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")\n</pre> atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") In\u00a0[7]: Copied! <pre># Change the title and label fontsize\natom.title_fontsize = 30\natom.label_fontsize = 24\natom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")\n</pre> # Change the title and label fontsize atom.title_fontsize = 30 atom.label_fontsize = 24 atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") In\u00a0[8]: Copied! <pre># Use the update_layout method to change layout properties\natom.update_layout(template=\"simple_white\", barmode=\"group\", hovermode=\"x\")\natom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")\n</pre> # Use the update_layout method to change layout properties atom.update_layout(template=\"simple_white\", barmode=\"group\", hovermode=\"x\") atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") In\u00a0[9]: Copied! <pre># Use the update_traces method to change the trace (note the y-axis)\natom.update_traces(histnorm=\"percent\", selector=dict(type=\"histogram\"))\natom.plot_distribution(columns=[1, 2], distributions=None, title=\"Distribution of temperatures\")\n</pre> # Use the update_traces method to change the trace (note the y-axis) atom.update_traces(histnorm=\"percent\", selector=dict(type=\"histogram\")) atom.plot_distribution(columns=[1, 2], distributions=None, title=\"Distribution of temperatures\") In\u00a0[10]: Copied! <pre># Let's go back to the default aesthetics\natom.reset_aesthetics()\natom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")\n</pre> # Let's go back to the default aesthetics atom.reset_aesthetics() atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") In\u00a0[11]: Copied! <pre># And update the title with some custom fonts\natom.plot_distribution(\n    columns=[1, 2],\n    title=dict(\n        text=\"Distribution of temperatures\",\n        font_color=\"teal\",\n        x=0,\n        xanchor=\"left\",\n    )\n)\n</pre> # And update the title with some custom fonts atom.plot_distribution(     columns=[1, 2],     title=dict(         text=\"Distribution of temperatures\",         font_color=\"teal\",         x=0,         xanchor=\"left\",     ) ) In\u00a0[12]: Copied! <pre># We can update the legend in a similar fashion\natom.plot_distribution(\n    columns=[1, 2],\n    title=dict(\n        text=\"Distribution of temperatures\",\n        font_color=\"teal\",\n        x=0,\n        xanchor=\"left\",\n    ),\n    legend=dict(title=\"Legend's title\"),\n)\n</pre> # We can update the legend in a similar fashion atom.plot_distribution(     columns=[1, 2],     title=dict(         text=\"Distribution of temperatures\",         font_color=\"teal\",         x=0,         xanchor=\"left\",     ),     legend=dict(title=\"Legend's title\"), ) In\u00a0[13]: Copied! <pre>atom.run(\"LR\")\n\n# You can plot the ROC curve for a selection of rows,\n# for example, for rows in a specific location\natom.plot_roc(\n    rows={\n        \"Portland\": atom.test.loc[atom.og.X.Location == \"Portland\"],\n        \"Sydney\": atom.test.loc[atom.og.X.Location == \"Sydney\"],\n    }\n)\n</pre> atom.run(\"LR\")  # You can plot the ROC curve for a selection of rows, # for example, for rows in a specific location atom.plot_roc(     rows={         \"Portland\": atom.test.loc[atom.og.X.Location == \"Portland\"],         \"Sydney\": atom.test.loc[atom.og.X.Location == \"Sydney\"],     } ) <pre>\nTraining ========================= &gt;&gt;\nModels: LR\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5854\nTest evaluation --&gt; f1: 0.5805\nTime elapsed: 1.303s\n-------------------------------------------------\nTime: 1.303s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.339s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5805\n</pre> In\u00a0[14]: Copied! <pre># Note how the same column over different plots is grouped\nwith atom.canvas(2, 2):\n    atom.plot_distribution(columns=1)\n    atom.plot_distribution(columns=2)\n    atom.plot_qq(columns=[1, 2], distributions=[\"norm\", \"invgauss\"])\n    atom.plot_qq(columns=[1, 2])\n</pre> # Note how the same column over different plots is grouped with atom.canvas(2, 2):     atom.plot_distribution(columns=1)     atom.plot_distribution(columns=2)     atom.plot_qq(columns=[1, 2], distributions=[\"norm\", \"invgauss\"])     atom.plot_qq(columns=[1, 2])"}, {"location": "examples/advanced_plotting/#example-advanced-plotting", "title": "Example: Advanced plotting\u00b6", "text": "<p>This example shows how to make the best use of all of atom's plotting options.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/advanced_plotting/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#customize-colors-and-font-size", "title": "Customize colors and font size\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#customize-the-plots-layout", "title": "Customize the plot's layout\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#customize-the-plots-traces", "title": "Customize the plot's traces\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#customize-the-title-and-legend", "title": "Customize the title and legend\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#customizing-the-rows-to-plot", "title": "Customizing the rows to plot\u00b6", "text": ""}, {"location": "examples/advanced_plotting/#using-a-canvas", "title": "Using a canvas\u00b6", "text": ""}, {"location": "examples/automated_feature_scaling/", "title": "Automated feature scaling", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_breast_cancer\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX, y = load_breast_cancer(return_X_y=True)\n</pre> # Load the data X, y = load_breast_cancer(return_X_y=True) In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X, y, verbose=2, random_state=1)\n</pre> atom = ATOMClassifier(X, y, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 141.24 kB\nScaled: False\nOutlier values: 167 (1.2%)\n\n</pre> In\u00a0[4]: Copied! <pre># Check which models require feature scaling\natom.available_models(needs_scaling=True)\n</pre> # Check which models require feature scaling atom.available_models(needs_scaling=True) Out[4]: acronym fullname estimator module handles_missing needs_scaling accepts_sparse native_multilabel native_multioutput validation supports_engines 0 CatB CatBoost CatBoostClassifier catboost.core True True True False False n_estimators catboost 1 KNN KNearestNeighbors KNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn, sklearnex, cuml 2 LGB LightGBM LGBMClassifier lightgbm.sklearn True True True False False n_estimators lightgbm 3 lSVM LinearSVM LinearSVC sklearn.svm._classes False True True False False None sklearn, cuml 4 LR LogisticRegression LogisticRegression sklearn.linear_model._logistic False True True False False None sklearn, sklearnex, cuml 5 MLP MultiLayerPerceptron MLPClassifier sklearn.neural_network._multilayer_perceptron False True True True False max_iter sklearn 6 PA PassiveAggressive PassiveAggressiveClassifier sklearn.linear_model._passive_aggressive False True True False False max_iter sklearn 7 Perc Perceptron Perceptron sklearn.linear_model._perceptron False True False False False max_iter sklearn 8 RNN RadiusNearestNeighbors RadiusNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn 9 Ridge Ridge RidgeClassifier sklearn.linear_model._ridge False True True True False None sklearn, sklearnex, cuml 10 SGD StochasticGradientDescent SGDClassifier sklearn.linear_model._stochastic_gradient False True True False False max_iter sklearn 11 SVM SupportVectorMachine SVC sklearn.svm._classes False True True False False None sklearn, sklearnex, cuml 12 XGB XGBoost XGBClassifier xgboost.sklearn True True True False False n_estimators xgboost In\u00a0[5]: Copied! <pre># We fit two models: LR needs scaling and Bag doesn't\natom.run([\"LR\", \"Bag\"])\n</pre> # We fit two models: LR needs scaling and Bag doesn't atom.run([\"LR\", \"Bag\"]) <pre>\nTraining ========================= &gt;&gt;\nModels: LR, Bag\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9913\nTest evaluation --&gt; f1: 0.9861\nTime elapsed: 0.253s\n-------------------------------------------------\nTime: 0.253s\n\n\nResults for Bagging:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9982\nTest evaluation --&gt; f1: 0.9444\nTime elapsed: 0.085s\n-------------------------------------------------\nTime: 0.085s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.344s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9861 !\nBagging            --&gt; f1: 0.9444\n</pre> In\u00a0[6]: Copied! <pre># Now, we create a new branch and scale the features before fitting the model\natom.branch = \"scaling\"\n</pre> # Now, we create a new branch and scale the features before fitting the model atom.branch = \"scaling\" <pre>Successfully created new branch: scaling.\n</pre> In\u00a0[7]: Copied! <pre>atom.scale()\n</pre> atom.scale() <pre>Fitting Scaler...\nScaling features...\n</pre> In\u00a0[8]: Copied! <pre>atom.run(\"LR_2\")\n</pre> atom.run(\"LR_2\") <pre>\nTraining ========================= &gt;&gt;\nModels: LR_2\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9913\nTest evaluation --&gt; f1: 0.9861\nTime elapsed: 0.038s\n-------------------------------------------------\nTime: 0.038s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.042s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9861\n</pre> In\u00a0[9]: Copied! <pre># Let's compare the differences between the models\nprint(atom.lr.scaler)\nprint(atom.bag.scaler)\nprint(atom.lr_2.scaler)\n</pre> # Let's compare the differences between the models print(atom.lr.scaler) print(atom.bag.scaler) print(atom.lr_2.scaler) <pre>Scaler()\nNone\nNone\n</pre> In\u00a0[10]: Copied! <pre># And the data they use is different\nprint(atom.lr.X.iloc[:5, :3])\nprint(\"-----------------------------\")\nprint(atom.bag.X.iloc[:5, :3])\nprint(\"-----------------------------\")\nprint(atom.lr_2.X_train.equals(atom.lr.X_train))\n</pre> # And the data they use is different print(atom.lr.X.iloc[:5, :3]) print(\"-----------------------------\") print(atom.bag.X.iloc[:5, :3]) print(\"-----------------------------\") print(atom.lr_2.X_train.equals(atom.lr.X_train)) <pre>         x0        x1        x2\n0 -0.181875  0.356669 -0.147122\n1  1.162216  0.300578  1.159704\n2  1.056470  1.212060  0.933833\n3  0.277287  2.457753  0.188054\n4 -1.442482 -0.825921 -1.343434\n-----------------------------\n      x0     x1      x2\n0  13.48  20.82   88.40\n1  18.31  20.58  120.80\n2  17.93  24.48  115.20\n3  15.13  29.81   96.71\n4   8.95  15.76   58.74\n-----------------------------\nTrue\n</pre> In\u00a0[11]: Copied! <pre># Note that the scaler is included in the model's pipeline\nprint(atom.lr.pipeline)\nprint(\"-----------------------------\")\nprint(atom.bag.pipeline)\nprint(\"-----------------------------\")\nprint(atom.lr_2.pipeline)\n</pre> # Note that the scaler is included in the model's pipeline print(atom.lr.pipeline) print(\"-----------------------------\") print(atom.bag.pipeline) print(\"-----------------------------\") print(atom.lr_2.pipeline) <pre>Pipeline(memory=Memory(location=None),\n         ('steps', [('AutomatedScaler', Scaler())]),\n         verbose=False)\n-----------------------------\nPipeline(memory=Memory(location=None), steps=[], verbose=False)\n-----------------------------\nPipeline(memory=Memory(location=None),\n         ('steps', [('scaler', Scaler(verbose=2))]),\n         verbose=False)\n</pre> In\u00a0[12]: Copied! <pre>atom.plot_pipeline()\n</pre> atom.plot_pipeline()"}, {"location": "examples/automated_feature_scaling/#example-automated-feature-scaling", "title": "Example: Automated feature scaling\u00b6", "text": "<p>This example shows how ATOM handles models that require automated feature scaling.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/automated_feature_scaling/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/automated_feature_scaling/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/automated_feature_scaling/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/binary_classification/", "title": "Binary classification", "text": "In\u00a0[13]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[14]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() In\u00a0[15]: Copied! <pre># Call atom using only 5% of the complete dataset (for explanatory purposes)\natom = ATOMClassifier(X, y=\"RainTomorrow\", n_rows=0.05, n_jobs=8, verbose=2)\n</pre> # Call atom using only 5% of the complete dataset (for explanatory purposes) atom = ATOMClassifier(X, y=\"RainTomorrow\", n_rows=0.05, n_jobs=8, verbose=2) In\u00a0[16]: Copied! <pre># Impute missing values\natom.impute(strat_num=\"median\", strat_cat=\"drop\", max_nan_rows=0.8)\n</pre> # Impute missing values atom.impute(strat_num=\"median\", strat_cat=\"drop\", max_nan_rows=0.8) In\u00a0[17]: Copied! <pre># Encode the categorical features\natom.encode(strategy=\"Target\", max_onehot=10, infrequent_to_value=0.04)\n</pre> # Encode the categorical features atom.encode(strategy=\"Target\", max_onehot=10, infrequent_to_value=0.04) In\u00a0[18]: Copied! <pre># Train an Extra-Trees and a Random Forest model\natom.run(models=[\"ET\", \"RF\"], metric=\"f1\", n_bootstrap=5)\n</pre> # Train an Extra-Trees and a Random Forest model atom.run(models=[\"ET\", \"RF\"], metric=\"f1\", n_bootstrap=5) In\u00a0[19]: Copied! <pre># Let's have a look at the final results\natom.results\n</pre> # Let's have a look at the final results atom.results In\u00a0[20]: Copied! <pre># Visualize the bootstrap results\natom.plot_results(title=\"RF vs ET performance\")\n</pre> # Visualize the bootstrap results atom.plot_results(title=\"RF vs ET performance\") In\u00a0[21]: Copied! <pre># Print the results of some common metrics\natom.evaluate()\n</pre> # Print the results of some common metrics atom.evaluate() In\u00a0[22]: Copied! <pre># The winner attribute calls the best model (atom.winner == atom.rf)\nprint(f\"The winner is the {atom.winner.name} model!!\")\n</pre> # The winner attribute calls the best model (atom.winner == atom.rf) print(f\"The winner is the {atom.winner.name} model!!\") In\u00a0[23]: Copied! <pre># Visualize the distribution of predicted probabilities\natom.winner.plot_probabilities()\n</pre> # Visualize the distribution of predicted probabilities atom.winner.plot_probabilities() In\u00a0[24]: Copied! <pre># Compare how different metrics perform for different thresholds\natom.winner.plot_threshold(metric=[\"f1\", \"accuracy\", \"ap\"], steps=50)\n</pre> # Compare how different metrics perform for different thresholds atom.winner.plot_threshold(metric=[\"f1\", \"accuracy\", \"ap\"], steps=50)"}, {"location": "examples/binary_classification/#example-binary-classification", "title": "Example: Binary classification\u00b6", "text": "<p>This example shows how to use ATOM to solve a binary classification problem. Additonnaly, we'll perform a variety of data cleaning steps to prepare the data for modeling.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/binary_classification/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/binary_classification/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/binary_classification/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/bootstrapping/", "title": "Bootstrapping", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_breast_cancer\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX, y = load_breast_cancer(return_X_y=True, as_frame=True)\n</pre> # Load the data X, y = load_breast_cancer(return_X_y=True, as_frame=True) In\u00a0[3]: Copied! <pre># Initialize atom and train several models using bootstrapping\natom = ATOMClassifier(X, y, verbose=2, random_state=1)\natom.run(models=[\"LR\", \"Tree\", \"LGB\"], n_bootstrap=10)\n</pre> # Initialize atom and train several models using bootstrapping atom = ATOMClassifier(X, y, verbose=2, random_state=1) atom.run(models=[\"LR\", \"Tree\", \"LGB\"], n_bootstrap=10) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 138.97 kB\nScaled: False\nOutlier values: 167 (1.2%)\n\n\nTraining ========================= &gt;&gt;\nModels: LR, Tree, LGB\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9913\nTest evaluation --&gt; f1: 0.9861\nTime elapsed: 0.135s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.9797 \u00b1 0.0053\nTime elapsed: 0.287s\n-------------------------------------------------\nTime: 0.422s\n\n\nResults for DecisionTree:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9589\nTime elapsed: 0.040s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.9314 \u00b1 0.0103\nTime elapsed: 0.124s\n-------------------------------------------------\nTime: 0.164s\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 1.0\nTest evaluation --&gt; f1: 0.9583\nTime elapsed: 0.597s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.9542 \u00b1 0.01\nTime elapsed: 1.222s\n-------------------------------------------------\nTime: 1.819s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 2.415s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9797 \u00b1 0.0053 !\nDecisionTree       --&gt; f1: 0.9314 \u00b1 0.0103\nLightGBM           --&gt; f1: 0.9542 \u00b1 0.01\n</pre> In\u00a0[4]: Copied! <pre># Show the results of the bootstrap scores\natom.lr.bootstrap\n</pre> # Show the results of the bootstrap scores atom.lr.bootstrap Out[4]: f1 0 0.979310 1 0.979021 2 0.979021 3 0.971831 4 0.986111 5 0.979021 6 0.971831 7 0.986111 8 0.986111 9 0.979021 In\u00a0[5]: Copied! <pre>atom.plot_bootstrap()\n</pre> atom.plot_bootstrap()"}, {"location": "examples/bootstrapping/#example-bootstrapping", "title": "Example: Bootstrapping\u00b6", "text": "<p>This example shows how to use the bootstrapping) technique to assess the robustness of a model.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/bootstrapping/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/bootstrapping/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/calibration/", "title": "Calibration", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load the data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[2]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X, \"RainTomorrow\", n_rows=1e4, verbose=1, warnings=False)\n\n# Apply data cleaning steps\natom.clean()\natom.impute(strat_num=\"median\", strat_cat=\"most_frequent\")\natom.encode(strategy=\"target\", max_onehot=5, infrequent_to_value=0.05)\n\n# Train a linear SVM\natom.run(\"gnb\")\n</pre> atom = ATOMClassifier(X, \"RainTomorrow\", n_rows=1e4, verbose=1, warnings=False)  # Apply data cleaning steps atom.clean() atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\") atom.encode(strategy=\"target\", max_onehot=5, infrequent_to_value=0.05)  # Train a linear SVM atom.run(\"gnb\") <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (10000, 22)\nTrain set size: 8000\nTest set size: 2000\n-------------------------------------\nMemory: 1.76 MB\nScaled: False\nMissing values: 21951 (10.0%)\nCategorical features: 5 (23.8%)\nDuplicates: 6 (0.1%)\n\nFitting Cleaner...\nCleaning the data...\nFitting Imputer...\nImputing missing values...\nFitting Encoder...\nEncoding categorical columns...\n\nTraining ========================= &gt;&gt;\nModels: GNB\nMetric: f1\n\n\nResults for GaussianNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.586\nTest evaluation --&gt; f1: 0.5668\nTime elapsed: 0.104s\n-------------------------------------------------\nTime: 0.104s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.111s\n-------------------------------------\nGaussianNB --&gt; f1: 0.5668\n</pre> In\u00a0[4]: Copied! <pre># Check the model's calibration\natom.plot_calibration()\n</pre> # Check the model's calibration atom.plot_calibration() In\u00a0[5]: Copied! <pre># Let's try to improve it using the calibrate method\natom.winner.calibrate(method=\"isotonic\")\n</pre> # Let's try to improve it using the calibrate method atom.winner.calibrate(method=\"isotonic\") <pre>Results for GaussianNB:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.484\nTest evaluation --&gt; f1: 0.4664\nTime elapsed: 0.207s\n</pre> In\u00a0[6]: Copied! <pre># And check again...\natom.plot_calibration()\n</pre> # And check again... atom.plot_calibration()"}, {"location": "examples/calibration/#example-calibration", "title": "Example: Calibration\u00b6", "text": "<p>This example shows how to calibrate a classifier through atom.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/calibration/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/calibration/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/calibration/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/data_engines/", "title": "Data engines", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport polars as pl\nfrom sklearn.datasets import load_breast_cancer\nfrom atom import ATOMClassifier\n</pre> # Import packages import polars as pl from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data and convert to polars for demonstration purposes\nX, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\nX = pl.from_pandas(X)\ny = pl.from_pandas(y)\n\nX.head()\n</pre> # Load the data and convert to polars for demonstration purposes X, y = load_breast_cancer(return_X_y=True, as_frame=True)  X = pl.from_pandas(X) y = pl.from_pandas(y)  X.head() Out[2]: shape: (5, 30)mean radiusmean texturemean perimetermean areamean smoothnessmean compactnessmean concavitymean concave pointsmean symmetrymean fractal dimensionradius errortexture errorperimeter errorarea errorsmoothness errorcompactness errorconcavity errorconcave points errorsymmetry errorfractal dimension errorworst radiusworst textureworst perimeterworst areaworst smoothnessworst compactnessworst concavityworst concave pointsworst symmetryworst fractal dimensionf64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f6417.9910.38122.81001.00.11840.27760.30010.14710.24190.078711.0950.90538.589153.40.0063990.049040.053730.015870.030030.00619325.3817.33184.62019.00.16220.66560.71190.26540.46010.118920.5717.77132.91326.00.084740.078640.08690.070170.18120.056670.54350.73393.39874.080.0052250.013080.01860.01340.013890.00353224.9923.41158.81956.00.12380.18660.24160.1860.2750.0890219.6921.25130.01203.00.10960.15990.19740.12790.20690.059990.74560.78694.58594.030.006150.040060.038320.020580.02250.00457123.5725.53152.51709.00.14440.42450.45040.2430.36130.0875811.4220.3877.58386.10.14250.28390.24140.10520.25970.097440.49561.1563.44527.230.009110.074580.056610.018670.059630.00920814.9126.598.87567.70.20980.86630.68690.25750.66380.17320.2914.34135.11297.00.10030.13280.1980.10430.18090.058830.75720.78135.43894.440.011490.024610.056880.018850.017560.00511522.5416.67152.21575.00.13740.2050.40.16250.23640.07678 In\u00a0[3]: Copied! <pre># Specify the data engine in the constructor\n# Note that atom accepts any dataframe-like object to create the dataset\natom = ATOMClassifier(X, y, engine=\"polars\", verbose=2, random_state=1)\n</pre> # Specify the data engine in the constructor # Note that atom accepts any dataframe-like object to create the dataset atom = ATOMClassifier(X, y, engine=\"polars\", verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\nData engine: polars\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 138.97 kB\nScaled: False\nOutlier values: 167 (1.2%)\n\n</pre> In\u00a0[4]: Copied! <pre># The data attributes return now polars types\natom.X.head(5)\n</pre> # The data attributes return now polars types atom.X.head(5) Out[4]: shape: (5, 30)mean radiusmean texturemean perimetermean areamean smoothnessmean compactnessmean concavitymean concave pointsmean symmetrymean fractal dimensionradius errortexture errorperimeter errorarea errorsmoothness errorcompactness errorconcavity errorconcave points errorsymmetry errorfractal dimension errorworst radiusworst textureworst perimeterworst areaworst smoothnessworst compactnessworst concavityworst concave pointsworst symmetryworst fractal dimensionf64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f64f6413.4820.8288.4559.20.10160.12550.10630.054390.1720.064190.2130.59141.54518.520.0053670.022390.030490.012620.013770.00318715.5326.02107.3740.40.1610.42250.5030.22580.28070.107118.3120.58120.81052.00.10680.12480.15690.094510.1860.059410.54490.92253.21867.360.0061760.018770.029130.010460.015590.00272521.8626.2142.21493.00.14920.25360.37590.1510.30740.0786317.9324.48115.2998.90.088550.070270.056990.047440.15380.05510.42121.4332.76545.810.0054440.011690.016220.0085220.014190.00275120.9234.69135.11320.00.13150.18060.2080.11360.25040.0794815.1329.8196.71719.50.08320.046050.046860.027390.18520.052940.46811.6273.04345.380.0068310.014270.024890.0090870.031510.0017517.2636.91110.1931.40.11480.098660.15470.065750.32330.061658.9515.7658.74245.20.094620.12430.092630.023080.13050.071630.31320.97893.2816.940.018350.06760.092630.023080.023840.0056019.41417.0763.34270.00.11790.18790.15440.038460.16520.07722 In\u00a0[5]: Copied! <pre>atom.y.head(5)\n</pre> atom.y.head(5) Out[5]: shape: (5,)targeti3200001 In\u00a0[6]: Copied! <pre>atom.run(\"LR\")\n</pre> atom.run(\"LR\") <pre>\nTraining ========================= &gt;&gt;\nModels: LR\nMetric: f1\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.9913\nTest evaluation --&gt; f1: 0.9861\nTime elapsed: 0.129s\n-------------------------------------------------\nTime: 0.129s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.132s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.9861\n</pre> In\u00a0[7]: Copied! <pre># The prediction methods also return types of the requested data engine\natom.lr.predict(X)\n</pre> # The prediction methods also return types of the requested data engine atom.lr.predict(X) Out[7]: shape: (569,)targeti64000000000000\u2026111110000001 In\u00a0[8]: Copied! <pre>atom.lr.engine = \"pandas-pyarrow\"\natom.lr.predict(X.head(5))\n</pre> atom.lr.engine = \"pandas-pyarrow\" atom.lr.predict(X.head(5)) Out[8]: <pre>0    0\n1    0\n2    0\n3    0\n4    0\nName: target, dtype: int64[pyarrow]</pre> In\u00a0[9]: Copied! <pre>atom.lr.engine = \"dask\"\natom.lr.predict(X.head(5))\n</pre> atom.lr.engine = \"dask\" atom.lr.predict(X.head(5)) Out[9]: <pre>Dask Series Structure:\nnpartitions=1\n0    int64\n4      ...\nName: target, dtype: int64\nDask Name: from_pandas, 1 graph layer</pre> In\u00a0[10]: Copied! <pre>atom.lr.engine = \"pyarrow\"\natom.lr.predict(X.head(5))\n</pre> atom.lr.engine = \"pyarrow\" atom.lr.predict(X.head(5)) Out[10]: <pre>&lt;pyarrow.lib.Int64Array object at 0x0000016E06BCD1E0&gt;\n[\n  0,\n  0,\n  0,\n  0,\n  0\n]</pre>"}, {"location": "examples/data_engines/#example-data-engines", "title": "Example: Data engines\u00b6", "text": "<p>This example shows how ATOM interacts with other data engines than pandas, for example polars.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/data_engines/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/data_engines/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/data_engines/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/deep_learning/", "title": "Deep learning", "text": "In\u00a0[1]: Copied! <pre># Disable annoying tf warnings\nimport os\nos.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\"\n\nfrom tensorflow import get_logger\nget_logger().setLevel(\"ERROR\")\n\nimport absl.logging\nabsl.logging.set_verbosity(absl.logging.ERROR)\n\nfrom atom import ATOMClassifier, ATOMModel\nfrom sklearn.preprocessing import FunctionTransformer\nfrom optuna.pruners import PatientPruner\nfrom optuna.distributions import CategoricalDistribution, IntDistribution\n\nfrom scikeras.wrappers import KerasClassifier\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Flatten, Conv2D, Dropout\n</pre> # Disable annoying tf warnings import os os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\"  from tensorflow import get_logger get_logger().setLevel(\"ERROR\")  import absl.logging absl.logging.set_verbosity(absl.logging.ERROR)  from atom import ATOMClassifier, ATOMModel from sklearn.preprocessing import FunctionTransformer from optuna.pruners import PatientPruner from optuna.distributions import CategoricalDistribution, IntDistribution  from scikeras.wrappers import KerasClassifier from tensorflow.keras.datasets import mnist from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Flatten, Conv2D, Dropout In\u00a0[2]: Copied! <pre># Download the MNIST dataset\n(X_train, y_train), (X_test, y_test) = mnist.load_data()\n\n# Flatten data to follow sklearn's API (2d input)\nX_train = X_train.reshape(len(X_train), -1)\nX_test = X_test.reshape(len(X_test), -1)\n\ndata = (X_train, y_train), (X_test, y_test)\n</pre> # Download the MNIST dataset (X_train, y_train), (X_test, y_test) = mnist.load_data()  # Flatten data to follow sklearn's API (2d input) X_train = X_train.reshape(len(X_train), -1) X_test = X_test.reshape(len(X_test), -1)  data = (X_train, y_train), (X_test, y_test) In\u00a0[3]: Copied! <pre># Create the convolutional neural network\nclass ConvNN(KerasClassifier):\n    \"\"\"Convolutional neural network model.\"\"\"\n\n    def __repr__(self):\n        return f\"ConvCNN(epochs={self.epochs}, batch_size={self.batch_size})\"\n    \n    @property\n    def feature_encoder(self):\n        \"\"\"Convert the 2d input to the image's format (len(X), 28, 28, 1).\"\"\"\n        return FunctionTransformer(\n            func=lambda X: X.reshape(X.shape[0], 28, 28, 1),\n        )\n\n    @staticmethod\n    def _keras_build_fn(**kwargs):\n        \"\"\"Create the model's architecture.\"\"\"\n        model = Sequential()\n        model.add(\n            Conv2D(\n                filters=8,\n                kernel_size=3,\n                activation=\"relu\",\n                input_shape=(28, 28, 1),\n            )\n        )\n        model.add(Conv2D(filters=4, kernel_size=5, activation=\"relu\"))\n        model.add(Flatten())\n        model.add(Dense(units=10, activation=\"softmax\"))\n        model.compile(\n            optimizer=\"adam\",\n            loss=\"sparse_categorical_crossentropy\",\n        )\n\n        return model\n</pre> # Create the convolutional neural network class ConvNN(KerasClassifier):     \"\"\"Convolutional neural network model.\"\"\"      def __repr__(self):         return f\"ConvCNN(epochs={self.epochs}, batch_size={self.batch_size})\"          @property     def feature_encoder(self):         \"\"\"Convert the 2d input to the image's format (len(X), 28, 28, 1).\"\"\"         return FunctionTransformer(             func=lambda X: X.reshape(X.shape[0], 28, 28, 1),         )      @staticmethod     def _keras_build_fn(**kwargs):         \"\"\"Create the model's architecture.\"\"\"         model = Sequential()         model.add(             Conv2D(                 filters=8,                 kernel_size=3,                 activation=\"relu\",                 input_shape=(28, 28, 1),             )         )         model.add(Conv2D(filters=4, kernel_size=5, activation=\"relu\"))         model.add(Flatten())         model.add(Dense(units=10, activation=\"softmax\"))         model.compile(             optimizer=\"adam\",             loss=\"sparse_categorical_crossentropy\",         )          return model In\u00a0[4]: Copied! <pre># Convert the model to an ATOM model\nmodel = ATOMModel(\n    estimator=ConvNN(verbose=0),\n    acronym=\"CNN\",\n    needs_scaling=True,  # Applies automated feature scaling before fitting\n    validation=\"epochs\",  # Applies in-training validation on parameter epochs\n)\n</pre> # Convert the model to an ATOM model model = ATOMModel(     estimator=ConvNN(verbose=0),     acronym=\"CNN\",     needs_scaling=True,  # Applies automated feature scaling before fitting     validation=\"epochs\",  # Applies in-training validation on parameter epochs ) In\u00a0[5]: Copied! <pre>atom = ATOMClassifier(*data, n_rows=0.1, verbose=2, random_state=1)\n</pre> atom = ATOMClassifier(*data, n_rows=0.1, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multiclass classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (7000, 785)\nTrain set size: 6000\nTest set size: 1000\n-------------------------------------\nMemory: 5.54 MB\nScaled: False\nOutlier values: 41839 (0.9%)\n\n</pre> In\u00a0[6]: Copied! <pre># Like any other model, we can define custom distributions for hyperparameter tuning\natom.run(\n    models=model,\n    metric=\"f1_weighted\",\n    n_trials=12,\n    ht_params={\n        \"distributions\": {\n            \"epochs\": IntDistribution(2, 10),\n            \"batch_size\": CategoricalDistribution([128, 256, 512]),\n        },\n    },\n    errors='raise'\n)\n</pre> # Like any other model, we can define custom distributions for hyperparameter tuning atom.run(     models=model,     metric=\"f1_weighted\",     n_trials=12,     ht_params={         \"distributions\": {             \"epochs\": IntDistribution(2, 10),             \"batch_size\": CategoricalDistribution([128, 256, 512]),         },     },     errors='raise' ) <pre>\nTraining ========================= &gt;&gt;\nModels: CNN\nMetric: f1_weighted\n\n\nRunning hyperparameter tuning for ConvNN...\n| trial |  epochs | batch_size | f1_weighted | best_f1_weighted | time_trial | time_ht |    state |\n| ----- | ------- | ---------- | ----------- | ---------------- | ---------- | ------- | -------- |\n| 0     |       5 |        128 |      0.9256 |           0.9256 |     4.756s |  4.756s | COMPLETE |\n| 1     |       3 |        512 |      0.8566 |           0.9256 |     3.864s |  8.620s | COMPLETE |\n| 2     |       5 |        512 |      0.8968 |           0.9256 |     4.704s | 13.324s | COMPLETE |\n| 3     |       3 |        128 |      0.9045 |           0.9256 |     4.009s | 17.333s | COMPLETE |\n| 4     |       5 |        128 |      0.9256 |           0.9256 |     0.048s | 17.381s | COMPLETE |\n| 5     |       9 |        128 |      0.9277 |           0.9277 |     6.059s | 23.440s | COMPLETE |\n| 6     |       9 |        128 |      0.9277 |           0.9277 |     0.041s | 23.481s | COMPLETE |\n| 7     |       3 |        128 |      0.9045 |           0.9277 |     0.046s | 23.527s | COMPLETE |\n| 8     |      10 |        256 |      0.7922 |           0.9277 |     3.483s | 27.010s |   PRUNED |\n| 9     |       8 |        128 |      0.8496 |           0.9277 |     3.190s | 30.200s |   PRUNED |\n| 10    |       7 |        256 |      0.8165 |           0.9277 |     3.153s | 33.353s |   PRUNED |\n| 11    |      10 |        128 |       0.821 |           0.9277 |     3.498s | 36.852s |   PRUNED |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 5\nBest parameters:\n --&gt; epochs: 9\n --&gt; batch_size: 128\nBest evaluation --&gt; f1_weighted: 0.9277\nTime elapsed: 36.852s\nFit ---------------------------------------------\nTrain evaluation --&gt; f1_weighted: 0.9795\nTest evaluation --&gt; f1_weighted: 0.9531\nTime elapsed: 46.786s\n-------------------------------------------------\nTime: 01m:24s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 01m:31s\n-------------------------------------\nConvNN --&gt; f1_weighted: 0.9531\n</pre> In\u00a0[7]: Copied! <pre>atom.cnn.trials\n</pre> atom.cnn.trials Out[7]: epochs batch_size estimator f1_weighted best_f1_weighted time_trial time_ht state trial 0 5 128 ConvCNN(epochs=5, batch_size=128) 0.925570 0.927664 4.756187 4.756187 COMPLETE 1 3 512 ConvCNN(epochs=3, batch_size=512) 0.856597 0.927664 3.863504 8.619691 COMPLETE 2 5 512 ConvCNN(epochs=5, batch_size=512) 0.896831 0.927664 4.704265 13.323956 COMPLETE 3 3 128 ConvCNN(epochs=3, batch_size=128) 0.904526 0.927664 4.008634 17.332590 COMPLETE 4 5 128 ConvCNN(epochs=5, batch_size=128) 0.925570 0.927664 0.048043 17.380633 COMPLETE 5 9 128 ConvCNN(epochs=9, batch_size=128) 0.927664 0.927664 6.059495 23.440128 COMPLETE 6 9 128 ConvCNN(epochs=9, batch_size=128) 0.927664 0.927664 0.041037 23.481165 COMPLETE 7 3 128 ConvCNN(epochs=3, batch_size=128) 0.904526 0.927664 0.046042 23.527207 COMPLETE 8 10 256 ConvCNN(epochs=10, batch_size=256) 0.792157 0.927664 3.483158 27.010365 PRUNED 9 8 128 ConvCNN(epochs=8, batch_size=128) 0.849556 0.927664 3.189892 30.200257 PRUNED 10 7 256 ConvCNN(epochs=7, batch_size=256) 0.816544 0.927664 3.153120 33.353377 PRUNED 11 10 128 ConvCNN(epochs=10, batch_size=128) 0.821044 0.927664 3.498174 36.851551 PRUNED In\u00a0[8]: Copied! <pre>atom.plot_evals(dataset=\"test+train\")\n</pre> atom.plot_evals(dataset=\"test+train\") In\u00a0[9]: Copied! <pre># Use the prediction methods like any other model\natom.cnn.predict_proba(X_train)\n</pre> # Use the prediction methods like any other model atom.cnn.predict_proba(X_train) Out[9]: 0 1 2 3 4 5 6 7 8 9 0 2.312403e-05 4.813091e-07 9.877838e-07 1.521687e-02 1.477957e-10 9.845214e-01 1.979216e-09 1.859409e-04 1.672720e-07 5.092833e-05 1 9.999985e-01 1.913526e-14 6.021650e-07 4.580108e-07 1.116983e-10 3.819218e-07 5.251873e-08 3.225117e-08 3.185537e-08 8.395847e-08 2 9.198901e-12 7.791282e-12 2.474698e-05 3.879381e-03 9.823568e-01 9.732957e-10 6.507817e-14 1.241411e-02 6.393744e-07 1.324400e-03 3 2.723569e-06 9.855152e-01 4.268080e-03 8.463531e-04 4.408682e-05 8.344805e-05 8.088706e-06 1.071986e-04 9.105954e-03 1.884496e-05 4 7.993587e-09 3.200859e-09 2.385552e-08 4.573155e-07 1.899138e-03 6.267613e-07 6.418151e-10 2.177684e-03 5.593851e-05 9.958662e-01 ... ... ... ... ... ... ... ... ... ... ... 59995 7.141304e-07 8.722313e-07 3.200821e-06 5.318429e-04 1.037134e-07 1.061244e-04 1.843534e-09 1.376003e-08 9.993328e-01 2.418581e-05 59996 5.651224e-06 2.765106e-08 3.561635e-04 9.909723e-01 8.901452e-09 3.109492e-04 1.283445e-09 4.298236e-08 8.242389e-03 1.125573e-04 59997 1.372623e-07 3.574151e-07 1.871507e-10 4.340361e-05 4.912128e-07 9.997080e-01 2.914571e-08 1.305577e-08 9.207054e-05 1.555610e-04 59998 2.379551e-04 1.090190e-08 8.885978e-05 4.208754e-05 2.906187e-03 1.157583e-03 9.955516e-01 8.701521e-06 3.407994e-06 3.484051e-06 59999 3.986048e-03 1.135677e-06 2.533903e-05 1.527677e-05 2.258937e-06 4.415337e-02 1.476940e-06 5.445668e-07 9.514875e-01 3.271214e-04 <p>60000 rows \u00d7 10 columns</p> In\u00a0[10]: Copied! <pre># Or make plots...\natom.cnn.plot_hyperparameters()\n</pre> # Or make plots... atom.cnn.plot_hyperparameters() In\u00a0[11]: Copied! <pre>atom.plot_parallel_coordinate()\n</pre> atom.plot_parallel_coordinate()"}, {"location": "examples/deep_learning/#example-deep-learning", "title": "Example: Deep learning\u00b6", "text": "<p>This example shows how to use ATOM to train and validate a Convolutional Neural Network implemented with Keras using scikeras.</p> <p>Import the MNIST dataset from keras.datasets. This is a well known image dataset whose goal is to classify handwritten digits.</p>"}, {"location": "examples/deep_learning/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/deep_learning/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/deep_learning/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/ensembles/", "title": "Ensembles", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_breast_cancer\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX, y = load_breast_cancer(return_X_y=True, as_frame=True)\n</pre> # Load the data X, y = load_breast_cancer(return_X_y=True, as_frame=True) In\u00a0[3]: Copied! <pre># Initialize atom and train several models\natom = ATOMClassifier(X, y, holdout_size=0.2, verbose=2, random_state=1)\natom.run(models=[\"LR\", \"Tree\", \"LGB\"], metric=\"accuracy\")\n</pre> # Initialize atom and train several models atom = ATOMClassifier(X, y, holdout_size=0.2, verbose=2, random_state=1) atom.run(models=[\"LR\", \"Tree\", \"LGB\"], metric=\"accuracy\") <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (456, 31)\nTrain set size: 343\nTest set size: 113\nHoldout set size: 113\n-------------------------------------\nMemory: 111.40 kB\nScaled: False\nOutlier values: 124 (1.2%)\n\n\nTraining ========================= &gt;&gt;\nModels: LR, Tree, LGB\nMetric: accuracy\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; accuracy: 0.9913\nTest evaluation --&gt; accuracy: 0.9823\nTime elapsed: 0.422s\n-------------------------------------------------\nTime: 0.422s\n\n\nResults for DecisionTree:\nFit ---------------------------------------------\nTrain evaluation --&gt; accuracy: 1.0\nTest evaluation --&gt; accuracy: 0.9558\nTime elapsed: 0.028s\n-------------------------------------------------\nTime: 0.028s\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; accuracy: 1.0\nTest evaluation --&gt; accuracy: 0.9558\nTime elapsed: 0.597s\n-------------------------------------------------\nTime: 0.597s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.533s\n-------------------------------------\nLogisticRegression --&gt; accuracy: 0.9823 !\nDecisionTree       --&gt; accuracy: 0.9558\nLightGBM           --&gt; accuracy: 0.9558\n</pre> In\u00a0[4]: Copied! <pre># Combine the models into a Voting model\natom.voting(voting=\"soft\")\n</pre> # Combine the models into a Voting model atom.voting(voting=\"soft\") <pre>Results for Voting:\nFit ---------------------------------------------\nTrain evaluation --&gt; accuracy: 1.0\nTest evaluation --&gt; accuracy: 0.9735\nTime elapsed: 0.228s\n</pre> In\u00a0[5]: Copied! <pre># Note that we now have an extra model in the pipeline\natom.models\n</pre> # Note that we now have an extra model in the pipeline atom.models Out[5]: <pre>['LR', 'Tree', 'LGB', 'Vote']</pre> In\u00a0[6]: Copied! <pre># The plot_pipeline method helps us visualize the ensemble\natom.plot_pipeline()\n</pre> # The plot_pipeline method helps us visualize the ensemble atom.plot_pipeline() In\u00a0[7]: Copied! <pre># We can use it like any other model to make predictions or plots\natom.vote.predict_proba(\"test\")\n</pre> # We can use it like any other model to make predictions or plots atom.vote.predict_proba(\"test\") Out[7]: 0 1 343 0.000010 0.999990 344 0.999989 0.000011 345 0.999988 0.000012 346 0.000175 0.999825 347 0.001798 0.998202 ... ... ... 451 0.997818 0.002182 452 0.010445 0.989555 453 0.999987 0.000013 454 0.000325 0.999675 455 0.999984 0.000016 <p>113 rows \u00d7 2 columns</p> In\u00a0[8]: Copied! <pre>atom.vote.plot_threshold(metric=[\"auc\", \"recall\", \"accuracy\"])\n</pre> atom.vote.plot_threshold(metric=[\"auc\", \"recall\", \"accuracy\"]) In\u00a0[9]: Copied! <pre>atom.plot_results(legend=None)\n</pre> atom.plot_results(legend=None) In\u00a0[10]: Copied! <pre>atom.delete(\"vote\")\n</pre> atom.delete(\"vote\") <pre>Deleting 1 models...\n --&gt; Model Vote successfully deleted.\n</pre> In\u00a0[11]: Copied! <pre>atom.stacking(final_estimator=\"LDA\", train_on_test=True)\n</pre> atom.stacking(final_estimator=\"LDA\", train_on_test=True) <pre>Results for Stacking:\nFit ---------------------------------------------\nTrain evaluation --&gt; accuracy: 0.9942\nTest evaluation --&gt; accuracy: 0.9735\nTime elapsed: 0.148s\n</pre> In\u00a0[12]: Copied! <pre># Now we use the holdout set to evaluate the performance of the Stack model\natom.stack.results\n</pre> # Now we use the holdout set to evaluate the performance of the Stack model atom.stack.results Out[12]: <pre>accuracy_train      0.994200\naccuracy_test       0.973500\naccuracy_holdout    0.982300\ntime_fit            0.148135\ntime                0.148135\nName: Stack, dtype: float64</pre> In\u00a0[13]: Copied! <pre>atom.plot_results(rows=\"holdout\", legend=None)\n</pre> atom.plot_results(rows=\"holdout\", legend=None) In\u00a0[14]: Copied! <pre>atom.stack.plot_roc(rows=\"holdout\")\n</pre> atom.stack.plot_roc(rows=\"holdout\") In\u00a0[15]: Copied! <pre># Again, the model can be used for predictions or plots\natom.stack.predict(X)\n</pre> # Again, the model can be used for predictions or plots atom.stack.predict(X) Out[15]: <pre>0      0\n1      0\n2      0\n3      0\n4      0\n      ..\n564    0\n565    0\n566    0\n567    0\n568    1\nName: target, Length: 569, dtype: int64</pre> In\u00a0[16]: Copied! <pre>atom.stack.plot_shap_beeswarm(show=10)\n</pre> atom.stack.plot_shap_beeswarm(show=10) <pre>PermutationExplainer explainer: 114it [01:20,  1.29it/s]                                                                                                                                                                                                                                                             \n</pre>"}, {"location": "examples/ensembles/#example-ensembles", "title": "Example: Ensembles\u00b6", "text": "<p>This example shows how to use atom's ensemble techniques to improve predictions on a dataset combining several models.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/ensembles/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/ensembles/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/ensembles/#voting", "title": "Voting\u00b6", "text": ""}, {"location": "examples/ensembles/#stacking", "title": "Stacking\u00b6", "text": "<p>Just like Voting, we can create a Stacking mode. lUsing <code>train_on_test=True</code> trains the final estimator on the test set to avoid overfitting on the training set.</p>"}, {"location": "examples/feature_engineering/", "title": "Feature engineering", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[2]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[3]: Copied! <pre># Initialize atom and apply data cleaning\natom = ATOMClassifier(X, n_rows=1e4, test_size=0.2, verbose=0)\natom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8)\natom.encode(max_onehot=10, infrequent_to_value=0.04)\n</pre> # Initialize atom and apply data cleaning atom = ATOMClassifier(X, n_rows=1e4, test_size=0.2, verbose=0) atom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8) atom.encode(max_onehot=10, infrequent_to_value=0.04) In\u00a0[4]: Copied! <pre>atom.verbose = 2  # Increase verbosity to see the output\n\n# Let's see how a LightGBM model performs\natom.run('LGB', metric='auc')\n</pre> atom.verbose = 2  # Increase verbosity to see the output  # Let's see how a LightGBM model performs atom.run('LGB', metric='auc') <pre>\nTraining ========================= &gt;&gt;\nModels: LGB\nMetric: auc\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.9846\nTest evaluation --&gt; auc: 0.8783\nTime elapsed: 1.012s\n-------------------------------------------------\nTime: 1.012s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.017s\n-------------------------------------\nLightGBM --&gt; auc: 0.8783\n</pre> In\u00a0[5]: Copied! <pre># Since we are going to compare different datasets,\n# we need to create separate branches\natom.branch = \"dfs\"\n</pre> # Since we are going to compare different datasets, # we need to create separate branches atom.branch = \"dfs\" <pre>Successfully created new branch: dfs.\n</pre> In\u00a0[6]: Copied! <pre># Create 50 new features using dfs\natom.feature_generation(\"dfs\", n_features=50, operators=[\"add\", \"sub\", \"log\"])\n</pre> # Create 50 new features using dfs atom.feature_generation(\"dfs\", n_features=50, operators=[\"add\", \"sub\", \"log\"]) <pre>Fitting FeatureGenerator...\nGenerating new features...\n --&gt; 50 new features were added.\n</pre> In\u00a0[7]: Copied! <pre># The warnings warn us that some operators created missing values!\n# We can see the columns with missing values using the nans attribute\natom.nans\n</pre> # The warnings warn us that some operators created missing values! # We can see the columns with missing values using the nans attribute atom.nans Out[7]: <pre>Location                      0\nMinTemp                       0\nMaxTemp                       0\nRainfall                      0\nEvaporation                   0\n                             ..\nWindDir3pm + WindGustSpeed    0\nWindDir9am + WindGustDir      0\nWindDir9am - WindGustDir      0\nWindGustDir + WindSpeed3pm    0\nRainTomorrow                  0\nLength: 74, dtype: int64</pre> In\u00a0[8]: Copied! <pre># Turn off warnings in the future\natom.warnings = False\n\n# Impute the data again to get rid of the missing values\natom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8)\n</pre> # Turn off warnings in the future atom.warnings = False  # Impute the data again to get rid of the missing values atom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8) <pre>Fitting Imputer...\nImputing missing values...\n</pre> In\u00a0[9]: Copied! <pre># 50 new features may be to much...\n# Let's check for multicollinearity and use rfecv to reduce the number\natom.feature_selection(\n    strategy=\"rfecv\",\n    solver=\"LGB\",\n    n_features=30,\n    scoring=\"auc\",\n    max_correlation=0.98,\n)\n</pre> # 50 new features may be to much... # Let's check for multicollinearity and use rfecv to reduce the number atom.feature_selection(     strategy=\"rfecv\",     solver=\"LGB\",     n_features=30,     scoring=\"auc\",     max_correlation=0.98, ) <pre>Fitting FeatureSelector...\nPerforming feature selection ...\n --&gt; Feature MinTemp was removed due to collinearity with another feature.\n --&gt; Feature Location + MinTemp was removed due to collinearity with another feature.\n --&gt; Feature MinTemp + RainToday_No was removed due to collinearity with another feature.\n --&gt; Feature MinTemp - WindDir3pm was removed due to collinearity with another feature.\n --&gt; Feature MinTemp - WindDir9am was removed due to collinearity with another feature.\n --&gt; Feature MaxTemp was removed due to collinearity with another feature.\n --&gt; Feature Temp3pm was removed due to collinearity with another feature.\n --&gt; Feature Location + MaxTemp was removed due to collinearity with another feature.\n --&gt; Feature Location + Temp3pm was removed due to collinearity with another feature.\n --&gt; Feature MaxTemp - RainToday_Yes was removed due to collinearity with another feature.\n --&gt; Feature MaxTemp - WindGustDir was removed due to collinearity with another feature.\n --&gt; Feature Evaporation was removed due to collinearity with another feature.\n --&gt; Feature Evaporation + WindDir3pm was removed due to collinearity with another feature.\n --&gt; Feature Sunshine was removed due to collinearity with another feature.\n --&gt; Feature WindGustDir was removed due to collinearity with another feature.\n --&gt; Feature WindGustSpeed was removed due to collinearity with another feature.\n --&gt; Feature WindSpeed3pm was removed due to collinearity with another feature.\n --&gt; Feature Humidity9am was removed due to collinearity with another feature.\n --&gt; Feature Humidity3pm was removed due to collinearity with another feature.\n --&gt; Feature Humidity3pm + Sunshine was removed due to collinearity with another feature.\n --&gt; Feature Humidity3pm + WindGustDir was removed due to collinearity with another feature.\n --&gt; Feature Humidity3pm - Location was removed due to collinearity with another feature.\n --&gt; Feature Humidity3pm - RainToday_No was removed due to collinearity with another feature.\n --&gt; Feature Humidity3pm - RainToday_infrequent was removed due to collinearity with another feature.\n --&gt; Feature Cloud9am - RainToday_infrequent was removed due to collinearity with another feature.\n --&gt; Feature Temp9am was removed due to collinearity with another feature.\n --&gt; Feature RainToday_Yes - WindDir3pm was removed due to collinearity with another feature.\n --&gt; Feature MinTemp + Temp3pm was removed due to collinearity with another feature.\n --&gt; rfecv selected 41 features from the dataset.\n   --&gt; Dropping feature Location (rank 5).\n   --&gt; Dropping feature RainToday_No (rank 2).\n   --&gt; Dropping feature RainToday_Yes (rank 3).\n   --&gt; Dropping feature Location - RainToday_Yes (rank 4).\n</pre> In\u00a0[10]: Copied! <pre># The collinear attribute shows what features were removed due to multicollinearity\natom.collinear_\n</pre> # The collinear attribute shows what features were removed due to multicollinearity atom.collinear_ Out[10]: drop corr_feature corr_value 0 MinTemp Location + MinTemp, MinTemp + RainToday_No, Mi... 1.0, 0.9979, 1.0, 1.0, 1.0 1 Location + MinTemp MinTemp, MinTemp + RainToday_No, MinTemp + Win... 1.0, 0.9979, 1.0, 1.0, 1.0 2 MinTemp + RainToday_No MinTemp, Location + MinTemp, MinTemp + WindGus... 0.9979, 0.9979, 0.9978, 0.9979, 0.9979 3 MinTemp - WindDir3pm MinTemp, Location + MinTemp, MinTemp + RainTod... 1.0, 1.0, 0.9979, 0.9999, 1.0 4 MinTemp - WindDir9am MinTemp, Location + MinTemp, MinTemp + RainTod... 1.0, 1.0, 0.9979, 0.9999, 1.0 5 MaxTemp Temp3pm, Location + MaxTemp, Location + Temp3p... 0.9834, 1.0, 0.9834, 0.9999, 0.9985, 1.0 6 Temp3pm MaxTemp, Location + MaxTemp, Location + Temp3p... 0.9834, 0.9834, 1.0, 0.9833, 0.9825, 0.9835 7 Location + MaxTemp MaxTemp, Temp3pm, Location + Temp3pm, MaxTemp ... 1.0, 0.9834, 0.9834, 0.9999, 0.9985, 1.0 8 Location + Temp3pm MaxTemp, Temp3pm, Location + MaxTemp, MaxTemp ... 0.9834, 1.0, 0.9834, 0.9833, 0.9825, 0.9835 9 MaxTemp - RainToday_Yes MaxTemp, Temp3pm, Location + MaxTemp, Location... 0.9985, 0.9825, 0.9985, 0.9825, 0.9984, 0.9984 10 MaxTemp - WindGustDir MaxTemp, Temp3pm, Location + MaxTemp, Location... 1.0, 0.9835, 1.0, 0.9835, 0.9999, 0.9984 11 Evaporation Evaporation + RainToday_Yes, Evaporation + Win... 0.9936, 0.9999 12 Evaporation + WindDir3pm Evaporation, Evaporation + RainToday_Yes 0.9999, 0.9935 13 Sunshine Sunshine + WindDir3pm 0.9999 14 WindGustDir Location + WindGustDir 1.0 15 WindGustSpeed WindDir3pm + WindGustSpeed 1.0 16 WindSpeed3pm WindGustDir + WindSpeed3pm 1.0 17 Humidity9am Humidity9am + WindGustDir 1.0 18 Humidity3pm Evaporation + Humidity3pm, Humidity3pm + Sunsh... 0.9857, 0.9911, 1.0, 1.0, 0.9998, 1.0 19 Humidity3pm + Sunshine Humidity3pm, Evaporation + Humidity3pm, Humidi... 0.9911, 0.9804, 0.9911, 0.9911, 0.9907, 0.9911 20 Humidity3pm + WindGustDir Humidity3pm, Evaporation + Humidity3pm, Humidi... 1.0, 0.9857, 0.9911, 1.0, 0.9998, 1.0 21 Humidity3pm - Location Humidity3pm, Evaporation + Humidity3pm, Humidi... 1.0, 0.9857, 0.9911, 1.0, 0.9998, 1.0 22 Humidity3pm - RainToday_No Humidity3pm, Evaporation + Humidity3pm, Humidi... 0.9998, 0.9855, 0.9907, 0.9998, 0.9998, 0.9998 23 Humidity3pm - RainToday_infrequent Humidity3pm, Evaporation + Humidity3pm, Humidi... 1.0, 0.9857, 0.9911, 1.0, 1.0, 0.9998 24 Cloud9am - RainToday_infrequent Cloud9am 0.9992 25 Temp9am Temp9am + WindGustDir 1.0 26 RainToday_Yes - WindDir3pm RainToday_Yes 0.9944 27 MinTemp + Temp3pm MaxTemp + MinTemp 0.9949 In\u00a0[11]: Copied! <pre># After applying rfecv, we can plot the score per number of features\natom.plot_rfecv()\n</pre> # After applying rfecv, we can plot the score per number of features atom.plot_rfecv() In\u00a0[12]: Copied! <pre># Let's see how the model performs now\n# Add a tag to the model's acronym to not overwrite previous LGB\natom.run(\"LGB_dfs\", errors=\"raise\")\n</pre> # Let's see how the model performs now # Add a tag to the model's acronym to not overwrite previous LGB atom.run(\"LGB_dfs\", errors=\"raise\") <pre>\nTraining ========================= &gt;&gt;\nModels: LGB_dfs\nMetric: auc\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.991\nTest evaluation --&gt; auc: 0.8768\nTime elapsed: 1.673s\n-------------------------------------------------\nTime: 1.673s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.678s\n-------------------------------------\nLightGBM --&gt; auc: 0.8768\n</pre> In\u00a0[13]: Copied! <pre># Create another branch for the genetic features\n# Split form master to avoid the dfs features\natom.branch = \"gfg_from_main\"\n</pre> # Create another branch for the genetic features # Split form master to avoid the dfs features atom.branch = \"gfg_from_main\" <pre>Successfully created new branch: gfg.\n</pre> In\u00a0[14]: Copied! <pre># Create new features using Genetic Programming\natom.feature_generation(strategy='gfg', n_features=20)\n</pre> # Create new features using Genetic Programming atom.feature_generation(strategy='gfg', n_features=20) <pre>Fitting FeatureGenerator...\n    |   Population Average    |             Best Individual              |\n---- ------------------------- ------------------------------------------ ----------\n Gen   Length          Fitness   Length          Fitness      OOB Fitness  Time Left\n   0     3.02         0.139961        3         0.490021              N/A     23.20s\n   1     3.18         0.357605        7          0.49915              N/A     22.79s\n   2     3.82         0.425184       10         0.517679              N/A     22.07s\n   3     4.54           0.4404        9         0.527987              N/A     20.03s\n   4     6.87         0.445283       11         0.538222              N/A     18.79s\n   5     9.75         0.455204       15         0.543529              N/A     17.89s\n   6    11.53         0.456228       19         0.546248              N/A     16.75s\n   7    11.94         0.456611       21         0.547784              N/A     17.84s\n   8    12.74         0.463229       23          0.54873              N/A     14.39s\n   9    12.66         0.473977       21         0.548153              N/A     13.51s\n  10    11.80         0.478966       19         0.546534              N/A     11.67s\n  11    11.74         0.482432       19         0.547183              N/A     10.21s\n  12    12.63         0.473585       19         0.548053              N/A      9.43s\n  13    13.58         0.460883       23         0.550949              N/A      7.55s\n  14    14.06         0.462297       21         0.550264              N/A      6.35s\n  15    14.81         0.461855       25         0.551663              N/A      5.34s\n  16    14.88         0.467768       23         0.550597              N/A      3.89s\n  17    14.85         0.477248       21         0.550264              N/A      2.55s\n  18    15.07         0.478368       16         0.558362              N/A      1.27s\n  19    14.70         0.477435       16         0.558362              N/A      0.00s\nGenerating new features...\n --&gt; 20 new features were added.\n</pre> In\u00a0[15]: Copied! <pre># We can see the feature's fitness and description through the genetic_features attribute\natom.genetic_features_\n</pre> # We can see the feature's fitness and description through the genetic_features attribute atom.genetic_features_ Out[15]: name description fitness 0 x23 add(add(sub(Cloud3pm, mul(RainToday_No, abs(Wi... 0.542362 1 x24 add(add(sub(Cloud3pm, mul(RainToday_No, abs(Wi... 0.542049 2 x25 add(add(sub(Cloud3pm, mul(RainToday_No, abs(Wi... 0.540022 3 x26 add(add(sub(Cloud3pm, mul(RainToday_No, Sunshi... 0.534542 4 x27 add(sub(sub(sub(Humidity3pm, Pressure3pm), mul... 0.533542 5 x28 add(add(sub(sub(Cloud3pm, mul(RainToday_No, Su... 0.533542 6 x29 add(sub(sub(sub(Humidity3pm, Pressure3pm), abs... 0.533542 7 x30 add(sub(sub(Humidity3pm, Pressure3pm), mul(Rai... 0.532984 8 x31 sub(Sunshine, add(add(sub(Cloud3pm, abs(WindSp... 0.532205 9 x32 sub(Sunshine, add(add(sub(Cloud3pm, abs(WindSp... 0.532200 10 x33 add(add(sub(Cloud3pm, abs(WindSpeed3pm)), Wind... 0.532200 11 x34 add(sub(sub(sub(Humidity3pm, Sunshine), Pressu... 0.532200 12 x35 add(sub(sub(sub(Humidity3pm, Pressure3pm), Sun... 0.532200 13 x36 sub(Sunshine, add(add(sub(Cloud3pm, abs(WindSp... 0.532200 14 x37 add(add(sub(Cloud3pm, abs(WindSpeed3pm)), Wind... 0.532200 15 x38 sub(add(add(sub(Humidity3pm, Pressure3pm), Win... 0.532200 16 x39 add(sub(sub(sub(sub(Humidity3pm, Pressure3pm),... 0.531546 17 x40 add(add(sub(Cloud3pm, abs(WindSpeed3pm)), Wind... 0.531546 18 x41 sub(Sunshine, add(add(sub(Cloud3pm, abs(abs(Wi... 0.531200 19 x42 add(sub(sub(sub(Humidity3pm, Pressure3pm), Sun... 0.531067 In\u00a0[16]: Copied! <pre># Fit the model again\natom.run(\"LGB_gfg\", metric=\"auc\")\n</pre> # Fit the model again atom.run(\"LGB_gfg\", metric=\"auc\") <pre>\nTraining ========================= &gt;&gt;\nModels: LGB_gfg\nMetric: auc\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.9884\nTest evaluation --&gt; auc: 0.8791\nTime elapsed: 1.487s\n-------------------------------------------------\nTime: 1.487s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.493s\n-------------------------------------\nLightGBM --&gt; auc: 0.8791\n</pre> In\u00a0[17]: Copied! <pre># Visualize the whole pipeline\natom.plot_pipeline()\n</pre> # Visualize the whole pipeline atom.plot_pipeline() In\u00a0[18]: Copied! <pre># Use atom's plots to compare the three models\natom.plot_roc(rows=\"test+train\")\n</pre> # Use atom's plots to compare the three models atom.plot_roc(rows=\"test+train\") In\u00a0[19]: Copied! <pre># To compare other plots it might be useful to use a canvas\nwith atom.canvas(1, 2, figsize=(1800, 800)):\n    atom.lgb_dfs.plot_roc(rows=\"test+train\")\n    atom.lgb_dfs.plot_feature_importance(show=10, title=\"LGB + dfs\")\n</pre> # To compare other plots it might be useful to use a canvas with atom.canvas(1, 2, figsize=(1800, 800)):     atom.lgb_dfs.plot_roc(rows=\"test+train\")     atom.lgb_dfs.plot_feature_importance(show=10, title=\"LGB + dfs\") In\u00a0[20]: Copied! <pre># We can check the feature importance with other plots as well\natom.plot_permutation_importance(models=[\"LGB_dfs\", \"LGB_gfg\"], show=12)\n</pre> # We can check the feature importance with other plots as well atom.plot_permutation_importance(models=[\"LGB_dfs\", \"LGB_gfg\"], show=12) In\u00a0[21]: Copied! <pre>atom.LGB_gfg.plot_shap_decision(rows=(0, 10), show=15)\n</pre> atom.LGB_gfg.plot_shap_decision(rows=(0, 10), show=15)"}, {"location": "examples/feature_engineering/#example-feature-engineering", "title": "Example: Feature engineering\u00b6", "text": "<p>This example shows how to use automated feature generation to improve a model's performance.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/feature_engineering/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/feature_engineering/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/feature_engineering/#deep-feature-synthesis", "title": "Deep Feature Synthesis\u00b6", "text": ""}, {"location": "examples/feature_engineering/#genetic-feature-generation", "title": "Genetic Feature Generation\u00b6", "text": ""}, {"location": "examples/feature_engineering/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/getting_started/", "title": "Getting started", "text": "In\u00a0[6]: Copied! <pre>import pandas as pd\nfrom atom import ATOMClassifier\n\n# Load the Australian Weather dataset\nX = pd.read_csv(\"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\")\n</pre> import pandas as pd from atom import ATOMClassifier  # Load the Australian Weather dataset X = pd.read_csv(\"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\") In\u00a0[7]: Copied! <pre>atom = ATOMClassifier(X, y=\"RainTomorrow\", n_rows=1000, verbose=2)\n</pre> atom = ATOMClassifier(X, y=\"RainTomorrow\", n_rows=1000, verbose=2) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (1000, 22)\nTrain set size: 800\nTest set size: 200\n-------------------------------------\nMemory: 176.13 kB\nScaled: False\nMissing values: 2243 (10.2%)\nCategorical features: 5 (23.8%)\n\n</pre> In\u00a0[8]: Copied! <pre>atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\")  \natom.encode(strategy=\"Target\", max_onehot=8)\n</pre> atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\")   atom.encode(strategy=\"Target\", max_onehot=8) <pre>Fitting Imputer...\nImputing missing values...\n --&gt; Imputing 5 missing values with median (11.8) in column MinTemp.\n --&gt; Imputing 1 missing values with median (22.2) in column MaxTemp.\n --&gt; Imputing 11 missing values with median (0.0) in column Rainfall.\n --&gt; Imputing 429 missing values with median (4.8) in column Evaporation.\n --&gt; Imputing 477 missing values with median (8.6) in column Sunshine.\n --&gt; Imputing 67 missing values with most_frequent (SE) in column WindGustDir.\n --&gt; Imputing 66 missing values with median (39.0) in column WindGustSpeed.\n --&gt; Imputing 78 missing values with most_frequent (N) in column WindDir9am.\n --&gt; Imputing 24 missing values with most_frequent (SSE) in column WindDir3pm.\n --&gt; Imputing 7 missing values with median (13.0) in column WindSpeed9am.\n --&gt; Imputing 20 missing values with median (19.0) in column WindSpeed3pm.\n --&gt; Imputing 15 missing values with median (70.0) in column Humidity9am.\n --&gt; Imputing 24 missing values with median (53.0) in column Humidity3pm.\n --&gt; Imputing 106 missing values with median (1017.9) in column Pressure9am.\n --&gt; Imputing 104 missing values with median (1015.7) in column Pressure3pm.\n --&gt; Imputing 371 missing values with median (5.0) in column Cloud9am.\n --&gt; Imputing 402 missing values with median (5.0) in column Cloud3pm.\n --&gt; Imputing 7 missing values with median (16.4) in column Temp9am.\n --&gt; Imputing 18 missing values with median (20.8) in column Temp3pm.\n --&gt; Imputing 11 missing values with most_frequent (No) in column RainToday.\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Target-encoding feature Location. Contains 49 classes.\n --&gt; Target-encoding feature WindGustDir. Contains 16 classes.\n --&gt; Target-encoding feature WindDir9am. Contains 16 classes.\n --&gt; Target-encoding feature WindDir3pm. Contains 16 classes.\n --&gt; Ordinal-encoding feature RainToday. Contains 2 classes.\n</pre> In\u00a0[9]: Copied! <pre>atom.run(models=[\"LDA\", \"AdaB\"], metric=\"auc\", n_trials=10)\n</pre> atom.run(models=[\"LDA\", \"AdaB\"], metric=\"auc\", n_trials=10) <pre>\nTraining ========================= &gt;&gt;\nModels: LDA, AdaB\nMetric: auc\n\n\nRunning hyperparameter tuning for LinearDiscriminantAnalysis...\n| trial |  solver | shrinkage |     auc | best_auc | time_trial | time_ht |    state |\n| ----- | ------- | --------- | ------- | -------- | ---------- | ------- | -------- |\n| 0     |    lsqr |      auto |  0.6291 |   0.6291 |     0.127s |  0.127s | COMPLETE |\n| 1     |     svd |      None |  0.7018 |   0.7018 |     0.122s |  0.250s | COMPLETE |\n| 2     |     svd |      None |  0.7018 |   0.7018 |     0.001s |  0.251s | COMPLETE |\n| 3     |     svd |      None |  0.7018 |   0.7018 |     0.000s |  0.251s | COMPLETE |\n| 4     |     svd |      None |  0.7018 |   0.7018 |     0.000s |  0.251s | COMPLETE |\n| 5     |   eigen |      auto |  0.6675 |   0.7018 |     0.129s |  0.380s | COMPLETE |\n| 6     |    lsqr |       0.9 |  0.7511 |   0.7511 |     0.124s |  0.504s | COMPLETE |\n| 7     |     svd |      None |  0.7018 |   0.7511 |     0.000s |  0.504s | COMPLETE |\n| 8     |    lsqr |       0.8 |  0.7035 |   0.7511 |     0.121s |  0.625s | COMPLETE |\n| 9     |   eigen |      None |  0.6638 |   0.7511 |     0.120s |  0.745s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 6\nBest parameters:\n --&gt; solver: lsqr\n --&gt; shrinkage: 0.9\nBest evaluation --&gt; auc: 0.7511\nTime elapsed: 0.745s\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.8034\nTest evaluation --&gt; auc: 0.8655\nTime elapsed: 0.035s\n-------------------------------------------------\nTime: 0.779s\n\n\nRunning hyperparameter tuning for AdaBoost...\n| trial | n_estimators | learning_rate |     auc | best_auc | time_trial | time_ht |    state |\n| ----- | ------------ | ------------- | ------- | -------- | ---------- | ------- | -------- |\n| 0     |          220 |        0.0145 |  0.5558 |   0.5558 |     0.559s |  0.559s | COMPLETE |\n| 1     |          340 |        0.0149 |  0.6245 |   0.6245 |     0.797s |  1.356s | COMPLETE |\n| 2     |          310 |        0.3206 |  0.6427 |   0.6427 |     0.745s |  2.101s | COMPLETE |\n| 3     |          120 |        8.1247 |     0.5 |   0.6427 |     0.368s |  2.469s | COMPLETE |\n| 4     |           70 |         0.065 |  0.5728 |   0.6427 |     0.262s |  2.731s | COMPLETE |\n| 5     |          280 |        3.2722 |     0.5 |   0.6427 |     0.684s |  3.415s | COMPLETE |\n| 6     |          330 |        0.0341 |  0.6167 |   0.6427 |     0.790s |  4.205s | COMPLETE |\n| 7     |           90 |        0.0442 |  0.5856 |   0.6427 |     0.308s |  4.513s | COMPLETE |\n| 8     |          290 |        5.6564 |     0.5 |   0.6427 |     0.723s |  5.236s | COMPLETE |\n| 9     |          450 |        5.7754 |  0.5128 |   0.6427 |     1.046s |  6.282s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 2\nBest parameters:\n --&gt; n_estimators: 310\n --&gt; learning_rate: 0.3206\nBest evaluation --&gt; auc: 0.6427\nTime elapsed: 6.282s\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.952\nTest evaluation --&gt; auc: 0.8025\nTime elapsed: 0.790s\n-------------------------------------------------\nTime: 7.072s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 9.717s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; auc: 0.8655 !\nAdaBoost                   --&gt; auc: 0.8025\n</pre> In\u00a0[10]: Copied! <pre>atom.evaluate()\n</pre> atom.evaluate() Out[10]: accuracy ap ba f1 jaccard mcc precision recall auc LDA 0.830000 0.778200 0.804700 0.685200 0.521100 0.574700 0.627100 0.755100 0.865500 AdaB 0.825000 0.671200 0.711800 0.578300 0.406800 0.485000 0.705900 0.489800 0.802500"}, {"location": "examples/getting_started/#example-getting-started", "title": "Example: Getting started\u00b6", "text": "<p>This example shows how to get started with the atom-ml library.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/holdout_set/", "title": "Holdout set", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() In\u00a0[3]: Copied! <pre># Initialize atom specifying a fraction of the dataset for holdout\natom = ATOMClassifier(X, n_rows=0.5, holdout_size=0.2, verbose=2)\n</pre> # Initialize atom specifying a fraction of the dataset for holdout atom = ATOMClassifier(X, n_rows=0.5, holdout_size=0.2, verbose=2) In\u00a0[4]: Copied! <pre># The test and holdout fractions are split after subsampling the dataset\n# Also note that the holdout data set is not a part of atom's dataset\nprint(\"Length loaded data:\", len(X))\nprint(\"Length dataset + holdout:\", len(atom.dataset) + len(atom.holdout))\n</pre> # The test and holdout fractions are split after subsampling the dataset # Also note that the holdout data set is not a part of atom's dataset print(\"Length loaded data:\", len(X)) print(\"Length dataset + holdout:\", len(atom.dataset) + len(atom.holdout)) In\u00a0[5]: Copied! <pre>atom.impute()\natom.encode()\n</pre> atom.impute() atom.encode() In\u00a0[6]: Copied! <pre># Unlike train and test, the holdout data set is not transformed until used for predictions\natom.holdout\n</pre> # Unlike train and test, the holdout data set is not transformed until used for predictions atom.holdout In\u00a0[7]: Copied! <pre>atom.run(models=[\"GNB\", \"LR\", \"RF\"])\n</pre> atom.run(models=[\"GNB\", \"LR\", \"RF\"]) In\u00a0[8]: Copied! <pre>atom.plot_prc()\n</pre> atom.plot_prc() In\u00a0[9]: Copied! <pre># Based on the results on the test set, we select the best model for further tuning\natom.run(\"lr_tuned\", n_trials=10)\n</pre> # Based on the results on the test set, we select the best model for further tuning atom.run(\"lr_tuned\", n_trials=10) <p>We already used the test set to choose the best model for futher tuning, so this set is no longer truly independent. Although it may not be directly visible in the results, using the test set now to evaluate the tuned LR model would be a mistake, since it carries a bias. For this reason, we have set apart an extra, indepedent set to validate the final model: the holdout set. If we are not going to use the test set for validation, we might as well use it to train the model and so optimize the use of the available data. Use the full_train method for this.</p> In\u00a0[10]: Copied! <pre># Re-train the model on the full dataset (train + test) \natom.lr_tuned.full_train()\n</pre> # Re-train the model on the full dataset (train + test)  atom.lr_tuned.full_train() In\u00a0[11]: Copied! <pre># Evaluate on the holdout set\natom.lr_tuned.evaluate(rows=\"holdout\")\n</pre> # Evaluate on the holdout set atom.lr_tuned.evaluate(rows=\"holdout\") In\u00a0[12]: Copied! <pre>atom.lr_tuned.plot_prc(rows=\"holdout\", legend=\"upper right\")\n</pre> atom.lr_tuned.plot_prc(rows=\"holdout\", legend=\"upper right\")"}, {"location": "examples/holdout_set/#example-holdout-set", "title": "Example: Holdout set\u00b6", "text": "<p>This example shows when and how to use ATOM's holdout set in an exploration pipeline.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/holdout_set/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/holdout_set/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/holdout_set/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/hyperparameter_tuning/", "title": "Hyperparameter tuning", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_breast_cancer\nfrom optuna.distributions import IntDistribution\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_breast_cancer from optuna.distributions import IntDistribution from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX, y = load_breast_cancer(return_X_y=True)\n</pre> # Load the data X, y = load_breast_cancer(return_X_y=True) In\u00a0[3]: Copied! <pre># Initialize atom\natom = ATOMClassifier(X, y, n_jobs=4, verbose=2, random_state=1)\n</pre> # Initialize atom atom = ATOMClassifier(X, y, n_jobs=4, verbose=2, random_state=1) In\u00a0[4]: Copied! <pre># Train a MultiLayerPerceptron model on two metrics\n# using a custom number of hidden layers\natom.run(\n    models=\"MLP\",\n    metric=[\"f1\", \"ap\"],\n    n_trials=10,\n    est_params={\"activation\": \"relu\"},\n    ht_params={\n        \"distributions\": {\n            \"hidden_layer_1\": IntDistribution(2, 4),\n            \"hidden_layer_2\": IntDistribution(10, 20),\n            \"hidden_layer_3\": IntDistribution(10, 20),\n            \"hidden_layer_4\": IntDistribution(2, 4),\n        }\n    },\n    errors='raise'\n)\n</pre> # Train a MultiLayerPerceptron model on two metrics # using a custom number of hidden layers atom.run(     models=\"MLP\",     metric=[\"f1\", \"ap\"],     n_trials=10,     est_params={\"activation\": \"relu\"},     ht_params={         \"distributions\": {             \"hidden_layer_1\": IntDistribution(2, 4),             \"hidden_layer_2\": IntDistribution(10, 20),             \"hidden_layer_3\": IntDistribution(10, 20),             \"hidden_layer_4\": IntDistribution(2, 4),         }     },     errors='raise' ) In\u00a0[5]: Copied! <pre># For multi-metric runs, the selected best trial is the first in the Pareto front\natom.mlp.best_trial\n</pre> # For multi-metric runs, the selected best trial is the first in the Pareto front atom.mlp.best_trial In\u00a0[6]: Copied! <pre>atom.plot_pareto_front()\n</pre> atom.plot_pareto_front() In\u00a0[7]: Copied! <pre># If you are unhappy with the results, it's possible to conitnue the study\natom.mlp.hyperparameter_tuning(n_trials=5)\n</pre> # If you are unhappy with the results, it's possible to conitnue the study atom.mlp.hyperparameter_tuning(n_trials=5) In\u00a0[8]: Copied! <pre># The trials attribute gives an overview of the trial results\natom.mlp.trials\n</pre> # The trials attribute gives an overview of the trial results atom.mlp.trials In\u00a0[9]: Copied! <pre># Select a custom best trial...\natom.mlp.best_trial = 2\n\n# ...and check that the best parameters are now those in the selected trial\natom.mlp.best_params\n</pre> # Select a custom best trial... atom.mlp.best_trial = 2  # ...and check that the best parameters are now those in the selected trial atom.mlp.best_params In\u00a0[10]: Copied! <pre># Lastly, fit the model on the complete training set \n# using the new combination of hyperparameters\natom.mlp.fit()\n</pre> # Lastly, fit the model on the complete training set  # using the new combination of hyperparameters atom.mlp.fit() In\u00a0[11]: Copied! <pre>atom.plot_trials()\n</pre> atom.plot_trials() In\u00a0[12]: Copied! <pre>atom.plot_parallel_coordinate()\n</pre> atom.plot_parallel_coordinate()"}, {"location": "examples/hyperparameter_tuning/#example-hyperparameter-tuning", "title": "Example: Hyperparameter tuning\u00b6", "text": "<p>This example shows an advanced example on how to optimize your model's hyperparameters for multi-metric runs.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/hyperparameter_tuning/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/hyperparameter_tuning/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/hyperparameter_tuning/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/imbalanced_datasets/", "title": "Imbalanced datasets", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom atom import ATOMClassifier\nfrom sklearn.datasets import make_classification\n</pre> # Import packages from atom import ATOMClassifier from sklearn.datasets import make_classification In\u00a0[2]: Copied! <pre># Create a mock imbalanced dataset\nX, y = make_classification(\n    n_samples=5000,\n    n_features=30,\n    n_informative=20,\n    weights=(0.95,),\n    random_state=1,\n)\n</pre> # Create a mock imbalanced dataset X, y = make_classification(     n_samples=5000,     n_features=30,     n_informative=20,     weights=(0.95,),     random_state=1, ) In\u00a0[3]: Copied! <pre># Initialize atom\natom = ATOMClassifier(X, y, test_size=0.2, verbose=2, random_state=1)\n</pre> # Initialize atom atom = ATOMClassifier(X, y, test_size=0.2, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (5000, 31)\nTrain set size: 4000\nTest set size: 1000\n-------------------------------------\nMemory: 1.24 MB\nScaled: False\nOutlier values: 570 (0.5%)\n\n</pre> In\u00a0[4]: Copied! <pre># Let's have a look at the data. Note that, since the input wasn't\n# a dataframe, atom has given default names to the columns.\natom.head()\n</pre> # Let's have a look at the data. Note that, since the input wasn't # a dataframe, atom has given default names to the columns. atom.head() Out[4]: x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 ... x21 x22 x23 x24 x25 x26 x27 x28 x29 target 0 -0.535760 -2.426045 1.256836 0.374501 -3.241958 -1.239468 -0.208750 -6.015995 3.698669 0.112512 ... 0.044302 -1.935727 10.870353 0.286755 -2.416507 0.556990 -1.522635 3.719201 1.449135 0 1 -3.311935 -3.149920 -0.801252 -2.644414 -0.704889 -3.312256 0.714515 2.992345 5.056910 3.036775 ... 2.224359 0.451273 -1.822108 -1.435801 0.036132 -1.364583 1.215663 5.232161 1.408798 0 2 3.821199 1.328129 -1.000720 -13.151697 0.254253 1.263636 -1.088451 4.924264 -1.225646 -6.974824 ... 3.541222 1.686667 -13.763703 -1.321256 1.677687 0.774966 -5.067689 4.663386 -1.714186 0 3 5.931126 3.338830 0.545906 2.296355 -3.941088 3.527252 -0.158770 3.138381 -0.927460 -1.642079 ... -3.634442 7.853176 -8.457598 0.000490 -2.612756 -1.138206 0.497150 4.351289 -0.321748 0 4 -2.829472 -1.227185 -0.751892 3.056106 -1.988920 -2.219184 -0.075882 5.790102 -2.786671 2.023458 ... 4.057954 1.178564 -15.028187 1.627140 -1.093587 -0.422655 1.777011 6.660638 -2.553723 0 <p>5 rows \u00d7 31 columns</p> In\u00a0[5]: Copied! <pre># Let's start reducing the number of features\natom.feature_selection(\"rfe\", solver=\"rf\", n_features=12)\n</pre> # Let's start reducing the number of features atom.feature_selection(\"rfe\", solver=\"rf\", n_features=12) <pre>Fitting FeatureSelector...\nPerforming feature selection ...\n --&gt; rfe selected 12 features from the dataset.\n   --&gt; Dropping feature x1 (rank 8).\n   --&gt; Dropping feature x2 (rank 11).\n   --&gt; Dropping feature x4 (rank 3).\n   --&gt; Dropping feature x6 (rank 16).\n   --&gt; Dropping feature x7 (rank 14).\n   --&gt; Dropping feature x10 (rank 19).\n   --&gt; Dropping feature x12 (rank 13).\n   --&gt; Dropping feature x13 (rank 12).\n   --&gt; Dropping feature x14 (rank 9).\n   --&gt; Dropping feature x16 (rank 10).\n   --&gt; Dropping feature x18 (rank 17).\n   --&gt; Dropping feature x19 (rank 2).\n   --&gt; Dropping feature x20 (rank 4).\n   --&gt; Dropping feature x22 (rank 7).\n   --&gt; Dropping feature x23 (rank 5).\n   --&gt; Dropping feature x24 (rank 18).\n   --&gt; Dropping feature x25 (rank 6).\n   --&gt; Dropping feature x26 (rank 15).\n</pre> In\u00a0[6]: Copied! <pre># Fit a model directly on the imbalanced data\natom.run(\"RF\", metric=\"ba\")\n</pre> # Fit a model directly on the imbalanced data atom.run(\"RF\", metric=\"ba\") <pre>\nTraining ========================= &gt;&gt;\nModels: RF\nMetric: ba\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; ba: 1.0\nTest evaluation --&gt; ba: 0.5556\nTime elapsed: 1.148s\n-------------------------------------------------\nTime: 1.148s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.150s\n-------------------------------------\nRandomForest --&gt; ba: 0.5556 ~\n</pre> In\u00a0[7]: Copied! <pre># The transformer and the models have been added to the branch\natom.branch\n</pre> # The transformer and the models have been added to the branch atom.branch Out[7]: <pre>Branch(main)</pre> In\u00a0[8]: Copied! <pre># Create a new branch for oversampling\natom.branch = \"oversample\"\n</pre> # Create a new branch for oversampling atom.branch = \"oversample\" <pre>Successfully created new branch: oversample.\n</pre> In\u00a0[9]: Copied! <pre># Perform oversampling of the minority class\natom.balance(strategy=\"smote\")\n</pre> # Perform oversampling of the minority class atom.balance(strategy=\"smote\") <pre>Oversampling with SMOTE...\n --&gt; Adding 3570 samples to class 1.\n</pre> In\u00a0[10]: Copied! <pre>atom.classes  # Check the balanced training set!\n</pre> atom.classes  # Check the balanced training set! Out[10]: dataset train test 0 4731 3785 946 1 3839 3785 54 In\u00a0[11]: Copied! <pre># Train another model on the new branch. Add a tag after \n# the model's acronym to distinguish it from the first model\natom.run(\"rf_os\")  # os for oversample\n</pre> # Train another model on the new branch. Add a tag after  # the model's acronym to distinguish it from the first model atom.run(\"rf_os\")  # os for oversample <pre>\nTraining ========================= &gt;&gt;\nModels: RF_os\nMetric: ba\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; ba: 1.0\nTest evaluation --&gt; ba: 0.7672\nTime elapsed: 2.089s\n-------------------------------------------------\nTime: 2.089s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 2.091s\n-------------------------------------\nRandomForest --&gt; ba: 0.7672 ~\n</pre> In\u00a0[12]: Copied! <pre># Create the undersampling branch\n# Split from master to not adopt the oversmapling transformer\natom.branch = \"undersample_from_main\"\n</pre> # Create the undersampling branch # Split from master to not adopt the oversmapling transformer atom.branch = \"undersample_from_main\" <pre>Successfully created new branch: undersample.\n</pre> In\u00a0[13]: Copied! <pre>atom.classes  # In this branch, the data is still imbalanced\n</pre> atom.classes  # In this branch, the data is still imbalanced Out[13]: dataset train test 0 4731 3785 946 1 269 215 54 In\u00a0[14]: Copied! <pre># Perform undersampling of the majority class\natom.balance(strategy=\"NearMiss\")\n</pre> # Perform undersampling of the majority class atom.balance(strategy=\"NearMiss\") <pre>Undersampling with NearMiss...\n --&gt; Removing 3570 samples from class 0.\n</pre> In\u00a0[15]: Copied! <pre>atom.run(\"rf_us\")\n</pre> atom.run(\"rf_us\") <pre>\nTraining ========================= &gt;&gt;\nModels: RF_us\nMetric: ba\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; ba: 1.0\nTest evaluation --&gt; ba: 0.6706\nTime elapsed: 0.207s\n-------------------------------------------------\nTime: 0.207s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.209s\n-------------------------------------\nRandomForest --&gt; ba: 0.6706 ~\n</pre> In\u00a0[16]: Copied! <pre># Check that the branch only contains the desired transformers \natom.branch\n</pre> # Check that the branch only contains the desired transformers  atom.branch Out[16]: <pre>Branch(undersample)</pre> In\u00a0[17]: Copied! <pre># Visualize the complete pipeline\natom.plot_pipeline()\n</pre> # Visualize the complete pipeline atom.plot_pipeline() In\u00a0[18]: Copied! <pre>atom.evaluate()\n</pre> atom.evaluate() Out[18]: accuracy ap ba f1 jaccard mcc precision recall auc RF 0.952000 0.656200 0.555600 0.200000 0.111100 0.325200 1.000000 0.111100 0.910700 RF_os 0.956000 0.621500 0.767200 0.576900 0.405400 0.554200 0.600000 0.555600 0.925100 RF_us 0.509000 0.368700 0.670600 0.157800 0.085700 0.154500 0.087000 0.851900 0.825800 In\u00a0[19]: Copied! <pre>atom.plot_prc()\n</pre> atom.plot_prc() In\u00a0[20]: Copied! <pre>atom.plot_roc()\n</pre> atom.plot_roc()"}, {"location": "examples/imbalanced_datasets/#example-imbalanced-datasets", "title": "Example: Imbalanced datasets\u00b6", "text": "<p>This example shows how ATOM can help you handle imbalanced datasets. We will evaluate the performance of three different Random Forest models: one trained directly on the imbalanced dataset, one trained on an oversampled dataset and the last one trained on an undersampled dataset.</p>"}, {"location": "examples/imbalanced_datasets/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/imbalanced_datasets/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/imbalanced_datasets/#oversampling", "title": "Oversampling\u00b6", "text": ""}, {"location": "examples/imbalanced_datasets/#undersampling", "title": "Undersampling\u00b6", "text": ""}, {"location": "examples/imbalanced_datasets/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/in_training_validation/", "title": "In-training validation", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_breast_cancer\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX, y = load_breast_cancer(return_X_y=True)\n</pre> # Load the data X, y = load_breast_cancer(return_X_y=True) In\u00a0[3]: Copied! <pre># Initialize atom\natom = ATOMClassifier(X, y, verbose=2, random_state=1)\n</pre> # Initialize atom atom = ATOMClassifier(X, y, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 141.24 kB\nScaled: False\nOutlier values: 167 (1.2%)\n\n</pre> In\u00a0[4]: Copied! <pre># Not all models support in-training validation\n# You can chek which ones do using the available_models method\natom.available_models(validation=True)\n</pre> # Not all models support in-training validation # You can chek which ones do using the available_models method atom.available_models(validation=True) Out[4]: acronym fullname estimator module handles_missing needs_scaling accepts_sparse native_multilabel native_multioutput validation supports_engines 0 CatB CatBoost CatBoostClassifier catboost.core True True True False False n_estimators catboost 1 LGB LightGBM LGBMClassifier lightgbm.sklearn True True True False False n_estimators lightgbm 2 MLP MultiLayerPerceptron MLPClassifier sklearn.neural_network._multilayer_perceptron False True True True False max_iter sklearn 3 PA PassiveAggressive PassiveAggressiveClassifier sklearn.linear_model._passive_aggressive False True True False False max_iter sklearn 4 Perc Perceptron Perceptron sklearn.linear_model._perceptron False True False False False max_iter sklearn 5 SGD StochasticGradientDescent SGDClassifier sklearn.linear_model._stochastic_gradient False True True False False max_iter sklearn 6 XGB XGBoost XGBClassifier xgboost.sklearn True True True False False n_estimators xgboost In\u00a0[5]: Copied! <pre># Run the models normally\natom.run(models=[\"MLP\", \"LGB\"], metric=\"auc\")\n</pre> # Run the models normally atom.run(models=[\"MLP\", \"LGB\"], metric=\"auc\") <pre>\nTraining ========================= &gt;&gt;\nModels: MLP, LGB\nMetric: auc\n\n\nResults for MultiLayerPerceptron:\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 0.9997\nTest evaluation --&gt; auc: 0.9936\nTime elapsed: 1.825s\n-------------------------------------------------\nTime: 1.825s\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; auc: 1.0\nTest evaluation --&gt; auc: 0.9775\nTime elapsed: 0.417s\n-------------------------------------------------\nTime: 0.417s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 2.246s\n-------------------------------------\nMultiLayerPerceptron --&gt; auc: 0.9936 !\nLightGBM             --&gt; auc: 0.9775\n</pre> In\u00a0[6]: Copied! <pre>atom.plot_evals(title=\"In-training validation scores\")\n</pre> atom.plot_evals(title=\"In-training validation scores\") In\u00a0[7]: Copied! <pre># Plot the validation on the train and test set\natom.lgb.plot_evals(dataset=\"train+test\", title=\"LightGBM's in-training validation\")\n</pre> # Plot the validation on the train and test set atom.lgb.plot_evals(dataset=\"train+test\", title=\"LightGBM's in-training validation\")"}, {"location": "examples/in_training_validation/#example-in-training-validation", "title": "Example: In-training validation\u00b6", "text": "<p>This example shows how to keep track of the model's performance during training.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/in_training_validation/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/in_training_validation/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/in_training_validation/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/memory_considerations/", "title": "Memory considerations", "text": "In\u00a0[5]: Copied! <pre># Import packages\nimport os\nimport tempfile\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import os import tempfile import pandas as pd from atom import ATOMClassifier In\u00a0[6]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[6]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[7]: Copied! <pre># Define a temp directory to store the files in this example\ntempdir = tempfile.gettempdir()\n</pre> # Define a temp directory to store the files in this example tempdir = tempfile.gettempdir() In\u00a0[8]: Copied! <pre>def get_size(filepath):\n    \"\"\"Return the size of the object in MB.\"\"\"\n    return f\"{os.path.getsize(filepath + '.pkl') / 1e6:.2f}MB\"\n</pre> def get_size(filepath):     \"\"\"Return the size of the object in MB.\"\"\"     return f\"{os.path.getsize(filepath + '.pkl') / 1e6:.2f}MB\" In\u00a0[9]: Copied! <pre>atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=2)\n</pre> atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=2) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.03 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n\n</pre> <p>Note that the datset takes ~25MB. We can reduce the size of the dataset using the shrink method, which reduces the dtypes to their smallest possible value.</p> In\u00a0[10]: Copied! <pre>atom.dtypes\n</pre> atom.dtypes Out[10]: <pre>Location          object\nMinTemp          float64\nMaxTemp          float64\nRainfall         float64\nEvaporation      float64\nSunshine         float64\nWindGustDir       object\nWindGustSpeed    float64\nWindDir9am        object\nWindDir3pm        object\nWindSpeed9am     float64\nWindSpeed3pm     float64\nHumidity9am      float64\nHumidity3pm      float64\nPressure9am      float64\nPressure3pm      float64\nCloud9am         float64\nCloud3pm         float64\nTemp9am          float64\nTemp3pm          float64\nRainToday         object\nRainTomorrow       int64\ndtype: object</pre> In\u00a0[11]: Copied! <pre>atom.shrink(str2cat=True)\n</pre> atom.shrink(str2cat=True) <pre>The column dtypes are successfully converted.\n</pre> In\u00a0[12]: Copied! <pre>atom.dtypes\n</pre> atom.dtypes Out[12]: <pre>Location         category\nMinTemp           Float32\nMaxTemp           Float32\nRainfall          Float32\nEvaporation       Float32\nSunshine          Float32\nWindGustDir      category\nWindGustSpeed       Int16\nWindDir9am       category\nWindDir3pm       category\nWindSpeed9am        Int16\nWindSpeed3pm         Int8\nHumidity9am          Int8\nHumidity3pm          Int8\nPressure9am       Float32\nPressure3pm       Float32\nCloud9am             Int8\nCloud3pm             Int8\nTemp9am           Float32\nTemp3pm           Float32\nRainToday        category\nRainTomorrow         Int8\ndtype: object</pre> In\u00a0[13]: Copied! <pre># Let's check the memory usage again...\n# Notice the huge drop!\natom.stats()\n</pre> # Let's check the memory usage again... # Notice the huge drop! atom.stats() <pre>Dataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 9.67 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n</pre> In\u00a0[14]: Copied! <pre># Now, we create some new branches to train models with different trasnformers\natom.impute()\natom.encode()\natom.run(\"LDA\")\n\natom.branch = \"b2\"\natom.scale()\natom.run(\"LDA_scaled\")\n\natom.branch = \"b3_from_main\"\natom.normalize()\natom.run(\"LDA_norm\")\n</pre> # Now, we create some new branches to train models with different trasnformers atom.impute() atom.encode() atom.run(\"LDA\")  atom.branch = \"b2\" atom.scale() atom.run(\"LDA_scaled\")  atom.branch = \"b3_from_main\" atom.normalize() atom.run(\"LDA_norm\") <pre>Fitting Imputer...\nImputing missing values...\n --&gt; Imputing 637 missing values with mean (12.19) in column MinTemp.\n --&gt; Imputing 322 missing values with mean (23.23) in column MaxTemp.\n --&gt; Imputing 1406 missing values with mean (2.37) in column Rainfall.\n --&gt; Imputing 60843 missing values with mean (5.48) in column Evaporation.\n --&gt; Imputing 67816 missing values with mean (7.63) in column Sunshine.\n --&gt; Imputing 9330 missing values with most_frequent (W) in column WindGustDir.\n --&gt; Imputing 9270 missing values with mean (40.0) in column WindGustSpeed.\n --&gt; Imputing 10013 missing values with most_frequent (N) in column WindDir9am.\n --&gt; Imputing 3778 missing values with most_frequent (SE) in column WindDir3pm.\n --&gt; Imputing 1348 missing values with mean (14.02) in column WindSpeed9am.\n --&gt; Imputing 2630 missing values with mean (18.64) in column WindSpeed3pm.\n --&gt; Imputing 1774 missing values with mean (68.82) in column Humidity9am.\n --&gt; Imputing 3610 missing values with mean (51.45) in column Humidity3pm.\n --&gt; Imputing 14014 missing values with mean (1017.64) in column Pressure9am.\n --&gt; Imputing 13981 missing values with mean (1015.25) in column Pressure3pm.\n --&gt; Imputing 53657 missing values with mean (4.44) in column Cloud9am.\n --&gt; Imputing 57094 missing values with mean (4.5) in column Cloud3pm.\n --&gt; Imputing 904 missing values with mean (16.99) in column Temp9am.\n --&gt; Imputing 2726 missing values with mean (21.69) in column Temp3pm.\n --&gt; Imputing 1406 missing values with most_frequent (No) in column RainToday.\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Target-encoding feature Location. Contains 49 classes.\n --&gt; Target-encoding feature WindGustDir. Contains 16 classes.\n --&gt; Target-encoding feature WindDir9am. Contains 16 classes.\n --&gt; Target-encoding feature WindDir3pm. Contains 16 classes.\n --&gt; Ordinal-encoding feature RainToday. Contains 2 classes.\n\nTraining ========================= &gt;&gt;\nModels: LDA\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5906\nTest evaluation --&gt; f1: 0.5904\nTime elapsed: 0.942s\n-------------------------------------------------\nTime: 0.942s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.005s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.5904\nSuccessfully created new branch: b2.\nFitting Scaler...\nScaling features...\n\nTraining ========================= &gt;&gt;\nModels: LDA_scaled\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5906\nTest evaluation --&gt; f1: 0.5904\nTime elapsed: 0.956s\n-------------------------------------------------\nTime: 0.956s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.017s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.5904\nSuccessfully created new branch: b3.\nFitting Normalizer...\nNormalizing features...\n\nTraining ========================= &gt;&gt;\nModels: LDA_norm\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5955\nTest evaluation --&gt; f1: 0.594\nTime elapsed: 0.929s\n-------------------------------------------------\nTime: 0.929s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.991s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.594\n</pre> In\u00a0[15]: Copied! <pre># If we save atom now, notice the size\n# This is because atom keeps a copy of every branch in memory\nfilename = os.path.join(tempdir, \"atom1\")\natom.save(filename)\nget_size(filename)\n</pre> # If we save atom now, notice the size # This is because atom keeps a copy of every branch in memory filename = os.path.join(tempdir, \"atom1\") atom.save(filename) get_size(filename) <pre>ATOMClassifier successfully saved.\n</pre> Out[15]: <pre>'83.93MB'</pre> <p>To avoid large memory usages, set the <code>memory</code> parameter.</p> In\u00a0[16]: Copied! <pre>atom = ATOMClassifier(X, y=\"RainTomorrow\", memory=tempdir, verbose=1, random_state=1)\natom.shrink(str2cat=True)\natom.impute()\natom.encode()\natom.run(\"LDA\")\n\natom.branch = \"b2\"\natom.scale()\natom.run(\"LDA_scaled\")\n\natom.branch = \"b3_from_main\"\natom.normalize()\natom.run(\"LDA_norm\")\n</pre> atom = ATOMClassifier(X, y=\"RainTomorrow\", memory=tempdir, verbose=1, random_state=1) atom.shrink(str2cat=True) atom.impute() atom.encode() atom.run(\"LDA\")  atom.branch = \"b2\" atom.scale() atom.run(\"LDA_scaled\")  atom.branch = \"b3_from_main\" atom.normalize() atom.run(\"LDA_norm\") <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\nCache storage: C:\\Users\\Mavs\\AppData\\Local\\Temp\\joblib\n\nDataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.03 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n\nThe column dtypes are successfully converted.\nLoading cached results for Imputer...\nLoading cached results for Encoder...\n\nTraining ========================= &gt;&gt;\nModels: LDA\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5914\nTest evaluation --&gt; f1: 0.5892\nTime elapsed: 0.953s\n-------------------------------------------------\nTime: 0.953s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.015s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.5892\nSuccessfully created new branch: b2.\nLoading cached results for Scaler...\n\nTraining ========================= &gt;&gt;\nModels: LDA_scaled\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5914\nTest evaluation --&gt; f1: 0.5892\nTime elapsed: 0.971s\n-------------------------------------------------\nTime: 0.971s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 1.028s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.5892\nSuccessfully created new branch: b3.\nLoading cached results for Normalizer...\n\nTraining ========================= &gt;&gt;\nModels: LDA_norm\nMetric: f1\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5957\nTest evaluation --&gt; f1: 0.5935\nTime elapsed: 0.924s\n-------------------------------------------------\nTime: 0.924s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.985s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; f1: 0.5935\n</pre> In\u00a0[17]: Copied! <pre># And now, it only takes a fraction of the previous size\n# This is because the data of inactive branches is now stored locally\nfilename = os.path.join(tempdir, \"atom2\")\natom.save(filename)\nget_size(filename)\n</pre> # And now, it only takes a fraction of the previous size # This is because the data of inactive branches is now stored locally filename = os.path.join(tempdir, \"atom2\") atom.save(filename) get_size(filename) <pre>ATOMClassifier successfully saved.\n</pre> Out[17]: <pre>'24.78MB'</pre> <p>Additionnaly, repeated calls to the same transformers with the same data will use the cached results. Don't forget to specify the <code>random_state</code> parameter to ensure the data remains the exact same.</p> In\u00a0[18]: Copied! <pre>atom = ATOMClassifier(X, y=\"RainTomorrow\", memory=tempdir, verbose=1, random_state=1)\natom.shrink(str2cat=True)\n</pre> atom = ATOMClassifier(X, y=\"RainTomorrow\", memory=tempdir, verbose=1, random_state=1) atom.shrink(str2cat=True) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\nCache storage: C:\\Users\\Mavs\\AppData\\Local\\Temp\\joblib\n\nDataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.03 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n\nThe column dtypes are successfully converted.\n</pre> In\u00a0[19]: Copied! <pre># Note the transformers are no longer fitted,\n# instead the results are immediately read from cache\natom.impute()\natom.encode()\n</pre> # Note the transformers are no longer fitted, # instead the results are immediately read from cache atom.impute() atom.encode() <pre>Loading cached results for Imputer...\nLoading cached results for Encoder...\n</pre> In\u00a0[20]: Copied! <pre>atom.dataset\n</pre> atom.dataset Out[20]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 0.070767 13.0 30.500000 0.000000 6.80000 10.000000 0.272677 59.0 0.254995 0.282496 ... 19.000000 8.00000 1013.599976 1008.000000 0.000000 2.00000 19.600000 29.900000 0.0 0 1 0.130163 8.8 25.200001 0.000000 5.00000 7.614201 0.285167 50.0 0.26967 0.278696 ... 68.842218 51.50239 1011.200012 1006.500000 4.446657 3.00000 15.900000 23.700001 0.0 1 2 0.262043 19.9 26.600000 8.000000 5.46491 7.614201 0.26658 57.0 0.254995 0.250291 ... 81.000000 81.00000 1013.099976 1008.599976 4.446657 4.50922 24.500000 24.700001 1.0 1 3 0.183912 19.6 31.900000 2.600000 5.46491 7.614201 0.26658 59.0 0.269775 0.220975 ... 70.000000 42.00000 1001.200012 1002.400024 2.000000 8.00000 25.799999 22.000000 1.0 0 4 0.258569 15.3 22.400000 16.000000 4.20000 3.300000 0.194464 39.0 0.245824 0.189182 ... 83.000000 63.00000 1025.500000 1023.599976 6.000000 6.00000 16.900000 21.100000 1.0 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 142188 0.278746 9.0 21.799999 0.000000 5.46491 7.614201 0.158276 33.0 0.203597 0.277443 ... 44.000000 38.00000 1017.660981 1015.270396 4.446657 4.50922 16.600000 21.100000 0.0 1 142189 0.307562 11.5 19.200001 0.800000 2.00000 7.000000 0.158276 22.0 0.143946 0.187433 ... 73.000000 52.00000 1021.299988 1018.799988 3.000000 4.00000 17.100000 18.400000 0.0 0 142190 0.197839 17.5 29.100000 35.599998 5.46491 7.614201 0.158276 33.0 0.203597 0.180537 ... 77.000000 46.00000 1015.200012 1013.700012 4.446657 4.50922 21.000000 28.799999 1.0 0 142191 0.371853 5.9 18.000000 0.400000 0.80000 6.700000 0.285167 26.0 0.254995 0.278696 ... 92.000000 65.00000 1028.000000 1025.300049 3.000000 2.00000 9.400000 16.600000 0.0 0 142192 0.297818 10.2 18.100000 0.200000 5.46491 7.614201 0.205887 24.0 0.150067 0.221562 ... 84.000000 94.00000 1018.099976 1016.000000 4.446657 4.50922 15.300000 16.000000 0.0 0 <p>142193 rows \u00d7 22 columns</p>"}, {"location": "examples/memory_considerations/#example-memory-considerations", "title": "Example: Memory considerations\u00b6", "text": "<p>This example shows how to use the <code>memory</code> parameter to make efficient use of the available memory.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/memory_considerations/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/memory_considerations/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/metadata/", "title": "Metadata", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport numpy as np\nfrom sklearn.datasets import load_wine\nfrom atom import ATOMClassifier\n</pre> # Import packages import numpy as np from sklearn.datasets import load_wine from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX, y = load_wine(return_X_y=True, as_frame=True)\n\n# Let's have a look\nX.head()\n</pre> # Load data X, y = load_wine(return_X_y=True, as_frame=True)  # Let's have a look X.head() Out[2]: alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue od280/od315_of_diluted_wines proline 0 14.23 1.71 2.43 15.6 127.0 2.80 3.06 0.28 2.29 5.64 1.04 3.92 1065.0 1 13.20 1.78 2.14 11.2 100.0 2.65 2.76 0.26 1.28 4.38 1.05 3.40 1050.0 2 13.16 2.36 2.67 18.6 101.0 2.80 3.24 0.30 2.81 5.68 1.03 3.17 1185.0 3 14.37 1.95 2.50 16.8 113.0 3.85 3.49 0.24 2.18 7.80 0.86 3.45 1480.0 4 13.24 2.59 2.87 21.0 118.0 2.80 2.69 0.39 1.82 4.32 1.04 2.93 735.0 In\u00a0[3]: Copied! <pre># Create (dummy) groups and sample_weights for the rows\ngroups = np.random.randint(5, size=X.shape[0])\nsample_weight = np.random.randint(5, size=X.shape[0])\nprint(groups)\n</pre> # Create (dummy) groups and sample_weights for the rows groups = np.random.randint(5, size=X.shape[0]) sample_weight = np.random.randint(5, size=X.shape[0]) print(groups) <pre>[3 2 4 4 4 2 3 1 3 4 4 3 4 4 2 0 4 0 4 4 0 0 4 1 4 0 1 4 4 3 1 1 0 0 2 0 3\n 0 2 4 1 0 2 4 4 1 1 1 0 3 1 1 0 2 3 4 4 0 1 1 3 3 0 2 0 4 4 4 2 0 0 4 1 0\n 2 4 3 0 4 3 1 2 2 0 2 4 2 0 3 0 0 3 4 2 3 1 3 0 2 0 1 2 4 3 3 3 0 2 4 0 4\n 3 4 1 4 3 3 0 0 4 2 2 3 2 3 1 0 2 4 0 4 4 0 2 0 2 3 4 4 4 2 4 2 2 4 3 2 2\n 4 3 4 2 1 1 0 0 1 4 3 2 3 0 0 4 2 0 1 3 1 4 4 1 1 3 0 1 1 2]\n</pre> <p>Add the metadata to the constructor. We leave <code>index=True</code> to prove the group functionality works. When groups are specified, <code>test_size</code> specifies the number of groups in the test set.</p> In\u00a0[4]: Copied! <pre>atom = ATOMClassifier(\n    X,\n    y=y,\n    index=True,\n    metadata={\"groups\": groups, \"sample_weight\": sample_weight},\n    test_size=1,\n    verbose=2,\n    random_state=1,\n)\n</pre> atom = ATOMClassifier(     X,     y=y,     index=True,     metadata={\"groups\": groups, \"sample_weight\": sample_weight},     test_size=1,     verbose=2,     random_state=1, ) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multiclass classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (178, 14)\nTrain set size: 145\nTest set size: 33\n-------------------------------------\nMemory: 24.82 kB\nScaled: False\nOutlier values: 9 (0.4%)\n\n</pre> In\u00a0[5]: Copied! <pre># Show all rows in the test set belong to the same group\natom.metadata[\"groups\"].loc[atom.test.index]\n</pre> # Show all rows in the test set belong to the same group atom.metadata[\"groups\"].loc[atom.test.index] Out[5]: <pre>34     2\n120    2\n53     2\n68     2\n151    2\n81     2\n164    2\n5      2\n135    2\n140    2\n143    2\n74     2\n146    2\n133    2\n38     2\n142    2\n63     2\n127    2\n123    2\n86     2\n84     2\n159    2\n1      2\n101    2\n177    2\n42     2\n121    2\n107    2\n147    2\n93     2\n98     2\n82     2\n14     2\nName: groups, dtype: int64</pre> In\u00a0[14]: Copied! <pre># Visualize the groups\natom.plot_data_splits()\n</pre> # Visualize the groups atom.plot_data_splits() In\u00a0[6]: Copied! <pre>atom.scale()\n</pre> atom.scale() <pre>Fitting Scaler...\nScaling features...\n</pre> In\u00a0[7]: Copied! <pre># Note the sample weights are passed to the scaler\natom.pipeline[0].get_metadata_routing()\n</pre> # Note the sample weights are passed to the scaler atom.pipeline[0].get_metadata_routing() Out[7]: <pre>{'fit': {'sample_weight': True}}</pre> In\u00a0[9]: Copied! <pre>atom.run(\"LR\")\n</pre> atom.run(\"LR\") <pre>\nTraining ========================= &gt;&gt;\nModels: LR\nMetric: f1_weighted\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1_weighted: 1.0\nTest evaluation --&gt; f1_weighted: 1.0\nTime elapsed: 0.036s\n-------------------------------------------------\nTime: 0.036s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.040s\n-------------------------------------\nLogisticRegression --&gt; f1_weighted: 1.0\n</pre> In\u00a0[10]: Copied! <pre># The same applies to models...\natom.lr.estimator.get_metadata_routing()\n</pre> # The same applies to models... atom.lr.estimator.get_metadata_routing() Out[10]: <pre>{'fit': {'sample_weight': True}, 'score': {'sample_weight': None}}</pre> In\u00a0[11]: Copied! <pre># ... and metrics\natom._metric[0].get_metadata_routing()\n</pre> # ... and metrics atom._metric[0].get_metadata_routing() Out[11]: <pre>{'score': {'sample_weight': True}}</pre> In\u00a0[16]: Copied! <pre>atom.lr.cross_validate()\n</pre> atom.lr.cross_validate() <pre>Applying cross-validation...\n</pre> Out[16]: train_f1_weighted test_f1_weighted time 0 1.000000 0.985135 0.024023 1 1.000000 1.000000 0.022020 2 1.000000 0.962963 0.017015 3 1.000000 1.000000 0.015013 4 1.000000 1.000000 0.020018 mean 1.000000 0.989620 0.019618 In\u00a0[17]: Copied! <pre>atom.plot_cv_splits()\n</pre> atom.plot_cv_splits()"}, {"location": "examples/metadata/#example-metadata", "title": "Example: Metadata\u00b6", "text": "<p>This example shows how to add metadata like <code>groups</code> and <code>sample_weight</code> to atom.</p> <p>Import the wine dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict wines into three groups (which cultivator it's from) using features based on the results of chemical analysis.</p>"}, {"location": "examples/metadata/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/metadata/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/multi_metric/", "title": "Multi-metric runs", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMRegressor\n</pre> # Import packages import pandas as pd from atom import ATOMRegressor In\u00a0[2]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/abalone.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/abalone.csv\")  # Let's have a look X.head() Out[2]: Sex Length Diameter Height Whole weight Shucked weight Viscera weight Shell weight Rings 0 M 0.455 0.365 0.095 0.5140 0.2245 0.1010 0.150 15 1 M 0.350 0.265 0.090 0.2255 0.0995 0.0485 0.070 7 2 F 0.530 0.420 0.135 0.6770 0.2565 0.1415 0.210 9 3 M 0.440 0.365 0.125 0.5160 0.2155 0.1140 0.155 10 4 I 0.330 0.255 0.080 0.2050 0.0895 0.0395 0.055 7 In\u00a0[3]: Copied! <pre>atom = ATOMRegressor(X, n_jobs=1, verbose=2, random_state=1)\n</pre> atom = ATOMRegressor(X, n_jobs=1, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Regression.\n\nDataset stats ==================== &gt;&gt;\nShape: (4177, 9)\nTrain set size: 3342\nTest set size: 835\n-------------------------------------\nMemory: 300.88 kB\nScaled: False\nCategorical features: 1 (12.5%)\nOutlier values: 189 (0.6%)\n\n</pre> In\u00a0[4]: Copied! <pre>atom.encode()\n</pre> atom.encode() <pre>Fitting Encoder...\nEncoding categorical columns...\n --&gt; OneHot-encoding feature Sex. Contains 3 classes.\n</pre> In\u00a0[5]: Copied! <pre># For every step of the BO, both metrics are calculated,\n# but only the first is used for optimization!\natom.run(\n    models=[\"lsvm\", \"hGBM\"],\n    metric=(\"r2\", \"rmse\"),\n    n_trials=10,\n    n_bootstrap=6,\n)\n</pre> # For every step of the BO, both metrics are calculated, # but only the first is used for optimization! atom.run(     models=[\"lsvm\", \"hGBM\"],     metric=(\"r2\", \"rmse\"),     n_trials=10,     n_bootstrap=6, ) <pre>\nTraining ========================= &gt;&gt;\nModels: lSVM, hGBM\nMetric: r2, rmse\n\n\nRunning hyperparameter tuning for LinearSVM...\n| trial |                    loss |       C |    dual |      r2 | best_r2 |    rmse | best_rmse | time_trial | time_ht |    state |\n| ----- | ----------------------- | ------- | ------- | ------- | ------- | ------- | --------- | ---------- | ------- | -------- |\n| 0     | squared_epsilon_insen.. |   0.001 |    True |  0.2887 |  0.2887 | -2.6528 |   -2.6528 |     0.054s |  0.054s | COMPLETE |\n| 1     | squared_epsilon_insen.. |  0.0534 |   False |  0.4507 |  0.4507 | -2.3314 |   -2.3314 |     0.047s |  0.101s | COMPLETE |\n| 2     | squared_epsilon_insen.. |  0.0105 |    True |   0.451 |   0.451 | -2.3307 |   -2.3307 |     0.056s |  0.157s | COMPLETE |\n| 3     |     epsilon_insensitive |  0.6215 |    True |  0.4266 |   0.451 | -2.3818 |   -2.3307 |     0.059s |  0.216s | COMPLETE |\n| 4     | squared_epsilon_insen.. |  0.0369 |   False |  0.4509 |   0.451 | -2.3308 |   -2.3307 |     0.049s |  0.265s | COMPLETE |\n| 5     |     epsilon_insensitive |  0.0016 |    True | -1.5995 |   0.451 | -5.0716 |   -2.3307 |     0.049s |  0.314s | COMPLETE |\n| 6     | squared_epsilon_insen.. | 61.5811 |   False |  0.4499 |   0.451 |  -2.333 |   -2.3307 |     0.054s |  0.369s | COMPLETE |\n| 7     | squared_epsilon_insen.. |  14.898 |   False |  0.4499 |   0.451 |  -2.333 |   -2.3307 |     0.049s |  0.418s | COMPLETE |\n| 8     |     epsilon_insensitive |  0.0252 |    True |  0.3798 |   0.451 | -2.4772 |   -2.3307 |     0.051s |  0.469s | COMPLETE |\n| 9     | squared_epsilon_insen.. |  0.0294 |    True |  0.4512 |  0.4512 | -2.3302 |   -2.3302 |     0.051s |  0.520s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 9\nBest parameters:\n --&gt; loss: squared_epsilon_insensitive\n --&gt; C: 0.0294\n --&gt; dual: True\nBest evaluation --&gt; r2: 0.4512   rmse: -2.3302\nTime elapsed: 0.520s\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.4587   rmse: -2.3806\nTest evaluation --&gt; r2: 0.4586   rmse: -2.3365\nTime elapsed: 0.120s\nBootstrap ---------------------------------------\nEvaluation --&gt; r2: 0.458 \u00b1 0.0014   rmse: -2.3377 \u00b1 0.0031\nTime elapsed: 0.199s\n-------------------------------------------------\nTime: 0.838s\n\n\nRunning hyperparameter tuning for HistGradientBoosting...\n| trial |      loss | quantile | learning_rate | max_iter | max_leaf_nodes | max_depth | min_samples_leaf | l2_regularization |      r2 | best_r2 |    rmse | best_rmse | time_trial | time_ht |    state |\n| ----- | --------- | -------- | ------------- | -------- | -------------- | --------- | ---------------- | ----------------- | ------- | ------- | ------- | --------- | ---------- | ------- | -------- |\n| 0     | absolut.. |      0.1 |        0.0236 |      180 |             26 |        12 |               11 |               0.0 |  0.5373 |  0.5373 | -2.1398 |   -2.1398 |     0.928s |  0.928s | COMPLETE |\n| 1     |     gamma |      0.5 |         0.242 |      160 |             38 |         3 |               20 |               0.0 |   0.556 |   0.556 | -2.0959 |   -2.0959 |     0.178s |  1.106s | COMPLETE |\n| 2     |  quantile |      0.4 |        0.2448 |      210 |             12 |         3 |               25 |               0.3 |  0.4906 |   0.556 |  -2.245 |   -2.0959 |     0.391s |  1.497s | COMPLETE |\n| 3     |  quantile |      0.6 |         0.017 |      480 |             28 |        16 |               13 |               0.1 |  0.5535 |   0.556 | -2.1018 |   -2.0959 |     2.741s |  4.239s | COMPLETE |\n| 4     | squared.. |      1.0 |        0.2649 |       70 |             10 |        10 |               28 |               0.8 |  0.5403 |   0.556 | -2.1327 |   -2.0959 |     0.117s |  4.356s | COMPLETE |\n| 5     | squared.. |      0.1 |        0.0283 |      360 |             32 |         9 |               11 |               0.5 |  0.5466 |   0.556 |  -2.118 |   -2.0959 |     0.863s |  5.219s | COMPLETE |\n| 6     |  quantile |      0.4 |        0.1264 |      380 |             37 |        12 |               29 |               1.0 |  0.4977 |   0.556 | -2.2292 |   -2.0959 |     2.699s |  7.918s | COMPLETE |\n| 7     |     gamma |      0.6 |         0.678 |      330 |             25 |         6 |               12 |               0.8 |  0.3783 |   0.556 | -2.4802 |   -2.0959 |     0.593s |  8.511s | COMPLETE |\n| 8     | absolut.. |      0.9 |        0.0831 |      280 |             42 |        16 |               10 |               1.0 |  0.5285 |   0.556 |   -2.16 |   -2.0959 |     1.647s | 10.158s | COMPLETE |\n| 9     | absolut.. |      0.6 |        0.0373 |      300 |             40 |        13 |               17 |               0.8 |  0.5381 |   0.556 | -2.1378 |   -2.0959 |     1.939s | 12.098s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 1\nBest parameters:\n --&gt; loss: gamma\n --&gt; quantile: 0.5\n --&gt; learning_rate: 0.242\n --&gt; max_iter: 160\n --&gt; max_leaf_nodes: 38\n --&gt; max_depth: 3\n --&gt; min_samples_leaf: 20\n --&gt; l2_regularization: 0.0\nBest evaluation --&gt; r2: 0.556   rmse: -2.0959\nTime elapsed: 12.098s\nFit ---------------------------------------------\nTrain evaluation --&gt; r2: 0.7182   rmse: -1.7178\nTest evaluation --&gt; r2: 0.5427   rmse: -2.1473\nTime elapsed: 0.232s\nBootstrap ---------------------------------------\nEvaluation --&gt; r2: 0.5241 \u00b1 0.022   rmse: -2.19 \u00b1 0.0504\nTime elapsed: 0.782s\n-------------------------------------------------\nTime: 13.111s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 15.597s\n-------------------------------------\nLinearSVM            --&gt; r2: 0.458 \u00b1 0.0014   rmse: -2.3377 \u00b1 0.0031\nHistGradientBoosting --&gt; r2: 0.5241 \u00b1 0.022   rmse: -2.19 \u00b1 0.0504 ~ !\n</pre> In\u00a0[6]: Copied! <pre># Check the robustness of the pipeline using cross-validation\natom.winner.cross_validate()\n</pre> # Check the robustness of the pipeline using cross-validation atom.winner.cross_validate() <pre>Applying cross-validation...\n</pre> Out[6]: train_r2 test_r2 train_rmse test_rmse time 0 0.719472 0.535855 -1.704209 -2.211607 0.135122 1 0.726760 0.539374 -1.682744 -2.198686 0.135123 2 0.723168 0.515653 -1.716590 -2.132145 0.143130 3 0.701827 0.596559 -1.738110 -2.148098 0.116105 4 0.718167 0.542704 -1.717794 -2.147347 0.148133 mean 0.717879 0.546029 -1.711889 -2.167577 0.135523 In\u00a0[7]: Copied! <pre># The columns in the results dataframe contain one for each metric\natom.results.data[[\"r2_ht\", \"r2_train\", \"r2_test\", \"rmse_ht\", \"rmse_train\", \"rmse_test\"]]\n</pre> # The columns in the results dataframe contain one for each metric atom.results.data[[\"r2_ht\", \"r2_train\", \"r2_test\", \"rmse_ht\", \"rmse_train\", \"rmse_test\"]] Out[7]: r2_ht r2_train r2_test rmse_ht rmse_train rmse_test lSVM 0.451203 0.4580 0.4565 -2.330239 -2.3823 -2.3411 hGBM 0.556021 0.7182 0.5427 -2.095926 -1.7178 -2.1473 In\u00a0[8]: Copied! <pre># Some plots allow us to choose the metric we want to show\nwith atom.canvas():\n    atom.plot_trials(metric=\"r2\", title=\"Hyperparameter tuning performance for R2\")\n    atom.plot_trials(metric=\"rmse\", title=\"Hyperparameter tuning performance for RMSE\")\n</pre> # Some plots allow us to choose the metric we want to show with atom.canvas():     atom.plot_trials(metric=\"r2\", title=\"Hyperparameter tuning performance for R2\")     atom.plot_trials(metric=\"rmse\", title=\"Hyperparameter tuning performance for RMSE\") In\u00a0[9]: Copied! <pre>atom.plot_results(metric=\"r2\")\n</pre> atom.plot_results(metric=\"r2\")"}, {"location": "examples/multi_metric/#example-multi-metric-runs", "title": "Example: Multi-metric runs\u00b6", "text": "<p>This example shows how to evaluate an atom's pipeline on multiple metrics.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/multi_metric/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/multi_metric/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/multi_metric/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/multiclass_classification/", "title": "Multiclass classification", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_wine\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_wine from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX, y = load_wine(return_X_y=True, as_frame=True)\n\n# Let's have a look\nX.head()\n</pre> # Load data X, y = load_wine(return_X_y=True, as_frame=True)  # Let's have a look X.head() Out[2]: alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue od280/od315_of_diluted_wines proline 0 14.23 1.71 2.43 15.6 127.0 2.80 3.06 0.28 2.29 5.64 1.04 3.92 1065.0 1 13.20 1.78 2.14 11.2 100.0 2.65 2.76 0.26 1.28 4.38 1.05 3.40 1050.0 2 13.16 2.36 2.67 18.6 101.0 2.80 3.24 0.30 2.81 5.68 1.03 3.17 1185.0 3 14.37 1.95 2.50 16.8 113.0 3.85 3.49 0.24 2.18 7.80 0.86 3.45 1480.0 4 13.24 2.59 2.87 21.0 118.0 2.80 2.69 0.39 1.82 4.32 1.04 2.93 735.0 In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X, y, n_jobs=1, verbose=2, random_state=1)\n\n# Fit the pipeline with the selected models\natom.run(\n    models=[\"LR\",\"LDA\", \"RF\"],\n    metric=\"roc_auc_ovr\",\n    n_trials=14,\n    n_bootstrap=5,\n    errors=\"raise\",\n)\n</pre> atom = ATOMClassifier(X, y, n_jobs=1, verbose=2, random_state=1)  # Fit the pipeline with the selected models atom.run(     models=[\"LR\",\"LDA\", \"RF\"],     metric=\"roc_auc_ovr\",     n_trials=14,     n_bootstrap=5,     errors=\"raise\", ) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multiclass classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (178, 14)\nTrain set size: 143\nTest set size: 35\n-------------------------------------\nMemory: 19.36 kB\nScaled: False\nOutlier values: 12 (0.6%)\n\n\nTraining ========================= &gt;&gt;\nModels: LR, LDA, RF\nMetric: roc_auc_ovr\n\n\nRunning hyperparameter tuning for LogisticRegression...\n| trial | penalty |       C |  solver | max_iter | l1_ratio | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht |    state |\n| ----- | ------- | ------- | ------- | -------- | -------- | ----------- | ---------------- | ---------- | ------- | -------- |\n| 0     |      l1 |  0.0054 |    saga |      480 |      0.7 |         0.5 |              0.5 |     0.033s |  0.033s | COMPLETE |\n| 1     |      l1 |   0.122 |    saga |      380 |      0.7 |         1.0 |              1.0 |     0.031s |  0.064s | COMPLETE |\n| 2     |      l2 |  0.0071 |     sag |      720 |      0.3 |         1.0 |              1.0 |     0.030s |  0.094s | COMPLETE |\n| 3     |      l1 | 87.9641 | libli.. |      920 |      0.3 |         1.0 |              1.0 |     0.030s |  0.124s | COMPLETE |\n| 4     |      l2 |  0.0114 |     sag |      630 |      0.7 |         1.0 |              1.0 |     0.029s |  0.153s | COMPLETE |\n| 5     |      l2 |  0.0018 |     sag |      920 |      0.1 |         1.0 |              1.0 |     0.030s |  0.183s | COMPLETE |\n| 6     |      l2 | 43.4053 |     sag |      780 |      0.3 |         1.0 |              1.0 |     0.049s |  0.232s | COMPLETE |\n| 7     |      l2 |  2.0759 | libli.. |      470 |      0.2 |         1.0 |              1.0 |     0.028s |  0.260s | COMPLETE |\n| 8     |    None |   0.043 |     sag |      110 |      1.0 |         1.0 |              1.0 |     0.030s |  0.290s | COMPLETE |\n| 9     |      l1 | 46.0233 |    saga |      740 |      0.1 |         1.0 |              1.0 |     0.057s |  0.347s | COMPLETE |\n| 10    |      l2 |  0.4741 |   lbfgs |      280 |      1.0 |         1.0 |              1.0 |     0.044s |  0.391s | COMPLETE |\n| 11    |      l2 |  0.0765 | newto.. |      370 |      0.5 |         1.0 |              1.0 |     0.044s |  0.435s | COMPLETE |\n| 12    | elast.. |  0.5609 |    saga |      640 |      0.6 |         1.0 |              1.0 |     0.044s |  0.479s | COMPLETE |\n| 13    |    None |  0.0481 | newto.. |      240 |      0.5 |         1.0 |              1.0 |     0.043s |  0.522s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 1\nBest parameters:\n --&gt; penalty: l1\n --&gt; C: 0.122\n --&gt; solver: saga\n --&gt; max_iter: 380\n --&gt; l1_ratio: 0.7\nBest evaluation --&gt; roc_auc_ovr: 1.0\nTime elapsed: 0.522s\nFit ---------------------------------------------\nTrain evaluation --&gt; roc_auc_ovr: 0.9995\nTest evaluation --&gt; roc_auc_ovr: 0.9989\nTime elapsed: 0.152s\nBootstrap ---------------------------------------\nEvaluation --&gt; roc_auc_ovr: 0.9991 \u00b1 0.0009\nTime elapsed: 0.142s\n-------------------------------------------------\nTime: 0.816s\n\n\nRunning hyperparameter tuning for LinearDiscriminantAnalysis...\n| trial |  solver | shrinkage | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht |    state |\n| ----- | ------- | --------- | ----------- | ---------------- | ---------- | ------- | -------- |\n| 0     |    lsqr |       0.9 |      0.9221 |           0.9221 |     0.018s |  0.018s | COMPLETE |\n| 1     |   eigen |       1.0 |      0.9221 |           0.9221 |     0.012s |  0.030s | COMPLETE |\n| 2     |   eigen |       1.0 |      0.9221 |           0.9221 |     0.000s |  0.030s | COMPLETE |\n| 3     |    lsqr |       0.7 |      0.9241 |           0.9241 |     0.009s |  0.039s | COMPLETE |\n| 4     |   eigen |       0.7 |      0.9241 |           0.9241 |     0.010s |  0.049s | COMPLETE |\n| 5     |    lsqr |      auto |         1.0 |              1.0 |     0.012s |  0.061s | COMPLETE |\n| 6     |   eigen |       1.0 |      0.9221 |              1.0 |     0.001s |  0.062s | COMPLETE |\n| 7     |    lsqr |       1.0 |      0.9221 |              1.0 |     0.009s |  0.071s | COMPLETE |\n| 8     |     svd |      None |         1.0 |              1.0 |     0.008s |  0.079s | COMPLETE |\n| 9     |     svd |      None |         1.0 |              1.0 |     0.000s |  0.079s | COMPLETE |\n| 10    |    lsqr |      auto |         1.0 |              1.0 |     0.001s |  0.080s | COMPLETE |\n| 11    |     svd |      None |         1.0 |              1.0 |     0.002s |  0.082s | COMPLETE |\n| 12    |     svd |      None |         1.0 |              1.0 |     0.001s |  0.083s | COMPLETE |\n| 13    |     svd |      None |         1.0 |              1.0 |     0.001s |  0.084s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 5\nBest parameters:\n --&gt; solver: lsqr\n --&gt; shrinkage: auto\nBest evaluation --&gt; roc_auc_ovr: 1.0\nTime elapsed: 0.084s\nFit ---------------------------------------------\nTrain evaluation --&gt; roc_auc_ovr: 1.0\nTest evaluation --&gt; roc_auc_ovr: 1.0\nTime elapsed: 0.039s\nBootstrap ---------------------------------------\nEvaluation --&gt; roc_auc_ovr: 0.9998 \u00b1 0.0005\nTime elapsed: 0.065s\n-------------------------------------------------\nTime: 0.188s\n\n\nRunning hyperparameter tuning for RandomForest...\n| trial | n_estimators | criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | ccp_alpha | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht |    state |\n| ----- | ------------ | --------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | --------- | ----------- | ---------------- | ---------- | ------- | -------- |\n| 0     |          210 |      gini |        10 |                17 |               20 |          0.5 |     False |        None |       0.0 |      0.9803 |           0.9803 |     0.167s |  0.167s | COMPLETE |\n| 1     |          380 |      gini |         4 |                15 |                3 |          0.9 |     False |        None |      0.01 |      0.9757 |           0.9803 |     0.393s |  0.560s | COMPLETE |\n| 2     |          380 |   entropy |         6 |                 2 |               13 |          0.9 |     False |        None |      0.03 |      0.9655 |           0.9803 |     0.390s |  0.950s | COMPLETE |\n| 3     |          470 |      gini |        11 |                 9 |               18 |          nan |      True |         0.6 |     0.025 |      0.9944 |           0.9944 |     0.481s |  1.432s | COMPLETE |\n| 4     |          100 |   entropy |        12 |                14 |                6 |          0.9 |     False |         nan |     0.035 |      0.9916 |           0.9944 |     0.111s |  1.543s | COMPLETE |\n| 5     |          470 |   entropy |        13 |                11 |                1 |          nan |      True |         0.6 |      0.01 |      0.9949 |           0.9949 |     0.550s |  2.092s | COMPLETE |\n| 6     |          250 |      gini |        14 |                13 |               17 |          0.7 |      True |         nan |      0.02 |      0.9949 |           0.9949 |     0.268s |  2.361s | COMPLETE |\n| 7     |          220 |      gini |         5 |                10 |                7 |          0.5 |      True |         0.9 |     0.035 |      0.9949 |           0.9949 |     0.251s |  2.612s | COMPLETE |\n| 8     |          130 |   entropy |         4 |                 6 |               11 |          0.9 |     False |         nan |      0.03 |      0.9693 |           0.9949 |     0.139s |  2.751s | COMPLETE |\n| 9     |          370 |      gini |        12 |                 2 |                4 |          0.5 |     False |         nan |      0.02 |      0.9949 |           0.9949 |     0.317s |  3.068s | COMPLETE |\n| 10    |          500 |   entropy |        13 |                20 |                1 |          0.8 |      True |         0.6 |      0.01 |      0.9932 |           0.9949 |     0.608s |  3.676s | COMPLETE |\n| 11    |           20 |   entropy |        14 |                12 |               16 |          0.7 |      True |         0.5 |      0.01 |      0.9981 |           0.9981 |     0.048s |  3.724s | COMPLETE |\n| 12    |           10 |   entropy |         9 |                 7 |               15 |          0.6 |      True |         0.5 |      0.01 |      0.9847 |           0.9981 |     0.036s |  3.760s | COMPLETE |\n| 13    |           30 |   entropy |        16 |                11 |                9 |         log2 |      True |         0.7 |       0.0 |      0.9981 |           0.9981 |     0.065s |  3.825s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 11\nBest parameters:\n --&gt; n_estimators: 20\n --&gt; criterion: entropy\n --&gt; max_depth: 14\n --&gt; min_samples_split: 12\n --&gt; min_samples_leaf: 16\n --&gt; max_features: 0.7\n --&gt; bootstrap: True\n --&gt; max_samples: 0.5\n --&gt; ccp_alpha: 0.01\nBest evaluation --&gt; roc_auc_ovr: 0.9981\nTime elapsed: 3.825s\nFit ---------------------------------------------\nTrain evaluation --&gt; roc_auc_ovr: 0.999\nTest evaluation --&gt; roc_auc_ovr: 0.9986\nTime elapsed: 0.055s\nBootstrap ---------------------------------------\nEvaluation --&gt; roc_auc_ovr: 0.9885 \u00b1 0.0065\nTime elapsed: 0.139s\n-------------------------------------------------\nTime: 4.019s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 8.389s\n-------------------------------------\nLogisticRegression         --&gt; roc_auc_ovr: 0.9991 \u00b1 0.0009\nLinearDiscriminantAnalysis --&gt; roc_auc_ovr: 0.9998 \u00b1 0.0005 !\nRandomForest               --&gt; roc_auc_ovr: 0.9885 \u00b1 0.0065\n</pre> In\u00a0[4]: Copied! <pre>atom.results\n</pre> atom.results Out[4]: roc_auc_ovr_ht time_ht roc_auc_ovr_train roc_auc_ovr_test time_fit roc_auc_ovr_bootstrap time_bootstrap time LR 1.000000 0.522480 0.998700 0.998900 0.152041 0.999093 0.141717 0.816238 LDA 1.000000 0.084077 1.000000 0.998900 0.039036 0.999773 0.065059 0.188172 RF 0.998148 3.824844 0.999000 0.998600 0.055050 0.988525 0.139127 4.019021 In\u00a0[5]: Copied! <pre># Show the score for some different metrics\natom.evaluate([\"precision_macro\", \"recall_macro\", \"jaccard_weighted\"])\n</pre> # Show the score for some different metrics atom.evaluate([\"precision_macro\", \"recall_macro\", \"jaccard_weighted\"]) Out[5]: precision_macro recall_macro jaccard_weighted LR 0.939400 0.952400 0.896100 LDA 0.966700 0.976200 0.945700 RF 0.911700 0.915300 0.842200 In\u00a0[6]: Copied! <pre># Some plots allow you to choose the target class to look at\natom.rf.plot_probabilities(rows=\"train\", target=0)\n</pre> # Some plots allow you to choose the target class to look at atom.rf.plot_probabilities(rows=\"train\", target=0) In\u00a0[7]: Copied! <pre>atom.lda.plot_shap_heatmap(target=2, show=7)\n</pre> atom.lda.plot_shap_heatmap(target=2, show=7)"}, {"location": "examples/multiclass_classification/#example-multiclass-classification", "title": "Example: Multiclass classification\u00b6", "text": "<p>This example shows how to compare the performance of three models on a multiclass classification task.</p> <p>Import the wine dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict wines into three groups (which cultivator it's from) using features based on the results of chemical analysis.</p>"}, {"location": "examples/multiclass_classification/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/multiclass_classification/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/multiclass_classification/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/multilabel_classification/", "title": "Multilabel classification", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\nfrom sklearn.datasets import make_multilabel_classification\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier from sklearn.datasets import make_multilabel_classification In\u00a0[2]: Copied! <pre># Create data\nX, y = make_multilabel_classification(n_samples=300, n_classes=3, random_state=1)\n</pre> # Create data X, y = make_multilabel_classification(n_samples=300, n_classes=3, random_state=1) In\u00a0[3]: Copied! <pre># Note that for multioutput tasks, you must specify the `y` keyword\natom = ATOMClassifier(X, y=y, verbose=2, random_state=1)\n</pre> # Note that for multioutput tasks, you must specify the `y` keyword atom = ATOMClassifier(X, y=y, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multilabel classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (300, 23)\nTrain set size: 240\nTest set size: 60\n-------------------------------------\nMemory: 51.73 kB\nScaled: False\nOutlier values: 35 (0.6%)\n\n</pre> In\u00a0[4]: Copied! <pre># Show the models that natively support multilabel tasks\natom.available_models(native_multilabel=True)\n</pre> # Show the models that natively support multilabel tasks atom.available_models(native_multilabel=True) Out[4]: acronym fullname estimator module handles_missing needs_scaling accepts_sparse native_multilabel native_multioutput validation supports_engines 0 Tree DecisionTree DecisionTreeClassifier sklearn.tree._classes True False True True True None sklearn 1 ETree ExtraTree ExtraTreeClassifier sklearn.tree._classes False False True True True None sklearn 2 ET ExtraTrees ExtraTreesClassifier sklearn.ensemble._forest False False True True True None sklearn 3 KNN KNearestNeighbors KNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn, sklearnex, cuml 4 MLP MultiLayerPerceptron MLPClassifier sklearn.neural_network._multilayer_perceptron False True True True False max_iter sklearn 5 RNN RadiusNearestNeighbors RadiusNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn 6 RF RandomForest RandomForestClassifier sklearn.ensemble._forest False False True True True None sklearn, sklearnex, cuml 7 Ridge Ridge RidgeClassifier sklearn.linear_model._ridge False True True True False None sklearn, sklearnex, cuml In\u00a0[5]: Copied! <pre>atom.run(models=[\"LDA\", \"RF\"], metric=\"recall_weighted\")\n</pre> atom.run(models=[\"LDA\", \"RF\"], metric=\"recall_weighted\") <pre>\nTraining ========================= &gt;&gt;\nModels: LDA, RF\nMetric: recall_weighted\n\n\nResults for LinearDiscriminantAnalysis:\nFit ---------------------------------------------\nTrain evaluation --&gt; recall_weighted: 0.8912\nTest evaluation --&gt; recall_weighted: 0.899\nTime elapsed: 0.040s\n-------------------------------------------------\nTime: 0.040s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; recall_weighted: 1.0\nTest evaluation --&gt; recall_weighted: 0.9091\nTime elapsed: 0.156s\n-------------------------------------------------\nTime: 0.156s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.216s\n-------------------------------------\nLinearDiscriminantAnalysis --&gt; recall_weighted: 0.899\nRandomForest               --&gt; recall_weighted: 0.9091 !\n</pre> In\u00a0[6]: Copied! <pre># Note that non-native multioutput models use a meta-estimator wrapper\nprint(f\"Estimator for LDA is: {atom.lda.estimator}\")\nprint(f\"Estimator for RF is: {atom.rf.estimator}\")\n</pre> # Note that non-native multioutput models use a meta-estimator wrapper print(f\"Estimator for LDA is: {atom.lda.estimator}\") print(f\"Estimator for RF is: {atom.rf.estimator}\") <pre>Estimator for LDA is: ClassifierChain(base_estimator=LinearDiscriminantAnalysis(), random_state=1)\nEstimator for RF is: RandomForestClassifier(n_jobs=1, random_state=1)\n</pre> In\u00a0[7]: Copied! <pre>from atom import ATOMModel\nfrom sklearn.multioutput import ClassifierChain\nfrom sklearn.linear_model import LogisticRegression\nfrom optuna.distributions import CategoricalDistribution, IntDistribution\n\ncustom_model = ATOMModel(\n    estimator=ClassifierChain(LogisticRegression(), cv=3),\n    name=\"chain\",\n    needs_scaling=True,\n    native_multilabel=True,\n)\n\natom.run(\n    models=custom_model,\n    n_trials=5,\n    ht_params={\n        \"distributions\": {\n            \"order\": CategoricalDistribution([[0, 1, 2], [2, 1, 0], [1, 2, 0]]),\n            \"base_estimator__max_iter\": IntDistribution(100, 200, step=10),\n            \"base_estimator__solver\": CategoricalDistribution([\"lbfgs\", \"newton-cg\"]),            \n        }\n    }\n)\n</pre> from atom import ATOMModel from sklearn.multioutput import ClassifierChain from sklearn.linear_model import LogisticRegression from optuna.distributions import CategoricalDistribution, IntDistribution  custom_model = ATOMModel(     estimator=ClassifierChain(LogisticRegression(), cv=3),     name=\"chain\",     needs_scaling=True,     native_multilabel=True, )  atom.run(     models=custom_model,     n_trials=5,     ht_params={         \"distributions\": {             \"order\": CategoricalDistribution([[0, 1, 2], [2, 1, 0], [1, 2, 0]]),             \"base_estimator__max_iter\": IntDistribution(100, 200, step=10),             \"base_estimator__solver\": CategoricalDistribution([\"lbfgs\", \"newton-cg\"]),                     }     } ) <pre>\nTraining ========================= &gt;&gt;\nModels: chain\nMetric: recall_weighted\n\n\nRunning hyperparameter tuning for ClassifierChain...\n| trial |     order | base_estimator__max_iter | base_estimator__solver | recall_weighted | best_recall_weighted | time_trial | time_ht |    state |\n| ----- | --------- | ------------------------ | ---------------------- | --------------- | -------------------- | ---------- | ------- | -------- |\n| 0     | [2, 1, 0] |                      130 |                  lbfgs |          0.8205 |               0.8205 |     0.055s |  0.055s | COMPLETE |\n| 1     | [1, 2, 0] |                      150 |              newton-cg |          0.8205 |               0.8205 |     0.069s |  0.124s | COMPLETE |\n| 2     | [2, 1, 0] |                      170 |              newton-cg |          0.8205 |               0.8205 |     0.056s |  0.180s | COMPLETE |\n| 3     | [1, 2, 0] |                      200 |              newton-cg |          0.8205 |               0.8205 |     0.060s |  0.240s | COMPLETE |\n| 4     | [2, 1, 0] |                      100 |              newton-cg |          0.8205 |               0.8205 |     0.047s |  0.287s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 0\nBest parameters:\n --&gt; order: [2, 1, 0]\n --&gt; base_estimator__max_iter: 130\n --&gt; base_estimator__solver: lbfgs\nBest evaluation --&gt; recall_weighted: 0.8205\nTime elapsed: 0.287s\nFit ---------------------------------------------\nTrain evaluation --&gt; recall_weighted: 0.8964\nTest evaluation --&gt; recall_weighted: 0.9192\nTime elapsed: 0.195s\n-------------------------------------------------\nTime: 0.482s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 0.507s\n-------------------------------------\nClassifierChain --&gt; recall_weighted: 0.9192\n</pre> In\u00a0[9]: Copied! <pre>atom.rf.evaluate()\n</pre> atom.rf.evaluate() Out[9]: <pre>accuracy              0.6333\nap                    0.9120\nf1_weighted           0.8608\njaccard_weighted      0.7802\nprecision_weighted    0.8711\nrecall_weighted       0.9091\nauc                   0.9167\nName: RF, dtype: float64</pre> In\u00a0[10]: Copied! <pre># Use the target parameter in plots to specify which target column to use\natom.plot_roc(target=2)\n</pre> # Use the target parameter in plots to specify which target column to use atom.plot_roc(target=2) In\u00a0[11]: Copied! <pre># When the target parameter also specifies the class, use format (column, class)\natom.plot_probabilities(models=\"chain\", target=(2, 1))\n</pre> # When the target parameter also specifies the class, use format (column, class) atom.plot_probabilities(models=\"chain\", target=(2, 1)) In\u00a0[12]: Copied! <pre>with atom.canvas(figsize=(900, 600)):\n    atom.plot_calibration(target=0)\n    atom.plot_calibration(target=1)\n</pre> with atom.canvas(figsize=(900, 600)):     atom.plot_calibration(target=0)     atom.plot_calibration(target=1)"}, {"location": "examples/multilabel_classification/#example-multilabel-classification", "title": "Example: Multilabel classification\u00b6", "text": "<p>This example shows how to use ATOM to solve a multilabel classification problem.</p> <p>The data used is a synthetic dataset created using sklearn's make_multilabel_classification function.</p>"}, {"location": "examples/multilabel_classification/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/multilabel_classification/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/multilabel_classification/#add-custom-multilabel-models", "title": "Add custom multilabel models\u00b6", "text": "<p>To use your own meta-estimator with custom parameters, add it as a custom model. It's also possible to tune the hyperparameters of this custom meta-estimator.</p>"}, {"location": "examples/multilabel_classification/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/multioutput_regression/", "title": "Multioutput regression", "text": "In\u00a0[1]: Copied! <pre># Disable annoying tf warnings\nimport os\nos.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\"\n\nfrom tensorflow import get_logger\nget_logger().setLevel('ERROR')\n\nimport numpy as np\nfrom atom import ATOMRegressor, ATOMModel\nfrom sklearn.datasets import make_regression\n\nfrom scikeras.wrappers import KerasRegressor\nfrom keras.models import Sequential\nfrom keras.layers import Dense\n</pre> # Disable annoying tf warnings import os os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\"  from tensorflow import get_logger get_logger().setLevel('ERROR')  import numpy as np from atom import ATOMRegressor, ATOMModel from sklearn.datasets import make_regression  from scikeras.wrappers import KerasRegressor from keras.models import Sequential from keras.layers import Dense <pre>WARNING:tensorflow:From C:\\Users\\Mavs\\Documents\\Python\\ATOM\\venv311\\Lib\\site-packages\\keras\\src\\losses.py:2976: The name tf.losses.sparse_softmax_cross_entropy is deprecated. Please use tf.compat.v1.losses.sparse_softmax_cross_entropy instead.\n\n</pre> In\u00a0[2]: Copied! <pre># Create data\nX, y = make_regression(n_samples=1000, n_features=10, n_informative=5, n_targets=3)\n</pre> # Create data X, y = make_regression(n_samples=1000, n_features=10, n_informative=5, n_targets=3) In\u00a0[3]: Copied! <pre># Create the neural network\nclass NeuralNetwork(KerasRegressor):\n    \"\"\"Multioutput multilayer perceptron.\"\"\"\n\n    def __repr__(self):\n        return \"NeuralNetwork()\"\n\n    @staticmethod\n    def _keras_build_fn(n_inputs, n_outputs, **kwargs):\n        \"\"\"Create the model's architecture.\"\"\"\n        model = Sequential()\n        model.add(Dense(20, input_dim=n_inputs, activation=\"relu\"))\n        model.add(Dense(20, activation=\"relu\"))\n        model.add(Dense(n_outputs))\n        model.compile(loss=\"mse\", optimizer=\"adam\")\n        return model\n</pre> # Create the neural network class NeuralNetwork(KerasRegressor):     \"\"\"Multioutput multilayer perceptron.\"\"\"      def __repr__(self):         return \"NeuralNetwork()\"      @staticmethod     def _keras_build_fn(n_inputs, n_outputs, **kwargs):         \"\"\"Create the model's architecture.\"\"\"         model = Sequential()         model.add(Dense(20, input_dim=n_inputs, activation=\"relu\"))         model.add(Dense(20, activation=\"relu\"))         model.add(Dense(n_outputs))         model.compile(loss=\"mse\", optimizer=\"adam\")         return model In\u00a0[4]: Copied! <pre># Convert the model to an ATOM model\nmodel = ATOMModel(\n    estimator=NeuralNetwork(n_inputs=5, n_outputs=y.shape[1], epochs=100, verbose=0),\n    name=\"NN\",\n    needs_scaling=True,  # Applies automated feature scaling before fitting\n    native_multioutput=True,  # Do not use a multioutput meta-estimator wrapper\n)\n</pre> # Convert the model to an ATOM model model = ATOMModel(     estimator=NeuralNetwork(n_inputs=5, n_outputs=y.shape[1], epochs=100, verbose=0),     name=\"NN\",     needs_scaling=True,  # Applies automated feature scaling before fitting     native_multioutput=True,  # Do not use a multioutput meta-estimator wrapper ) In\u00a0[5]: Copied! <pre>atom = ATOMRegressor(X, y=y, verbose=2, random_state=1)\n</pre> atom = ATOMRegressor(X, y=y, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multioutput regression.\n\nDataset stats ==================== &gt;&gt;\nShape: (1000, 13)\nTrain set size: 800\nTest set size: 200\n-------------------------------------\nMemory: 104.13 kB\nScaled: True\nOutlier values: 29 (0.3%)\n\n</pre> In\u00a0[6]: Copied! <pre># Show the models that natively support multioutput tasks\natom.available_models(native_multioutput=True)\n</pre> # Show the models that natively support multioutput tasks atom.available_models(native_multioutput=True) Out[6]: acronym fullname estimator module handles_missing needs_scaling accepts_sparse native_multilabel native_multioutput validation supports_engines 0 Tree DecisionTree DecisionTreeRegressor sklearn.tree._classes True False True True True None sklearn 1 ETree ExtraTree ExtraTreeRegressor sklearn.tree._classes False False True True True None sklearn 2 ET ExtraTrees ExtraTreesRegressor sklearn.ensemble._forest False False True True True None sklearn 3 KNN KNearestNeighbors KNeighborsRegressor sklearn.neighbors._regression False True True True True None sklearn, sklearnex, cuml 4 RNN RadiusNearestNeighbors RadiusNeighborsRegressor sklearn.neighbors._regression False True True True True None sklearn 5 RF RandomForest RandomForestRegressor sklearn.ensemble._forest False False True True True None sklearn, sklearnex, cuml In\u00a0[7]: Copied! <pre># Note we only added 5 informative features to the dataset, let's remove the rest\n# If we use a model with no native support for multioutput as solver, specify the\n# rfe's importance_getter parameter and return the mean of the coefficients over the\n# target columns\natom.feature_selection(\n    strategy=\"rfe\",\n    solver=\"ols\",  # This becomes MultiOutputRegressor(OLS)\n    n_features=5,\n    importance_getter=lambda x: np.mean([e.coef_ for e in x.estimators_], axis=0),\n)\n</pre> # Note we only added 5 informative features to the dataset, let's remove the rest # If we use a model with no native support for multioutput as solver, specify the # rfe's importance_getter parameter and return the mean of the coefficients over the # target columns atom.feature_selection(     strategy=\"rfe\",     solver=\"ols\",  # This becomes MultiOutputRegressor(OLS)     n_features=5,     importance_getter=lambda x: np.mean([e.coef_ for e in x.estimators_], axis=0), ) <pre>Fitting FeatureSelector...\nPerforming feature selection ...\n --&gt; rfe selected 5 features from the dataset.\n   --&gt; Dropping feature x0 (rank 5).\n   --&gt; Dropping feature x4 (rank 6).\n   --&gt; Dropping feature x5 (rank 2).\n   --&gt; Dropping feature x7 (rank 3).\n   --&gt; Dropping feature x9 (rank 4).\n</pre> In\u00a0[8]: Copied! <pre># Let's train a native, non-native and our custom model\natom.run(models=[\"Lasso\", \"RF\", model], metric=\"mse\", errors=\"raise\")\n</pre> # Let's train a native, non-native and our custom model atom.run(models=[\"Lasso\", \"RF\", model], metric=\"mse\", errors=\"raise\") <pre>\nTraining ========================= &gt;&gt;\nModels: Lasso, RF, NN\nMetric: mse\n\n\nResults for Lasso:\nFit ---------------------------------------------\nTrain evaluation --&gt; mse: -4.6709\nTest evaluation --&gt; mse: -4.4039\nTime elapsed: 0.031s\n-------------------------------------------------\nTime: 0.031s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; mse: -197.8132\nTest evaluation --&gt; mse: -1436.9264\nTime elapsed: 0.385s\n-------------------------------------------------\nTime: 0.385s\n\n\nResults for NeuralNetwork:\nFit ---------------------------------------------\nTrain evaluation --&gt; mse: -113.9745\nTest evaluation --&gt; mse: -131.0996\nTime elapsed: 4.949s\n-------------------------------------------------\nTime: 4.949s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 5.367s\n-------------------------------------\nLasso         --&gt; mse: -4.4039 !\nRandomForest  --&gt; mse: -1436.9264 ~\nNeuralNetwork --&gt; mse: -131.0996\n</pre> In\u00a0[9]: Copied! <pre># And check which of the models used a meta-estimator wrapper\nfor m in atom.models:\n    print(f\"Estimator for {m} is: {atom[m].estimator}\")\n</pre> # And check which of the models used a meta-estimator wrapper for m in atom.models:     print(f\"Estimator for {m} is: {atom[m].estimator}\") <pre>Estimator for Lasso is: MultiOutputRegressor(estimator=Lasso(), n_jobs=1)\nEstimator for RF is: RandomForestRegressor(n_jobs=1, random_state=1)\nEstimator for NN is: NeuralNetwork()\n</pre> In\u00a0[10]: Copied! <pre># Use the target parameter in plots to specify which target column to use\natom.plot_residuals(target=2)\n</pre> # Use the target parameter in plots to specify which target column to use atom.plot_residuals(target=2) In\u00a0[11]: Copied! <pre>with atom.canvas(3, 1, figsize=(900, 1300)):\n    atom.plot_errors(target=0)\n    atom.plot_errors(target=1)\n    atom.plot_errors(target=2)\n</pre> with atom.canvas(3, 1, figsize=(900, 1300)):     atom.plot_errors(target=0)     atom.plot_errors(target=1)     atom.plot_errors(target=2)"}, {"location": "examples/multioutput_regression/#example-multioutput-regression", "title": "Example: Multioutput regression\u00b6", "text": "<p>This example shows how to use ATOM to make preditions on a multioutput regression dataset. One of the models used is a MLP regressor implemented with Keras using scikeras.</p> <p>The data used is a synthetic dataset created using sklearn's make_regression function.</p>"}, {"location": "examples/multioutput_regression/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/multioutput_regression/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/multioutput_regression/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/multivariate_forecast/", "title": "Multivariate forecast", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport numpy as np\nfrom sktime.datasets import load_macroeconomic\nfrom atom import ATOMForecaster\n</pre> # Import packages import numpy as np from sktime.datasets import load_macroeconomic from atom import ATOMForecaster In\u00a0[2]: Copied! <pre># Load the data\nX = load_macroeconomic()\n\nprint(X)\n</pre> # Load the data X = load_macroeconomic()  print(X) <pre>          realgdp  realcons   realinv  realgovt  realdpi      cpi      m1  \\\nPeriod                                                                      \n1959Q1   2710.349    1707.4   286.898   470.045   1886.9   28.980   139.7   \n1959Q2   2778.801    1733.7   310.859   481.301   1919.7   29.150   141.7   \n1959Q3   2775.488    1751.8   289.226   491.260   1916.4   29.350   140.5   \n1959Q4   2785.204    1753.7   299.356   484.052   1931.3   29.370   140.0   \n1960Q1   2847.699    1770.5   331.722   462.199   1955.5   29.540   139.6   \n...           ...       ...       ...       ...      ...      ...     ...   \n2008Q3  13324.600    9267.7  1990.693   991.551   9838.3  216.889  1474.7   \n2008Q4  13141.920    9195.3  1857.661  1007.273   9920.4  212.174  1576.5   \n2009Q1  12925.410    9209.2  1558.494   996.287   9926.4  212.671  1592.8   \n2009Q2  12901.504    9189.0  1456.678  1023.528  10077.5  214.469  1653.6   \n2009Q3  12990.341    9256.0  1486.398  1044.088  10040.6  216.385  1673.9   \n\n        tbilrate  unemp      pop  infl  realint  \nPeriod                                           \n1959Q1      2.82    5.8  177.146  0.00     0.00  \n1959Q2      3.08    5.1  177.830  2.34     0.74  \n1959Q3      3.82    5.3  178.657  2.74     1.09  \n1959Q4      4.33    5.6  179.386  0.27     4.06  \n1960Q1      3.50    5.2  180.007  2.31     1.19  \n...          ...    ...      ...   ...      ...  \n2008Q3      1.17    6.0  305.270 -3.16     4.33  \n2008Q4      0.12    6.9  305.952 -8.79     8.91  \n2009Q1      0.22    8.1  306.547  0.94    -0.71  \n2009Q2      0.18    9.2  307.226  3.37    -3.19  \n2009Q3      0.12    9.6  308.013  3.56    -3.44  \n\n[203 rows x 12 columns]\n</pre> In\u00a0[3]: Copied! <pre># We specify the last two columns as our target columns\natom = ATOMForecaster(X, y=(-2, -1), verbose=2, random_state=1)\n</pre> # We specify the last two columns as our target columns atom = ATOMForecaster(X, y=(-2, -1), verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multivariate forecast.\n\nDataset stats ==================== &gt;&gt;\nShape: (203, 12)\nTrain set size: 163\n --&gt; From: 1959Q1  To: 1999Q3\nTest set size: 40\n --&gt; From: 1999Q4  To: 2009Q3\n-------------------------------------\nMemory: 29.41 kB\nScaled: False\nOutlier values: 9 (0.5%)\n\n</pre> In\u00a0[4]: Copied! <pre>atom.dataset\n</pre> atom.dataset Out[4]: realgdp realcons realinv realgovt realdpi cpi m1 tbilrate unemp pop infl realint Period 1959Q1 2710.349 1707.4 286.898 470.045 1886.9 28.980 139.7 2.82 5.8 177.146 0.00 0.00 1959Q2 2778.801 1733.7 310.859 481.301 1919.7 29.150 141.7 3.08 5.1 177.830 2.34 0.74 1959Q3 2775.488 1751.8 289.226 491.260 1916.4 29.350 140.5 3.82 5.3 178.657 2.74 1.09 1959Q4 2785.204 1753.7 299.356 484.052 1931.3 29.370 140.0 4.33 5.6 179.386 0.27 4.06 1960Q1 2847.699 1770.5 331.722 462.199 1955.5 29.540 139.6 3.50 5.2 180.007 2.31 1.19 ... ... ... ... ... ... ... ... ... ... ... ... ... 2008Q3 13324.600 9267.7 1990.693 991.551 9838.3 216.889 1474.7 1.17 6.0 305.270 -3.16 4.33 2008Q4 13141.920 9195.3 1857.661 1007.273 9920.4 212.174 1576.5 0.12 6.9 305.952 -8.79 8.91 2009Q1 12925.410 9209.2 1558.494 996.287 9926.4 212.671 1592.8 0.22 8.1 306.547 0.94 -0.71 2009Q2 12901.504 9189.0 1456.678 1023.528 10077.5 214.469 1653.6 0.18 9.2 307.226 3.37 -3.19 2009Q3 12990.341 9256.0 1486.398 1044.088 10040.6 216.385 1673.9 0.12 9.6 308.013 3.56 -3.44 <p>203 rows \u00d7 12 columns</p> In\u00a0[5]: Copied! <pre># Examine the targets\natom.plot_series()\n</pre> # Examine the targets atom.plot_series() In\u00a0[6]: Copied! <pre>atom.plot_decomposition()\n</pre> atom.plot_decomposition() In\u00a0[7]: Copied! <pre># Exogenous features are transformed normally\natom.normalize()\n</pre> # Exogenous features are transformed normally atom.normalize() <pre>Fitting Normalizer...\nNormalizing features...\n</pre> In\u00a0[8]: Copied! <pre>atom.warnings = True  # Let's turn on warnings for a sec\n</pre> atom.warnings = True  # Let's turn on warnings for a sec In\u00a0[9]: Copied! <pre># Use the apply method to transform the target columns\natom.apply(np.sqrt, columns=atom.target)\n</pre> # Use the apply method to transform the target columns atom.apply(np.sqrt, columns=atom.target) <pre>Fitting FunctionTransformer...\n</pre> <pre>C:\\Users\\Mavs\\Documents\\Python\\ATOM\\venv311\\Lib\\site-packages\\pandas\\core\\internals\\blocks.py:366: RuntimeWarning:\n\ninvalid value encountered in sqrt\n\n</pre> In\u00a0[10]: Copied! <pre># Note from the warnings that we might have NaNs in the dataset now\natom.nans\n</pre> # Note from the warnings that we might have NaNs in the dataset now atom.nans Out[10]: <pre>realgdp      0\nrealcons     0\nrealinv      0\nrealgovt     0\nrealdpi      0\ncpi          0\nm1           0\ntbilrate     0\nunemp        0\npop          0\ninfl         6\nrealint     52\ndtype: int64</pre> In\u00a0[11]: Copied! <pre># And, indeed, we can see them in the target columns\natom.y\n</pre> # And, indeed, we can see them in the target columns atom.y Out[11]: infl realint Period 1959Q1 0.000000 0.000000 1959Q2 1.529706 0.860233 1959Q3 1.655295 1.044031 1959Q4 0.519615 2.014944 1960Q1 1.519868 1.090871 ... ... ... 2008Q3 NaN 2.080865 2008Q4 NaN 2.984962 2009Q1 0.969536 NaN 2009Q2 1.835756 NaN 2009Q3 1.886796 NaN <p>203 rows \u00d7 2 columns</p> In\u00a0[12]: Copied! <pre># Impute the missing values created by the transformation\natom.impute(strat_num=\"bfill\", columns=atom.target)\n</pre> # Impute the missing values created by the transformation atom.impute(strat_num=\"bfill\", columns=atom.target) <pre>Fitting Imputer...\nImputing missing values...\n --&gt; Imputing 6 missing values with bfill in column infl.\n --&gt; Imputing 52 missing values with bfill in column realint.\n</pre> In\u00a0[13]: Copied! <pre>atom.y\n</pre> atom.y Out[13]: infl realint Period 1959Q1 0.000000 0.000000 1959Q2 1.529706 0.860233 1959Q3 1.655295 1.044031 1959Q4 0.519615 2.014944 1960Q1 1.519868 1.090871 ... ... ... 2008Q3 0.969536 2.080865 2008Q4 0.969536 2.984962 2009Q1 0.969536 2.984962 2009Q2 1.835756 2.984962 2009Q3 1.886796 2.984962 <p>203 rows \u00d7 2 columns</p> In\u00a0[14]: Copied! <pre>atom.run([\"BATS\", \"MSTL\"], n_trials=10, warnings=False)\n</pre> atom.run([\"BATS\", \"MSTL\"], n_trials=10, warnings=False) <pre>\nTraining ========================= &gt;&gt;\nModels: BATS, MSTL\nMetric: mape\n\n\nRunning hyperparameter tuning for BATS...\n| trial | use_box_cox | use_trend | use_damped_trend | use_arma_errors |    mape | best_mape | time_trial | time_ht |    state |\n| ----- | ----------- | --------- | ---------------- | --------------- | ------- | --------- | ---------- | ------- | -------- |\n| 0     |       False |      True |             None |            True | -0.6224 |   -0.6224 |     5.472s |  5.472s | COMPLETE |\n| 1     |        None |     False |             True |           False |  -0.638 |   -0.6224 |     0.159s |  5.631s | COMPLETE |\n| 2     |        None |      True |            False |           False | -0.9856 |   -0.6224 |     0.322s |  5.954s | COMPLETE |\n| 3     |       False |     False |            False |           False |  -0.638 |   -0.6224 |     0.158s |  6.112s | COMPLETE |\n| 4     |        None |      True |            False |           False | -0.9856 |   -0.6224 |     0.001s |  6.113s | COMPLETE |\n| 5     |       False |     False |            False |           False |  -0.638 |   -0.6224 |     0.002s |  6.115s | COMPLETE |\n| 6     |        None |     False |            False |           False |  -0.638 |   -0.6224 |     0.157s |  6.272s | COMPLETE |\n| 7     |       False |      True |             None |           False | -0.6224 |   -0.6224 |     1.245s |  7.517s | COMPLETE |\n| 8     |        True |      True |             None |            True | -0.6224 |   -0.6224 |     5.364s | 12.881s | COMPLETE |\n| 9     |        True |      None |             None |           False | -0.5939 |   -0.5939 |     1.417s | 14.299s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 9\nBest parameters:\n --&gt; use_box_cox: True\n --&gt; use_trend: None\n --&gt; use_damped_trend: None\n --&gt; use_arma_errors: False\nBest evaluation --&gt; mape: -0.5939\nTime elapsed: 14.299s\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -31036189868254.254\nTest evaluation --&gt; mape: -0.7341\nTime elapsed: 1.168s\n-------------------------------------------------\nTime: 15.467s\n\n\nRunning hyperparameter tuning for MSTL...\n| trial | seasonal_deg | trend_deg | low_pass_deg |  robust |    mape | best_mape | time_trial | time_ht |    state |\n| ----- | ------------ | --------- | ------------ | ------- | ------- | --------- | ---------- | ------- | -------- |\n| 0     |            1 |         1 |            0 |   False | -0.6357 |   -0.6357 |    20.777s | 20.777s | COMPLETE |\n| 1     |            1 |         1 |            1 |   False | -0.6357 |   -0.6357 |     0.095s | 20.872s | COMPLETE |\n| 2     |            1 |         1 |            1 |   False | -0.6357 |   -0.6357 |     0.001s | 20.873s | COMPLETE |\n| 3     |            1 |         0 |            1 |   False | -0.6357 |   -0.6357 |     0.104s | 20.977s | COMPLETE |\n| 4     |            0 |         0 |            1 |   False | -0.6357 |   -0.6357 |     0.119s | 21.096s | COMPLETE |\n| 5     |            0 |         1 |            1 |    True | -0.6357 |   -0.6357 |     0.123s | 21.219s | COMPLETE |\n| 6     |            0 |         1 |            1 |    True | -0.6357 |   -0.6357 |     0.003s | 21.222s | COMPLETE |\n| 7     |            0 |         1 |            1 |    True | -0.6357 |   -0.6357 |     0.002s | 21.224s | COMPLETE |\n| 8     |            1 |         0 |            0 |    True | -0.6357 |   -0.6357 |     0.107s | 21.331s | COMPLETE |\n| 9     |            1 |         0 |            0 |    True | -0.6357 |   -0.6357 |     0.001s | 21.332s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 0\nBest parameters:\n --&gt; stl_kwargs: {'seasonal_deg': 1, 'trend_deg': 1, 'low_pass_deg': 0, 'robust': False}\nBest evaluation --&gt; mape: -0.6357\nTime elapsed: 21.332s\nFit ---------------------------------------------\nTrain evaluation --&gt; mape: -40954763135468.12\nTest evaluation --&gt; mape: -0.7308\nTime elapsed: 0.107s\n-------------------------------------------------\nTime: 21.439s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 37.028s\n-------------------------------------\nBATS --&gt; mape: -0.7341\nMSTL --&gt; mape: -0.7308 !\n</pre> In\u00a0[15]: Copied! <pre>atom.evaluate()\n</pre> atom.evaluate() Out[15]: mae mape mse r2 rmse BATS -0.553500 -0.734100 -0.505500 -0.012300 -0.693300 MSTL -0.552600 -0.730800 -0.504800 -0.011100 -0.692900 In\u00a0[16]: Copied! <pre>with atom.canvas():\n    atom.winner.plot_forecast(target=0)\n    atom.winner.plot_forecast(target=1)\n</pre> with atom.canvas():     atom.winner.plot_forecast(target=0)     atom.winner.plot_forecast(target=1)"}, {"location": "examples/multivariate_forecast/#example-multivariate-forecast", "title": "Example: Multivariate forecast\u00b6", "text": "<p>This example shows how to use ATOM to work with a multivariate time series dataset with exogenous features.</p> <p>Import the macroeconomic dataset from sktime.datasets. This is a small dataset that measures US Macroeconomic Data between 1959 and 2009.</p>"}, {"location": "examples/multivariate_forecast/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/multivariate_forecast/#analyze-the-data", "title": "Analyze the data\u00b6", "text": ""}, {"location": "examples/multivariate_forecast/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/multivariate_forecast/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/nlp/", "title": "NLP", "text": "In\u00a0[1]: Copied! <pre>import numpy as np\nfrom atom import ATOMClassifier\nfrom sklearn.datasets import fetch_20newsgroups\n</pre> import numpy as np from atom import ATOMClassifier from sklearn.datasets import fetch_20newsgroups In\u00a0[2]: Copied! <pre># Use only a subset of the available topics for faster processing\nX_text, y_text = fetch_20newsgroups(\n    return_X_y=True,\n    categories=[\n        'sci.med',\n        'comp.windows.x',\n        'misc.forsale',\n        'rec.autos',\n    ],\n    shuffle=True,\n    random_state=1,\n)\nX_text = np.array(X_text).reshape(-1, 1)\n</pre> # Use only a subset of the available topics for faster processing X_text, y_text = fetch_20newsgroups(     return_X_y=True,     categories=[         'sci.med',         'comp.windows.x',         'misc.forsale',         'rec.autos',     ],     shuffle=True,     random_state=1, ) X_text = np.array(X_text).reshape(-1, 1) In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X_text, y_text, index=True, test_size=0.3, verbose=2, random_state=1)\n</pre> atom = ATOMClassifier(X_text, y_text, index=True, test_size=0.3, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Multiclass classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (2366, 2)\nTrain set size: 1657\nTest set size: 709\n-------------------------------------\nMemory: 122.87 kB\nScaled: False\nCategorical features: 1 (100.0%)\n\n</pre> In\u00a0[4]: Copied! <pre>atom.dataset  # Note that the feature is automatically named 'corpus'\n</pre> atom.dataset  # Note that the feature is automatically named 'corpus' Out[4]: corpus target 1731 From: rlm@helen.surfcty.com (Robert L. McMilli... 0 1496 From: carl@SOL1.GPS.CALTECH.EDU (Carl J Lydick... 3 1290 From: thssjxy@iitmax.iit.edu (Smile)\\nSubject:... 1 2021 From: c23st@kocrsv01.delcoelect.com (Spiros Tr... 2 142 From: ginkgo@ecsvax.uncecs.edu (J. Geary Morto... 1 ... ... ... 510 From: mary@uicsl.csl.uiuc.edu (Mary E. Allison... 3 1948 From: ndd@sunbar.mc.duke.edu (Ned Danieley)\\nS... 0 798 From: kk@unisql.UUCP (Kerry Kimbrough)\\nSubjec... 0 2222 From: hamachi@adobe.com (Gordon Hamachi)\\nSubj... 2 2215 From: mobasser@vu-vlsi.ee.vill.edu (Bijan Moba... 2 <p>2366 rows \u00d7 2 columns</p> In\u00a0[5]: Copied! <pre># Let's have a look at the first document\natom.corpus[0]\n</pre> # Let's have a look at the first document atom.corpus[0] Out[5]: <pre>'From: caf@omen.UUCP (Chuck Forsberg WA7KGX)\\nSubject: Re: My New Diet --&gt; IT WORKS GREAT !!!!\\nOrganization: Omen Technology INC, Portland Rain Forest\\nLines: 32\\n\\nIn article &lt;1qk6v3INNrm6@lynx.unm.edu&gt; bhjelle@carina.unm.edu () writes:\\n&gt;\\n&gt;Gordon Banks:\\n&gt;\\n&gt;&gt;a lot to keep from going back to morbid obesity.  I think all\\n&gt;&gt;of us cycle.  One\\'s success depends on how large the fluctuations\\n&gt;&gt;in the cycle are.  Some people can cycle only 5 pounds.  Unfortunately,\\n&gt;&gt;I\\'m not one of them.\\n&gt;&gt;\\n&gt;&gt;\\n&gt;This certainly describes my situation perfectly. For me there is\\n&gt;a constant dynamic between my tendency to eat, which appears to\\n&gt;be totally limitless, and the purely conscious desire to not\\n&gt;put on too much weight. When I get too fat, I just diet/exercise\\n&gt;more (with varying degrees of success) to take off the\\n&gt;extra weight. Usually I cycle within a 15 lb range, but\\n&gt;smaller and larger cycles occur as well. I\\'m always afraid\\n&gt;that this method will stop working someday, but usually\\n&gt;I seem to be able to hold the weight gain in check.\\n&gt;This is one reason I have a hard time accepting the notion\\n&gt;of some metabolic derangement associated with cycle dieting\\n&gt;(that results in long-term weight gain). I have been cycle-\\n&gt;dieting for at least 20 years without seeing such a change.\\n\\nAs mentioned in Adiposity 101, only some experience weight\\nrebound.  The fact that you don\\'t doesn\\'t prove it doesn\\'t\\nhappen to others.\\n-- \\nChuck Forsberg WA7KGX          ...!tektronix!reed!omen!caf \\nAuthor of YMODEM, ZMODEM, Professional-YAM, ZCOMM, and DSZ\\n  Omen Technology Inc    \"The High Reliability Software\"\\n17505-V NW Sauvie IS RD   Portland OR 97231   503-621-3406\\n'</pre> In\u00a0[6]: Copied! <pre># Clean the documents from noise (emails, numbers, etc...)\natom.textclean()\n</pre> # Clean the documents from noise (emails, numbers, etc...) atom.textclean() <pre>Fitting TextCleaner...\nCleaning the corpus...\n --&gt; Decoding unicode characters to ascii.\n --&gt; Converting text to lower case.\n --&gt; Dropping emails from documents.\n --&gt; Dropping URL links from documents.\n --&gt; Dropping HTML tags from documents.\n --&gt; Dropping emojis from documents.\n --&gt; Dropping numbers from documents.\n --&gt; Dropping punctuation from the text.\n</pre> In\u00a0[7]: Copied! <pre># Check how the first document changed\natom.corpus[0]\n</pre> # Check how the first document changed atom.corpus[0] Out[7]: <pre>'from  chuck forsberg wa7kgx\\nsubject re my new diet  it works great \\norganization omen technology inc portland rain forest\\nlines \\n\\nin article    writes\\n\\ngordon banks\\n\\na lot to keep from going back to morbid obesity  i think all\\nof us cycle  ones success depends on how large the fluctuations\\nin the cycle are  some people can cycle only  pounds  unfortunately\\nim not one of them\\n\\n\\nthis certainly describes my situation perfectly for me there is\\na constant dynamic between my tendency to eat which appears to\\nbe totally limitless and the purely conscious desire to not\\nput on too much weight when i get too fat i just dietexercise\\nmore with varying degrees of success to take off the\\nextra weight usually i cycle within a  lb range but\\nsmaller and larger cycles occur as well im always afraid\\nthat this method will stop working someday but usually\\ni seem to be able to hold the weight gain in check\\nthis is one reason i have a hard time accepting the notion\\nof some metabolic derangement associated with cycle dieting\\nthat results in longterm weight gain i have been cycle\\ndieting for at least  years without seeing such a change\\n\\nas mentioned in adiposity  only some experience weight\\nrebound  the fact that you dont doesnt prove it doesnt\\nhappen to others\\n \\nchuck forsberg wa7kgx          tektronixreedomencaf \\nauthor of ymodem zmodem professionalyam zcomm and dsz\\n  omen technology inc    the high reliability software\\nv nw sauvie is rd   portland or    \\n'</pre> In\u00a0[8]: Copied! <pre># Convert the strings to a sequence of words\natom.tokenize()\n</pre> # Convert the strings to a sequence of words atom.tokenize() <pre>Fitting Tokenizer...\nTokenizing the corpus...\n</pre> In\u00a0[9]: Copied! <pre># Print the first few words of the first document\natom.corpus[0][:7]\n</pre> # Print the first few words of the first document atom.corpus[0][:7] Out[9]: <pre>['from', 'chuck', 'forsberg', 'wa7kgx', 'subject', 're', 'my']</pre> In\u00a0[10]: Copied! <pre># Normalize the text to a predefined standard\natom.textnormalize(stopwords=\"english\", lemmatize=True)\n</pre> # Normalize the text to a predefined standard atom.textnormalize(stopwords=\"english\", lemmatize=True) <pre>Fitting TextNormalizer...\nNormalizing the corpus...\n --&gt; Dropping stopwords.\n --&gt; Applying lemmatization.\n</pre> In\u00a0[11]: Copied! <pre>atom.corpus[0][:7]  # Check changes...\n</pre> atom.corpus[0][:7]  # Check changes... Out[11]: <pre>['chuck', 'forsberg', 'wa7kgx', 'subject', 'new', 'diet', 'work']</pre> In\u00a0[12]: Copied! <pre># Visualize the most common words with a wordcloud\natom.plot_wordcloud(figsize=(700, 500))\n</pre> # Visualize the most common words with a wordcloud atom.plot_wordcloud(figsize=(700, 500)) In\u00a0[13]: Copied! <pre># Have a look at the most frequent bigrams\natom.plot_ngrams(2)\n</pre> # Have a look at the most frequent bigrams atom.plot_ngrams(2) In\u00a0[14]: Copied! <pre># Create the bigrams using the tokenizer\natom.tokenize(bigram_freq=215)\n</pre> # Create the bigrams using the tokenizer atom.tokenize(bigram_freq=215) <pre>Fitting Tokenizer...\nTokenizing the corpus...\n --&gt; Creating 7 bigrams on 3128 locations.\n</pre> In\u00a0[15]: Copied! <pre>atom.bigrams_\n</pre> atom.bigrams_ Out[15]: bigram frequency 0 x_x 1168 1 line_article 532 2 line_nntppostinghost 389 3 organization_university 331 4 gordon_bank 266 5 distribution_usa 227 6 line_distribution 215 In\u00a0[16]: Copied! <pre># As a last step before modelling, convert the words to vectors\natom.vectorize(strategy=\"tfidf\")\n</pre> # As a last step before modelling, convert the words to vectors atom.vectorize(strategy=\"tfidf\") <pre>Fitting Vectorizer...\nVectorizing the corpus...\n</pre> In\u00a0[17]: Copied! <pre># The dimensionality of the dataset has increased a lot!\natom.shape\n</pre> # The dimensionality of the dataset has increased a lot! atom.shape Out[17]: <pre>(2366, 24176)</pre> In\u00a0[18]: Copied! <pre># Note that the data is sparse and the columns are named\n# after the words they are embedding\natom.dtypes\n</pre> # Note that the data is sparse and the columns are named # after the words they are embedding atom.dtypes Out[18]: <pre>corpus_000000e5    Sparse[float64, 0]\ncorpus_00000ee5    Sparse[float64, 0]\ncorpus_000010af    Sparse[float64, 0]\ncorpus_0007259d    Sparse[float64, 0]\ncorpus_00072a27    Sparse[float64, 0]\n                          ...        \ncorpus_zurich      Sparse[float64, 0]\ncorpus_zvi         Sparse[float64, 0]\ncorpus_zx          Sparse[float64, 0]\ncorpus_zz          Sparse[float64, 0]\ntarget                          int64\nLength: 24176, dtype: object</pre> In\u00a0[19]: Copied! <pre># When the dataset is sparse, stats() shows the density\natom.stats()\n</pre> # When the dataset is sparse, stats() shows the density atom.stats() <pre>Dataset stats ==================== &gt;&gt;\nShape: (2366, 24176)\nTrain set size: 1657\nTest set size: 709\n-------------------------------------\nMemory: 2.54 MB\nSparse: True\nDensity: 0.35%\n</pre> In\u00a0[20]: Copied! <pre># Check which models have support for sparse matrices\natom.available_models(accepts_sparse=True)\n</pre> # Check which models have support for sparse matrices atom.available_models(accepts_sparse=True) Out[20]: acronym fullname estimator module handles_missing needs_scaling accepts_sparse native_multilabel native_multioutput validation supports_engines 0 AdaB AdaBoost AdaBoostClassifier sklearn.ensemble._weight_boosting False False True False False None sklearn 1 Bag Bagging BaggingClassifier sklearn.ensemble._bagging True False True False False None sklearn 2 BNB BernoulliNB BernoulliNB sklearn.naive_bayes False False True False False None sklearn, cuml 3 CatB CatBoost CatBoostClassifier catboost.core True True True False False n_estimators catboost 4 CatNB CategoricalNB CategoricalNB sklearn.naive_bayes False False True False False None sklearn, cuml 5 CNB ComplementNB ComplementNB sklearn.naive_bayes False False True False False None sklearn, cuml 6 Tree DecisionTree DecisionTreeClassifier sklearn.tree._classes True False True True True None sklearn 7 ETree ExtraTree ExtraTreeClassifier sklearn.tree._classes False False True True True None sklearn 8 ET ExtraTrees ExtraTreesClassifier sklearn.ensemble._forest False False True True True None sklearn 9 GBM GradientBoostingMachine GradientBoostingClassifier sklearn.ensemble._gb False False True False False None sklearn 10 KNN KNearestNeighbors KNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn, sklearnex, cuml 11 LGB LightGBM LGBMClassifier lightgbm.sklearn True True True False False n_estimators lightgbm 12 lSVM LinearSVM LinearSVC sklearn.svm._classes False True True False False None sklearn, cuml 13 LR LogisticRegression LogisticRegression sklearn.linear_model._logistic False True True False False None sklearn, sklearnex, cuml 14 MLP MultiLayerPerceptron MLPClassifier sklearn.neural_network._multilayer_perceptron False True True True False max_iter sklearn 15 MNB MultinomialNB MultinomialNB sklearn.naive_bayes False False True False False None sklearn, cuml 16 PA PassiveAggressive PassiveAggressiveClassifier sklearn.linear_model._passive_aggressive False True True False False max_iter sklearn 17 RNN RadiusNearestNeighbors RadiusNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn 18 RF RandomForest RandomForestClassifier sklearn.ensemble._forest False False True True True None sklearn, sklearnex, cuml 19 Ridge Ridge RidgeClassifier sklearn.linear_model._ridge False True True True False None sklearn, sklearnex, cuml 20 SGD StochasticGradientDescent SGDClassifier sklearn.linear_model._stochastic_gradient False True True False False max_iter sklearn 21 SVM SupportVectorMachine SVC sklearn.svm._classes False True True False False None sklearn, sklearnex, cuml 22 XGB XGBoost XGBClassifier xgboost.sklearn True True True False False n_estimators xgboost In\u00a0[21]: Copied! <pre># Train the model\natom.run(models=\"RF\", metric=\"f1_weighted\")\n</pre> # Train the model atom.run(models=\"RF\", metric=\"f1_weighted\") <pre>\nTraining ========================= &gt;&gt;\nModels: RF\nMetric: f1_weighted\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1_weighted: 1.0\nTest evaluation --&gt; f1_weighted: 0.9181\nTime elapsed: 03m:05s\n-------------------------------------------------\nTime: 03m:05s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 03m:05s\n-------------------------------------\nRandomForest --&gt; f1_weighted: 0.9181\n</pre> In\u00a0[22]: Copied! <pre>atom.evaluate()\n</pre> atom.evaluate() Out[22]: ba f1_weighted jaccard_weighted mcc precision_weighted recall_weighted RF 0.918300 0.918100 0.848600 0.891800 0.920600 0.918200 In\u00a0[23]: Copied! <pre>atom.plot_confusion_matrix(figsize=(700, 600))\n</pre> atom.plot_confusion_matrix(figsize=(700, 600)) In\u00a0[24]: Copied! <pre>atom.plot_shap_decision(rows=0, show=15)\n</pre> atom.plot_shap_decision(rows=0, show=15) In\u00a0[25]: Copied! <pre>atom.plot_shap_beeswarm(target=0, show=15)\n</pre> atom.plot_shap_beeswarm(target=0, show=15) <pre>100%|===================| 2824/2836 [02:27&lt;00:00]        </pre>"}, {"location": "examples/nlp/#example-nlp", "title": "Example: NLP\u00b6", "text": "<p>This example shows how to use ATOM to quickly go from raw text data to model predictions.</p> <p>Import the 20 newsgroups text dataset from sklearn.datasets. The dataset comprises around 18000 articles on 20 topics. The goal is to predict the topic of every article.</p>"}, {"location": "examples/nlp/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/nlp/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/nlp/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/pruning/", "title": "Pruning", "text": "In\u00a0[1]: Copied! <pre># Import packages\nfrom sklearn.datasets import load_breast_cancer\nfrom optuna.pruners import HyperbandPruner\nfrom atom import ATOMClassifier\n</pre> # Import packages from sklearn.datasets import load_breast_cancer from optuna.pruners import HyperbandPruner from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX, y = load_breast_cancer(return_X_y=True)\n</pre> # Load the data X, y = load_breast_cancer(return_X_y=True) In\u00a0[3]: Copied! <pre># Initialize atom\natom = ATOMClassifier(X, y, verbose=2, random_state=1)\n</pre> # Initialize atom atom = ATOMClassifier(X, y, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (569, 31)\nTrain set size: 456\nTest set size: 113\n-------------------------------------\nMemory: 141.24 kB\nScaled: False\nOutlier values: 167 (1.2%)\n\n</pre> In\u00a0[4]: Copied! <pre># Use ht_params to specify a custom pruner\n# Note that pruned trials show the number of iterations it completed\natom.run(\n    models=\"SGD\",\n    metric=\"f1\",\n    n_trials=25,\n    ht_params={\n        \"distributions\": [\"penalty\", \"max_iter\"],\n        \"pruner\": HyperbandPruner(),\n    }\n)\n</pre> # Use ht_params to specify a custom pruner # Note that pruned trials show the number of iterations it completed atom.run(     models=\"SGD\",     metric=\"f1\",     n_trials=25,     ht_params={         \"distributions\": [\"penalty\", \"max_iter\"],         \"pruner\": HyperbandPruner(),     } ) <pre>\nTraining ========================= &gt;&gt;\nModels: SGD\nMetric: f1\n\n\nRunning hyperparameter tuning for StochasticGradientDescent...\n| trial | penalty | max_iter |      f1 | best_f1 | time_trial | time_ht |    state |\n| ----- | ------- | -------- | ------- | ------- | ---------- | ------- | -------- |\n| 0     |      l1 |      650 |  0.9558 |  0.9558 |     3.786s |  3.786s | COMPLETE |\n| 1     | elast.. |     1050 |  0.9744 |  0.9744 |     8.431s | 12.217s | COMPLETE |\n| 2     | elast.. |      500 |  0.9828 |  0.9828 |     0.040s | 12.257s |   PRUNED |\n| 3     |    None |      700 |  0.9739 |  0.9828 |     3.873s | 16.130s | COMPLETE |\n| 4     |      l1 |     1400 |  0.9735 |  0.9828 |     0.047s | 16.177s |   PRUNED |\n| 5     |    None |     1400 |  0.9735 |  0.9828 |     7.163s | 23.340s | COMPLETE |\n| 6     |      l2 |     1200 |  0.9825 |  0.9828 |     5.103s | 28.443s | COMPLETE |\n| 7     |      l2 |     1250 |  0.9825 |  0.9828 |     5.729s | 34.172s | COMPLETE |\n| 8     |    None |      600 |  0.9828 |  0.9828 |     0.034s | 34.206s |   PRUNED |\n| 9     |      l1 |      600 |  0.9402 |  0.9828 |     0.042s | 34.249s |   PRUNED |\n| 10    |      l2 |      950 |  0.9565 |  0.9828 |     4.432s | 38.681s | COMPLETE |\n| 11    |      l2 |     1200 |  0.9825 |  0.9828 |     0.005s | 38.686s | COMPLETE |\n| 12    |      l2 |     1200 |  0.9825 |  0.9828 |     0.004s | 38.690s | COMPLETE |\n| 13    |      l2 |     1200 |  0.9825 |  0.9828 |     0.005s | 38.695s | COMPLETE |\n| 14    |      l2 |     1500 |  0.9573 |  0.9828 |     0.050s | 38.745s |   PRUNED |\n| 15    |      l2 |      950 |  0.9565 |  0.9828 |     0.005s | 38.750s | COMPLETE |\n| 16    |      l2 |     1100 |  0.9391 |  0.9828 |     0.044s | 38.795s |   PRUNED |\n| 17    |      l2 |      850 |  0.9831 |  0.9831 |     0.047s | 38.842s |   PRUNED |\n| 18    | elast.. |     1300 |   0.931 |  0.9831 |     0.050s | 38.892s |   PRUNED |\n| 19    |      l2 |     1300 |  0.9649 |  0.9831 |     0.072s | 38.963s |   PRUNED |\n| 20    |      l2 |      800 |  0.9661 |  0.9831 |     0.044s | 39.007s |   PRUNED |\n| 21    |      l2 |     1150 |  0.9402 |  0.9831 |     0.039s | 39.046s |   PRUNED |\n| 22    |      l2 |     1300 |  0.9573 |  0.9831 |     0.050s | 39.096s |   PRUNED |\n| 23    |      l2 |     1250 |  0.9825 |  0.9831 |     0.006s | 39.102s | COMPLETE |\n| 24    |      l2 |     1050 |  0.9565 |  0.9831 |     0.096s | 39.198s |   PRUNED |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 6\nBest parameters:\n --&gt; penalty: l2\n --&gt; max_iter: 1200\nBest evaluation --&gt; f1: 0.9825\nTime elapsed: 39.198s\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.993\nTest evaluation --&gt; f1: 0.9722\nTime elapsed: 10.046s\n-------------------------------------------------\nTime: 49.244s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 49.452s\n-------------------------------------\nStochasticGradientDescent --&gt; f1: 0.9722\n</pre> In\u00a0[5]: Copied! <pre>atom.plot_trials()\n</pre> atom.plot_trials() In\u00a0[7]: Copied! <pre>atom.plot_timeline()\n</pre> atom.plot_timeline() In\u00a0[6]: Copied! <pre>atom.plot_hyperparameter_importance()\n</pre> atom.plot_hyperparameter_importance()"}, {"location": "examples/pruning/#example-pruning", "title": "Example: Pruning\u00b6", "text": "<p>This example shows an advanced example on how to use hyperparameter tuning with pruning.</p> <p>Import the breast cancer dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.</p>"}, {"location": "examples/pruning/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/pruning/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/pruning/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/ray_backend/", "title": "Ray backend", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport ray\nfrom atom import ATOMClassifier\nfrom sklearn.datasets import make_classification\n</pre> # Import packages import ray from atom import ATOMClassifier from sklearn.datasets import make_classification In\u00a0[2]: Copied! <pre># Use a small dataset for illustration purposes\nX, y = make_classification(n_samples=10000, n_features=10, random_state=1)\n</pre> # Use a small dataset for illustration purposes X, y = make_classification(n_samples=10000, n_features=10, random_state=1) In\u00a0[3]: Copied! <pre># Note we already specify the number of cores for parallel execution here\natom = ATOMClassifier(X, y, n_jobs=2, backend=\"ray\", verbose=2, random_state=1)\n</pre> # Note we already specify the number of cores for parallel execution here atom = ATOMClassifier(X, y, n_jobs=2, backend=\"ray\", verbose=2, random_state=1) <pre>2024-03-04 10:03:31,922\tINFO worker.py:1715 -- Started a local Ray instance. View the dashboard at http://127.0.0.1:8265 \n</pre> <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\nParallel processing with 2 cores.\nParallelization backend: ray\n\nDataset stats ==================== &gt;&gt;\nShape: (10000, 11)\nTrain set size: 8000\nTest set size: 2000\n-------------------------------------\nMemory: 880.13 kB\nScaled: True\nOutlier values: 211 (0.2%)\n\n</pre> In\u00a0[4]: Copied! <pre># Using `parallel=True`, we train one model in each node\n# Note that when training in parallel, the verbosity of the models is zero\natom.run(models=[\"PA\", \"SGD\"], est_params={\"max_iter\": 150}, parallel=True, errors=\"raise\")\n</pre> # Using `parallel=True`, we train one model in each node # Note that when training in parallel, the verbosity of the models is zero atom.run(models=[\"PA\", \"SGD\"], est_params={\"max_iter\": 150}, parallel=True, errors=\"raise\") <pre>\nTraining ========================= &gt;&gt;\nModels: PA, SGD\nMetric: f1\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 13.971s\n-------------------------------------\nPassiveAggressive         --&gt; f1: 0.8198\nStochasticGradientDescent --&gt; f1: 0.8766 !\n</pre> In\u00a0[5]: Copied! <pre># Notice how the summed time to train the models is less than the total time\natom.plot_results(metric=\"time_fit\")\n</pre> # Notice how the summed time to train the models is less than the total time atom.plot_results(metric=\"time_fit\") In\u00a0[6]: Copied! <pre># Create a rest API endpoint and do inference on the holdout set\natom.pa.serve(port=8001)\n</pre> # Create a rest API endpoint and do inference on the holdout set atom.pa.serve(port=8001) <pre>Serving model PassiveAggressive on 127.0.0.1:8001...\n</pre> In\u00a0[7]: Copied! <pre>import requests\n\nX_predict = atom.X_test.iloc[:10, :]\nresponse = requests.get(\"http://127.0.0.1:8001/\", json=X_predict.to_json())\n</pre> import requests  X_predict = atom.X_test.iloc[:10, :] response = requests.get(\"http://127.0.0.1:8001/\", json=X_predict.to_json()) In\u00a0[8]: Copied! <pre>response.json()\n</pre> response.json() Out[8]: <pre>[1, 1, 0, 0, 1, 1, 0, 1, 0, 0]</pre> In\u00a0[9]: Copied! <pre># Don't forget to shut down the ray server\nray.shutdown()\n</pre> # Don't forget to shut down the ray server ray.shutdown()"}, {"location": "examples/ray_backend/#example-ray-backend", "title": "Example: Ray backend\u00b6", "text": "<p>This example shows how to use the ray backend to train models in a parallel context.</p> <p>The data used is a synthetic dataset created using sklearn's make_classification function.</p>"}, {"location": "examples/ray_backend/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/ray_backend/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/ray_backend/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/regression/", "title": "Regression", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMRegressor\n</pre> # Import packages import pandas as pd from atom import ATOMRegressor In\u00a0[2]: Copied! <pre># Load the data\nX = pd.read_csv(\"docs_source/examples/datasets/abalone.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load the data X = pd.read_csv(\"docs_source/examples/datasets/abalone.csv\")  # Let's have a look X.head() Out[2]: Sex Length Diameter Height Whole weight Shucked weight Viscera weight Shell weight Rings 0 M 0.455 0.365 0.095 0.5140 0.2245 0.1010 0.150 15 1 M 0.350 0.265 0.090 0.2255 0.0995 0.0485 0.070 7 2 F 0.530 0.420 0.135 0.6770 0.2565 0.1415 0.210 9 3 M 0.440 0.365 0.125 0.5160 0.2155 0.1140 0.155 10 4 I 0.330 0.255 0.080 0.2050 0.0895 0.0395 0.055 7 In\u00a0[3]: Copied! <pre># Initialize atom for regression tasks\natom = ATOMRegressor(X, \"Rings\", verbose=2, random_state=42)\n</pre> # Initialize atom for regression tasks atom = ATOMRegressor(X, \"Rings\", verbose=2, random_state=42) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Regression.\n\nDataset stats ==================== &gt;&gt;\nShape: (4177, 9)\nTrain set size: 3342\nTest set size: 835\n-------------------------------------\nMemory: 300.88 kB\nScaled: False\nCategorical features: 1 (12.5%)\nOutlier values: 195 (0.6%)\n\n</pre> In\u00a0[4]: Copied! <pre># Encode the categorical features\natom.encode()\n</pre> # Encode the categorical features atom.encode() <pre>Fitting Encoder...\nEncoding categorical columns...\n --&gt; OneHot-encoding feature Sex. Contains 3 classes.\n</pre> In\u00a0[5]: Copied! <pre># Plot the dataset's correlation matrix\natom.plot_correlation()\n</pre> # Plot the dataset's correlation matrix atom.plot_correlation() In\u00a0[6]: Copied! <pre># Apply pca for dimensionality reduction\natom.feature_selection(strategy=\"pca\", n_features=6)\n</pre> # Apply pca for dimensionality reduction atom.feature_selection(strategy=\"pca\", n_features=6) <pre>Fitting FeatureSelector...\nPerforming feature selection ...\n --&gt; Applying Principal Component Analysis...\n   --&gt; Scaling features...\n   --&gt; Keeping 6 components.\n   --&gt; Explained variance ratio: 0.97\n</pre> In\u00a0[7]: Copied! <pre># Note that the fetaures are automatically renamed to pca0, pca1, etc...\natom.columns\n</pre> # Note that the fetaures are automatically renamed to pca0, pca1, etc... atom.columns Out[7]: <pre>Index(['pca0', 'pca1', 'pca2', 'pca3', 'pca4', 'pca5', 'Rings'], dtype='object')</pre> In\u00a0[8]: Copied! <pre># Use the plotting methods to see the retained variance ratio\natom.plot_pca()\n</pre> # Use the plotting methods to see the retained variance ratio atom.plot_pca() In\u00a0[9]: Copied! <pre>atom.plot_components()\n</pre> atom.plot_components() In\u00a0[10]: Copied! <pre>atom.run(\n    models=[\"Tree\", \"Bag\", \"ET\"],\n    metric=\"mse\",\n    n_trials=5,\n    n_bootstrap=5,\n)\n</pre> atom.run(     models=[\"Tree\", \"Bag\", \"ET\"],     metric=\"mse\",     n_trials=5,     n_bootstrap=5, ) <pre>\nTraining ========================= &gt;&gt;\nModels: Tree, Bag, ET\nMetric: mse\n\n\nRunning hyperparameter tuning for DecisionTree...\n| trial |   criterion | splitter | max_depth | min_samples_split | min_samples_leaf | max_features | ccp_alpha |     mse | best_mse | time_trial | time_ht |    state |\n| ----- | ----------- | -------- | --------- | ----------------- | ---------------- | ------------ | --------- | ------- | -------- | ---------- | ------- | -------- |\n| 0     | absolute_.. |     best |         5 |                 8 |               10 |         None |     0.035 | -6.5456 |  -6.5456 |     0.412s |  0.412s | COMPLETE |\n| 1     | squared_e.. |     best |        10 |                 5 |                1 |          0.5 |      0.03 | -7.1959 |  -6.5456 |     0.096s |  0.508s | COMPLETE |\n| 2     | absolute_.. |   random |        14 |                15 |               16 |         sqrt |     0.025 | -8.5859 |  -6.5456 |     0.108s |  0.616s | COMPLETE |\n| 3     | friedman_.. |   random |         4 |                10 |               17 |          0.9 |      0.01 | -7.4933 |  -6.5456 |     0.095s |  0.711s | COMPLETE |\n| 4     |     poisson |     best |        12 |                15 |                8 |          0.6 |      0.02 | -5.8126 |  -5.8126 |     0.095s |  0.806s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 4\nBest parameters:\n --&gt; criterion: poisson\n --&gt; splitter: best\n --&gt; max_depth: 12\n --&gt; min_samples_split: 15\n --&gt; min_samples_leaf: 8\n --&gt; max_features: 0.6\n --&gt; ccp_alpha: 0.02\nBest evaluation --&gt; mse: -5.8126\nTime elapsed: 0.806s\nFit ---------------------------------------------\nTrain evaluation --&gt; mse: -6.2977\nTest evaluation --&gt; mse: -7.1923\nTime elapsed: 0.069s\nBootstrap ---------------------------------------\nEvaluation --&gt; mse: -7.6026 \u00b1 0.3783\nTime elapsed: 0.130s\n-------------------------------------------------\nTime: 1.005s\n\n\nRunning hyperparameter tuning for Bagging...\n| trial | n_estimators | max_samples | max_features | bootstrap | bootstrap_features |     mse | best_mse | time_trial | time_ht |    state |\n| ----- | ------------ | ----------- | ------------ | --------- | ------------------ | ------- | -------- | ---------- | ------- | -------- |\n| 0     |          190 |         1.0 |          0.9 |      True |               True | -4.5751 |  -4.5751 |     3.790s |  3.790s | COMPLETE |\n| 1     |          440 |         0.8 |          0.9 |     False |               True | -6.7839 |  -4.5751 |     9.983s | 13.773s | COMPLETE |\n| 2     |          100 |         0.6 |          0.6 |      True |              False | -5.0065 |  -4.5751 |     0.975s | 14.749s | COMPLETE |\n| 3     |           70 |         0.6 |          0.7 |     False |              False | -5.4027 |  -4.5751 |     1.037s | 15.786s | COMPLETE |\n| 4     |          300 |         0.5 |          0.8 |      True |              False | -5.0964 |  -4.5751 |     2.864s | 18.650s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 0\nBest parameters:\n --&gt; n_estimators: 190\n --&gt; max_samples: 1.0\n --&gt; max_features: 0.9\n --&gt; bootstrap: True\n --&gt; bootstrap_features: True\nBest evaluation --&gt; mse: -4.5751\nTime elapsed: 18.650s\nFit ---------------------------------------------\nTrain evaluation --&gt; mse: -0.7581\nTest evaluation --&gt; mse: -5.7896\nTime elapsed: 3.868s\nBootstrap ---------------------------------------\nEvaluation --&gt; mse: -5.9893 \u00b1 0.1646\nTime elapsed: 18.942s\n-------------------------------------------------\nTime: 41.460s\n\n\nRunning hyperparameter tuning for ExtraTrees...\n| trial | n_estimators |     criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | ccp_alpha |     mse | best_mse | time_trial | time_ht |    state |\n| ----- | ------------ | ------------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | --------- | ------- | -------- | ---------- | ------- | -------- |\n| 0     |          190 | squared_error |         8 |                13 |                3 |          0.5 |      True |         0.6 |     0.025 | -5.1462 |  -5.1462 |     0.516s |  0.516s | COMPLETE |\n| 1     |          230 | absolute_er.. |         8 |                 8 |                8 |         sqrt |      True |         0.6 |       0.0 | -9.3444 |  -5.1462 |     2.209s |  2.725s | COMPLETE |\n| 2     |          180 | absolute_er.. |         7 |                 2 |                3 |          0.6 |      True |         0.6 |      0.03 | -5.7371 |  -5.1462 |     2.783s |  5.508s | COMPLETE |\n| 3     |          100 | squared_error |        14 |                15 |                8 |         None |      True |         0.9 |     0.005 | -5.1938 |  -5.1462 |     0.285s |  5.792s | COMPLETE |\n| 4     |          340 | squared_error |         6 |                15 |                8 |         None |      True |         0.8 |      0.01 | -4.8716 |  -4.8716 |     0.518s |  6.310s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 4\nBest parameters:\n --&gt; n_estimators: 340\n --&gt; criterion: squared_error\n --&gt; max_depth: 6\n --&gt; min_samples_split: 15\n --&gt; min_samples_leaf: 8\n --&gt; max_features: None\n --&gt; bootstrap: True\n --&gt; max_samples: 0.8\n --&gt; ccp_alpha: 0.01\nBest evaluation --&gt; mse: -4.8716\nTime elapsed: 6.310s\nFit ---------------------------------------------\nTrain evaluation --&gt; mse: -5.4808\nTest evaluation --&gt; mse: -6.3445\nTime elapsed: 0.662s\nBootstrap ---------------------------------------\nEvaluation --&gt; mse: -6.3694 \u00b1 0.0737\nTime elapsed: 3.118s\n-------------------------------------------------\nTime: 10.090s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 56.610s\n-------------------------------------\nDecisionTree --&gt; mse: -7.6026 \u00b1 0.3783\nBagging      --&gt; mse: -5.9893 \u00b1 0.1646 ~ !\nExtraTrees   --&gt; mse: -6.3694 \u00b1 0.0737\n</pre> In\u00a0[11]: Copied! <pre># Use the errors or residuals plots to check the model performances\natom.plot_residuals()\n</pre> # Use the errors or residuals plots to check the model performances atom.plot_residuals() In\u00a0[12]: Copied! <pre>atom.plot_errors()\n</pre> atom.plot_errors() In\u00a0[13]: Copied! <pre># Analyze the relation between the target response and the features\natom.plot_partial_dependence(columns=(0, 1, 2, 3))\n</pre> # Analyze the relation between the target response and the features atom.plot_partial_dependence(columns=(0, 1, 2, 3))"}, {"location": "examples/regression/#example-regression", "title": "Example: Regression\u00b6", "text": "<p>This example shows how to use ATOM to apply pca on the data and run a regression pipeline.</p> <p>Download the abalone dataset from https://archive.ics.uci.edu/ml/datasets/Abalone. The goal of this dataset is to predict the rings (age) of abalone shells from physical measurements.</p>"}, {"location": "examples/regression/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/regression/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/regression/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/successive_halving/", "title": "Successive halving", "text": "In\u00a0[1]: Copied! <pre>from sklearn.datasets import fetch_california_housing\nfrom atom import ATOMRegressor\n</pre> from sklearn.datasets import fetch_california_housing from atom import ATOMRegressor In\u00a0[2]: Copied! <pre># Load the data\nX, y = fetch_california_housing(return_X_y=True)\n</pre> # Load the data X, y = fetch_california_housing(return_X_y=True) In\u00a0[3]: Copied! <pre>atom = ATOMRegressor(X, y, verbose=2, random_state=1)\n</pre> atom = ATOMRegressor(X, y, verbose=2, random_state=1) <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Regression.\n\nDataset stats ==================== &gt;&gt;\nShape: (20640, 9)\nTrain set size: 16512\nTest set size: 4128\n-------------------------------------\nMemory: 1.49 MB\nScaled: False\nOutlier values: 786 (0.5%)\n\n</pre> In\u00a0[4]: Copied! <pre># Compare tree-based models via successive halving\natom.successive_halving(\n    models=[\"Tree\", \"Bag\", \"ET\", \"RF\", \"LGB\", \"CatB\"],\n    metric=\"mae\",\n    n_bootstrap=5,\n)\n</pre> # Compare tree-based models via successive halving atom.successive_halving(     models=[\"Tree\", \"Bag\", \"ET\", \"RF\", \"LGB\", \"CatB\"],     metric=\"mae\",     n_bootstrap=5, ) <pre>\nTraining ========================= &gt;&gt;\nMetric: mae\n\n\nRun: 0 =========================== &gt;&gt;\nModels: Tree6, Bag6, ET6, RF6, LGB6, CatB6\nSize of training set: 16512 (17%)\nSize of test set: 4128\n\n\nResults for DecisionTree:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.0\nTest evaluation --&gt; mae: -0.5394\nTime elapsed: 0.110s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.576 \u00b1 0.0119\nTime elapsed: 0.361s\n-------------------------------------------------\nTime: 0.472s\n\n\nResults for Bagging:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.1715\nTest evaluation --&gt; mae: -0.4308\nTime elapsed: 0.302s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.435 \u00b1 0.0059\nTime elapsed: 1.129s\n-------------------------------------------------\nTime: 1.431s\n\n\nResults for ExtraTrees:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.0\nTest evaluation --&gt; mae: -0.3977\nTime elapsed: 0.980s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.4059 \u00b1 0.0028\nTime elapsed: 4.264s\n-------------------------------------------------\nTime: 5.243s\n\n\nResults for RandomForest:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.1508\nTest evaluation --&gt; mae: -0.4053\nTime elapsed: 2.362s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.4162 \u00b1 0.0031\nTime elapsed: 10.267s\n-------------------------------------------------\nTime: 12.629s\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.2031\nTest evaluation --&gt; mae: -0.3594\nTime elapsed: 0.430s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.3673 \u00b1 0.0016\nTime elapsed: 0.788s\n-------------------------------------------------\nTime: 1.218s\n\n\nResults for CatBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.1639\nTest evaluation --&gt; mae: -0.3453\nTime elapsed: 6.837s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.3543 \u00b1 0.0025\nTime elapsed: 01m:14s\n-------------------------------------------------\nTime: 01m:21s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 01m:42s\n-------------------------------------\nDecisionTree --&gt; mae: -0.576 \u00b1 0.0119 ~\nBagging      --&gt; mae: -0.435 \u00b1 0.0059 ~\nExtraTrees   --&gt; mae: -0.4059 \u00b1 0.0028 ~\nRandomForest --&gt; mae: -0.4162 \u00b1 0.0031 ~\nLightGBM     --&gt; mae: -0.3673 \u00b1 0.0016 ~\nCatBoost     --&gt; mae: -0.3543 \u00b1 0.0025 ~ !\n\n\nRun: 1 =========================== &gt;&gt;\nModels: ET3, LGB3, CatB3\nSize of training set: 16512 (33%)\nSize of test set: 4128\n\n\nResults for ExtraTrees:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.0\nTest evaluation --&gt; mae: -0.3739\nTime elapsed: 1.755s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.3841 \u00b1 0.0027\nTime elapsed: 6.913s\n-------------------------------------------------\nTime: 8.668s\n\n\nResults for LightGBM:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.2327\nTest evaluation --&gt; mae: -0.3356\nTime elapsed: 0.484s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.345 \u00b1 0.0037\nTime elapsed: 0.942s\n-------------------------------------------------\nTime: 1.425s\n\n\nResults for CatBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.1896\nTest evaluation --&gt; mae: -0.3276\nTime elapsed: 5.944s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.3337 \u00b1 0.0017\nTime elapsed: 27.655s\n-------------------------------------------------\nTime: 33.599s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 43.699s\n-------------------------------------\nExtraTrees --&gt; mae: -0.3841 \u00b1 0.0027 ~\nLightGBM   --&gt; mae: -0.345 \u00b1 0.0037 ~\nCatBoost   --&gt; mae: -0.3337 \u00b1 0.0017 ~ !\n\n\nRun: 2 =========================== &gt;&gt;\nModels: CatB1\nSize of training set: 16512 (100%)\nSize of test set: 4128\n\n\nResults for CatBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; mae: -0.2231\nTest evaluation --&gt; mae: -0.3008\nTime elapsed: 8.146s\nBootstrap ---------------------------------------\nEvaluation --&gt; mae: -0.3079 \u00b1 0.0029\nTime elapsed: 40.905s\n-------------------------------------------------\nTime: 49.051s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 49.053s\n-------------------------------------\nCatBoost --&gt; mae: -0.3079 \u00b1 0.0029 ~\n</pre> In\u00a0[5]: Copied! <pre># The results is now multi-index, where frac is the fraction\n# of the training set used to fit the model. The model names\n# end with the number of models fitted during that run\natom.results\n</pre> # The results is now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the number of models fitted during that run atom.results Out[5]: mae_train mae_test time_fit mae_bootstrap time_bootstrap time frac model 0.17 Bag6 -0.2017 -0.4327 0.302116 -0.434981 1.129138 1.431254 CatB6 -0.2043 -0.3560 6.837450 -0.354266 73.713478 80.550928 ET6 -0.0694 -0.4077 0.979613 -0.405855 4.263598 5.243211 LGB6 -0.2202 -0.3676 0.430176 -0.367271 0.788259 1.218435 RF6 -0.1851 -0.4165 2.362080 -0.416217 10.267119 12.629199 Tree6 -0.1039 -0.5897 0.110449 -0.575962 0.361372 0.471821 0.33 CatB3 -0.2249 -0.3341 5.943560 -0.333670 27.655384 33.598944 ET3 -0.0935 -0.3879 1.755022 -0.384081 6.913167 8.668189 LGB3 -0.2489 -0.3405 0.483790 -0.344951 0.941663 1.425453 1.00 CatB1 -0.2231 -0.3008 8.146296 -0.307908 40.904606 49.050902 In\u00a0[6]: Copied! <pre># Plot the successive halving's results\natom.plot_successive_halving()\n</pre> # Plot the successive halving's results atom.plot_successive_halving() In\u00a0[7]: Copied! <pre># Use regex to call all the models with the same estimator...\natom.plot_errors(models=[\"CatB.*\"])\n</pre> # Use regex to call all the models with the same estimator... atom.plot_errors(models=[\"CatB.*\"]) In\u00a0[8]: Copied! <pre># ...or to call the models from the same run\natom.plot_errors(models=\".*3\")\n</pre> # ...or to call the models from the same run atom.plot_errors(models=\".*3\")"}, {"location": "examples/successive_halving/#example-successive-halving", "title": "Example: Successive halving\u00b6", "text": "<p>This example shows how to compare multiple tree-based models using successive halving.</p> <p>Import the california housing dataset from sklearn.datasets. This is a small and easy to train dataset whose goal is to predict house prices.</p>"}, {"location": "examples/successive_halving/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/successive_halving/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/successive_halving/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/train_sizing/", "title": "Train sizing", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport pandas as pd\nfrom atom import ATOMClassifier\n</pre> # Import packages import pandas as pd from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load the data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load the data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[2]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[3]: Copied! <pre># Initialize atom and prepare the data\natom = ATOMClassifier(X, verbose=2, random_state=1)\natom.clean()\natom.impute(strat_num=\"median\", strat_cat=\"most_frequent\", max_nan_rows=0.8)\natom.encode()\n</pre> # Initialize atom and prepare the data atom = ATOMClassifier(X, verbose=2, random_state=1) atom.clean() atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\", max_nan_rows=0.8) atom.encode() <pre>&lt;&lt; ================== ATOM ================== &gt;&gt;\n\nConfiguration ==================== &gt;&gt;\nAlgorithm task: Binary classification.\n\nDataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.03 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n\nFitting Cleaner...\nCleaning the data...\nFitting Imputer...\nImputing missing values...\n --&gt; Dropping 161 samples for containing more than 16 missing values.\n --&gt; Imputing 481 missing values with median (12.0) in column MinTemp.\n --&gt; Imputing 265 missing values with median (22.6) in column MaxTemp.\n --&gt; Imputing 1354 missing values with median (0.0) in column Rainfall.\n --&gt; Imputing 60682 missing values with median (4.8) in column Evaporation.\n --&gt; Imputing 67659 missing values with median (8.4) in column Sunshine.\n --&gt; Imputing 9187 missing values with most_frequent (W) in column WindGustDir.\n --&gt; Imputing 9127 missing values with median (39.0) in column WindGustSpeed.\n --&gt; Imputing 9852 missing values with most_frequent (N) in column WindDir9am.\n --&gt; Imputing 3617 missing values with most_frequent (SE) in column WindDir3pm.\n --&gt; Imputing 1187 missing values with median (13.0) in column WindSpeed9am.\n --&gt; Imputing 2469 missing values with median (19.0) in column WindSpeed3pm.\n --&gt; Imputing 1613 missing values with median (70.0) in column Humidity9am.\n --&gt; Imputing 3449 missing values with median (52.0) in column Humidity3pm.\n --&gt; Imputing 13863 missing values with median (1017.6) in column Pressure9am.\n --&gt; Imputing 13830 missing values with median (1015.2) in column Pressure3pm.\n --&gt; Imputing 53496 missing values with median (5.0) in column Cloud9am.\n --&gt; Imputing 56933 missing values with median (5.0) in column Cloud3pm.\n --&gt; Imputing 743 missing values with median (16.7) in column Temp9am.\n --&gt; Imputing 2565 missing values with median (21.1) in column Temp3pm.\n --&gt; Imputing 1354 missing values with most_frequent (No) in column RainToday.\nFitting Encoder...\nEncoding categorical columns...\n --&gt; Target-encoding feature Location. Contains 49 classes.\n --&gt; Target-encoding feature WindGustDir. Contains 16 classes.\n --&gt; Target-encoding feature WindDir9am. Contains 16 classes.\n --&gt; Target-encoding feature WindDir3pm. Contains 16 classes.\n --&gt; Ordinal-encoding feature RainToday. Contains 2 classes.\n</pre> In\u00a0[4]: Copied! <pre># Analyze the impact of the training set's size on a LR model\natom.train_sizing(\"LR\", train_sizes=10, n_bootstrap=5)\n</pre> # Analyze the impact of the training set's size on a LR model atom.train_sizing(\"LR\", train_sizes=10, n_bootstrap=5) <pre>\nTraining ========================= &gt;&gt;\nMetric: f1\n\n\nRun: 0 =========================== &gt;&gt;\nModels: LR01\nSize of training set: 11362 (10%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.563\nTest evaluation --&gt; f1: 0.5854\nTime elapsed: 1.181s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5849 \u00b1 0.002\nTime elapsed: 0.910s\n-------------------------------------------------\nTime: 2.091s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 2.109s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5849 \u00b1 0.002\n\n\nRun: 1 =========================== &gt;&gt;\nModels: LR02\nSize of training set: 22724 (20%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.582\nTest evaluation --&gt; f1: 0.5873\nTime elapsed: 1.455s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5852 \u00b1 0.0021\nTime elapsed: 1.120s\n-------------------------------------------------\nTime: 2.575s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 2.598s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5852 \u00b1 0.0021\n\n\nRun: 2 =========================== &gt;&gt;\nModels: LR03\nSize of training set: 34087 (30%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.581\nTest evaluation --&gt; f1: 0.5851\nTime elapsed: 1.702s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5861 \u00b1 0.0009\nTime elapsed: 1.355s\n-------------------------------------------------\nTime: 3.057s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 3.082s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5861 \u00b1 0.0009\n\n\nRun: 3 =========================== &gt;&gt;\nModels: LR04\nSize of training set: 45449 (40%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5827\nTest evaluation --&gt; f1: 0.5869\nTime elapsed: 2.250s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5863 \u00b1 0.0017\nTime elapsed: 1.599s\n-------------------------------------------------\nTime: 3.850s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 3.881s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5863 \u00b1 0.0017\n\n\nRun: 4 =========================== &gt;&gt;\nModels: LR05\nSize of training set: 56812 (50%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5819\nTest evaluation --&gt; f1: 0.585\nTime elapsed: 2.163s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5854 \u00b1 0.0017\nTime elapsed: 1.878s\n-------------------------------------------------\nTime: 4.041s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 4.077s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5854 \u00b1 0.0017\n\n\nRun: 5 =========================== &gt;&gt;\nModels: LR06\nSize of training set: 68174 (60%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5832\nTest evaluation --&gt; f1: 0.5848\nTime elapsed: 2.338s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5849 \u00b1 0.0018\nTime elapsed: 1.899s\n-------------------------------------------------\nTime: 4.237s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 4.279s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5849 \u00b1 0.0018\n\n\nRun: 6 =========================== &gt;&gt;\nModels: LR07\nSize of training set: 79536 (70%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5873\nTest evaluation --&gt; f1: 0.5849\nTime elapsed: 2.427s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5852 \u00b1 0.0012\nTime elapsed: 2.060s\n-------------------------------------------------\nTime: 4.486s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 4.531s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5852 \u00b1 0.0012\n\n\nRun: 7 =========================== &gt;&gt;\nModels: LR08\nSize of training set: 90899 (80%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.589\nTest evaluation --&gt; f1: 0.5837\nTime elapsed: 2.631s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5853 \u00b1 0.0026\nTime elapsed: 2.173s\n-------------------------------------------------\nTime: 4.804s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 4.853s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5853 \u00b1 0.0026\n\n\nRun: 8 =========================== &gt;&gt;\nModels: LR09\nSize of training set: 102261 (90%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5871\nTest evaluation --&gt; f1: 0.5845\nTime elapsed: 2.837s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5846 \u00b1 0.002\nTime elapsed: 2.550s\n-------------------------------------------------\nTime: 5.387s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 5.443s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5846 \u00b1 0.002\n\n\nRun: 9 =========================== &gt;&gt;\nModels: LR10\nSize of training set: 113624 (100%)\nSize of test set: 28408\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f1: 0.5858\nTest evaluation --&gt; f1: 0.5848\nTime elapsed: 4.211s\nBootstrap ---------------------------------------\nEvaluation --&gt; f1: 0.5848 \u00b1 0.0007\nTime elapsed: 2.967s\n-------------------------------------------------\nTime: 7.178s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 7.243s\n-------------------------------------\nLogisticRegression --&gt; f1: 0.5848 \u00b1 0.0007\n</pre> In\u00a0[5]: Copied! <pre># The results are now multi-index, where frac is the fraction\n# of the training set used to fit the model. The model names\n# end with the fraction as well (without the dot)\natom.results\n</pre> # The results are now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the fraction as well (without the dot) atom.results Out[5]: f1_train f1_test time_fit f1_bootstrap time_bootstrap time frac model 0.100000 LR01 0.562100 0.584800 1.181076 0.584922 0.909830 2.090906 0.200000 LR02 0.583200 0.584600 1.455324 0.585234 1.120021 2.575345 0.300000 LR03 0.580000 0.585200 1.702020 0.586118 1.354517 3.056537 0.400000 LR04 0.584500 0.585700 2.250048 0.586348 1.599457 3.849505 0.500000 LR05 0.583300 0.586500 2.163214 0.585384 1.877947 4.041161 0.600000 LR06 0.583100 0.583200 2.338079 0.584891 1.898731 4.236810 0.700000 LR07 0.587800 0.585800 2.426779 0.585235 2.059590 4.486369 0.800000 LR08 0.591600 0.588600 2.630608 0.585269 2.172981 4.803589 0.900000 LR09 0.585600 0.583300 2.836993 0.584633 2.550147 5.387140 1.000000 LR10 0.585800 0.584800 4.211031 0.584836 2.966612 7.177643 In\u00a0[6]: Copied! <pre># Every model can be accessed through its name\natom.lr05.plot_shap_waterfall(show=6)\n</pre> # Every model can be accessed through its name atom.lr05.plot_shap_waterfall(show=6) In\u00a0[7]: Copied! <pre># Plot the train sizing's results\natom.plot_learning_curve()\n</pre> # Plot the train sizing's results atom.plot_learning_curve()"}, {"location": "examples/train_sizing/#example-train-sizing", "title": "Example: Train sizing\u00b6", "text": "<p>This example shows how to asses a model's performance based on the size of the training set.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/train_sizing/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/train_sizing/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/train_sizing/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/univariate_forecast/", "title": "Univariate forecast", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport numpy as np\nfrom sktime.datasets import load_airline\nfrom atom import ATOMForecaster\n</pre> # Import packages import numpy as np from sktime.datasets import load_airline from atom import ATOMForecaster In\u00a0[2]: Copied! <pre># Load the data\ny = load_airline()\n\nprint(y)\n</pre> # Load the data y = load_airline()  print(y) In\u00a0[3]: Copied! <pre>atom = ATOMForecaster(y, verbose=2, random_state=1)\n</pre> atom = ATOMForecaster(y, verbose=2, random_state=1) In\u00a0[4]: Copied! <pre># Since the dataset contains only the target column, atom.X is empty\natom.X\n</pre> # Since the dataset contains only the target column, atom.X is empty atom.X In\u00a0[5]: Copied! <pre># Examine the dataset\natom.plot_series()\n</pre> # Examine the dataset atom.plot_series() In\u00a0[6]: Copied! <pre>atom.plot_qq()\n</pre> atom.plot_qq() In\u00a0[7]: Copied! <pre># ATOM has a number of plots to understand the seasonality of the data\nwith atom.canvas(rows=2, cols=1, sharex=True, vspace=0.01, legend=None):\n    atom.plot_acf()\n    atom.plot_pacf()\n</pre> # ATOM has a number of plots to understand the seasonality of the data with atom.canvas(rows=2, cols=1, sharex=True, vspace=0.01, legend=None):     atom.plot_acf()     atom.plot_pacf() In\u00a0[8]: Copied! <pre>with atom.canvas(rows=2, cols=1, sharex=True, vspace=0.01, legend=None):\n    atom.plot_periodogram()\n    atom.plot_fft()\n</pre> with atom.canvas(rows=2, cols=1, sharex=True, vspace=0.01, legend=None):     atom.plot_periodogram()     atom.plot_fft() In\u00a0[9]: Copied! <pre># It's also possible to compute the seasonality\nsp = atom.get_seasonal_period()\nsp\n</pre> # It's also possible to compute the seasonality sp = atom.get_seasonal_period() sp In\u00a0[10]: Copied! <pre># And use that seasonality\natom.sp = sp\n</pre> # And use that seasonality atom.sp = sp In\u00a0[11]: Copied! <pre># Use the regular data cleaning methods to transform the target column\natom.scale(columns=-1)\n</pre> # Use the regular data cleaning methods to transform the target column atom.scale(columns=-1) In\u00a0[12]: Copied! <pre>atom.y\n</pre> atom.y In\u00a0[13]: Copied! <pre>atom.run([\"AutoARIMA\", \"TBATS\", \"Prophet\"])\n</pre> atom.run([\"AutoARIMA\", \"TBATS\", \"Prophet\"]) In\u00a0[14]: Copied! <pre># It's also possible to use regression models for forecast tasks\natom.run(\"RF\")\n</pre> # It's also possible to use regression models for forecast tasks atom.run(\"RF\") In\u00a0[15]: Copied! <pre>atom.rf.estimator\n</pre> atom.rf.estimator In\u00a0[16]: Copied! <pre>atom.evaluate()\n</pre> atom.evaluate() In\u00a0[17]: Copied! <pre>atom.winner.plot_forecast()\n</pre> atom.winner.plot_forecast() In\u00a0[18]: Copied! <pre>atom.plot_errors()\n</pre> atom.plot_errors()"}, {"location": "examples/univariate_forecast/#example-univariate-forecast", "title": "Example: Univariate forecast\u00b6", "text": "<p>This example shows how to use ATOM to work with a univariate time series dataset.</p> <p>Import the airline dataset from sktime.datasets. This is a small and easy to train dataset that measures monthly totals of international airline passengers from 1949 to 1960.</p>"}, {"location": "examples/univariate_forecast/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/univariate_forecast/#analyze-the-data", "title": "Analyze the data\u00b6", "text": ""}, {"location": "examples/univariate_forecast/#seasonality", "title": "Seasonality\u00b6", "text": ""}, {"location": "examples/univariate_forecast/#run-the-pipeline", "title": "Run the pipeline\u00b6", "text": ""}, {"location": "examples/univariate_forecast/#analyze-the-results", "title": "Analyze the results\u00b6", "text": ""}, {"location": "examples/utilities/", "title": "Utilities", "text": "In\u00a0[1]: Copied! <pre># Import packages\nimport os\nimport tempfile\nimport pandas as pd\nfrom sklearn.metrics import fbeta_score\nfrom atom import ATOMClassifier\n</pre> # Import packages import os import tempfile import pandas as pd from sklearn.metrics import fbeta_score from atom import ATOMClassifier In\u00a0[2]: Copied! <pre># Load data\nX = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")\n\n# Let's have a look\nX.head()\n</pre> # Load data X = pd.read_csv(\"docs_source/examples/datasets/weatherAUS.csv\")  # Let's have a look X.head() Out[2]: Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 <p>5 rows \u00d7 22 columns</p> In\u00a0[3]: Copied! <pre>atom = ATOMClassifier(X, random_state=1)\natom.clean()\n\n# Quickly check what columns have missing values\nprint(f\"Columns with missing values:\\n{atom.nans}\")\n\n# Or what columns are categorical\nprint(f\"\\nCategorical columns: {atom.categorical}\")\n\n# Or if the dataset is scaled\nprint(f\"\\nIs the dataset scaled? {atom.scaled}\")\n</pre> atom = ATOMClassifier(X, random_state=1) atom.clean()  # Quickly check what columns have missing values print(f\"Columns with missing values:\\n{atom.nans}\")  # Or what columns are categorical print(f\"\\nCategorical columns: {atom.categorical}\")  # Or if the dataset is scaled print(f\"\\nIs the dataset scaled? {atom.scaled}\") <pre>Columns with missing values:\nLocation             0\nMinTemp            637\nMaxTemp            322\nRainfall          1406\nEvaporation      60843\nSunshine         67816\nWindGustDir       9330\nWindGustSpeed     9270\nWindDir9am       10013\nWindDir3pm        3778\nWindSpeed9am      1348\nWindSpeed3pm      2630\nHumidity9am       1774\nHumidity3pm       3610\nPressure9am      14014\nPressure3pm      13981\nCloud9am         53657\nCloud3pm         57094\nTemp9am            904\nTemp3pm           2726\nRainToday         1406\nRainTomorrow         0\ndtype: int64\n\nCategorical columns: Index(['Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainToday'], dtype='object')\n\nIs the dataset scaled? False\n</pre> In\u00a0[4]: Copied! <pre># Note the number of missing values and categorical columns\natom.stats()\n</pre> # Note the number of missing values and categorical columns atom.stats() <pre>Dataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 27.44 MB\nScaled: False\nMissing values: 316559 (10.1%)\nCategorical features: 5 (23.8%)\nDuplicates: 45 (0.0%)\n</pre> In\u00a0[5]: Copied! <pre># Now, let's impute and encode the dataset...\natom.impute()\natom.encode()\n\n# ... and the values are gone\natom.stats()\n</pre> # Now, let's impute and encode the dataset... atom.impute() atom.encode()  # ... and the values are gone atom.stats() <pre>Dataset stats ==================== &gt;&gt;\nShape: (142193, 22)\nTrain set size: 113755\nTest set size: 28438\n-------------------------------------\nMemory: 25.74 MB\nScaled: False\nOutlier values: 8731 (0.3%)\nDuplicates: 45 (0.0%)\n</pre> In\u00a0[6]: Copied! <pre># Compare the relationship of multiple columns with a scatter maxtrix\natom.plot_relationships(columns=slice(0, 3))\n</pre> # Compare the relationship of multiple columns with a scatter maxtrix atom.plot_relationships(columns=slice(0, 3)) In\u00a0[7]: Copied! <pre># Check which distribution fits a column best\natom.distributions(columns=slice(0, 3))\n</pre> # Check which distribution fits a column best atom.distributions(columns=slice(0, 3)) Out[7]: Location MinTemp MaxTemp dist stat beta score 0.0711 0.0165 0.0276 p_value 0.0 0.0 0.0 expon score 0.3377 0.354 0.4194 p_value 0.0 0.0 0.0 gamma score 0.0784 0.02 0.0272 p_value 0.0 0.0 0.0 invgauss score 0.0952 0.0409 0.2407 p_value 0.0 0.0 0.0 lognorm score 0.0724 0.0201 0.0272 p_value 0.0 0.0 0.0 norm score 0.0724 0.0198 0.0406 p_value 0.0 0.0 0.0 pearson3 score 0.0647 0.02 0.0272 p_value 0.0 0.0 0.0 triang score 0.0888 0.0841 0.2514 p_value 0.0 0.0 0.0 uniform score 0.1933 0.2127 0.2859 p_value 0.0 0.0 0.0 weibull_min score 0.0695 0.0197 0.0437 p_value 0.0 0.0 0.0 weibull_max score 0.0753 0.0146 0.0245 p_value 0.0 0.0 0.0 In\u00a0[8]: Copied! <pre># Investigate a column's distribution\natom.plot_distribution(columns=\"MinTemp\", distributions=\"beta\")\natom.plot_qq(columns=\"MinTemp\", distributions=\"beta\")\n</pre> # Investigate a column's distribution atom.plot_distribution(columns=\"MinTemp\", distributions=\"beta\") atom.plot_qq(columns=\"MinTemp\", distributions=\"beta\") <p>There are two ways to quickly transform the dataset mid-pipeline. The first way is through the property's <code>@setter</code>. The downside for this approach is that the transformation is not stored in atom's pipeline, so the transformation is not applied on new data. Therefore, we recommend using the second approach, through the add method.</p> In\u00a0[9]: Copied! <pre># Note that we can only replace a dataframe with a new dataframe!\natom.X = atom.X.assign(AvgTemp=(atom.X[\"MaxTemp\"] + atom.X[\"MinTemp\"])/2)\n\n# This will automatically update all other data attributes\nassert \"AvgTemp\" in atom\n\n# But it's not saved to atom's pipeline\natom.pipeline\n</pre> # Note that we can only replace a dataframe with a new dataframe! atom.X = atom.X.assign(AvgTemp=(atom.X[\"MaxTemp\"] + atom.X[\"MinTemp\"])/2)  # This will automatically update all other data attributes assert \"AvgTemp\" in atom  # But it's not saved to atom's pipeline atom.pipeline Out[9]: <pre>Pipeline(memory=Memory(location=None),\n         steps=[('cleaner',\n                 Cleaner(engine={'data': 'pandas', 'estimator': 'sklearn'})),\n                ('imputer',\n                 Imputer(engine={'data': 'pandas', 'estimator': 'sklearn'}, random_state=1)),\n                ('encoder', Encoder())],\n         verbose=False)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0PipelineiFitted<pre>Pipeline(memory=Memory(location=None),\n         steps=[('cleaner',\n                 Cleaner(engine={'data': 'pandas', 'estimator': 'sklearn'})),\n                ('imputer',\n                 Imputer(engine={'data': 'pandas', 'estimator': 'sklearn'}, random_state=1)),\n                ('encoder', Encoder())],\n         verbose=False)</pre> Cleaner<pre>Cleaner()</pre> Imputer<pre>Imputer(random_state=1)</pre> Encoder<pre>Encoder()</pre> In\u00a0[10]: Copied! <pre># Same transformation, different approach (AvgTemp is overwritten)\ndef transform(df):\n    df[\"AvgTemp\"] = (df.MaxTemp + df.MinTemp) / 2\n    return df\n\natom.apply(transform)\n\nassert \"AvgTemp\" in atom\n</pre> # Same transformation, different approach (AvgTemp is overwritten) def transform(df):     df[\"AvgTemp\"] = (df.MaxTemp + df.MinTemp) / 2     return df  atom.apply(transform)  assert \"AvgTemp\" in atom In\u00a0[11]: Copied! <pre># Now the function appears in the pipeline\natom.pipeline\n</pre> # Now the function appears in the pipeline atom.pipeline Out[11]: <pre>Pipeline(memory=Memory(location=None),\n         steps=[('cleaner',\n                 Cleaner(engine={'data': 'pandas', 'estimator': 'sklearn'})),\n                ('imputer',\n                 Imputer(engine={'data': 'pandas', 'estimator': 'sklearn'}, random_state=1)),\n                ('encoder', Encoder()),\n                ('functiontransformer',\n                 FunctionTransformer(func=&lt;function transform at 0x00000225D33CC4A0&gt;))],\n         verbose=False)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0PipelineiFitted<pre>Pipeline(memory=Memory(location=None),\n         steps=[('cleaner',\n                 Cleaner(engine={'data': 'pandas', 'estimator': 'sklearn'})),\n                ('imputer',\n                 Imputer(engine={'data': 'pandas', 'estimator': 'sklearn'}, random_state=1)),\n                ('encoder', Encoder()),\n                ('functiontransformer',\n                 FunctionTransformer(func=&lt;function transform at 0x00000225D33CC4A0&gt;))],\n         verbose=False)</pre> Cleaner<pre>Cleaner()</pre> Imputer<pre>Imputer(random_state=1)</pre> Encoder<pre>Encoder()</pre> \u00a0FunctionTransformer?Documentation for FunctionTransformer<pre>FunctionTransformer(func=&lt;function transform at 0x00000225D33CC4A0&gt;)</pre> In\u00a0[12]: Copied! <pre>atom.available_models()\n</pre> atom.available_models() Out[12]: acronym fullname estimator module handles_missing needs_scaling accepts_sparse native_multilabel native_multioutput validation supports_engines 0 AdaB AdaBoost AdaBoostClassifier sklearn.ensemble._weight_boosting False False True False False None sklearn 1 Bag Bagging BaggingClassifier sklearn.ensemble._bagging True False True False False None sklearn 2 BNB BernoulliNB BernoulliNB sklearn.naive_bayes False False True False False None sklearn, cuml 3 CatB CatBoost CatBoostClassifier catboost.core True True True False False n_estimators catboost 4 CatNB CategoricalNB CategoricalNB sklearn.naive_bayes False False True False False None sklearn, cuml 5 CNB ComplementNB ComplementNB sklearn.naive_bayes False False True False False None sklearn, cuml 6 Tree DecisionTree DecisionTreeClassifier sklearn.tree._classes True False True True True None sklearn 7 Dummy Dummy DummyClassifier sklearn.dummy False False False False False None sklearn 8 ETree ExtraTree ExtraTreeClassifier sklearn.tree._classes False False True True True None sklearn 9 ET ExtraTrees ExtraTreesClassifier sklearn.ensemble._forest False False True True True None sklearn 10 GNB GaussianNB GaussianNB sklearn.naive_bayes False False False False False None sklearn, cuml 11 GP GaussianProcess GaussianProcessClassifier sklearn.gaussian_process._gpc False False False False False None sklearn 12 GBM GradientBoostingMachine GradientBoostingClassifier sklearn.ensemble._gb False False True False False None sklearn 13 hGBM HistGradientBoosting HistGradientBoostingClassifier sklearn.ensemble._hist_gradient_boosting.gradi... True False False False False None sklearn 14 KNN KNearestNeighbors KNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn, sklearnex, cuml 15 LGB LightGBM LGBMClassifier lightgbm.sklearn True True True False False n_estimators lightgbm 16 LDA LinearDiscriminantAnalysis LinearDiscriminantAnalysis sklearn.discriminant_analysis False False False False False None sklearn 17 lSVM LinearSVM LinearSVC sklearn.svm._classes False True True False False None sklearn, cuml 18 LR LogisticRegression LogisticRegression sklearn.linear_model._logistic False True True False False None sklearn, sklearnex, cuml 19 MLP MultiLayerPerceptron MLPClassifier sklearn.neural_network._multilayer_perceptron False True True True False max_iter sklearn 20 MNB MultinomialNB MultinomialNB sklearn.naive_bayes False False True False False None sklearn, cuml 21 PA PassiveAggressive PassiveAggressiveClassifier sklearn.linear_model._passive_aggressive False True True False False max_iter sklearn 22 Perc Perceptron Perceptron sklearn.linear_model._perceptron False True False False False max_iter sklearn 23 QDA QuadraticDiscriminantAnalysis QuadraticDiscriminantAnalysis sklearn.discriminant_analysis False False False False False None sklearn 24 RNN RadiusNearestNeighbors RadiusNeighborsClassifier sklearn.neighbors._classification False True True True True None sklearn 25 RF RandomForest RandomForestClassifier sklearn.ensemble._forest False False True True True None sklearn, sklearnex, cuml 26 Ridge Ridge RidgeClassifier sklearn.linear_model._ridge False True True True False None sklearn, sklearnex, cuml 27 SGD StochasticGradientDescent SGDClassifier sklearn.linear_model._stochastic_gradient False True True False False max_iter sklearn 28 SVM SupportVectorMachine SVC sklearn.svm._classes False True True False False None sklearn, sklearnex, cuml 29 XGB XGBoost XGBClassifier xgboost.sklearn True True True False False n_estimators xgboost In\u00a0[13]: Copied! <pre>atom.verbose = 1\n\n# Define a custom metric\ndef f2(y_true, y_pred):\n    return fbeta_score(y_true, y_pred, beta=2)\n\n# Use the greater_is_better, needs_proba and needs_threshold parameters if necessary\natom.run(models=\"LR\", metric=f2)\n</pre> atom.verbose = 1  # Define a custom metric def f2(y_true, y_pred):     return fbeta_score(y_true, y_pred, beta=2)  # Use the greater_is_better, needs_proba and needs_threshold parameters if necessary atom.run(models=\"LR\", metric=f2) <pre>\nTraining ========================= &gt;&gt;\nModels: LR\nMetric: f2\n\n\nResults for LogisticRegression:\nFit ---------------------------------------------\nTrain evaluation --&gt; f2: 0.5277\nTest evaluation --&gt; f2: 0.5266\nTime elapsed: 4.639s\n-------------------------------------------------\nTime: 4.639s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 4.749s\n-------------------------------------\nLogisticRegression --&gt; f2: 0.5266\n</pre> In\u00a0[14]: Copied! <pre># You can use the est_params parameter to customize the estimator\n# Let's run AdaBoost using LR instead of a decision tree as base estimator\natom.run(\"AdaB\", est_params={\"estimator\": atom.lr.estimator})\n</pre> # You can use the est_params parameter to customize the estimator # Let's run AdaBoost using LR instead of a decision tree as base estimator atom.run(\"AdaB\", est_params={\"estimator\": atom.lr.estimator}) <pre>\nTraining ========================= &gt;&gt;\nModels: AdaB\nMetric: f2\n\n\nResults for AdaBoost:\nFit ---------------------------------------------\nTrain evaluation --&gt; f2: 0.5129\nTest evaluation --&gt; f2: 0.5172\nTime elapsed: 01m:21s\n-------------------------------------------------\nTime: 01m:21s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 01m:22s\n-------------------------------------\nAdaBoost --&gt; f2: 0.5172\n</pre> In\u00a0[15]: Copied! <pre>atom.adab.estimator\n</pre> atom.adab.estimator Out[15]: <pre>AdaBoostClassifier(estimator=LogisticRegression(n_jobs=1, random_state=1),\n                   random_state=1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0AdaBoostClassifier?Documentation for AdaBoostClassifieriFitted<pre>AdaBoostClassifier(estimator=LogisticRegression(n_jobs=1, random_state=1),\n                   random_state=1)</pre> estimator: LogisticRegression<pre>LogisticRegression(n_jobs=1, random_state=1)</pre> \u00a0LogisticRegression?Documentation for LogisticRegression<pre>LogisticRegression(n_jobs=1, random_state=1)</pre> In\u00a0[16]: Copied! <pre># Note that parameters specified by est_params are not optimized in the BO\natom.run(\n    models=\"Tree\",\n    n_trials=10,\n    est_params={\n        \"criterion\": \"gini\",\n        \"splitter\": \"best\",\n        \"min_samples_leaf\": 1,\n        \"ccp_alpha\": 0.035,\n    },\n    verbose=2,\n)\n</pre> # Note that parameters specified by est_params are not optimized in the BO atom.run(     models=\"Tree\",     n_trials=10,     est_params={         \"criterion\": \"gini\",         \"splitter\": \"best\",         \"min_samples_leaf\": 1,         \"ccp_alpha\": 0.035,     },     verbose=2, ) <pre>\nTraining ========================= &gt;&gt;\nModels: Tree\nMetric: f2\n\n\nRunning hyperparameter tuning for DecisionTree...\n| trial | max_depth | min_samples_split | max_features |      f2 | best_f2 | time_trial | time_ht |    state |\n| ----- | --------- | ----------------- | ------------ | ------- | ------- | ---------- | ------- | -------- |\n| 0     |        13 |                12 |          0.5 |  0.4488 |  0.4488 |     9.644s |  9.644s | COMPLETE |\n| 1     |        14 |                16 |         log2 |  0.4762 |  0.4762 |     5.440s | 15.084s | COMPLETE |\n| 2     |        16 |                13 |          0.8 |  0.4798 |  0.4798 |     6.380s | 21.464s | COMPLETE |\n| 3     |         9 |                 6 |         None |  0.5182 |  0.5182 |     6.861s | 28.325s | COMPLETE |\n| 4     |         5 |                 2 |         log2 |  0.4859 |  0.5182 |     5.553s | 33.878s | COMPLETE |\n| 5     |         1 |                15 |          0.5 |  0.4918 |  0.5182 |     5.312s | 39.190s | COMPLETE |\n| 6     |        15 |                 9 |         sqrt |  0.4647 |  0.5182 |     5.292s | 44.482s | COMPLETE |\n| 7     |        13 |                20 |         None |   0.496 |  0.5182 |     6.539s | 51.022s | COMPLETE |\n| 8     |         3 |                19 |          0.5 |  0.5068 |  0.5182 |     5.410s | 56.432s | COMPLETE |\n| 9     |        15 |                20 |         sqrt |  0.4734 |  0.5182 |     6.054s | 01m:02s | COMPLETE |\nHyperparameter tuning ---------------------------\nBest trial --&gt; 3\nBest parameters:\n --&gt; max_depth: 9\n --&gt; min_samples_split: 6\n --&gt; max_features: None\nBest evaluation --&gt; f2: 0.5182\nTime elapsed: 01m:02s\nFit ---------------------------------------------\nTrain evaluation --&gt; f2: 0.4803\nTest evaluation --&gt; f2: 0.4851\nTime elapsed: 2.813s\n-------------------------------------------------\nTime: 01m:05s\n\n\nFinal results ==================== &gt;&gt;\nTotal time: 01m:05s\n-------------------------------------\nDecisionTree --&gt; f2: 0.4851\n</pre> <p>Note that both instances need to be initialized with the same data and use the same metric for model training to be able to merge.</p> In\u00a0[17]: Copied! <pre>tempdir = tempfile.gettempdir()\n</pre> tempdir = tempfile.gettempdir() In\u00a0[18]: Copied! <pre># Save the atom instance as a pickle\n# Use save_data=False to save the instance without the data\natom.save(os.path.join(tempdir, \"atom\"), save_data=False)\n</pre> # Save the atom instance as a pickle # Use save_data=False to save the instance without the data atom.save(os.path.join(tempdir, \"atom\"), save_data=False) <pre>ATOMClassifier successfully saved.\n</pre> In\u00a0[19]: Copied! <pre># No need to store the transformed data, providing the original dataset to\n# the loader automatically transforms it through all the steps in the pipeline\natom_2 = ATOMClassifier.load(os.path.join(tempdir, \"atom\"), data=(X,))\n</pre> # No need to store the transformed data, providing the original dataset to # the loader automatically transforms it through all the steps in the pipeline atom_2 = ATOMClassifier.load(os.path.join(tempdir, \"atom\"), data=(X,)) <pre>ATOMClassifier successfully loaded.\n</pre> In\u00a0[20]: Copied! <pre># Create a separate instance with its own branch and model\natom_3 = ATOMClassifier(X, verbose=0, random_state=1)\natom_3.branch.name = \"lightgbm\"\natom_3.impute()\natom_3.encode()\natom_3.run(\"LGB\", metric=f2)\n</pre> # Create a separate instance with its own branch and model atom_3 = ATOMClassifier(X, verbose=0, random_state=1) atom_3.branch.name = \"lightgbm\" atom_3.impute() atom_3.encode() atom_3.run(\"LGB\", metric=f2) In\u00a0[21]: Copied! <pre># Merge the instances\natom_2.merge(atom_3)\n</pre> # Merge the instances atom_2.merge(atom_3) <pre>Merging instances...\n --&gt; Merging branch lightgbm.\n --&gt; Merging model LGB.\n --&gt; Merging attributes.\n</pre> In\u00a0[22]: Copied! <pre># Note that it now contains both branches and all models\natom_2\n</pre> # Note that it now contains both branches and all models atom_2 Out[22]: <pre>ATOMClassifier\n --&gt; Branches:\n   --&gt; main !\n   --&gt; lightgbm\n --&gt; Models: LR, AdaB, Tree, LGB\n --&gt; Metric: f2</pre> In\u00a0[23]: Copied! <pre>atom_2.evaluate()\n</pre> atom_2.evaluate() Out[23]: accuracy ap ba f1 jaccard mcc precision recall auc LR 0.842100 0.681200 0.718400 0.583900 0.412300 0.502900 0.713200 0.494300 0.863200 AdaB 0.841600 0.675200 0.714300 0.577700 0.406200 0.499100 0.717700 0.483500 0.859200 Tree 0.814500 0.404300 0.688700 0.526800 0.357600 0.421100 0.615100 0.460700 0.688700 LGB 0.858400 0.743000 0.747500 0.633800 0.463900 0.559600 0.753800 0.546700 0.888300"}, {"location": "examples/utilities/#example-utilities", "title": "Example: Utilities\u00b6", "text": "<p>This example shows various useful utilities that can be used to improve atom's pipelines.</p> <p>The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here. The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target <code>RainTomorrow</code>.</p>"}, {"location": "examples/utilities/#load-the-data", "title": "Load the data\u00b6", "text": ""}, {"location": "examples/utilities/#use-the-utility-attributes", "title": "Use the utility attributes\u00b6", "text": ""}, {"location": "examples/utilities/#use-the-stats-method-to-assess-changes-in-the-dataset", "title": "Use the stats method to assess changes in the dataset\u00b6", "text": ""}, {"location": "examples/utilities/#inspect-feature-distributions", "title": "Inspect feature distributions\u00b6", "text": ""}, {"location": "examples/utilities/#change-the-data-mid-pipeline", "title": "Change the data mid-pipeline\u00b6", "text": ""}, {"location": "examples/utilities/#get-an-overview-of-the-available-models", "title": "Get an overview of the available models\u00b6", "text": ""}, {"location": "examples/utilities/#use-a-custom-metric", "title": "Use a custom metric\u00b6", "text": ""}, {"location": "examples/utilities/#customize-the-estimators-parameters", "title": "Customize the estimator's parameters\u00b6", "text": ""}, {"location": "examples/utilities/#save-load", "title": "Save &amp; load\u00b6", "text": ""}, {"location": "user_guide/accelerating/", "title": "Accelerating pipelines", "text": "<p>For very large datasets, ATOM offers various ways to accelerate its pipeline:</p> <ul> <li>Run estimators on GPU</li> <li>Use a faster estimator engine</li> <li>Run processes in parallel</li> </ul> <p>Warning</p> <p>Performance improvements are usually noticeable for datasets larger than ~5M rows. For smaller datasets, using other values than the default can even harm performance!</p>"}, {"location": "user_guide/accelerating/#gpu-acceleration", "title": "GPU acceleration", "text": "<p>Graphics Processing Units (GPUs) can significantly accelerate calculations for preprocessing steps or training machine learning models. Training models involve compute-intensive matrix multiplications and other operations that can take advantage of a GPU's massively parallel architecture. Training on large datasets can take hours to run on a single processor. However, if you offload those tasks to a GPU, you can reduce training time to minutes instead.</p> <p>Running transformers and models in atom using a GPU is as easy as initializing the instance with parameter <code>device=\"gpu\"</code>. The <code>device</code> parameter accepts any string that follows the SYCL_DEVICE_FILTER filter selector. Examples are:</p> <ul> <li>device=\"cpu\" (use CPU)</li> <li>device=\"gpu\" (use default GPU)</li> <li>device=\"gpu:0\" (use first GPU)</li> <li>device=\"gpu:1\" (use second GPU)</li> </ul> <p>Combine GPU acceleration with the cuml and sklearnex estimator engines. The XGBoost, LightGBM and CatBoost models come with their own GPU engine. Setting <code>device=\"gpu\"</code> is sufficient to accelerate them with GPU, regardless of the engine parameter.</p> <p>Warning</p> <p>ATOM does not support multi-GPU training. If there is more than one GPU on the machine and the <code>device</code> parameter does not specify which one to use, the first one is used by default.</p> <p>Example</p> <p></p> <p>Train a model on a GPU yourself using Google Colab. Just click on the badge above and run the notebook! Make sure to choose the GPU runtime type.</p>"}, {"location": "user_guide/accelerating/#estimator-acceleration", "title": "Estimator acceleration", "text": "<p>The estimator engine can be specified through the <code>engine</code> parameter, e.g. <code>engine=\"sklearnex\"</code> or <code>engine={\"data\": \"pyarrow\",\"estimator\": \"sklearnex\"}</code> to combine it with a data engine. ATOM integrates the following estimator engines: sklearn, sklearnex and cuml. Read here how to run the estimators on GPU instead of CPU.</p> <p>Warning</p> <p>Estimators accelerated with sklearnex or cuML sometimes use slightly different hyperparameters than their sklearn counterparts.</p>"}, {"location": "user_guide/accelerating/#sklearn", "title": "sklearn", "text": "<p>This is the default option, which uses the standard estimators from sklearn. Sklearn does not support training on GPU.</p>"}, {"location": "user_guide/accelerating/#sklearnex", "title": "sklearnex", "text": "<p>The Intel\u00ae Extension for Scikit-learn package (or sklearnex, for brevity) accelerates sklearn models and transformers, keeping full conformance with sklearn's API. Sklearnex is a free software AI accelerator that offers a way to make sklearn code 10\u2013100 times faster. The software acceleration is achieved through the use of vector instructions, IA hardware-specific memory optimizations, threading, and optimizations for all upcoming Intel platforms at launch time. See here an example using the sklearnex engine.</p> <p>Warning</p> <p>sklearnex estimators don't support sparse datasets nor multioutput tasks.</p> <p>Tip</p> <p>Intel\u00ae processors provide better performance than other CPUs.</p>"}, {"location": "user_guide/accelerating/#prerequisites", "title": "Prerequisites", "text": "<ul> <li>Operating System:<ul> <li>Linux (Ubuntu, Fedora, etc...)</li> <li>Windows 8.1+</li> <li>macOS (no GPU support)</li> </ul> </li> <li>CPU:<ul> <li>Processor must have x86 architecture.</li> <li>Processor must support at least one of SSE2, AVX, AVX2, AVX512 instruction sets.</li> <li>ARM* architecture is not supported.</li> </ul> </li> <li>GPU:<ul> <li>All Intel\u00ae integrated and discrete GPUs.</li> <li>Intel\u00ae GPU drivers.</li> </ul> </li> <li>Libraries:<ul> <li>sklearnex&gt;=2023.2.1 (automatically installed with atom when the processor has x86 architecture)</li> <li>dpcpp_cpp_rt&gt;=2023.2  (only for GPU acceleration)</li> </ul> </li> </ul>"}, {"location": "user_guide/accelerating/#supported-estimators", "title": "Supported estimators", "text": "<ul> <li>Pruner (only for strategy=\"dbscan\")</li> <li> <p>FeatureSelector (only for strategy=\"pca\" and dense datasets)</p> </li> <li> <p>ElasticNet (only for CPU acceleration)</p> </li> <li>KNearestNeighbors</li> <li>Lasso (only for CPU acceleration)</li> <li>LogisticRegression</li> <li>OrdinaryLeastSquares</li> <li>RandomForest</li> <li>Ridge (only for regression tasks and CPU acceleration)</li> <li>SupportVectorMachine (GPU acceleration only supports classification tasks)</li> </ul>"}, {"location": "user_guide/accelerating/#cuml", "title": "cuML", "text": "<p>cuML is the machine learning library of the RAPIDS project. cuML enables you to run traditional tabular ML tasks on GPUs without going into the details of CUDA programming. For large datasets, these GPU-based implementations can complete 10-50x faster than their CPU equivalents.</p> <p>ATOM uses <code>pandas</code> pandas (which in turn uses <code>numpy</code>) as its data backend. This means that the data must move from CPU to GPU memory before it can be used by a cuML estimator. To avoid this overhead, consider using cudf-pandas, which accelerates pandas' workflows on GPU, with automatic CPU fallback if needed. Remember to load <code>cudf.pandas</code> before importing ATOM.</p> <p>Warning</p> <ul> <li>cuML estimators don't support multioutput tasks.</li> <li>Install cuML using <code>pip install --extra-index-url=https://pypi.nvidia.com   cuml-cu11</code> or <code>pip install --extra-index-url=https://pypi.nvidia.com   cuml-cu12</code> depending on your CUDA version. Read more about RAPIDS'   installation here.</li> </ul> <p>Tip</p> <p>Only transformers and predictors are converted to the requested engine. To use a metric from cuML, insert it directly in the <code>run</code> method:</p> <pre><code>from atom import ATOMClassifier\nfrom cuml.metrics import accuracy_score\nfrom sklearn.datasets import make_classification\n\nX, y = make_classification(n_samples=100, random_state=1)\n\natom = ATOMClassifier(X, y, engine={\"estimator\": \"cuml\"}, verbose=2)\natom.run(\"LR\", metric=accuracy_score)\n</code></pre>"}, {"location": "user_guide/accelerating/#prerequisites_1", "title": "Prerequisites", "text": "<ul> <li>Operating System:<ul> <li>Ubuntu 18.04/20.04 or CentOS 7/8 with gcc/++ 9.0+</li> <li>Windows 10+ with WSL2 (see here a tutorial)</li> </ul> </li> <li>GPU:<ul> <li>NVIDIA Pascal\u2122 or better with compute capability 6.0+</li> </ul> </li> <li>Drivers:<ul> <li>CUDA &amp; NVIDIA Drivers of versions 11.0, 11.2, 11.4 or 11.5</li> </ul> </li> <li>Libraries:<ul> <li>cuML&gt;=24.04</li> </ul> </li> </ul>"}, {"location": "user_guide/accelerating/#supported-estimators_1", "title": "Supported estimators", "text": "<ul> <li>Cleaner</li> <li>Discretizer</li> <li>Imputer (only for strat_num!=\"knn\")</li> <li>Normalizer</li> <li>Pruner (only for strategy=\"dbscan\" and \"hdbscan\")</li> <li>Scaler</li> <li>Vectorizer</li> <li> <p>FeatureSelector (only for strategy=\"pca\")</p> </li> <li> <p>BernoulliNB</p> </li> <li>CategoricalNB</li> <li>ElasticNet</li> <li>GaussianNB</li> <li>KNearestNeighbors</li> <li>Lasso</li> <li>LinearSVM</li> <li>LogisticRegression</li> <li>MultinomialNB</li> <li>OrdinaryLeastSquares</li> <li>RandomForest</li> <li>Ridge (only for regression tasks)</li> <li>SupportVectorMachine</li> </ul>"}, {"location": "user_guide/accelerating/#parallel-execution", "title": "Parallel execution", "text": "<p>Another way to accelerate your pipelines is executing processes in parallel. Use the <code>backend</code> parameter to select one of several parallelization backends.</p> <ul> <li>loky: Used by default, can induce some communication and memory overhead   when exchanging input and output data with the worker Python processes. On   some rare systems (such as Pyiodide), the loky backend may not be available.</li> <li>multiprocessing: Previous process-based backend based on <code>multiprocessing.Pool</code>.   Less robust than loky.</li> <li>threading: Very low-overhead backend but it suffers from the Python Global   Interpreter Lock if the called function relies a lot on Python objects. It's   mostly useful when the execution bottleneck is a compiled extension that   explicitly releases the GIL (for instance a Cython loop wrapped in a \"with nogil\"   block or an expensive call to a library such as numpy).</li> <li>ray: Ray is an open-source unified compute framework that makes it   easy to scale AI and Python workloads. Read more about Ray here. See   here an example use case.</li> <li>dask: Dask is a flexible parallel computing library for analytics.   Read more about Dask here.</li> </ul> <p>The parallelization backend is applied in the following cases:</p> <ul> <li>In every individual estimator that uses parallelization internally.</li> <li>To calculate cross-validated results during hyperparameter tuning.</li> <li>To train multiple models in parallel (when <code>parallel=True</code>).</li> <li>To calculate partial dependencies in plot_partial_dependence.</li> </ul> <p>Note</p> <p>The <code>njobs</code> parameter sets the number of cores for the individual models as well as for parallel training. You won't gain much training two models in parallel with 2 cores, when the models also parallelize computations internally. Instead, use parallel training for models that can't parallelize their training (their constructor doesn't have the <code>n_jobs</code> parameter).</p>"}, {"location": "user_guide/data_cleaning/", "title": "Data cleaning", "text": "<p>More often than not, you'll need to do some data cleaning before fitting your dataset to a model.  Usually, this involves importing different libraries and writing many lines of code. Since ATOM is all about fast exploration  and experimentation, it provides various data cleaning classes to apply the most common transformations fast and easy.</p> <p>Note</p> <ul> <li>All of atom's data cleaning methods automatically adopt the relevant   transformer attributes (<code>n_jobs</code>, <code>verbose</code>, <code>logger</code>, <code>random_state</code>)   from atom. A different choice can be added as parameter to the method   call, e.g., <code>atom.scale(verbose=2)</code>.</li> <li>Like the add method, the data cleaning methods   accept the <code>columns</code> parameter to only transform a subset of the   dataset's features, e.g., <code>atom.scale(columns=[0, 1])</code>. Read   more in the row and column selection section.</li> </ul> <p></p>"}, {"location": "user_guide/data_cleaning/#balancing-the-data", "title": "Balancing the data", "text": "<p>One of the common issues found in datasets that are used for classification is imbalanced classes. Data imbalance usually reflects an unequal distribution of classes within a dataset. For example, in a credit card fraud detection dataset, most of the transactions are non-fraud, and a very few cases are fraud. This leaves us with a very unbalanced ratio of fraud vs non-fraud cases. The Balancer class can oversample the minority class or undersample the majority class using any of the transformers implemented in the imblearn package. It can be  accessed from atom through the balance method.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#standard-data-cleaning", "title": "Standard data cleaning", "text": "<p>There are many data cleaning steps that are useful to perform on any dataset before modeling. These are general rules that apply almost on every use-case and every task. The Cleaner class is a convenient tool to apply such steps. It can be accessed from atom through the clean method. Use the class' parameters to choose which transformations to perform. The available steps are:</p> <ul> <li>Drop columns with specific data types.</li> <li>Strip categorical features from white spaces.</li> <li>Drop duplicate rows.</li> <li>Drop rows with missing values in the target column.</li> <li>Encode the target column.</li> </ul> <p></p>"}, {"location": "user_guide/data_cleaning/#time-series-decomposition", "title": "Time series decomposition", "text": "<p>Time series decomposition involves thinking of a series as a combination of level, trend, seasonality, and noise components, each representing one of the underlying categories of patterns. Decomposing the series is a statistical task that deconstructs the data, leaving some components to model them in isolation.</p> <p>Use the Decomposer class to remove trend and seasonality. It can be accessed from atom through the decompose method.</p> <p>Tip</p> <p>Use the plot_decomposition method to visualize the trend, seasonality and residuals of the time series. This can help to determine if the data follows an additive or multiplicative trend.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#binning-numerical-features", "title": "Binning numerical features", "text": "<p>Discretization (otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes. Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins. The Discretizer class can be used to bin continuous data into intervals. It can be accessed from atom through the discretize method.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#encoding-categorical-features", "title": "Encoding categorical features", "text": "<p>Many datasets contain categorical features. Their variables are typically stored as text values which represent various classes. Some examples include color (\u201cRed\u201d, \u201cYellow\u201d, \u201cBlue\u201d), size (\u201cSmall\u201d, \u201cMedium\u201d, \u201cLarge\u201d) or geographic designations (city or country). Regardless of what the value is used for, the challenge is determining how to use this data in the analysis. The majority of sklearn's models don't support direct manipulation of this kind of data. Use the Encoder class to encode categorical features to numerical values. It can be  accessed from atom through the encode method.</p> <p>There are many strategies to encode categorical columns. The Encoder class applies one strategy or another depending on the number of classes in the column to be encoded. When there are only two, the values are encoded with 0 or 1. When there are more than two, the columns can be encoded using one-hot encoding or any other strategy of the category-encoders package, depending on the value of the <code>max_onehot</code> parameter. One-hot encodes the column making a dummy feature for every class. This approach preserves all the information but increases the size of the dataset considerably, making it often an undesirable strategy for high cardinality features. Other strategies like Target transform the column in place.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#imputing-missing-values", "title": "Imputing missing values", "text": "<p>For various reasons, many real world datasets contain missing values, often encoded as blanks, NaNs or other placeholders. Such datasets, however, are incompatible with ATOM's models, which assume that all values in an array are numerical, and that all have and hold meaning. The Imputer class handles missing values in the dataset by either dropping or imputing the value. It can be accessed from atom through the impute method.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#normalizing-the-feature-set", "title": "Normalizing the feature set", "text": "<p>Use the Normalizer class to transform the feature set to follow a Normal (Gaussian)-like distribution. In general, data must be transformed when using models that assume normality in the residuals. Examples of such models are LogisticRegression, LinearDiscriminantAnalysis and GaussianNB. The class can be accessed from atom through the normalize method.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#handling-outliers", "title": "Handling outliers", "text": "<p>When modeling, it is important to clean the data sample to ensure that the observations best represent the problem. Sometimes a dataset can contain extreme values that are outside the range of what is expected and unlike the other data. These are called outliers. Often, machine learning modeling and model skill in general can be improved by understanding and even removing these outlier samples. The Pruner class offers 7 different strategies to detect outliers (described hereunder). It can be accessed from atom through the prune method.</p> <p>z-score The z-score of a value in the dataset is defined as the number of standard deviations by which the value is above or below the mean of the column. Values above or below a certain threshold (specified with the parameter <code>max_sigma</code>) are considered outliers. Note that, contrary to the rest of the strategies, this approach selects outlier values, not outlier samples! Because of this, it is possible to replace the outlier value instead of dropping the entire sample.</p> <p>Isolation Forest Uses a tree-based anomaly detection algorithm. It is based on modeling the normal data in such a way as to isolate anomalies that are both few and different in the feature space. Read more in sklearn's documentation.</p> <p>Elliptic Envelope If the input variables have a Gaussian distribution, then simple statistical methods can be used to detect outliers. For example, if the dataset has two input variables and both are Gaussian, the feature space forms a multidimensional Gaussian, and knowledge of this distribution can be used to identify values far from the distribution. This approach can be generalized by defining a hypersphere (ellipsoid) that covers the normal data, and data that falls outside this shape is considered an outlier. Read more in sklearn's documentation.</p> <p>Local Outlier Factor A simple approach to identifying outliers is to locate those examples that are far from the other examples in the feature space. This can work well for feature spaces with low dimensionality (few features) but becomes less reliable as the number of features is increased. The local outlier factor is a technique that attempts to harness the idea of nearest neighbors for outlier detection. Each example is assigned a score of how isolated or how likely it is to be outliers based on the size of its local neighborhood. Those examples with the largest score are more likely to be outliers. Read more in sklearn's documentation.</p> <p>One-class SVM The support vector machine algorithm, initially developed for binary classification tasks, can also be used for one-class classification. When modeling one class, the algorithm captures the density of the majority class and classifies examples on the extremes of the density function as outliers. This modification of SVM is referred to as One-Class SVM. Read more in sklearn's documentation.</p> <p>DBSCAN The DBSCAN algorithm views clusters as areas of high density separated by areas of low density. Due to this rather generic view, clusters found by DBSCAN can be any shape, as opposed to k-means which assumes that clusters are convex shaped. Samples that lie outside any cluster are considered outliers. Read more in sklearn's documentation.</p> <p>OPTICS The OPTICS algorithm shares many similarities with the DBSCAN algorithm, and can be considered a generalization of DBSCAN that relaxes the <code>eps</code> requirement from a single value to a value range. The key difference between DBSCAN and OPTICS is that the OPTICS algorithm builds a reachability graph, and a spot within the cluster ordering. These two attributes are assigned when the model is fitted, and are used to determine cluster membership. Read more in sklearn's documentation.</p> <p></p>"}, {"location": "user_guide/data_cleaning/#scaling-the-feature-set", "title": "Scaling the feature set", "text": "<p>Standardization of a dataset is a common requirement for many machine learning estimators; they might behave badly if the individual features do not more or less look like standard normally distributed data (e.g. Gaussian with zero mean and unit variance). The Scaler class let you quickly scale atom's dataset using one of sklearn's scalers. It can be accessed from atom through the scale method.</p> <p>Info</p> <p>All strategies can utilize GPU speed-up. Click here for further information about GPU acceleration.</p>"}, {"location": "user_guide/data_management/", "title": "Data management", "text": ""}, {"location": "user_guide/data_management/#data-sets", "title": "Data sets", "text": "<p>ATOM is designed to work around one single dataset: the one with which atom is initialized. This is the dataset you want to explore, transform, and use for model training and validation. ATOM differentiates three different data sets:</p> <ul> <li>The training set is usually the largest of the data sets. As the   name suggests, this set is used to train the pipeline. During   hyperparameter tuning, only the training set is used to fit and   evaluate the estimator in every call. The training set in the current   branch can be accessed through the <code>train</code> attribute. It's   features and target can be accessed through <code>X_train</code> and <code>y_train</code>   respectively.</li> <li>The test set is used to evaluate the models. The model scores on   this set give an indication on how the model performs on new data. The   test set can be accessed through the <code>test</code> attribute. It's features   and target can be accessed through <code>X_test</code> and <code>y_test</code> respectively.</li> <li>The holdout set is an optional, separate set that should only be   used to evaluate the final model's performance. Create this set when   you are going to use the test set for an intermediate validation step.   The holdout set is immediately set apart during initialization and is   not considered part of atom's dataset (the <code>dataset</code> attribute only   returns the train and test sets). The holdout set is left untouched   until predictions are made on it, i.e., it does not undergo any pipeline   transformations until the data set is requested for the first time.   The holdout set is stored in atom's <code>holdout</code> attribute. See   herean example that shows how to use the holdout   data set.</li> </ul> <p>The data can be provided in different formats. If the data sets are not specified beforehand, you can input the features and target separately or together:</p> <ul> <li>X</li> <li>X, y</li> </ul> <p>Remember to use the <code>y</code> parameter to indicate the target column in <code>X</code> when using the first option. If not specified, the last column in <code>X</code> is used as the target. In both these cases, the sizes of the sets are defined using the <code>test_size</code> and <code>holdout_size</code> parameters. Note that the splits are made after the subsample of the dataset with the <code>n_rows</code> parameter (when not left to its default value).</p> <p>If you already have the separate data sets, provide them using one of the following formats:</p> <ul> <li>train, test</li> <li>train, test, holdout</li> <li>X_train, X_test, y_train, y_test</li> <li>X_train, X_test, X_holdout, y_train, y_test, y_holdout</li> <li>(X_train, y_train), (X_test, y_test)</li> <li>(X_train, y_train), (X_test, y_test), (X_holdout, y_holdout)</li> </ul> <p>The input data is always converted internally to a dataframe if it isn't one already. The column names should always be strings. If they are not, atom changes their type at initialization. If no column names are provided, default names are given of the form <code>X[N-1]</code>, where N stands for the n-th feature in the dataset.</p> <p></p>"}, {"location": "user_guide/data_management/#indexing", "title": "Indexing", "text": "<p>By default, atom resets the dataframe's index after initialization and after every transformation in the pipeline. To avoid this, specify the <code>index</code> parameter. If the dataset has an 'identifier' column, it is useful to use it as index for two reasons:</p> <ul> <li>An identifier doesn't usually contain any useful information   on the target column, and should therefore be removed before training.</li> <li>Predictions of specific rows can be accessed through their index.</li> </ul> <p>Warning</p> <p>Avoid duplicate indices in the dataframe. Having them raises an error when initializing atom and may potentially lead to unexpected behavior if introduced later.</p> <p></p>"}, {"location": "user_guide/data_management/#sparse-datasets", "title": "Sparse datasets", "text": "<p>If atom is initialized using a scipy sparse matrix, it is converted internally to a dataframe of sparse columns. Read more about pandas' sparse data structures here. The same conversion takes place when a transformer returns a sparse matrix, like for example, the Vectorizer.</p> <p>ATOM considers a dataset to be sparse if any of its columns is sparse. A dataset can only benefit from sparsity when all its columns are sparse, hence mixing sparse and non-sparse columns is not recommended and can cause estimators to decrease their training speed or even crash. Use the shrink method to convert dense features to sparse and the available_models method to check which models have native support for sparse matrices.</p> <p>Click here to see an example that uses sparse data.</p> <p>Warning</p> <p>Estimators accelerated using sklearnex don't support sparse datasets.</p> <p></p>"}, {"location": "user_guide/data_management/#metadata", "title": "Metadata", "text": "<p>Metadata is data that an estimator, scorer, or CV splitter takes into account if the user explicitly passes it as a parameter (besides <code>X</code> and <code>y</code>). ATOM offers native integration with sklearn's metadata routing system. Use the <code>metadata</code> parameter to pass metadata to atom. This metadata is then automatically propagated to all relevant estimators, scorers, and CV splitters. The parameter accepts a dictionary with keys 'groups' and/or 'sample_weight'. See the metadata example for a quick tutorial.</p> <p>groups</p> <p>Groups are used primarily in cross-validation techniques that need to account for grouped data. The <code>groups</code> parameter is particularly important in situations where the data is not independent, such as when there are multiple measurements from the same subject or when the data is organized in clusters that should not be split across different folds.</p> <p>Warning</p> <ul> <li>Groups are unavailable for forecast tasks.</li> <li>A group can only be present in one data set, thus a group   present in the training set is not validated upon, and a group present   in the test set is not used for training. It's highly recommended to use   a model's cross_validate method to validate   on all groups and so avoid potential biases.</li> </ul> <p>sample_weight</p> <p>Sample weights are numerical values assigned to individual data points in a dataset. They indicate the relative importance or frequency of each data point. Sample weights are used to:</p> <ul> <li>Handle imbalanced datasets: In classification problems, certain classes may be   underrepresented. Sample weights can give more importance to these minority   classes during model training.</li> <li>Correct for sampling bias: If the data collected does not represent the population   well, weights can adjust the influence of different samples to better reflect the   actual distribution.</li> <li>Emphasize certain samples: In cases where some samples are more reliable or   significant than others, weights can be used to give more prominence to these   samples in the analysis.</li> <li>Aggregation and averaging: When computing statistics, weighted averages can be   calculated to account for the varying importance of samples.</li> </ul> <p></p>"}, {"location": "user_guide/data_management/#multioutput-tasks", "title": "Multioutput tasks", "text": "<p>Multioutput is a task where there are more than one target column, i.e., the goal is to predict multiple targets at the same time. When providing a dataframe as target, use the y parameter. Providing <code>y</code> without keyword makes ATOM think you are providing <code>train, test</code> (see the data sets section).</p>"}, {"location": "user_guide/data_management/#task-types", "title": "Task types", "text": "<p>ATOM recognizes four multioutput tasks.</p> <p>Note</p> <p>Combinations of binary and multiclass target columns are treated as multiclass-multioutput tasks.</p>"}, {"location": "user_guide/data_management/#multilabel", "title": "Multilabel", "text": "<p>Multilabel is a classification task, labeling each sample with <code>m</code> labels from <code>n_classes</code> possible classes, where <code>m</code> can be 0 to <code>n_classes</code> inclusive. This can be thought of as predicting properties of a sample that are not mutually exclusive.</p> <p>For example, prediction of the topics relevant to a text document. The document may be about one of religion, politics, finance or education, several of the topic classes or all of the topic classes. The target column (<code>atom.y</code>) could look like this:</p> <pre><code>0                        [politics]\n1               [religion, finance]\n2    [politics, finance, education]\n3                                []\n4                         [finance]\n5               [finance, religion]\n6                         [finance]\n7               [religion, finance]\n8                       [education]\n9     [finance, religion, politics]\n\nName: target, dtype: object\n</code></pre> <p>A model can not directly ingest a variable amount of target classes. Use the clean method to assign a binary output to each class, for every sample. Positive classes are indicated with 1 and negative classes with 0. It is thus comparable to running n_classes binary classification tasks. In our example, the target (<code>atom.y</code>) is converted to:</p> <pre><code>   education  finance  politics  religion\n0          0        0         1         0\n1          0        1         0         1\n2          1        1         1         0\n3          0        0         0         0\n4          0        1         0         0\n5          0        1         0         1\n6          0        1         0         0\n7          0        1         0         1\n8          1        0         0         0\n9          0        1         1         1\n</code></pre>"}, {"location": "user_guide/data_management/#multiclass-multioutput", "title": "Multiclass-multioutput", "text": "<p>Multiclass-multioutput (also known as multitask classification) is a classification task which labels each sample with a set of non-binary properties. Both the number of properties and the number of classes per property is greater than 2. A single estimator thus handles several joint classification tasks. This is both a generalization of the multilabel classification task, which only considers binary attributes, as well as a generalization of the multiclass classification task, where only one property is considered.</p> <p>For example, classification of the properties \"type of fruit\" and \"colour\" for a set of images of fruit. The property \"type of fruit\" has the possible classes: \"apple\", \"pear\" and \"orange\". The property \"colour\" has the possible classes: \"green\", \"red\", \"yellow\" and \"orange\". Each sample is an image of a fruit, a label is output for both properties and each label is one of the possible classes of the corresponding property.</p>"}, {"location": "user_guide/data_management/#multioutput-regression", "title": "Multioutput regression", "text": "<p>Multioutput regression predicts multiple numerical properties for each sample. Each property is a numerical variable and the number of properties to be predicted for each sample is &gt;= 2. Some estimators that support multioutput regression are faster than just running n_output estimators.</p> <p>For example, prediction of both wind speed and wind direction, in degrees, using data obtained at a certain location. Each sample would be data obtained at one location and both wind speed and direction would be output for each sample.</p>"}, {"location": "user_guide/data_management/#multivariate", "title": "Multivariate", "text": "<p>Multivariate is the multioutput task for forecasting. In this case, we try to forecast more than one time series at the same time.</p> <p>Although all forecasting models in ATOM support multioutput tasks (thus have the <code>native multioutput=True</code> flag), we still differentiate two types of models:</p> <ul> <li>The \"genuine multioutput\" models apply forecasts where every prediction   of endogenous (<code>y</code>) variables will depend on values of the other target   columns.</li> <li>The rest of the models apply an estimator per column, meaning that forecasts   will be made per endogenous variable, and not be affected by other variables.   To access the column-wise estimators, use the estimator's <code>forecasters_</code>   parameter, which stores the fitted forecasters in a dataframe.</li> </ul> <p>Tip</p> <p>Use sktime's <code>get_tags()</code> method to check if an estimator is \"genuine multioutput\", e.g. <code>atom.tbats.estimator.get_tags()</code>. Search for the <code>scitype:y</code> key in the response. If the value is 'univariate', the estimator is genuine multioutput, and if 'multivariate', it isn't.</p> <p>Read more about time series tasks here.</p>"}, {"location": "user_guide/data_management/#native-multioutput-models", "title": "Native multioutput models", "text": "<p>Some models have native support for multioutput tasks. This means that the original estimator is used to make predictions directly on all the target columns. Read in the model selection section how to get an overview of all models and their tags, including the <code>native_multioutput</code>.</p>"}, {"location": "user_guide/data_management/#non-native-multioutput-models", "title": "Non-native multioutput models", "text": "<p>The majority of the models don't have integrated support for multioutput tasks. However, it's possible to still use them for such tasks, wrapping them in a meta-estimator capable of handling multiple target columns. For non-native multioutput models, ATOM does so automatically. For multilabel tasks, the meta-estimator is:</p> <ul> <li>ClassifierChain</li> </ul> <p>And for multiclass-multioutput and multioutput regression, the meta-estimators are respectively:</p> <ul> <li>MultioutputClassifier</li> <li>MultioutputRegressor</li> </ul> <p>Warning</p> <p>Currently, scikit-learn metrics do not support multiclass-multioutput classification tasks. In this case, ATOM calculates the mean of the selected metric over every target.</p> <p>Tip</p> <ul> <li>Set the <code>native_multilabel</code> or <code>native_multioutput</code> parameter in ATOMModel equal to <code>True</code> to ignore the meta-estimator for custom models.</li> <li>Check out the multilabel classification and multioutput regression examples.</li> </ul> <p></p>"}, {"location": "user_guide/data_management/#branches", "title": "Branches", "text": "<p>You might want to compare how a model performs on a dataset transformed through multiple pipelines, each using different transformers. For example, on one pipeline with an undersampling strategy and the other with an oversampling strategy. To be able to do this, ATOM has a branching system.</p> <p>The branching system helps the user to manage multiple data pipelines within the same atom instance. Branches are created and accessed through atom's <code>branch</code> property. A branch contains a specific pipeline, the dataset transformed through that pipeline, and all data and utility attributes that refer to that dataset. Transformers and models called from atom use the dataset in the current branch, as well as data attributes such as <code>atom.dataset</code>. It's not allowed to change the data in a branch after fitting a model with it. Instead, create a new branch for every unique pipeline.</p> <p>By default, atom starts with one branch called \"main\". To start a new branch, set a new name to the property, e.g., <code>atom.branch = \"undersample\"</code>. This creates a new branch from the current one. To create a branch from any other branch type \"_from_\" between the new name and the branch from which to split, e.g., <code>atom.branch = \"oversample_from_main\"</code> creates branch \"oversample\" from branch \"main\", even if the current branch is \"undersample\". To switch between existing branches, just type the name of the desired branch, e.g., <code>atom.branch = \"main\"</code> brings you back to the main branch. Note that every branch contains a unique copy of the whole dataset! Creating many branches can cause memory issues for large datasets.</p> <p>See the Imbalanced datasets or Feature engineering examples for branching use cases.</p> <p>Warning</p> <p>Always create a new branch if you want to change the dataset after fitting a model! Forcing a data change through the data property's <code>@setter</code> can cause unexpected model behavior and break down the plotting methods.</p> <p></p> <p> </p> Figure 1. Diagram of a possible branch system to compare an oversampling with an undersampling pipeline. <p></p>"}, {"location": "user_guide/data_management/#memory-considerations", "title": "Memory considerations", "text": "<p>An atom instance stores one copy of the dataset for each branch (this doesn't include the holdout set, which is only stored once), and one copy of the initial dataset with which the instance is initialized. This copy of the original dataset is necessary to avoid data leakage during hyperparameter tuning and for some specific methods like cross_validate and reset. It's created as soon as there are no branches in the initial state (usually after calling the first data transformation). If the dataset is occupying too much memory, consider using the shrink method to convert the dtypes to their smallest possible matching dtype.</p> <p>When working with large datasets and multiple branches, it becomes impossible to store all branches in memory at the same time. To avoid out-of-memory errors, use atom's <code>memory</code> parameter. If not <code>False</code>, atom saves the data of inactive branches as well as the original branch at the specified location (in a directory called <code>joblib</code>, the name of the underlying library managing the caching), maintaining only the current active branch in memory. This mechanism results in a slight drop in performance because of the I/O overhead, but can save a lot of memory. Additionally, the memory's location is also used to cache the output of the <code>fit</code> and <code>transform</code> methods of steps in the pipeline. See here an example using the memory parameter.</p> <p>Apart from the dataset itself, a model's metric scores and shap values are also stored as attributes of the model to avoid having to recalculate them every time they are needed. You can delete all these attributes using the clear method in order to free some memory before saving atom.</p> <p></p>"}, {"location": "user_guide/data_management/#data-transformations", "title": "Data transformations", "text": "<p>Performing data transformations is a common requirement of many datasets before they are ready to be ingested by a model. ATOM provides various classes to apply data cleaning and feature engineering transformations to the data. This tooling should be able to help you apply most of the typically needed transformations to get the data ready for modeling. For further fine-tuning, it's also possible to transform the data using custom transformers (see the add method) or through a function (see the apply method). Remember that all transformations are only applied to the dataset in the current branch.</p> <p></p>"}, {"location": "user_guide/data_management/#row-and-column-selection", "title": "Row and column selection", "text": "<p>Many methods in atom contain the <code>rows</code> or <code>columns</code> parameter to select a subset of the dataset. Examples are the evaluate and save_data methods for <code>rows</code>, and the distributions and shrink methods for <code>columns</code>. All data cleaning and feature engineering methods use the <code>columns</code> parameter to apply the transformation only to that selection of columns, and all prediction methods use the <code>rows</code> parameter to make predictions on that selection of rows.</p> <p>As you can see, these two parameters are very important and shared across many methods in atom. Rows and columns can be selected in multiple ways. The check is performed in the order described hereunder:</p> <ol> <li>By actual dataset, e.g., <code>rows=atom.test</code> is equal to <code>rows=\"test\"</code>.</li> <li>By range or slice, e.g., <code>rows=range(100)</code> to select the first 100    rows from the dataset or <code>rows=slice(20, 100)</code> to select rows 20 to 99.</li> <li>By exact name, e.g., <code>rows=[\"row1\", \"row2\"]</code> to select rows with    indices <code>row1</code> and <code>row2</code> or <code>columns=[\"col1\", \"col2\"]</code> to select    columns <code>col1</code> and <code>col2</code>. It's also possible to use the <code>+</code> sign to select    multiple rows or columns, e.g., <code>columns=\"col1+col2</code> is the same    as <code>columns=[\"col1\", \"col2\"]</code>.</li> <li>By position, e.g., <code>rows=[0, 1, 2]</code> to select the first three rows.</li> <li>By name of the data set (only for rows), e.g., <code>rows=\"train\"</code> to    select all rows in the training set, or <code>rows=\"test+holdout\"</code> to    select all rows in the test and holdout sets. Valid data sets are <code>dataset</code>,    <code>train</code>, <code>test</code> and <code>holdout</code>.</li> <li>By dtype (only for columns), e.g., <code>columns=\"number\"</code> to select only    numerical columns. See pandas' user guide.</li> <li>By regex match, e.g., <code>columns=\"mean_.*\"</code> to select all columns    starting with <code>mean_</code>.</li> <li>Excluding instead of including using the <code>!</code> sign, e.g. <code>columns=\"!col1\"</code>    to select all columns except <code>col1</code>. You can also exclude multiple rows or    columns like this <code>columns=[\"!col1\", \"!col2\"]</code> or this    <code>columns=\"!col1+!col2\"</code>. It's also possible to exclude data sets    for row selection, e.g., <code>columns=\"!train\"</code> or dtypes for column    selection, e.g., <code>columns=\"!number\"</code>. Note that if a column name    starts with <code>!</code>, the selection of that name will take priority over exclusion.    Rows and columns can only be included or excluded, and not both at the same    time. For example, this selection raises an exception <code>column=[\"col1\", \"!col2\"]</code>.</li> </ol> <p>Additionally, the forecast horizon (parameter <code>fh</code>) in forecasting tasks can be selected much in the same way as <code>rows</code>, where the horizon is inferred as the index of the row selection. Note that, contrary to sktime's API but for consistency with the rest of ATOM's API, atom's fh starts with the training set, i.e., selecting <code>atom.nf.predict(fh=range(5))</code> forecasts the first 5 rows of the training set, not the test set. To get the same result as sktime, use a ForecastingHorizon object, e.g., <code>atom.nf.predict(fh=ForecastingHorizon(range(5)))</code>.</p> <p>Info</p> <p>In some plotting methods, it's possible to plot separate lines for different subsets of the rows. For example, to compare the results on the train and test set. For these cases, either provide a sequence to the <code>rows</code> parameter for every line you want to draw, e.g., <code>atom.plot_roc(rows=(\"train\", \"test\"))</code>, or provide a dictionary where the keys are the names of the sets (used in the legend) and the values are the corresponding selection of rows, selected using any of the aforementioned approaches, e.g, <code>atom.plot_roc(rows={\"0-99\": range(100), \"100-199\": range(100, 200})</code>. Note that for these methods, using <code>atom.plot_roc(rows=\"train+test\")</code>, only plots one line with the data from both sets. See the advanced plotting example.</p> <p></p>"}, {"location": "user_guide/data_management/#data-engines", "title": "Data engines", "text": "<p>ATOM is mostly built around sklearn (and sktime for time series tasks), and both these libraries use numpy as their computation backend. Since <code>atom</code> relies heavily on column names, it uses pandas (which in turn uses numpy) as its data backend. However, for the convenience of the user, it implements several data engines, that wraps the data in a different type when called by the user. This is very similar to sklearn's set_output behaviour, but ATOM extends this to many more data types. For example, selecting the <code>polars</code> data engine, makes <code>atom.dataset</code> return a polars dataframe and <code>atom.winner.predict(X)</code> return a polars series. See here an example notebook.</p> <p>The data engine can be specified through the <code>engine</code> parameter, e.g. <code>engine=\"pyarrow\"</code> or <code>engine={\"data\": \"pyarrow\",\"estimator\": \"sklearnex\"}</code> to combine it with an [estimator engine][estimator acceleration]. ATOM integrates the following data engines:</p> <ul> <li>numpy: Transform the data to a <code>numpy</code> array.</li> <li>pandas: Leave the dataset as a <code>pandas</code> object. This is the default   engine, that leaves the data unchanged.</li> <li>pandas-pyarrow: Transform the data to <code>pandas</code> with the <code>pyarrow</code>   backend. Read more in pandas' user guide.</li> <li>polars: The polars library is a blazingly fast dataframe library   implemented in Rust and based on Apache Arrow. Transforms the data to a polars   dataframe or series.</li> <li>polars-lazy: This engine is similar to the <code>polars</code> engine, but it returns   a pl.LazyFrame instead of a pl.pd.DataFrame.</li> <li>pyarrow: PyArrow is a cross-language, platform-independent, in-memory data   format, that provides an efficient and fast way to serialize and deserialize data.   the data is transformed to a pa.Table or pa.Array.</li> <li>modin: The modin library is a multi-threading, drop-in replacement   for pandas, that uses Ray as backend. Transform the data to a modin dataframe   or series.</li> <li>dask: The dask library is a powerful Python library for parallel and   distributed computing. Transform the data to a dask dataframe or dask series.</li> <li>pyspark: The pyspark library is the Python API for Apache Spark.   Transform the data to a pyspark dataframe or pyspark series.</li> <li>pyspark-pandas: Similar to the <code>pyspark</code> engine, but it returns pyspark objects   with the pandas API.</li> </ul> <p>Note</p> <p>It's important to realize that, within atom, the data is still processed using pandas (with the numpy backend). Only when the data is returned to the user, it is transformed to the selected format.</p>"}, {"location": "user_guide/feature_engineering/", "title": "Feature engineering", "text": "<p>Feature engineering is the process of creating new features from the existing ones, in order to capture relationships with the target column that the first set of features didn't have on their own. This process is very important to improve the performance of machine learning algorithms. Although feature engineering works best when the data scientist applies use-case specific transformations, there are ways to do this in an automated manner, without prior domain knowledge. One of the problems of creating new features without human expert intervention, is that many of the newly created features can be useless, i.e., they do not help the algorithm to make better predictions. Even worse, having useless features can drop your performance. To avoid this, we perform feature selection, a process in which we select the relevant features in the dataset. See the Feature engineering example.</p> <p>Note</p> <ul> <li>All of atom's feature engineering methods automatically adopt the relevant   transformer attributes (<code>n_jobs</code>, <code>verbose</code>, <code>logger</code>, <code>random_state</code>) from   atom. A different choice can be added as parameter to the method call,   e.g., <code>atom.feature_selection(\"pca\", n_features=10, random_state=2)</code>.</li> <li>Like the add method, the feature engineering   methods accept the <code>columns</code> parameter to only transform a subset of the   dataset's features, e.g., <code>atom.feature_selection(\"pca\",n_features=10, columns=slice(5, 15))</code>. Read more in the   row and column selection section.</li> </ul> <p></p>"}, {"location": "user_guide/feature_engineering/#extracting-datetime-features", "title": "Extracting datetime features", "text": "<p>Features that contain dates or timestamps can not be directly ingested by models since they are not strictly numerical. Encoding them as categorical features is not an option since the encoding does not capture the relationship between the different moments in time. The FeatureExtractor class creates new features extracting datetime elements (e.g., day, month, year, hour...) from the columns. It can be accessed from atom through the feature_extraction method. The new features are named equally to the column from which they are extracted, followed by an underscore and the datetime element they create, e.g., <code>x0_day</code> for the day element of <code>x0</code>.</p> <p>Note that many time features have a cyclic pattern, e.g., after Sunday comes Monday. This means that if we would encode the days of the week from 0 to 6, we would lose that relation. A common method used to encode cyclical features is to transform the data into two dimensions using a sine and cosine transformation:</p> \\[ x_{sin} = sin\\left(\\frac{2\\pi * x}{max(x)}\\right) \\] \\[ x_{cos} = cos\\left(\\frac{2\\pi * x}{max(x)}\\right) \\] <p>The resulting features have their names followed by sin or cos, e.g. <code>x0_day_sin</code> and <code>x0_day_cos</code>. The datetime elements that can be encoded in a cyclic fashion are: microsecond, second, minute, hour, weekday, day, day_of_year, month and quarter. Note that decision trees based algorithms build their split rules according to one feature at a time. This means that they will fail to correctly process cyclic features since the sin/cos values are expected to be considered as one single coordinate system.</p> <p>Use the <code>fmt</code> parameter to specify your feature's format in case the column is categorical. The FeatureExtractor class will convert the column to the datetime dtype before extracting the specified features. Click here for an overview of the available formats.</p> <p></p>"}, {"location": "user_guide/feature_engineering/#generating-new-features", "title": "Generating new features", "text": "<p>The FeatureGenerator class creates new non-linear features based on the original feature set. It can be accessed from atom through the feature_generation method. You can choose between two strategies: Deep Feature Synthesis and Genetic Feature Generation.</p> <p>Deep Feature Synthesis Deep feature synthesis (DFS) applies the selected operators on the features in the dataset. For example, if the operator is \"log\", it will create the new feature <code>LOG(old_feature)</code> and if the operator is \"mul\", it will create the new feature <code>old_feature_1 x old_feature_2</code>. The operators can be chosen through the <code>operators</code> parameter. Choose from:</p> <ul> <li>add: Take the sum of two features.</li> <li>sub: Subtract two features from each other.</li> <li>mul: Multiply two features with each other.</li> <li>div: Divide two features with each other.</li> <li>abs: Calculate the absolute value of a feature.</li> <li>srqt: Calculate the square root of a feature.</li> <li>log: Calculate the natural logarithm of a feature.</li> <li>sin: Calculate the sine of a feature.</li> <li>cos: Calculate the cosine of a feature.</li> <li>tan: Calculate the tangent of a feature.</li> </ul> <p>ATOM's implementation of DFS uses the featuretools package.</p> <p></p> <p>Genetic Feature Generation Genetic feature generation (GFG) uses genetic programming, a branch of evolutionary programming, to determine which features are successful and create new ones based on those. Where dfs can be seen as some kind of \"brute force\" for feature engineering, gfg tries to improve its features with every generation of the algorithm. gfg uses the same operators as dfs, but instead of only applying the transformations once, it evolves them further, creating nested structures of combinations of features. The new features are given the name <code>feature_n</code>, where n stands for the n-th feature in the dataset. You can access the genetic feature's fitness and description (how they are calculated) through the <code>genetic_features</code> attribute.</p> <p>ATOM uses the SymbolicTransformer class from the gplearn package for the genetic algorithm. Read more about this implementation here.</p> <p></p>"}, {"location": "user_guide/feature_engineering/#grouping-similar-features", "title": "Grouping similar features", "text": "<p>When your dataset contains many similar features corresponding to a certain natural group or entity, it's possible to replace these features for a handful of them, that should capture the relations of the group, in order to lose as little information as possible. To achieve this, the FeatureGrouper class computes certain statistical properties that describe the group's distribution, like the mean or the median, and replaces the columns with the result of these statistical calculations over every row in the dataset. The goal of this approach is to reduce the number of columns in the dataset, avoiding the curse of dimensionality.</p> <p></p>"}, {"location": "user_guide/feature_engineering/#selecting-useful-features", "title": "Selecting useful features", "text": "<p>The FeatureSelector class provides tooling to select the relevant features from a dataset. It can be accessed from atom through the feature_selection method.</p> <p></p>"}, {"location": "user_guide/feature_engineering/#standard-strategies", "title": "Standard strategies", "text": "<p> Univariate Univariate feature selection works by selecting the best features based on univariate statistical F-test. The test is provided via the <code>solver</code> parameter. It takes any function taking two arrays (X, y), and returning arrays (scores, p-values). Read more in sklearn's documentation.</p> <p></p> <p> Principal Components Analysis Applying PCA reduces the dimensionality of the dataset by maximizing the variance of each dimension. The new features are called <code>pca0</code>, <code>pca1</code>, etc... PCA can be applied in three ways:</p> <ul> <li>If the data is dense (i.e., not sparse), the estimator used is PCA.   Before fitting the transformer, the data is scaled to mean=0 and std=1   if it wasn't already. Read more in sklearn's documentation.</li> <li>If the data is [sparse][sparse datasets] (often the case for term-document   matrices, see Vectorizer), the estimator used is TruncatedSVD.   Read more in sklearn's documentation.</li> <li>If <code>engine</code> is \"sklearnex\" or \"cuml\", the estimator   used is the package's PCA implementation. Sparse data is not supported for   neither engine.</li> </ul> <p></p> <p> Selection from model SFM uses an estimator with <code>feature_importances_</code> or <code>coef_</code> attributes to select the best features in a dataset based on importance weights. The estimator is provided through the <code>solver</code> parameter and can be already fitted. ATOM allows you to use one its predefined models, e.g., <code>solver=\"RF\"</code>. If you didn't call the FeatureSelector through atom, don't forget to indicate the estimator's task adding <code>_class</code> or <code>_reg</code> after the name, e.g., <code>RF_class</code> to use a random forest classifier. Read more in sklearn's documentation.</p> <p></p> <p> Sequential Feature Selection Sequential feature selection adds (forward selection) or removes (backward selection) features to form a feature subset in a greedy fashion. At each stage, this estimator chooses the best feature to add or remove based on the cross-validation score of an estimator. Read more in sklearn's documentation.</p> <p></p> <p> Recursive Feature Elimination Select features by recursively considering smaller and smaller sets of features. First, the estimator is trained on the initial set of features, and the importance of each feature is obtained either through a <code>coef_</code> or through a <code>feature_importances_</code> attribute. Then, the least important features are pruned from current set of features. That procedure is recursively repeated on the pruned set until the desired number of features to select is eventually reached. Note that, since RFE needs to fit the model again every iteration, this method can be fairly slow.</p> <p>RFECV applies the same algorithm as RFE but uses a cross-validated metric (under the scoring parameter, see RFECV) to assess every step's performance. Also, where RFE returns the number of features selected by <code>n_features</code>, RFECV returns the number of features that achieved the optimal score on the specified metric. Note that this is not always equal to the amount specified by <code>n_features</code>. Read more in sklearn's documentation.</p> <p></p>"}, {"location": "user_guide/feature_engineering/#advanced-strategies", "title": "Advanced strategies", "text": "<p>The following strategies are a collection of nature-inspired optimization algorithms that maximize an objective function. If not manually specified, the function calculates the cross-validated score of a model on the data. Use the <code>scoring</code> parameter (not present in description, part of kwargs) to specify the metric to optimize on.</p> <p></p> <p> Particle Swarm Optimization Particle Swarm Optimization (PSO) optimizes a problem by having a population of candidate solutions (particles), and moving them around in the search-space according to simple mathematical formula over the particle's position and velocity. Each particle's movement is influenced by its local best known position, but is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions. Read more here.</p> <p></p> <p> Harris Hawks Optimization Harris Hawks Optimization (HHO) mimics the action and reaction of Hawk's team collaboration hunting in nature and prey escaping to discover the solutions of the single-objective problem. Read more here.</p> <p></p> <p> Grey Wolf Optimization The Grey Wolf Optimizer (GWO) mimics the leadership hierarchy and hunting mechanism of grey wolves in nature. Four types of grey wolves such as alpha, beta, delta, and omega are employed for simulating the leadership hierarchy. In addition, three main steps of hunting, searching for prey, encircling prey, and attacking prey, are implemented to perform optimization. Read more here.</p> <p></p> <p> Dragonfly Optimization The Dragonfly Algorithm (DFO) algorithm originates from static and dynamic swarming behaviours. These two swarming behaviours are very similar to the two main phases of optimization using meta-heuristics: exploration and exploitation. Dragonflies create sub swarms and fly over different areas in a static swarm, which is the main objective of the exploration phase. In the static swarm, however, dragonflies fly in bigger swarms and along one direction, which is favourable in the exploitation phase. Read more here.</p> <p></p> <p> Genetic Optimization Genetic Optimization is a metaheuristic inspired by the process of natural selection that belongs to the larger class of evolutionary algorithms. Genetic algorithms are commonly used to generate high-quality solutions to optimization and search problems by relying on biologically inspired operators such as mutation, crossover and selection. Read more here.</p> <p></p>"}, {"location": "user_guide/feature_engineering/#other-selection-methods", "title": "Other selection methods", "text": "<p>Removing features with low or high variance Variance is the expectation of the squared deviation of a random variable from its mean. Features with low variance have many values repeated, which means the model can't learn much from them. In a similar way, features with very high variance have very few values repeated, which makes it also difficult for a model to learn from this feature.</p> <p>FeatureSelector removes a categorical feature when the maximum number of occurrences for any value is below <code>min_repeated</code> or when the same value is repeated in at least <code>max_repeated</code> fraction of the rows. The default option is to remove a feature if all values in it are either different or exactly the same.</p> <p></p> <p>Removing features with multi-collinearity Two features that are highly correlated are redundant, i.e., two will not contribute more to the model than only one of them. FeatureSelector will drop a feature that has a Pearson correlation coefficient larger than <code>max_correlation</code> with another feature. A correlation of 1 means the two columns are equal. A dataframe of the removed features and their correlation values can be accessed through the <code>collinear</code> attribute.</p>"}, {"location": "user_guide/introduction/", "title": "Introduction", "text": "<p>There is no magic formula in data science that can tell us which type of machine learning estimator in combination with which pipeline will perform best for a given raw dataset. Different models are better suited for different types of data and different types of problems. You can follow some rough guide on how to approach problems with regard to which model to try, but these are incomplete at best.</p> <p>During the exploration phase of a machine learning project, a data scientist tries to find the optimal pipeline for his specific use case. This usually involves applying standard data cleaning steps, creating or selecting useful features, trying out different models, etc. Testing multiple pipelines requires many lines of code, and writing it all in the same notebook often makes it long and cluttered. On the other hand, using multiple notebooks makes it harder to compare the results and to keep an overview. On top of that, refactoring the code for every test can be quite time-consuming. How many times have you conducted the same action to pre-process a raw dataset? How many times have you copy-and-pasted code from an old repository to re-use it in a new use case?</p> <p>Although best practices tell us to start with a simple model and build up to more complicated ones, many data scientists just use the model best known to them in order to avoid the aforementioned problems. This can result in poor performance (because the model is just not the right one for the task) or in inefficient management of time and computing resources (because a simpler/faster model could have achieved a similar performance).</p> <p>ATOM is here to help solve these common issues. The package acts as a wrapper of the whole machine learning pipeline, helping the data scientist to rapidly find a good model for his problem. Avoid endless imports and documentation lookups. Avoid rewriting the same code over and over again. With just a few lines of code, it's now possible to perform basic data cleaning steps, select relevant features and compare the performance of multiple models on a given dataset, providing quick insights on which pipeline performs best for the task at hand.</p> <p>It is important to realize that ATOM is not here to replace all the work a data scientist has to do before getting his model into production. ATOM doesn't spit out production-ready models just by tuning some parameters in its API. After helping you determine the right pipeline, you will most probably need to fine-tune it using use-case specific features and data cleaning steps in order to achieve maximum performance.</p> <p>Example steps taken by ATOM's pipeline:</p> <ol> <li>Data Cleaning<ul> <li>Handle missing values</li> <li>Encode categorical features</li> <li>Detect and remove outliers</li> <li>Balance the training set</li> </ul> </li> <li>Feature engineering<ul> <li>Create new non-linear features</li> <li>Select the most promising features</li> </ul> </li> <li>Train and validate multiple models<ul> <li>Apply hyperparameter tuning</li> <li>Fit the models on the training set</li> <li>Evaluate the results on the test set</li> </ul> </li> <li>Analyze the results<ul> <li>Get the scores on various metrics</li> <li>Make plots to compare the model performances</li> </ul> </li> </ol> <p></p> <p></p> Figure 1. Diagram of a possible pipeline created by ATOM."}, {"location": "user_guide/logging/", "title": "Logging &amp; Tracking", "text": ""}, {"location": "user_guide/logging/#logging", "title": "Logging", "text": "<p>To start logging your experiments, fill the <code>logger</code> parameter with the name or path to store the logging file. If automatic naming is used, the file is saved using the __name__ of the class followed by the timestamp of the logger's creation, e.g. <code>ATOMClassifier_11May21_20h11m03s</code>. The logging file contains method calls, all printed messages to stdout with maximum verbosity, and any exception raised during running. Additionally, the logging entries of external libraries are redirected to the same file handler.</p> <p></p>"}, {"location": "user_guide/logging/#tracking", "title": "Tracking", "text": "<p>ATOM uses MLflow Tracking as a backend API and UI for logging models, parameters, pipelines, data and plots. Start tracking your experiments assigning a name to the <code>experiment</code> parameter. Every model is tracked using a separate run. When no backend is configured, the data is stored locally at <code>./mlruns</code>. To configure the backend, use mlflow.set_tracking_uri in your notebook or IDE before initializing atom. This does not affect the currently active run (if one exists), but takes effect for successive runs. Run <code>mlflow ui</code> on your terminal to open MLflow's Tracking UI and view it at http://localhost:5000.</p> <p>Note</p> <p>When using ATOM on Databricks, the experiment's name should include the complete path to the storage, e.g., <code>/Users/username@domain.com/experiment_name</code>.</p> <p>Example</p> <pre><code>from atom import ATOMClassifier\nfrom sklearn.datasets import load_breast_cancer\n\nX, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\natom = ATOMClassifier(X, y, experiment=\"breast_cancer\")\natom.run(models=[\"LR\", \"RF\", \"LGB\"], n_trials=(0, 0, 10))\n</code></pre> <p></p> <p></p>"}, {"location": "user_guide/logging/#dagshub-integration", "title": "DAGsHub integration", "text": "<p>ATOM has a build-in integration with DAGsHub, a web platform based on open source tools, optimized for data science and oriented towards the open source community. To store your mlflow experiments in a DAGsHub repo, type <code>dagshub:&lt;experiment_name&gt;</code> in the <code>experiment</code> parameter (instead of just the experiment's name). If the repo does not already exist, a new public repo is created.</p> <p>Info</p> <p>If you are logged into your DAGsHub account when initializing atom with a dagshub experiment, a page on your web browser is automatically opened to give access permissions. If not, read here how to set up your DAGsHub credentials.</p> <p>Example</p> <pre><code>from atom import ATOMClassifier\nfrom sklearn.datasets import load_breast_cancer\n\nX, y = load_breast_cancer(return_X_y=True, as_frame=True)\n\natom = ATOMClassifier(X, y, experiment=\"dagshub:breast_cancer\")\natom.run(models=[\"LR\", \"RF\"])\n</code></pre> <p></p> <p></p>"}, {"location": "user_guide/logging/#tracked-elements", "title": "Tracked elements", "text": "<p>Tags The runs are automatically tagged with the model's full name, the branch from which the model was trained, and the time it took to fit the model. Add additional custom tags through the <code>ht_params</code> parameter, e.g., <code>atom.run([\"LR\", \"RF\"], ht_params={\"tags\": {\"tag1\": 1}})</code>.</p> <p>Parameters All parameters used by the estimator at initialization are tracked. Additional parameters passed to the fit method are not tracked.</p> <p>Model The model's estimator is stored as artifact. The estimator has to be compatible with the mlflow.sklearn, module.</p> <p>Hyperparameter tuning If hyperparameter tuning is performed, every trial is tracked as a nested run in the model's main run. This option can be switched off using atom's <code>log_ht</code> attribute, e.g., <code>atom.log_ht = False</code>. The data and pipeline options are never stored within nested runs.</p> <p>Metrics All metric results are tracked, not only during training, but also when the evaluate method is called at a later point. Metrics calculated during in-training validation are also stored.</p> <p>Dataset The train and test sets used to fit and evaluate the model can be stored as <code>.csv</code> files to the run's artifacts. This option can be switched on using atom's <code>log_data</code> attribute, e.g. <code>atom.log_data = True</code>.</p> <p>Pipeline The model's pipeline (returned from the export_pipeline method) can be stored as an artifact. This option can be switched on using atom's <code>log_pipeline</code> attribute, e.g., <code>atom.log_pipeline = True</code>.</p> <p>Plots By default, plots are stored as <code>.html</code> artifacts in all runs corresponding to the models that are showed in the plot. If the <code>filename</code> parameter is specified, they are stored under that name, else the method's name is used. This option can be switched off using atom's <code>log_plots</code> attribute, e.g., <code>atom.log_plots = False</code>.</p>"}, {"location": "user_guide/models/", "title": "Models", "text": ""}, {"location": "user_guide/models/#predefined-models", "title": "Predefined models", "text": "<p>ATOM provides many models for classification and regression tasks that can be used to fit the data in the pipeline. After fitting, a class containing the underlying estimator is attached to atom as an attribute. We refer to these \"subclasses\" as models. Apart from the estimator, the models contain a variety of attributes and methods that can help you understand how the underlying estimator performed. They can be accessed using their acronyms, e.g., <code>atom.LGB</code> to access the LightGBM model. The available models and their corresponding acronyms are:</p> <p>AdaBoost (AdaB)Adaptive Boosting.ARIMA (ARIMA)Autoregressive Integrated Moving Average.AutoARIMA (AutoARIMA)Automatic Autoregressive Integrated Moving Average.AutoETS (AutoETS)ETS model with automatic fitting capabilities.AutomaticRelevanceDetermination (ARD)Automatic Relevance Determination.Bagging (Bag)Bagging model (with decision tree as base estimator).BATS (BATS)BATS forecaster with multiple seasonality.BayesianRidge (BR)Bayesian ridge regression.BernoulliNB (BNB)Bernoulli Naive Bayes.CatBoost (CatB)Cat Boosting Machine.CategoricalNB (CatNB)Categorical Naive Bayes.ComplementNB (CNB)Complement Naive Bayes.Croston (Croston)Croston's method for forecasting.DecisionTree (Tree)Single Decision Tree.Dummy (Dummy)Dummy classifier/regressor.DynamicFactor (DF)Dynamic Factor.ElasticNet (EN)Linear Regression with elasticnet regularization.ETS (ETS)Error-Trend-Seasonality model.ExponentialSmoothing (ES)Holt-Winters Exponential Smoothing forecaster.ExtraTree (ETree)Extremely Randomized Tree.ExtraTrees (ET)Extremely Randomized Trees.GaussianNB (GNB)Gaussian Naive Bayes.GaussianProcess (GP)Gaussian process.GradientBoostingMachine (GBM)Gradient Boosting Machine.HuberRegression (Huber)Huber regressor.HistGradientBoosting (hGBM)Histogram-based Gradient Boosting Machine.KNearestNeighbors (KNN)K-Nearest Neighbors.Lasso (Lasso)Linear Regression with lasso regularization.LeastAngleRegression (Lars)Least Angle Regression.LightGBM (LGB)Light Gradient Boosting Machine.LinearDiscriminantAnalysis (LDA)Linear Discriminant Analysis.LinearSVM (lSVM)Linear Support Vector Machine.LogisticRegression (LR)Logistic Regression.MSTL (MSTL)Multiple Seasonal-Trend decomposition using LOESS.MultiLayerPerceptron (MLP)Multi-layer Perceptron.MultinomialNB (MNB)Multinomial Naive Bayes.NaiveForecaster (NF)Naive Forecaster.OrdinaryLeastSquares (OLS)Linear Regression.OrthogonalMatchingPursuit (OMP)Orthogonal Matching Pursuit.PassiveAggressive (PA)Passive Aggressive.Perceptron (Perc)Linear Perceptron classification.Prophet (Prophet)Prophet forecaster by Facebook.PolynomialTrend (PT)Polynomial Trend forecaster.QuadraticDiscriminantAnalysis (QDA)Quadratic Discriminant Analysis.RadiusNearestNeighbors (RNN)Radius Nearest Neighbors.RandomForest (RF)Random Forest.Ridge (Ridge)Linear least squares with l2 regularization.SARIMAX (SARIMAX)Seasonal Autoregressive Integrated Moving Average.STL (STL)Seasonal-Trend decomposition using LOESS.StochasticGradientDescent (SGD)Stochastic Gradient Descent.SupportVectorMachine (SVM)Support Vector Machine.TBATS (TBATS)TBATS forecaster with multiple seasonality.Theta (Theta)Theta method for forecasting.VAR (VAR)Vector Autoregressive.VARMAX (VARMAX)Vector Autoregressive Moving-Average.XGBoost (XGB)Extreme Gradient Boosting.</p> <p>Warning</p> <p>The model classes cannot be initialized directly by the user! Use them only through atom.</p> <p>Tip</p> <p>The acronyms are case-insensitive, e.g., <code>atom.lgb</code> also calls the LightGBM model.</p> <p></p>"}, {"location": "user_guide/models/#model-selection", "title": "Model selection", "text": "<p>Although ATOM allows running all models for a given task using <code>atom.run(models=None)</code>, it's usually smarter to select only a subset of models. Every model has a series of tags that indicate special characteristics of the model. Use a model's <code>get_tags</code> method to see its tags, or the available_models method to get an overview of all models and their tags. The tags differ per task, but can include:</p> <ul> <li>acronym: Model's acronym (used to call the model).</li> <li>fullname: Name of the model's class.</li> <li>estimator: Name of the model's underlying estimator.</li> <li>module: The estimator's module.</li> <li>handles_missing: Whether the model can handle missing values   without preprocessing. If False, consider using the Imputer class   before training the models.</li> <li>needs_scaling: Whether the model requires feature scaling. If True,   automated feature scaling is applied.</li> <li>accepts_sparse: Whether the model accepts sparse input.</li> <li>uses_exogenous: Whether the model uses exogenous variables.</li> <li>multiple_seasonality: Whether the model can handle more than one   seasonality period.</li> <li>native_multilabel: Whether the model has native support for multilabel tasks.</li> <li>native_multioutput: Whether the model has native support for multioutput tasks.</li> <li>validation: Whether the model has in-training validation.</li> <li>supports_engines: Engines supported by the model.</li> </ul> <p>To filter for specific tags, specify the column name with the desired value in the arguments of <code>available_models</code>, e.g., <code>atom.available_models(accepts_sparse=True)</code> to get all models that accept sparse input or <code>atom.available_models(supports_engines=\"cuml\")</code> to get all models that support the cuML engine.</p> <p></p>"}, {"location": "user_guide/models/#custom-models", "title": "Custom models", "text": "<p>It is also possible to create your own models in ATOM's pipeline. For example, imagine we want to use sklearn's RANSACRegressor estimator (note that is not included in ATOM's predefined models). There are two ways to achieve this:</p> <ul> <li>Using ATOMModel (recommended). With this approach you can pass   the required model characteristics to the pipeline.</li> </ul> <pre><code>from atom import ATOMRegressor, ATOMModel\nfrom sklearn.datasets import load_diabetes\nfrom sklearn.linear_model import RANSACRegressor\n\nransac = ATOMModel(RANSACRegressor, name=\"RANSAC\", needs_scaling=True)\n\nX, y = load_diabetes(return_X_y=True, as_frame=True)\n\natom = ATOMRegressor(X, y)\natom.run(ransac)\n</code></pre> <ul> <li>Using the estimator's class or an instance of the class. This approach   will also call ATOMModel under the hood, but it will leave its   parameters to their default values.</li> </ul> <pre><code>from atom import ATOMRegressor\nfrom sklearn.datasets import load_diabetes\nfrom sklearn.linear_model import RANSACRegressor\n\nX, y = load_diabetes(return_X_y=True, as_frame=True)\n\natom = ATOMRegressor(X, y)\natom.run(RANSACRegressor)\n</code></pre> <p>Additional things to take into account:</p> <ul> <li>Custom models can be accessed through their acronym like any other model, e.g.   <code>atom.ransac</code> in the example above.</li> <li>Custom models are not restricted to sklearn estimators, but they should   follow sklearn's API, i.e., have a fit and predict method.</li> <li>Parameter customization (for the initializer) is only possible for   custom models which provide an estimator that has a <code>set_params()</code> method,   i.e., it's a child class of BaseEstimator.</li> <li>Hyperparameter tuning for custom models is ignored unless appropriate   dimensions are provided through <code>ht_params</code>.</li> </ul> <p></p>"}, {"location": "user_guide/models/#deep-learning", "title": "Deep learning", "text": "<p>Deep learning models can be used through ATOM's custom models as long as they follow sklearn's API. For example, models implemented with the Keras package should use the scikeras wrappers KerasClassifier or KerasRegressor.</p> <p>Many deep learning use cases, for example in computer vision, use datasets with more than 2 dimensions, e.g., image data can have shape (n_samples, length, width, rgb). Luckily, scikeras has a workaround to be able to work with such datasets. Learn with this example how to use ATOM to train and validate a Convolutional Neural Network on an image dataset.</p> <p>Warning</p> <p>Models implemented with keras can only use custom hyperparameter tuning when <code>n_jobs=1</code> or <code>ht_params={\"cv\": 1}</code>. Using n_jobs &gt; 1 and cv &gt; 1 raises a PicklingError due to incompatibilities of the APIs.</p> <p></p>"}, {"location": "user_guide/models/#ensembles", "title": "Ensembles", "text": "<p>Ensemble models use multiple estimators to obtain better predictive performance than could be obtained from any of the constituent learning algorithms alone. ATOM implements two ensemble techniques: voting and stacking. Click here to see an example that uses ensemble models.</p> <p>If the ensemble's underlying estimator is a model that used automated feature scaling, it's added as a Pipeline containing the [<code>Scaler</code>][<code>scaler</code>] and estimator. If a mlflow experiment is active, the ensembles start their own run, just like the predefined models do.</p> <p>Warning</p> <p>Combining models trained on different branches into one ensemble is not allowed and will raise an exception.</p>"}, {"location": "user_guide/models/#voting", "title": "Voting", "text": "<p>The idea behind voting is to combine the predictions of conceptually different models to make new predictions. Such a technique can be useful for a set of equally well performing models in order to balance out their individual weaknesses. Read more in sklearn's documentation.</p> <p>A voting model is created from a trainer through the voting method. The voting model is added automatically to the list of models in the trainer, under the <code>Vote</code> acronym. The underlying estimator is a custom adaptation of VotingClassifier or VotingRegressor depending on the task. The differences between ATOM's and sklearn's implementation are:</p> <ul> <li>ATOM's implementation doesn't fit estimators if they're already fitted.</li> <li>ATOM's instance is considered fitted at initialization when all underlying   estimators are.</li> <li>ATOM's VotingClassifier doesn't implement a LabelEncoder to encode the   target column.</li> </ul> <p>The two estimators are customized in this way to save time and computational resources, since the classes are always initialized with fitted estimators. As a consequence of this, the VotingClassifier can not use sklearn's build-in LabelEncoder for the target column since it can't be fitted when initializing the class. For the vast majority of use cases, the changes will have no effect.</p> <p></p>"}, {"location": "user_guide/models/#stacking", "title": "Stacking", "text": "<p>Stacking is a method for combining estimators to reduce their biases. More precisely, the predictions of each individual estimator are stacked together and used as input to a final estimator to compute the prediction. Read more in sklearn's documentation.</p> <p>A stacking model is created from a trainer through the stacking method. The stacking model is added automatically to the list of models in the trainer, under the <code>Stack</code> acronym. The underlying estimators are StackingClassifier or StackingRegressor depending on the task.</p> <p>Tip</p> <p>By default, the final estimator is trained on the training set. Note that this is the same data on which the other estimators are fitted, increasing the chance of overfitting. If possible, it's recommended to use <code>train_on_test=True</code> in combination with a holdout set for model evaluation.</p>"}, {"location": "user_guide/nlp/", "title": "Natural Language Processing", "text": "<p>Natural Language Processing (NLP) is the subfield of machine learning that works with human language data. The nlp module contains four classes that help to convert raw text to meaningful numeric values, ready to be ingested by a model. ATOM uses the nltk library for the majority of its NLP processes.</p> <p>The text documents are expected to be provided in a column of the dataframe named <code>corpus</code> (the name is case-insensitive). Only the corpus is changed by the transformers, leaving the rest of the columns as is. This mechanism allows atom to combine datasets containing a text corpus with other non-text features. If an array is provided as input, it should consist of only one feature containing the text (one document per row). ATOM will then automatically convert the array to a dataframe with the desired column name. Documents are expected to be strings or sequences of words. Click here for an example using text data.</p> <p>Note</p> <p>All of atom's NLP methods automatically adopt the relevant transformer attributes (<code>verbose</code>, <code>logger</code>) from atom. A different choice can be added as parameter to the method call, e.g., <code>atom.tokenize(verbose=0)</code>.</p> <p>Info</p> <p>ATOM doesn't do topic modeling! The module's goal is to help process text documents into features that can be used for supervised learning.</p> <p></p>"}, {"location": "user_guide/nlp/#text-cleaning", "title": "Text cleaning", "text": "<p>Text data is rarely clean. Whether it's scraped from a website or inferred from paper documents, it's always populated with irrelevant information for the model, such as email addresses, HTML tags, numbers or punctuation marks. Use the TextCleaner class to clean the corpus from such noise. It can be accessed from atom through the textclean method. Use the class' parameters to choose which transformations to perform. The available steps are:</p> <ul> <li>Decode unicode characters to their ascii representations.</li> <li>Convert all characters to lower case.</li> <li>Drop email addresses from the text.</li> <li>Drop URL links from the text.</li> <li>Drop HTML tags from the text.</li> <li>Drop emojis from the text.</li> <li>Drop numbers from the text.</li> <li>Drop punctuations from the text.</li> </ul> <p></p>"}, {"location": "user_guide/nlp/#tokenization", "title": "Tokenization", "text": "<p>Some text processing algorithms, like stemming or lemmatization, require the corpus to be made out of tokens, instead of strings, in order to know what to consider as words. Tokenization is used to achieve this. It separates every document into a sequence of smaller units. In this case, the words.</p> <p>Sometimes, words have a different meaning on their own than when combined with adjacent words. For example, the word <code>new</code> has a completely different meaning when the word <code>york</code> is directly after it than when it's not. These combinations of two words are called bigrams. When there are three words, they are called trigrams, and with four words quadgrams.</p> <p>The Tokenizer class converts a document into a sequence of words, and can create the most frequent bigrams, trigrams and quadgrams. It can be accessed from atom through the tokenize method.</p> <p></p>"}, {"location": "user_guide/nlp/#text-normalization", "title": "Text Normalization", "text": "<p>Normalization for texts is a process that converts a list of words to a more uniform standard. This is useful to reduce the amount of different information that the computer has to deal with, and therefore improves efficiency. The goal of normalization techniques like stemming and lemmatization is to reduce inflectional and related forms of a word to a common base form.</p> <p>Normalize the words in the corpus using the TextNormalizer class. It can be accessed from atom through the textnormalize method.</p> <p></p>"}, {"location": "user_guide/nlp/#vectorization", "title": "Vectorization", "text": "<p>Text data cannot be fed directly to the algorithms themselves, as most of them expect numerical feature vectors with a fixed size, rather than words in the text documents with variable length. Vectorization is the general process of turning a collection of text documents into numerical feature vectors. You can apply it to the corpus using the Vectorizer class. It can be accessed from atom through the vectorize method.</p> <p>Info</p> <p>All strategies can utilize GPU speed-up. Click here for further information about GPU acceleration.</p> <p></p> <p>Bag of Words The Bag of Words (BOW) strategy applies tokenization, counting and normalization to the corpus. Documents are described by word occurrences while completely ignoring the relative position information of the words in the document. The created columns are named with the words they are embedding with the prefix <code>corpus_</code>. Read more in sklearn's documentation.</p> <p></p> <p>TF-IDF In a large text corpus, some words will be very present (e.g., \u201cthe\u201d, \u201ca\u201d, \u201cis\u201d in English), hence carrying very little meaningful information about the actual contents of the document. If we were to feed the direct count data directly to a classifier, those very frequent terms would shadow the frequencies of rarer, yet more interesting, terms. Use the TF-IDF strategy to re-weight the count features into floating point values. The created columns are named with the words they are embedding with the prefix <code>corpus_</code>. Read more in sklearn's documentation.</p> <p></p> <p>Hashing The larger the corpus, the larger the vocabulary will grow and thus increasing the number of features and memory use. Use the Hashing strategy to hash the words to a specified number of features. The created features are named <code>hash0</code>, <code>hash1</code>, etc... Read more in sklearn's documentation.</p>"}, {"location": "user_guide/nomenclature/", "title": "Nomenclature", "text": "<p>This documentation consistently uses terms to refer to certain concepts related to this package. The most frequent terms are described hereunder.</p> <p></p> <p>ATOM</p> <p>Refers to this package.</p> <p> atom</p> <p>Instance of the ATOMClassifier, ATOMForecaster or ATOMRegressor classes (note that the examples use it as the default variable name).</p> <p> categorical columns</p> <p>Refers to all columns of type <code>object</code>, <code>category</code>, <code>string</code> or <code>boolean</code>.</p> <p> class</p> <p>Unique value in a column, e.g., a binary classifier has two classes in the target column.</p> <p> dataframe</p> <p>Two-dimensional, size-mutable, potentially heterogeneous tabular data. The type is usually pd.DataFrame, but could potentially be any of the dataframe types backed by the selected data engine.</p> <p> dataframe-like</p> <p>Any type object from which a pd.DataFrame can be created. This includes an iterable, a dict whose values are 1d-arrays, a two-dimensional list, tuple, np.ndarray or sps.csr_matrix, or any object that follows the dataframe interchange protocol. This is the standard input format for any dataset.</p> <p>Additionally, you can provide a callable whose output is any of the aforementioned types. This is useful when the dataset is very large and you are performing parallel operations, since it can avoid broadcasting a large dataset from the driver to the workers.</p> <p> estimator</p> <p>An object which manages the estimation and decoding of an algorithm. The algorithm is estimated as a deterministic function of a set of parameters, a dataset and a random state. Should implement a <code>fit</code> method. Often used interchangeably with predictor because of user preference.</p> <p> missing values</p> <p>All values in the <code>missing</code> attribute, as well as <code>None</code>, <code>NaN</code>, <code>+inf</code> and <code>-inf</code>.</p> <p> model</p> <p>Instance of a model in atom. Not to confuse with estimator.</p> <p> outliers</p> <p>Sample that contains one or more outlier values. Note that the Pruner class can use a different definition for outliers depending on the chosen strategy.</p> <p> outlier value</p> <p>Value that lies further than 3 times the standard deviation away from the mean of its column, i.e., |z-score| &gt; 3.</p> <p> predictor</p> <p>An estimator implementing a <code>predict</code> method.</p> <p> scorer</p> <p>A non-estimator callable object which evaluates an estimator on given test data, returning a number. Unlike evaluation metrics, a greater returned number must correspond with a better score. See sklearn's documentation.</p> <p> segment</p> <p>Subset (segment) of a sequence, whether through slicing or generating a range of values. When given as a parameter type, it includes both range and slice.</p> <p> sequence</p> <p>A one-dimensional, indexable array of type sequence (except string), np.ndarray, pd.Index or series. This is the standard input format for a dataset's target column.</p> <p> series</p> <p>One-dimensional ndarray with axis labels. The type is usually pd.Series, but could potentially be any of the series types backed by the selected data engine.</p> <p> target</p> <p>The dependent variable in a supervised learning task. Passed as <code>y</code> to an estimator's fit method.</p> <p> task</p> <p>One of the supervised machine learning approaches that ATOM supports:</p> <ul> <li>binary classification</li> <li>multiclass classification</li> <li>multilabel classification</li> <li>multiclass-multioutput classification</li> <li>regression</li> <li>multioutput regression</li> <li>univariate forecast</li> <li>multivariate forecast</li> </ul> <p> transformer</p> <p>An estimator implementing a <code>transform</code> method. This encompasses all data cleaning and feature engineering classes.</p>"}, {"location": "user_guide/plots/", "title": "Plots", "text": "<p>ATOM provides many plotting methods to analyze the data or compare the model performances. Descriptions and examples can be found in the API section. ATOM mainly uses the plotly library for plotting. Plotly makes interactive, publication-quality graphs that are rendered using html. Some plots require other libraries like matplotlib, shap, wordcloud and schemdraw.</p> <p>Plots that compare model performances (methods with the <code>models</code> parameter) can be called directly from atom, e.g., <code>atom.plot_roc()</code>, or from one of the models, e.g., <code>atom.adab.plot_roc()</code>. If called from atom, use the <code>models</code> parameter to specify which models to plot. If called from a specific model, it makes the plot only for that model and the <code>models</code> parameter becomes unavailable.</p> <p>Plots that analyze the data (methods without the <code>models</code> parameter) can only be called from atom, and not from the models.</p> <p></p>"}, {"location": "user_guide/plots/#parameters", "title": "Parameters", "text": "<p>Apart from the plot-specific parameters, all plots have five parameters in common:</p> <ul> <li>The <code>title</code> parameter adds a title to the plot. The default value doesn't   show any title. Provide a configuration (as dictionary) to customize its   appearance, e.g., <code>title=dict(text=\"Awesome plot\", color=\"red\")</code>.   Read more in plotly's documentation.</li> <li> <p>The <code>legend</code> parameter is used to show/hide, position or customize the   plot's legend. Provide a configuration (as dictionary) to customize its   appearance (e.g., <code>legend=dict(title=\"Title for legend\", title_font_color=\"red\")</code>)   or choose one of the following locations:</p> <ul> <li>upper left</li> <li>upper right</li> <li>lower left</li> <li>lower right</li> <li>upper center</li> <li>lower center</li> <li>center left</li> <li>center right</li> <li>center</li> <li>out: Position the legend outside the axis, on the right hand side. This   is plotly's default position. Note that this shrinks the size of the axis   to fit both legend and axes in the specified <code>figsize</code>.</li> </ul> </li> <li> <p>The <code>figsize</code> parameter adjust the plot's size.</p> </li> <li>The <code>filename</code> parameter is used to save the plot.</li> <li>The <code>display</code> parameter determines whether to show or return the plot.</li> </ul> <p>Info</p> <p>In some plotting methods, it's possible to plot separate lines for different subsets of the rows. For example, to compare the results on the train and test set. For these cases, either provide a sequence to the <code>rows</code> parameter for every line you want to draw, e.g., <code>atom.plot_roc(rows=(\"train\", \"test\"))</code>, or provide a dictionary where the keys are the names of the sets (used in the legend) and the values are the corresponding selection of rows, selected using any of the aforementioned approaches, e.g, <code>atom.plot_roc(rows={\"0-99\": range(100), \"100-199\": range(100, 200})</code>. Note that for these methods, using <code>atom.plot_roc(rows=\"train+test\")</code>, only plots one line with the data from both sets. See the advanced plotting example.</p> <p></p>"}, {"location": "user_guide/plots/#aesthetics", "title": "Aesthetics", "text": "<p>The plot's aesthetics can be customized using the plot attributes prior to calling the plotting method, e.g., <code>atom.title_fontsize = 30</code>. The default values are:</p> <ul> <li>palette: [\"rgb(0, 98, 98)\", \"rgb(56, 166, 165)\", \"rgb(115, 175, 72)\",   \"rgb(237, 173, 8)\", \"rgb(225, 124, 5)\", \"rgb(204, 80, 62)\", \"rgb(148, 52, 110)\",   \"rgb(111, 64, 112)\", \"rgb(102, 102, 102)\"]</li> <li>title_fontsize: 24</li> <li>label_fontsize: 16</li> <li>tick_fontsize: 12</li> </ul> <p>Use atom's update_layout method to further customize the plot's layout using any of plotly's layout properties, e.g., <code>atom.update_layout(template=\"plotly_dark\")</code>. Similarly, use the update_traces method to customize the traces properties, e.g. <code>atom.update_traces(mode=\"lines+markers\")</code>.</p> <p>The reset_aesthetics method allows you to reset all aesthetics to their default value. See advanced plotting for an example.</p> <p></p>"}, {"location": "user_guide/plots/#canvas", "title": "Canvas", "text": "<p>Use the canvas method to draw multiple plots side by side, for example to make it easier to compare similar results. The canvas method is a <code>@contextmanager</code>, i.e., it's used through Python's <code>with</code> command. Plots in a canvas ignore the legend, figsize, filename and display parameters. Instead, specify these parameters in the canvas. If a variable is assigned to the canvas (e.g., <code>with atom.canvas() as fig</code>), it yields the resulting figure.</p> <p>For example, we can use a canvas to compare the results of a XGBoost and LightGBM model on the train and test set. We could also draw the lines for both models in the same axes, but that would clutter the plot too much. Click here for more examples.</p> <pre><code>from atom import ATOMClassifier\nfrom sklearn.datasets import make_classification\n\nX, y = make_classification(n_samples=1000, flip_y=0.2, random_state=1)\n\natom = ATOMClassifier(X, y)\natom.run([\"XGB\", \"LGB\"])\n\nwith atom.canvas(2, 2, title=\"XGBoost vs LightGBM\"):\n    atom.xgb.plot_roc(rows=\"train+test\", title=\"ROC - XGBoost\")\n    atom.lgb.plot_roc(rows=\"train+test\", title=\"ROC - LightGBM\")\n    atom.xgb.plot_prc(rows=\"train+test\", title=\"PRC - XGBoost\")\n    atom.lgb.plot_prc(rows=\"train+test\", title=\"PRC - LightGBM\")\n</code></pre> <p></p>"}, {"location": "user_guide/plots/#shap", "title": "SHAP", "text": "<p>The SHAP (SHapley Additive exPlanations) python package uses a game theoretic approach to explain the output of any machine learning model. It connects optimal credit allocation with local explanations using the classic Shapley values from game theory and their related extensions. ATOM implements methods to plot 7 of SHAP's plotting functions directly from its API. A list of available shap plots can be found here.</p> <p>Calculating the Shapley values is computationally expensive, especially for model agnostic explainers like Permutation. To avoid having to recalculate the values for every plot, ATOM stores the shapley values internally after the first calculation, and access them later when needed again.</p> <p>Warning</p> <ul> <li>It's not possible to draw multiple models in the same figure.   Selecting more than one model will raise an exception. To avoid   this, call the plot directly from a model, e.g., <code>atom.lr.plot_shap_force()</code>.</li> <li>The returned plot is a matplotlib figure, not plotly's.</li> <li>SHAP plots aren't available for forecast tasks.</li> </ul> <p></p>"}, {"location": "user_guide/plots/#available-plots", "title": "Available plots", "text": "<p>A list of available plots can be found hereunder. Note that not all plots can be called from every class and that their availability can depend on the task at hand.</p>"}, {"location": "user_guide/plots/#data-plots", "title": "Data plots", "text": "<p>plot_acfPlot the autocorrelation function.plot_ccfPlot the cross-correlation between two time series.plot_componentsPlot the explained variance ratio per component.plot_correlationPlot a correlation matrix.plot_data_splitsVisualize the data splits.plot_decompositionPlot the trend, seasonality and residuals of a time series.plot_distributionPlot column distributions.plot_fftPlot the fourier transformation of a time series.plot_ngramsPlot n-gram frequencies.plot_pacfPlot the partial autocorrelation function.plot_pcaPlot the explained variance ratio vs number of components.plot_periodogramPlot the spectral density of a time series.plot_qqPlot a quantile-quantile plot.plot_relationshipsPlot pairwise relationships in a dataset.plot_rfecvPlot the rfecv results.plot_seriesPlot a data series.plot_wordcloudPlot a wordcloud from the corpus.</p>"}, {"location": "user_guide/plots/#hyperparameter-tuning-plots", "title": "Hyperparameter tuning plots", "text": "<p>plot_edfPlot the Empirical Distribution Function of a study.plot_hyperparameter_importancePlot a model's hyperparameter importance.plot_hyperparametersPlot hyperparameter relationships in a study.plot_parallel_coordinatePlot high-dimensional parameter relationships in a study.plot_pareto_frontPlot the Pareto front of a study.plot_slicePlot the parameter relationship in a study.plot_terminator_improvementPlot the potentials for future objective improvement.plot_timelinePlot the timeline of a study.plot_trialsPlot the hyperparameter tuning trials.</p>"}, {"location": "user_guide/plots/#prediction-plots", "title": "Prediction plots", "text": "<p>plot_bootstrapPlot the bootstrapping scores.plot_calibrationPlot the calibration curve for a binary classifier.plot_confusion_matrixPlot a model's confusion matrix.plot_cv_splitsVisualize the cross-validation splits.plot_detPlot the Detection Error Tradeoff curve.plot_errorsPlot a model's prediction errors.plot_evalsPlot evaluation curves.plot_feature_importancePlot a model's feature importance.plot_forecastPlot model forecasts for the target time series.plot_gainsPlot the cumulative gains curve.plot_learning_curvePlot the learning curve: score vs number of training samples.plot_liftPlot the lift curve.plot_parshapPlot the partial correlation of shap values.plot_partial_dependencePlot the partial dependence of features.plot_permutation_importancePlot the feature permutation importance of models.plot_pipelinePlot a diagram of the pipeline.plot_prcPlot the precision-recall curve.plot_probabilitiesPlot the probability distribution of the target classes.plot_residualsPlot a model's residuals.plot_resultsCompare metric results of the models.plot_rocPlot the Receiver Operating Characteristics curve.plot_successive_halvingPlot scores per iteration of the successive halving.plot_thresholdPlot metric performances against threshold values.</p>"}, {"location": "user_guide/plots/#shap-plots", "title": "Shap plots", "text": "<p>plot_shap_barPlot SHAP's bar plot.plot_shap_beeswarmPlot SHAP's beeswarm plot.plot_shap_decisionPlot SHAP's decision plot.plot_shap_forcePlot SHAP's force plot.plot_shap_heatmapPlot SHAP's heatmap plot.plot_shap_scatterPlot SHAP's scatter plot.plot_shap_waterfallPlot SHAP's waterfall plot.</p>"}, {"location": "user_guide/predicting/", "title": "Predicting", "text": "<p>After training a model, you probably want to make predictions on new, unseen data. Just like a sklearn estimator, you can call the prediction methods from the model, e.g., <code>atom.tree.predict(X)</code>.</p> <p>All prediction methods transform the provided data through the pipeline in the model's branch before making the predictions. Transformers that should only be applied on the training set are excluded from this step (e.g., outlier pruning or class balancing).</p> <p>The available prediction methods are the standard methods for predictors in sklearn's and sktime's API.</p> <p>For classification and regression tasks:</p> <p>decision_functionGet confidence scores on new data or existing rows.predictGet predictions on new data or existing rows.predict_log_probaGet class log-probabilities on new data or existing rows.predict_probaGet class probabilities on new data or existing rows.scoreGet a metric score on new data.</p> <p>For forecast tasks:</p> <p>predictGet predictions on new data or existing rows.predict_intervalGet prediction intervals on new data or existing rows.predict_probaGet probabilistic forecasts on new data or existing rows.predict_quantilesGet quantile forecasts on new data or existing rows.predict_varGet variance forecasts on new data or existing rows.scoreGet a metric score on new data.</p> <p>Warning</p> <p>The <code>score</code> method return atom's metric score, not the metric returned by sklearn/sktime's score method for predictors. Use the method's <code>metric</code> parameter to calculate a different metric.</p> <p>Note</p> <ul> <li>The output of ATOM's methods are pandas objects, not numpy arrays.</li> <li>The <code>predict_proba</code> method of some meta-estimators for multioutput tasks   (such as MultioutputClassifier) return 3 dimensions, namely, a list of   arrays with shape=(n_samples, n_classes). One array per target column. Since   ATOM's prediction methods return pandas objects, such 3-dimensional arrays   are converted to a multiindex pd.DataFrame, where the first level of the row   indices are the target columns, and the second level are the classes.</li> <li>The prediction results are cached after the first call to avoid consequent   expensive calculations. This mechanism can increase the size of the instance   for large datasets. Use the clear method to free the   memory.</li> </ul> <p>It's also possible to get the prediction for a specific row or rows in the dataset. See the row and column selection section in the user guide to learn how to select the rows, e.g., <code>atom.rf.predict(\"test\")</code> or <code>atom.rf.predict_proba(range(100))</code>.</p> <p>Note</p> <p>For forecast models, prediction on rows follow the ForecastingHorizon API. That means that using the row index works, but for example using <code>atom.arima.predict(1)</code> returns the prediction on the first row of the test set (instead of the second row of the train set).</p>"}, {"location": "user_guide/time_series/", "title": "Time series", "text": "<p>Time series applies machine learning techniques to sequential data, where observations are ordered over time. This approach is crucial for predicting future values or events and finds applications in finance, healthcare, weather forecasting, and more. ATOM support two time series tasks: univariate forecast and multivariate forecast.</p> <p>Example</p> <p>See our time series examples for univariate and multivariate forecast.</p> <p></p>"}, {"location": "user_guide/time_series/#exogenous-variables", "title": "Exogenous variables", "text": "<p>Exogenous variables are external factors that can influence the target variable and, unlike endogenous variables, are not part of the time series being analyzed.</p> <p>Incorporating exogenous variables into time series models helps capture additional information that may impact the observed patterns. This inclusion allows for a more comprehensive understanding of the underlying dynamics and can lead to more accurate predictions.</p> <p>Exogenous variables are added to atom with the <code>X</code> variable. When no exogenous variables are provided, <code>atom.X</code> returns an empty dataframe. Note that not all models make use of exogenous variables. Read more here about how to check specific model characteristics.</p> <p></p>"}, {"location": "user_guide/time_series/#seasonality", "title": "Seasonality", "text": "<p>Seasonality refers to the recurring patterns that repeat at regular intervals over time, often corresponding to specific time periods, such as days, weeks, or months, and can significantly influence the observed data.</p> <p>Add seasonality to atom using the <code>sp</code> parameter or attribute. You can add a single value for single seasonality or a sequence of values for multiple seasonalities. If you don't know the seasonality a priori, you can use the <code>get_seasonal_period</code> method to automatically detect the seasonality, e.g. <code>atom.sp = atom.get_seasonal_period()</code> or directly from the constructor <code>atom = ATOMForecaster(y, sp=\"infer\")</code>.</p> <p>The majority of models only support one seasonal period. If more than one period is defined, such models only use the first one. Read here how to check which models support multiple seasonality.</p> <p>Info</p> <p>In a multivariate setting, the same period is used for all target columns.</p> <p>In addition to the period, it's possible to further tune the seasonality by specifying the trend and seasonal models. In an <code>additive</code> model, the components are added together. It implies that the effect of one component does not depend on the level of the other components. In a <code>multiplicative</code> model, the components are multiplied together. This suggests that the effect of one component is proportional to the level of the other components.</p> <p>Specify the trend and/or seasonal models providing the <code>sp</code> parameter (or attribute) with a dictionary, e.g., <code>atom.sp = {\"sp\": 12, \"seasonal_model\": \"multiplicative\"}</code>. Both the <code>seasonal_model</code> and <code>trend_model</code> values default to <code>additive</code>.</p> <p></p>"}, {"location": "user_guide/time_series/#forecasting-with-regressors", "title": "Forecasting with regressors", "text": "<p>All of ATOM's regressors can also be used in forecasting tasks. Simply select the regressor like any other model, e.g., <code>atom.run(models=\"RF\")</code> to use a RandomForest model.</p> <p>The regressor is automatically converted to a forecaster, based on reduction to tabular or time-series regression. During fitting, a sliding-window approach is used to first transform the time series into tabular or panel data, which is then used to fit a tabular or time-series regression estimator. During prediction, the last available data is used as input to the fitted regression estimator to generate forecasts.</p> <p>See below a graphical representation of the reduction logic using the following symbols:</p> <ul> <li>y: forecast target.</li> <li>x: past values of y that are used as features (X) to forecast y.</li> <li>*:observations, past or future, neither part of the window nor forecast.</li> </ul> <p>Assume we have the following training data (15 observations):</p> <p>|------------------------------| | * * * * * * * * * * * * * * *| |------------------------------|</p> <p>The reducer targets the first data point after the window, irrespective of the forecasting horizons requested. In the example, the following five windows are created:</p> <p>|------------------------------| | x x x x x x x x x x y * * * | | * x x x x x x x x x x y * * | | * * x x x x x x x x x x y * | | * * * x x x x x x x x x x y | | * * * * x x x x x x x x x x y| |------------------------------|</p> <p>Warning</p> <p>Regressor forecasters do not support in-sample predictions. Scores on the training set always return <code>NaN</code>.</p>"}, {"location": "user_guide/training/", "title": "Training", "text": "<p>The training phase is where the models are fitted on the training data. After this, you can use the plots and prediction methods to evaluate the results. The training applies the following steps for all models:</p> <ol> <li>Use hyperparameter tuning to select the optimal hyperparameters for    the model (optional).</li> <li>The model is fitted on the training set using the best combination    of hyperparameters found. After that, the model is evaluated on the tes set.</li> <li>Calculate various scores on the test set using a bootstrap    algorithm (optional).</li> </ol> <p>There are three approaches to run the training.</p> <ul> <li>Direct training:<ul> <li>DirectClassifier</li> <li>DirectForecaster</li> <li>DirectRegressor</li> </ul> </li> <li>Training via successive halving:<ul> <li>SuccessiveHalvingClassifier</li> <li>SuccessiveHalvingForecaster</li> <li>SuccessiveHalvingRegressor</li> </ul> </li> <li>Training via train sizing:<ul> <li>TrainSizingClassifier</li> <li>TrainSizingForecaster</li> <li>TrainSizingRegressor</li> </ul> </li> </ul> <p>The direct fashion repeats the aforementioned steps only once, while the other two approaches repeats them more than once. Just like the data cleaning and feature engineering classes, it's discouraged to use these classes directly. Instead, every approach can be called directly from atom through the run, successive_halving and train_sizing methods respectively.</p> <p>Models are called through their acronyms, e.g., <code>atom.run(models=\"RF\")</code> will train a RandomForest. If you want to run the same model multiple times, add a tag after the acronym to differentiate them. the tag must be separated from the accronym by an underscore.</p> <pre><code>atom.run(\n    models=[\"RF_1\", \"RF_2\"],\n    est_params={\n        \"RF_1\": {\"n_estimators\": 100},\n        \"RF_2\": {\"n_estimators\": 200},\n    }\n)\n</code></pre> <p>For example, this pipeline fits two Random Forest models, one with 100 and the other with 200 decision trees. The models can be accessed through <code>atom.rf_1</code> and <code>atom.rf_2</code>. Use tagged models to test how the same model performs when fitted with different parameters or on different data sets. See the Imbalanced datasets example.</p> <p>Additional things to take into account:</p> <ul> <li>If an exception is encountered while fitting an estimator, the   pipeline will automatically jump to the next model. The exceptions are   stored in the <code>errors</code> attribute. Note that when a model is skipped,   there is no model subclass for that estimator.</li> <li>When showing the final results, a <code>!</code> indicates the highest score   and a <code>~</code> indicates that the model is possibly overfitting (training   set has a score at least 20% higher than the test set).</li> </ul> <p></p>"}, {"location": "user_guide/training/#metric", "title": "Metric", "text": "<p>ATOM uses sklearn's scorers for model evaluation. A scorer consists of a metric function and some parameters that define the scorer's properties , such as if a higher or lower score is better (score or loss function) or if the function needs probability estimates or rounded predictions (see the make_scorer function). The <code>metric</code> parameter accepts three ways of defining the scorer:</p> <ul> <li>Using the name of one of the predefined scorers.</li> <li>Using a function with signature <code>function(y_true, y_pred) -&gt; score</code>.   In this case, ATOM uses make_scorer   with default parameters.</li> <li>Using a scorer object.</li> </ul> <p>Note that all scorers follow the convention that higher return values are better than lower return values. Thus, metrics which measure the distance between the model and the data (i.e., loss functions), like <code>max_error</code> or <code>mean_squared_error</code>, will return the negated value of the metric.</p> <p></p>"}, {"location": "user_guide/training/#predefined-scorers", "title": "Predefined scorers", "text": "<p>ATOM accepts all sklearn's scorers as well as some custom acronyms and custom scorers. Since some of sklearn's scorers have quite long names and ATOM is all about lazyfast experimentation, the package provides acronyms for some of the most commonly used ones. These acronyms are case-insensitive and can be used in the <code>metric</code> parameter instead of the scorer's full name, e.g., <code>atom.run(\"LR\", metric=\"BA\")</code> uses <code>balanced_accuracy</code>. The available acronyms are:</p> <ul> <li>\"AP\" for \"average_precision\"</li> <li>\"BA\" for \"balanced_accuracy\"</li> <li>\"AUC\" for \"roc_auc\"</li> <li>\"LogLoss\" for \"neg_log_loss\"</li> <li>\"EV\" for \"explained_variance\"</li> <li>\"ME\" for \"max_error\"</li> <li>\"MAE\" for \"neg_mean_absolute_error\"</li> <li>\"MSE\" for \"neg_mean_squared_error\"</li> <li>\"RMSE\" for \"neg_root_mean_squared_error\"</li> <li>\"MSLE\" for \"neg_mean_squared_log_error\"</li> <li>\"MEDAE\" for \"neg_median_absolute_error\"</li> <li>\"MAPE\" for \"neg_mean_absolute_percentage_error\"</li> <li>\"POISSON\" for \"neg_mean_poisson_deviance\"</li> <li>\"GAMMA\" for \"neg_mean_gamma_deviance\"</li> </ul> <p>ATOM also provides some extra common metrics for binary classification tasks.</p> <ul> <li>\"TN\" for True Negatives</li> <li>\"FP\" for False Positives</li> <li>\"FN\" for False Negatives</li> <li>\"TP\" for True Positives</li> <li>\"FPR\" for False Positive rate (fall-out)</li> <li>\"TPR\" for True Positive Rate (sensitivity, recall)</li> <li>\"TNR\" for True Negative Rate (specificity)</li> <li>\"FNR\" for False Negative Rate (miss rate)</li> <li>\"MCC\" for Matthews Correlation Coefficient (also for multiclass classification)</li> </ul> <p></p>"}, {"location": "user_guide/training/#multi-metric-runs", "title": "Multi-metric runs", "text": "<p>Sometimes it is useful to measure the performance of the models in more than one way. ATOM lets you run the pipeline with multiple metrics at the same time. To do so, provide the <code>metric</code> parameter with a list of desired metrics, e.g., <code>atom.run(\"LDA\", metric=[\"r2\", \"mse\"])</code>.</p> <p>When fitting multi-metric runs, the resulting scores will return a list of metrics. For example, if you provided three metrics to the pipeline, <code>atom.knn.score_train</code> could return [0.8734, 0.6672, 0.9001]. Only the first metric of a multi-metric run (this metric is called the main metric) is used to select the winning model.</p> <p>Info</p> <ul> <li>The <code>winning</code> model is retrieved comparing only   the main metric.</li> <li>Some plots let you choose which of the metrics in a multi-metric run   to show using the <code>metric</code> parameter, e.g., plot_results.</li> </ul> <p></p>"}, {"location": "user_guide/training/#automated-feature-scaling", "title": "Automated feature scaling", "text": "<p>Models that require feature scaling will automatically do so before training, unless the data is sparse or already scaled. The data is considered scaled if it has one of the following prerequisites:</p> <ul> <li>The mean value over the mean of all columns lies between -0.05 and 0.05   and the mean of the standard deviation over all columns lies between 0.85   and 1.15. Categorical and binary columns (only 0s and 1s) are excluded   from the calculation.</li> <li>There is a transformer in the pipeline whose __name__ contains the   word <code>scaler</code>.</li> </ul> <p>The scaling is applied using a Scaler with default parameters. It can be accessed from the model through the <code>scaler</code> attribute. The scaled dataset can be examined through the model's data attributes. Use the available_models method to see which models require feature scaling. See here an example.</p> <p></p>"}, {"location": "user_guide/training/#in-training-validation", "title": "In-training validation", "text": "<p>Some predefined models allow in-training validation. This means that the estimator is evaluated (using only the main metric) on the train and test set after every round of the training (a round can be an iteration for linear models or an added tree for boosted tree models). The validation scores are stored in the <code>evals</code> attribute, a dictionary of the train and test performances per round (also when pruning isn't applied). Click here for an example using in-training validation.</p> <p>The predefined models that support in-training validation are:</p> <ul> <li>CatBoost</li> <li>LightGBM</li> <li>MultiLayerPerceptron</li> <li>PassiveAggressive</li> <li>Perceptron</li> <li>StochasticGradientDescent</li> <li>XGBoost</li> </ul> <p>To apply in-training validation to a custom model, use the <code>validation</code> parameter when creating the custom model.</p> <p>Warning</p> <ul> <li>In-training validation is not calculated during hyperparameter tuning.</li> <li>CatBoost selects the weights achieved by the best evaluation on the test set after training. This means that, by default, there is some minor data leakage in the test set. Use the <code>use_best_model=False</code> parameter to avoid this behavior or use a holdout set to evaluate the final estimator.</li> </ul> <p>Tip</p> <p>Use the plot_evals method to visualize the in-training validation on the train and test sets.</p> <p></p>"}, {"location": "user_guide/training/#parameter-customization", "title": "Parameter customization", "text": "<p>By default, every estimator uses the default parameters they get from their respective packages. To select different ones, use the <code>est_params</code>. parameter of the run method. There are two ways to add custom parameters to the models: adding them directly to the dictionary as key-value pairs or through dictionaries.</p> <p>Adding the parameters directly to <code>est_params</code> (or using a dict with the key 'all') shares them across all models in the trainer. In this example, both the XGBoost and the LightGBM model use 200 boosted trees. Make sure all the models do have the specified parameters or an exception will be raised!</p> <pre><code>atom.run(models=[\"XGB\", \"LGB\"], est_params={\"n_estimators\": 200})\n</code></pre> <p>To specify parameters per model, use the model name as key and a dict of the parameters as value. In this example, the XGBoost model uses <code>n_estimators=200</code> and the MultiLayerPerceptron uses one hidden layer with 75 neurons.</p> <pre><code>atom.run(\n    models=[\"XGB\", \"MLP\"],\n    est_params={\n        \"XGB\": {\"n_estimators\": 200},\n        \"MLP\": {\"hidden_layer_sizes\": (75,)},\n    }\n)\n</code></pre> <p>Some estimators allow you to pass extra parameters to the fit method (besides X and y). This can be done adding <code>_fit</code> at the end of the parameter. For example, to change XGBoost's verbosity, we can run:</p> <pre><code>atom.run(models=\"XGB\", est_params={\"verbose_fit\": True})\n</code></pre> <p>Note</p> <p>If a parameter is specified through <code>est_params</code>, it's ignored by the study, even if it's added manually to <code>ht_params[\"distributions\"]</code>.</p> <p>Info</p> <p>The estimator's <code>n_jobs</code> and <code>random_state</code> parameters adopt atom's values (when available), unless specified through <code>est_params</code>.</p> <p></p>"}, {"location": "user_guide/training/#hyperparameter-tuning", "title": "Hyperparameter tuning", "text": "<p>In order to achieve maximum performance, it's important to tune an estimator's hyperparameters before training it. ATOM provides hyperparameter tuning through the optuna package. Just like optuna, we use the terms <code>study</code> and <code>trial</code> as follows:</p> <ul> <li>Study: optimization based on an objective function.</li> <li>Trial: a single execution of the objective function.</li> </ul> <p>Each trial is either computed by cross-validation on the complete training set or by randomly splitting the training set every iteration into a (sub)training and validation set. This process can create some minimum data leakage towards specific parameters (since the estimator is evaluated on data that is used to train the next estimator), but it ensures maximal use of the provided data. However, the leakage is not present in the independent test set, thus the final score of every model is unbiased. Note that, if the dataset is relatively small, the tuning's best score can consistently be lower than the final score on the test set due to the considerable lower fraction of instances on which it is trained. After finishing the study, the parameters that resulted in the best score are used to fit the final model on the complete training set.</p> <p>Info</p> <ul> <li>Unless specified differently by the user, the used samplers   are TPESampler   for single-metric runs and NSGAIISampler   for multi-metric runs.</li> <li>For multi-metric runs, the selected best trial   is the trial that performed best on the main metric. Use the property's   <code>@setter</code> to change it to any other trial. See the hyperparameter tuning   example.</li> </ul> <p>There are many possibilities to tune the study to your liking. The main parameter is <code>n_trials</code>, which determine the number of trials that are performed.</p> <p>Extra things to take into account:</p> <ul> <li>The train/validation splits are different per trial but equal for all models.</li> <li>Re-evaluating the objective function at the same point (with the same   hyperparameters) automatically skips the calculation and returns the   same score as the equivalent trial.</li> </ul> <p>Tip</p> <p>The hyperparameter tuning output can become quite wide for models with many hyperparameters. If you are working in a Jupyter Notebook, you can change the output's width running the following code in a cell: <pre><code>from IPython.display import display, HTML\ndisplay(HTML(\"&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;\"))\n</code></pre></p> <p>Other settings can be changed through the <code>ht_params</code> parameter, a dictionary where every key-value combination can be used to further customize the optimization.</p> <p>By default, which hyperparameters are tuned and their corresponding distributions are predefined by ATOM. Use the 'distributions' key to customize these. Just like with <code>est_params</code>, it's possible to share the same parameters across models or use a dictionary with the model name as key to specify the parameters for every individual model. Use the key 'all' to tune some hyperparameters for all models when you also want to tune other parameters only for specific ones. The following example tunes the <code>n_estimators</code> parameter for both models but the <code>max_depth</code> parameter only for the RandomForest.</p> <pre><code>atom.run(\n    models=[\"ET\", \"RF\"],\n    n_trials=30,\n    ht_params={\"distributions\": {\"all\": \"n_estimators\", \"RF\": \"max_depth\"}},\n)\n</code></pre> <p>Like the <code>columns</code> parameter in atom's methods, you can exclude parameters from the optimization adding <code>!</code> before its name. It's possible to exclude multiple parameters, but not to combine inclusion and exclusion for the same model. For example, to optimize a RandomForest using all its predefined parameters except <code>n_estimators</code>, run:</p> <pre><code>atom.run(\n    models=\"ET\",\n    n_trials=15,\n    ht_params={\"distributions\": \"!n_estimators\"},\n)\n</code></pre> <p>If just the parameter name is provided, the predefined distribution is used. It's also possible to provide custom distributions spaces, but make sure they are compliant with optuna's API. See every model's individual documentation in ATOM's API section for an overview of their hyperparameters and distributions.</p> <pre><code>from optuna.distributions import (\n    IntDistribution, FloatDistribution, CategoricalDistribution\n)\n\natom.run(\n    models=[\"ET\", \"RF\"],\n    n_trials=30,\n    ht_params={\n        \"dimensions\": {\n            \"all\": {\"n_estimators\": IntDistribution(10, 100, step=10)},\n            \"RF\": {\n                \"max_depth\": IntDistribution(1, 10),\n                \"max_features\": CategoricalDistribution([\"sqrt\", \"log2\"]),\n           },\n        },\n    }\n)\n</code></pre> <p>Parameters for optuna's study and the study's optimize method can be added as kwargs to <code>ht_params</code>. For example, to use a different sampler or add a custom callback.</p> <pre><code>from optuna.samplers import RandomSampler\n\natom.run(\n    models=\"LR\",\n    n_trials=30,\n    ht_params={\n        \"sampler\": RandomSampler(seed=atom.random_state),\n        \"callbacks\": custom_callback(),\n    },\n)\n</code></pre> <p>Note</p> <ul> <li>If you use the default sampler, it\u2019s recommended to consider setting   larger <code>n_trials</code> to make full use of the characteristics of TPESampler   because TPESampler uses some (by default, 10) trials for its startup.</li> <li>When specifying distributions manually, make sure to import the   distribution types from optuna: <code>from optuna.distributions import ...</code>.</li> </ul> <p>Warning</p> <p>Keras' models can only use hyperparameter tuning when <code>n_jobs=1</code> or <code>ht_params={\"cv\": 1}</code>. Using n_jobs &gt; 1 and cv &gt; 1 raises a PicklingError due to incompatibilities of the APIs. Read here more about deep learning models.</p> <p>Tip</p> <p>ATOM has several plots that can help you examine a model's study and trials. Have a look at them here.</p> <p></p>"}, {"location": "user_guide/training/#pruning", "title": "Pruning", "text": "<p>During hyperparameter tuning, pruning stops unpromising trials at the early stages of the training (a.k.a., automated early-stopping). This can save the pipeline much time that would otherwise be wasted on an estimator that is unlikely to yield the best results. A pruned trial can't be selected as <code>best_trial</code>. Click here to see an example that uses pruning.</p> <p>The study uses MedianPruner as default pruner. You can use any other of optuna's pruners through the <code>ht_params</code> parameter.</p> <pre><code>from optuna.pruners import HyperbandPruner\n\natom.run(\"SGD\", n_trials=30, ht_params={\"pruner\": HyperbandPruner()})\n</code></pre> <p>Warning</p> <ul> <li>Pruning is disabled for multi-metric runs.</li> <li>Pruning is only available for models that support in-training validation.</li> </ul> <p></p>"}, {"location": "user_guide/training/#bootstrapping", "title": "Bootstrapping", "text": "<p>After fitting the estimator, you can assess the robustness of the model using the bootstrap technique. This technique creates several new data sets selecting random samples from the training set (with replacement) and evaluates them on the test set. This way you can get a distribution of the performance of the model. The sets are the same for every model. The number of sets can be chosen through the <code>n_bootstrap</code> parameter.</p> <p>See here a bootstrapping example.</p> <p>Tip</p> <p>Use the plot_bootstrap method to plot the boostrap scores in a boxplot.</p> <p></p>"}, {"location": "user_guide/training/#successive-halving", "title": "Successive halving", "text": "<p>Successive halving is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, we recommend only to use this technique with similar models, e.g., only using tree-based models.</p> <p>Run successive halving from atom via the successive_halving method. Consecutive runs of the same model are saved with the model's acronym followed by the number of models in the run. For example, a RandomForest in a run with 4 models would become model <code>RF4</code>.</p> <p>See here a successive halving example.</p> <p>Tip</p> <p>Use the plot_successive_halving method to see every model's performance per iteration of the successive halving.</p> <p></p>"}, {"location": "user_guide/training/#train-sizing", "title": "Train sizing", "text": "<p>When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. Train sizing can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set.</p> <p>Run train sizing from atom via the train_sizing method. The number of iterations and the number of samples per training can be specified with the <code>train_sizes</code> parameter. Consecutive runs of the same model are saved with the model's acronym followed by the fraction of rows in the training set (the <code>.</code> is removed from the fraction!). For example, a RandomForest in a run with 80% of the training samples would become model <code>RF08</code>.</p> <p>See here a train sizing example.</p> <p>Tip</p> <p>Use the plot_learning_curve method to see the model's performance per size of the training set.</p>"}]}