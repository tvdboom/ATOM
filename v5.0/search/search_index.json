{"config": {"indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "", "title": "ATOM"}, {"location": "about/", "text": "About What is it? Automated Tool for Optimized Modelling (ATOM) is an open-source Python package designed to help data scientists fasten up the exploration phase of their machine learning projects. ATOM is a low-code, easy-to-use library, capable of running experiments quickly and efficiently, enabling the user to go from raw data to generating insights in just a few lines of code. Click here to get started. What can I do with it? ATOM is an end-to-end solution for machine learning pipelines. It supports the user from raw data ingestion to the final results' analysis. Click on the icons to read more about its main functionalities. Data cleaning Feature engineering Model selection Hyperparameter tuning Model training Model predictions Experiment logging Analysis & Interpretability Who is it intended for? Data scientists that want to fasten up the exploration phase of their machine learning projects. Data scientists that want to run a simple modelling experiment without having to spend too much time on coding. Data scientists that are new to Python and are not (yet) familiar with all the relevant machine learning packages. Data analysts without extensive knowledge of machine learning that want to try out model-based solutions. Anyone who wants to rapidly build a Proof of Concept, for example during a hackathon. Anyone who is new to the field of machine learning and wants a low-code, easy to learn package, to get started building predictive pipelines. Citing ATOM If you use ATOM in a scientific publication, please consider citing this documentation page as the resource. ATOM\u2019s first stable release v2.0.3 was made publicly available in November 2019. A formatted version of the citation would look like this: ATOM v2.0.3, November 2019. URL https://tvdboom.github.io/ATOM/ BibTeX entry: @Manual{ATOM, title = {ATOM: A Python package for fast exploration of machine learning pipelines}, author = {Mavs}, year={2019}, mont={November}, note = {ATOM version 2.0.3}, url = {https://tvdboom.github.io/ATOM/}, } Support ATOM recognizes the support from JetBrains by providing core project contributors with a set of developer tools free of charge.", "title": "About"}, {"location": "about/#about", "text": "", "title": "About"}, {"location": "about/#what-is-it", "text": "Automated Tool for Optimized Modelling (ATOM) is an open-source Python package designed to help data scientists fasten up the exploration phase of their machine learning projects. ATOM is a low-code, easy-to-use library, capable of running experiments quickly and efficiently, enabling the user to go from raw data to generating insights in just a few lines of code. Click here to get started.", "title": "What is it?"}, {"location": "about/#what-can-i-do-with-it", "text": "ATOM is an end-to-end solution for machine learning pipelines. It supports the user from raw data ingestion to the final results' analysis. Click on the icons to read more about its main functionalities. Data cleaning Feature engineering Model selection Hyperparameter tuning Model training Model predictions Experiment logging Analysis & Interpretability", "title": "What can I do with it?"}, {"location": "about/#who-is-it-intended-for", "text": "Data scientists that want to fasten up the exploration phase of their machine learning projects. Data scientists that want to run a simple modelling experiment without having to spend too much time on coding. Data scientists that are new to Python and are not (yet) familiar with all the relevant machine learning packages. Data analysts without extensive knowledge of machine learning that want to try out model-based solutions. Anyone who wants to rapidly build a Proof of Concept, for example during a hackathon. Anyone who is new to the field of machine learning and wants a low-code, easy to learn package, to get started building predictive pipelines.", "title": "Who is it intended for?"}, {"location": "about/#citing-atom", "text": "If you use ATOM in a scientific publication, please consider citing this documentation page as the resource. ATOM\u2019s first stable release v2.0.3 was made publicly available in November 2019. A formatted version of the citation would look like this: ATOM v2.0.3, November 2019. URL https://tvdboom.github.io/ATOM/ BibTeX entry: @Manual{ATOM, title = {ATOM: A Python package for fast exploration of machine learning pipelines}, author = {Mavs}, year={2019}, mont={November}, note = {ATOM version 2.0.3}, url = {https://tvdboom.github.io/ATOM/}, }", "title": "Citing ATOM"}, {"location": "about/#support", "text": "ATOM recognizes the support from JetBrains by providing core project contributors with a set of developer tools free of charge.", "title": "Support"}, {"location": "contributing/", "text": "Contributing Are you interested in contributing to ATOM? Do you want to report a bug? Do you have a question? Before you do, please read the following guidelines. Submission context Question or problem? For quick questions there's no need to open an issue. Check first if the question isn't already answered on the FAQ section. If not, reach us through the discussions page or on the slack channel. Report a bug? If you found a bug in the source code, you can help by submitting an issue to the issue tracker in the GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines . Missing a feature? You can request a new feature by submitting an issue to the GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first. Please consider what kind of change it is: For a major feature , first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into master , as it's always a matter of opinion whether if benefits the overall functionality of the project. Project layout The latest stable release of ATOM is on the master branch, whereas the latest version of ATOM in development is on the development branch. Make sure you are looking at and working on the correct branch if you're looking to contribute code. In terms of directory structure: All of ATOM's code sources are in the atom directory. The documentation sources are in the docs_sources directory. Images in the documentation are in the docs_sources/img directory. Tutorial notebooks are in the examples directory. If you want to include the example to the documentation as well, add the .ipynb file to docs_sources/examples and update the mkdocs.yml file accordingly. Unit tests are in the tests directory. Make sure to add the tests to the file corresponding to the module in the atom directory with the code that is being tested. Make sure to familiarize yourself with the project layout before making any major contributions, and especially make sure to send all code changes to the development branch. Submission guidelines Submitting an issue Before you submit an issue, please search the issue tracker , maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Submitting a pull request Before you submit a pull request, please work through this checklist to make sure that you have done everything necessary so we can efficiently review and accept your changes. Update the documentation so all of your changes are reflected there. Adhere to PEP 8 standards. Use a maximum of 90 characters per line. Try to keep docstrings below 74 characters. Update the project unit tests to test your code changes as thoroughly as possible. Make sure that your code is properly commented with docstrings and comments explaining your rationale behind non-obvious coding practices. Run isort : isort atom tests . Run flake8 : flake8 --show-source --statistics atom tests . If your contribution requires a new library dependency: Double-check that the new dependency is easy to install via pip and Anaconda. The library should support Python 3.8 and higher. Make sure the code works with the latest version of the library. Update the dependencies in the documentation. Add the library with the minimum required version to pyproject.toml . After submitting your pull request, GitHub will automatically run the tests on your changes and make sure that the updated code builds successfully. The checks are run on Python 3.8, 3.9 and 3.10, on Ubuntu and Windows. We also use services that automatically check code style and test coverage.", "title": "Contributing"}, {"location": "contributing/#contributing", "text": "Are you interested in contributing to ATOM? Do you want to report a bug? Do you have a question? Before you do, please read the following guidelines.", "title": "Contributing"}, {"location": "contributing/#submission-context", "text": "", "title": "Submission context"}, {"location": "contributing/#question-or-problem", "text": "For quick questions there's no need to open an issue. Check first if the question isn't already answered on the FAQ section. If not, reach us through the discussions page or on the slack channel.", "title": "Question or problem?"}, {"location": "contributing/#report-a-bug", "text": "If you found a bug in the source code, you can help by submitting an issue to the issue tracker in the GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines .", "title": "Report a bug?"}, {"location": "contributing/#missing-a-feature", "text": "You can request a new feature by submitting an issue to the GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first. Please consider what kind of change it is: For a major feature , first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into master , as it's always a matter of opinion whether if benefits the overall functionality of the project.", "title": "Missing a feature?"}, {"location": "contributing/#project-layout", "text": "The latest stable release of ATOM is on the master branch, whereas the latest version of ATOM in development is on the development branch. Make sure you are looking at and working on the correct branch if you're looking to contribute code. In terms of directory structure: All of ATOM's code sources are in the atom directory. The documentation sources are in the docs_sources directory. Images in the documentation are in the docs_sources/img directory. Tutorial notebooks are in the examples directory. If you want to include the example to the documentation as well, add the .ipynb file to docs_sources/examples and update the mkdocs.yml file accordingly. Unit tests are in the tests directory. Make sure to add the tests to the file corresponding to the module in the atom directory with the code that is being tested. Make sure to familiarize yourself with the project layout before making any major contributions, and especially make sure to send all code changes to the development branch.", "title": "Project layout"}, {"location": "contributing/#submission-guidelines", "text": "", "title": "Submission guidelines"}, {"location": "contributing/#submitting-an-issue", "text": "Before you submit an issue, please search the issue tracker , maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template.", "title": "Submitting an issue"}, {"location": "contributing/#submitting-a-pull-request", "text": "Before you submit a pull request, please work through this checklist to make sure that you have done everything necessary so we can efficiently review and accept your changes. Update the documentation so all of your changes are reflected there. Adhere to PEP 8 standards. Use a maximum of 90 characters per line. Try to keep docstrings below 74 characters. Update the project unit tests to test your code changes as thoroughly as possible. Make sure that your code is properly commented with docstrings and comments explaining your rationale behind non-obvious coding practices. Run isort : isort atom tests . Run flake8 : flake8 --show-source --statistics atom tests . If your contribution requires a new library dependency: Double-check that the new dependency is easy to install via pip and Anaconda. The library should support Python 3.8 and higher. Make sure the code works with the latest version of the library. Update the dependencies in the documentation. Add the library with the minimum required version to pyproject.toml . After submitting your pull request, GitHub will automatically run the tests on your changes and make sure that the updated code builds successfully. The checks are run on Python 3.8, 3.9 and 3.10, on Ubuntu and Windows. We also use services that automatically check code style and test coverage.", "title": "Submitting a pull request"}, {"location": "dependencies/", "text": "Dependencies Python & OS As of the moment, ATOM supports the following Python versions: Python 3.8 Python 3.9 Python 3.10 And operating systems: Linux (Ubuntu, Fedora, etc...) Windows 8.1+ macOS (not tested) Packages Required ATOM is built on top of several existing Python libraries. These packages are necessary for its correct functioning. category-encoders (>=2.4.1) explainerdashboard (>=0.4.0) dill (>=0.3.5) evalml (>=0.62.0) gplearn (>=0.4.1) gradio (>=3.3.1) imbalanced-learn (>=0.9.0) featuretools (>=1.14.0) joblib (>=1.1.0, <1.2.0) matplotlib (>=3.5.0, <3.6.0) mlflow (>=2.0.1) nltk (>=3.7) numpy (>=1.22) optuna (>=3.0.0) pandas (>=1.3.5) pandas-profiling (>=3.5.0) plotly (>=5.10.0) shap (>=0.41) schemdraw (>=0.14) scikit-learn (>=1.1.0) scikit-learn-intelex (>=2021.6.3) scipy (>=1.8.1) typeguard (>=2.13) wordcloud (>=1.8.1) zoofs (>=0.1.24) Optional You can install some optional packages to be able to use some well-known machine learning estimators that are not provided by sklearn but are among ATOM's predefined models . Install them using pip install atom-ml[models] . catboost (>=1.0.4) lightgbm (>=3.3.2) xgboost (>=1.6.0) Development The development dependencies are not installed with the package, and are not required for any of its functionalities. These libraries are only necessary to contribute to the project. Install them using pip install atom-ml[dev] . Linting isort (>=5.10.1) flake8 (>=5.0.4) flake8-pyproject (>=1.1.0) Testing pytest (>=7.1.0) pytest-cov (>=3.0.0) Documentation mike (>=1.1.2) mkdocs (>=1.2.3) mkdocs-autorefs (>=0.4.1) mkdocs-jupyter (>=0.22.0) mkdocs-material (>=8.5.3) mkdocs-simple-hooks (>=0.1.5) pyyaml (>=6.0)", "title": "Dependencies"}, {"location": "dependencies/#dependencies", "text": "", "title": "Dependencies"}, {"location": "dependencies/#python-os", "text": "As of the moment, ATOM supports the following Python versions: Python 3.8 Python 3.9 Python 3.10 And operating systems: Linux (Ubuntu, Fedora, etc...) Windows 8.1+ macOS (not tested)", "title": "Python &amp; OS"}, {"location": "dependencies/#packages", "text": "", "title": "Packages"}, {"location": "dependencies/#required", "text": "ATOM is built on top of several existing Python libraries. These packages are necessary for its correct functioning. category-encoders (>=2.4.1) explainerdashboard (>=0.4.0) dill (>=0.3.5) evalml (>=0.62.0) gplearn (>=0.4.1) gradio (>=3.3.1) imbalanced-learn (>=0.9.0) featuretools (>=1.14.0) joblib (>=1.1.0, <1.2.0) matplotlib (>=3.5.0, <3.6.0) mlflow (>=2.0.1) nltk (>=3.7) numpy (>=1.22) optuna (>=3.0.0) pandas (>=1.3.5) pandas-profiling (>=3.5.0) plotly (>=5.10.0) shap (>=0.41) schemdraw (>=0.14) scikit-learn (>=1.1.0) scikit-learn-intelex (>=2021.6.3) scipy (>=1.8.1) typeguard (>=2.13) wordcloud (>=1.8.1) zoofs (>=0.1.24)", "title": "Required"}, {"location": "dependencies/#optional", "text": "You can install some optional packages to be able to use some well-known machine learning estimators that are not provided by sklearn but are among ATOM's predefined models . Install them using pip install atom-ml[models] . catboost (>=1.0.4) lightgbm (>=3.3.2) xgboost (>=1.6.0)", "title": "Optional"}, {"location": "dependencies/#development", "text": "The development dependencies are not installed with the package, and are not required for any of its functionalities. These libraries are only necessary to contribute to the project. Install them using pip install atom-ml[dev] . Linting isort (>=5.10.1) flake8 (>=5.0.4) flake8-pyproject (>=1.1.0) Testing pytest (>=7.1.0) pytest-cov (>=3.0.0) Documentation mike (>=1.1.2) mkdocs (>=1.2.3) mkdocs-autorefs (>=0.4.1) mkdocs-jupyter (>=0.22.0) mkdocs-material (>=8.5.3) mkdocs-simple-hooks (>=0.1.5) pyyaml (>=6.0)", "title": "Development"}, {"location": "faq/", "text": "Frequently asked questions Here we try to give answers to some questions that have popped up regularly. If you have any other questions, don't hesitate to create a new discussion or post them on the Slack channel ! ??? faq Is this package related to the Atom text editor?\" There is, indeed, a text editor with the same name and a similar logo as this package. Is this a shameless copy? No. When I started the project, I didn't know about the text editor, and it doesn't require much thinking to come up with the idea of replacing the letter O of the word atom with the image of an atom. How does ATOM relate to AutoML? ATOM is not an AutoML tool since it does not automate the search for an optimal pipeline like well known AutoML tools such as auto-sklearn or EvalML do. Instead, ATOM helps the user find the optimal pipeline himself. One of the goals of this package is to help data scientists produce explainable pipelines, and using an AutoML black box function would impede that. That said, it is possible to integrate a EvalML pipeline with atom through the automl method. Is it possible to run deep learning models? Yes. Deep learning models can be added as custom models to the pipeline as long as they follow sklearn's API . For more information, see the deep learning section of the user guide. Can I run atom's methods on just a subset of the columns? Yes, all data cleaning and feature engineering methods accept a columns parameter to only transform the selected features. For example, to only impute the numerical columns in the dataset we could type atom.impute(strat_num=\"mean\", columns=atom.numerical) . The parameter accepts column names, column indices, dtypes or a slice object. How can I compare the same model on different datasets? In many occasions you might want to test how a model performs on datasets processed with different pipelines. For this, atom has the branch system . Create a new branch for every new pipeline you want to test and use the plot methods to compare all models, independent of the branch it was trained on. Can I train models through atom using a GPU? Yes. Refer to the user guide to see what algorithms and models have a GPU implementation. Be aware that it requires additional software and hardware dependencies. How are numerical and categorical columns differentiated? The columns are separated using a dataframe's select_dtypes method. Numerical columns are selected using include=\"number\" whereas categorical columns are selected using exclude=\"number\" . Can I run unsupervised learning pipelines? No. As for now, ATOM only supports supervised machine learning pipelines. However, various unsupervised algorithms can be chosen as strategy in the Pruner class to detect and remove outliers from the dataset. Is there a way to plot multiple models in the same shap plot? No. Unfortunately, there is no way to plot multiple models in the same shap plot since the plots are made by the shap package and passed as matplotlib.axes objects to atom. This means that it's not within the reach of this package to implement such a utility. Can I merge a sklearn pipeline with atom? Yes. Like any other transformer, it is possible to add a sklearn pipeline to atom using the add method. Every transformer in the pipeline is merged independently. The pipeline is not allowed to end with a model since atom manages its own models. If that is the case, add the pipeline using atom.add(pipeline[:-1]) . Is it possible to initialize atom with an existing train and test set? Yes. If you already have a separated train and test set you can initialize atom in two ways: atom = ATOMClassifier(train, test) atom = ATOMClassifier((X_train, y_train), (X_test, y_test)) Make sure the train and test size have the same number of columns! If atom is initialized in any of these two ways, the test_size parameter is ignored. Can I train the models using cross-validation? Applying cross-validation means transforming every step of the pipeline multiple times, each with different results. Doing this would prevent ATOM from being able to show the transformation results after every pre-processing step, which means losing the ability to inspect how a transformer changed the dataset. For this reason, it is not possible to apply cross-validation until after a model has been trained. After a model has been trained, the pipeline is defined, and cross-validation can be applied using the cross_validate method. See here an example using cross-validation. Is there a way to process datetime features? Yes, the FeatureExtractor class can automatically extract useful features (day, month, year, etc...) from datetime columns. The extracted features are always encoded to numerical values, so they can be fed directly to a model.", "title": "FAQ"}, {"location": "faq/#frequently-asked-questions", "text": "Here we try to give answers to some questions that have popped up regularly. If you have any other questions, don't hesitate to create a new discussion or post them on the Slack channel ! ??? faq Is this package related to the Atom text editor?\" There is, indeed, a text editor with the same name and a similar logo as this package. Is this a shameless copy? No. When I started the project, I didn't know about the text editor, and it doesn't require much thinking to come up with the idea of replacing the letter O of the word atom with the image of an atom. How does ATOM relate to AutoML? ATOM is not an AutoML tool since it does not automate the search for an optimal pipeline like well known AutoML tools such as auto-sklearn or EvalML do. Instead, ATOM helps the user find the optimal pipeline himself. One of the goals of this package is to help data scientists produce explainable pipelines, and using an AutoML black box function would impede that. That said, it is possible to integrate a EvalML pipeline with atom through the automl method. Is it possible to run deep learning models? Yes. Deep learning models can be added as custom models to the pipeline as long as they follow sklearn's API . For more information, see the deep learning section of the user guide. Can I run atom's methods on just a subset of the columns? Yes, all data cleaning and feature engineering methods accept a columns parameter to only transform the selected features. For example, to only impute the numerical columns in the dataset we could type atom.impute(strat_num=\"mean\", columns=atom.numerical) . The parameter accepts column names, column indices, dtypes or a slice object. How can I compare the same model on different datasets? In many occasions you might want to test how a model performs on datasets processed with different pipelines. For this, atom has the branch system . Create a new branch for every new pipeline you want to test and use the plot methods to compare all models, independent of the branch it was trained on. Can I train models through atom using a GPU? Yes. Refer to the user guide to see what algorithms and models have a GPU implementation. Be aware that it requires additional software and hardware dependencies. How are numerical and categorical columns differentiated? The columns are separated using a dataframe's select_dtypes method. Numerical columns are selected using include=\"number\" whereas categorical columns are selected using exclude=\"number\" . Can I run unsupervised learning pipelines? No. As for now, ATOM only supports supervised machine learning pipelines. However, various unsupervised algorithms can be chosen as strategy in the Pruner class to detect and remove outliers from the dataset. Is there a way to plot multiple models in the same shap plot? No. Unfortunately, there is no way to plot multiple models in the same shap plot since the plots are made by the shap package and passed as matplotlib.axes objects to atom. This means that it's not within the reach of this package to implement such a utility. Can I merge a sklearn pipeline with atom? Yes. Like any other transformer, it is possible to add a sklearn pipeline to atom using the add method. Every transformer in the pipeline is merged independently. The pipeline is not allowed to end with a model since atom manages its own models. If that is the case, add the pipeline using atom.add(pipeline[:-1]) . Is it possible to initialize atom with an existing train and test set? Yes. If you already have a separated train and test set you can initialize atom in two ways: atom = ATOMClassifier(train, test) atom = ATOMClassifier((X_train, y_train), (X_test, y_test)) Make sure the train and test size have the same number of columns! If atom is initialized in any of these two ways, the test_size parameter is ignored. Can I train the models using cross-validation? Applying cross-validation means transforming every step of the pipeline multiple times, each with different results. Doing this would prevent ATOM from being able to show the transformation results after every pre-processing step, which means losing the ability to inspect how a transformer changed the dataset. For this reason, it is not possible to apply cross-validation until after a model has been trained. After a model has been trained, the pipeline is defined, and cross-validation can be applied using the cross_validate method. See here an example using cross-validation. Is there a way to process datetime features? Yes, the FeatureExtractor class can automatically extract useful features (day, month, year, etc...) from datetime columns. The extracted features are always encoded to numerical values, so they can be fed directly to a model.", "title": "Frequently asked questions"}, {"location": "getting_started/", "text": "Getting started Installation Install ATOM's newest release easily via pip : pip install -U atom-ml or via conda : conda install -c conda-forge atom-ml Note Since atom was already taken, download the package under the name atom-ml ! Optional dependencies To install the optional dependencies , add [models] after the package's name. pip install -U atom-ml[models] Latest source Sometimes, new features and bug fixes are already implemented in the development branch, but waiting for the next release to be made available. If you can't wait for that, it's possible to install the package directly from git. pip install git+https://github.com/tvdboom/ATOM.git@development#egg=atom-ml Don't forget to include #egg=atom-ml to explicitly name the project, this way pip can track metadata for it without having to have run the setup.py script. Contributing If you are planning to contribute to the project, you'll need the development dependencies . Install them adding [dev] after the package's name. pip install -U atom-ml[dev] Click here for a complete list of package files for all versions published on PyPI. Usage ATOM contains a variety of classes and functions to perform data cleaning, feature engineering, model training, plotting and much more. The easiest way to use everything ATOM has to offer is through one of the main classes: ATOMClassifier for binary or multiclass classification tasks. ATOMRegressor for regression tasks. Let's walk you through an example. Click on the SageMaker Studio Lab badge on top of this section to run this example yourself. Make the necessary imports and load the data. >>> import pandas as pd >>> from atom import ATOMClassifier >>> # Load the Australian Weather dataset >>> X = pd . read_csv ( \"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\" ) >>> print ( X ) Location MinTemp MaxTemp ... Temp9am Temp3pm RainToday 0 MelbourneAirport 18.0 26.9 ... 18.5 26.0 Yes 1 Adelaide 17.2 23.4 ... 17.7 21.9 No 2 Cairns 18.6 24.6 ... 20.8 24.1 Yes 3 Portland 13.6 16.8 ... 15.6 16.0 Yes 4 Walpole 16.4 19.9 ... 17.4 18.1 No .. ... ... ... ... ... ... ... 995 Hobart 12.6 21.8 ... 18.0 18.7 No 996 PerthAirport 7.1 20.0 ... 14.3 19.7 No 997 WaggaWagga 10.0 25.9 ... 17.0 24.2 No 998 Albany 12.9 17.4 ... 15.6 16.8 No 999 Mildura -1.0 14.9 ... 4.1 14.5 No [1000 rows x 21 columns] Initialize the ATOMClassifier or ATOMRegressor class. These two classes are convenient wrappers for the whole machine learning pipeline. Contrary to sklearn's API, they are initialized providing the data you want to manipulate. You can either let atom split the dataset into a train and test set or provide the sets yourself. >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1000 , verbose = 2 ) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (1000, 22) Memory: 434.38 kB Scaled: False Missing values: 2131 (9.7%) Categorical features: 5 (23.8%) ------------------------------------- Train set size: 800 Test set size: 200 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 775 (3.4) | 620 (3.4) | 155 (3.4) | | 1 | 225 (1.0) | 180 (1.0) | 45 (1.0) | Data transformations are applied through atom's methods. For example, calling the impute method will initialize an Imputer instance, fit it on the training set and transform the whole dataset. The transformations are applied immediately after calling the method (no fit and transform commands necessary). >>> atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" ) >>> atom . encode ( strategy = \"LeaveOneOut\" , max_onehot = 8 ) Fitting Imputer... Imputing missing values... --> Imputing 1 missing values with median (12.0) in feature MinTemp. --> Imputing 2 missing values with median (22.8) in feature MaxTemp. --> Imputing 5 missing values with median (0.0) in feature Rainfall. --> Imputing 430 missing values with median (4.6) in feature Evaporation. --> Imputing 453 missing values with median (8.2) in feature Sunshine. --> Imputing 65 missing values with most_frequent (W) in feature WindGustDir. --> Imputing 65 missing values with median (39.0) in feature WindGustSpeed. --> Imputing 63 missing values with most_frequent (N) in feature WindDir9am. --> Imputing 24 missing values with most_frequent (WSW) in feature WindDir3pm. --> Imputing 8 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 19 missing values with median (19.0) in feature WindSpeed3pm. --> Imputing 10 missing values with median (70.0) in feature Humidity9am. --> Imputing 19 missing values with median (53.0) in feature Humidity3pm. --> Imputing 94 missing values with median (1017.4) in feature Pressure9am. --> Imputing 96 missing values with median (1015.15) in feature Pressure3pm. --> Imputing 369 missing values with median (6.0) in feature Cloud9am. --> Imputing 386 missing values with median (5.0) in feature Cloud3pm. --> Imputing 3 missing values with median (16.8) in feature Temp9am. --> Imputing 14 missing values with median (21.2) in feature Temp3pm. --> Imputing 5 missing values with most_frequent (No) in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 49 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. Similarly, models are trained and evaluated using the run method. Here, we fit both a LinearDiscriminantAnalysis and AdaBoost model, and apply hyperparameter tuning . >>> atom . run ( models = [ \"LDA\" , \"AdaB\" ], metric = \"auc\" , n_trials = 10 ) Training ========================= >> Models: LDA, AdaB Metric: roc_auc Running hyperparameter tuning for LinearDiscriminantAnalysis... | trial | solver | shrinkage | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | eigen | auto | 0.7888 | 0.7888 | 0.156s | 0.156s | COMPLETE | | 1 | lsqr | 0.9 | 0.7988 | 0.7988 | 0.141s | 0.297s | COMPLETE | | 2 | lsqr | 1.0 | 0.8125 | 0.8125 | 0.141s | 0.438s | COMPLETE | | 3 | lsqr | 0.6 | 0.858 | 0.858 | 0.125s | 0.563s | COMPLETE | | 4 | eigen | 1.0 | 0.782 | 0.858 | 0.125s | 0.688s | COMPLETE | | 5 | lsqr | 0.8 | 0.8396 | 0.858 | 0.141s | 0.828s | COMPLETE | | 6 | svd | --- | 0.7968 | 0.858 | 0.141s | 0.969s | COMPLETE | | 7 | lsqr | 0.7 | 0.8208 | 0.858 | 0.125s | 1.094s | COMPLETE | | 8 | eigen | 0.9 | 0.8548 | 0.858 | 0.141s | 1.234s | COMPLETE | | 9 | eigen | 0.7 | 0.8401 | 0.858 | 0.125s | 1.359s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> solver: lsqr --> shrinkage: 0.6 Best evaluation --> roc_auc: 0.858 Time elapsed: 1.359s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.8321 Test evaluation --> roc_auc: 0.8668 Time elapsed: 0.016s ------------------------------------------------- Total time: 1.375s Running hyperparameter tuning for AdaBoost... | trial | n_estimators | learning_rate | algorithm | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------------ | ------------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | 480 | 1.6346 | SAMME | 0.744 | 0.744 | 0.734s | 0.734s | COMPLETE | | 1 | 410 | 6.7512 | SAMME | 0.3454 | 0.744 | 0.125s | 0.859s | COMPLETE | | 2 | 480 | 7.4271 | SAMME.R | 0.3513 | 0.744 | 0.788s | 1.648s | COMPLETE | | 3 | 460 | 0.0238 | SAMME.R | 0.8365 | 0.8365 | 0.799s | 2.447s | COMPLETE | | 4 | 400 | 1.8333 | SAMME.R | 0.6328 | 0.8365 | 0.672s | 3.118s | COMPLETE | | 5 | 420 | 6.7105 | SAMME.R | 0.3772 | 0.8365 | 0.694s | 3.813s | COMPLETE | | 6 | 240 | 0.358 | SAMME.R | 0.7413 | 0.8365 | 0.469s | 4.282s | COMPLETE | | 7 | 320 | 0.2011 | SAMME | 0.8418 | 0.8418 | 0.531s | 4.813s | COMPLETE | | 8 | 260 | 0.1667 | SAMME | 0.808 | 0.8418 | 0.454s | 5.267s | COMPLETE | | 9 | 450 | 0.0464 | SAMME | 0.8001 | 0.8418 | 0.688s | 5.954s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 7 Best parameters: --> n_estimators: 320 --> learning_rate: 0.2011 --> algorithm: SAMME Best evaluation --> roc_auc: 0.8418 Time elapsed: 5.954s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9087 Test evaluation --> roc_auc: 0.7987 Time elapsed: 0.453s ------------------------------------------------- Total time: 6.407s Final results ==================== >> Total time: 8.017s ------------------------------------- LinearDiscriminantAnalysis --> roc_auc: 0.8668 ! AdaBoost --> roc_auc: 0.7987 And lastly, analyze the results. >>> atom . evaluate () accuracy average_precision ... recall roc_auc LDA 0.850 0.6893 ... 0.5333 0.8668 AdaB 0.825 0.6344 ... 0.3556 0.7987 [2 rows x 9 columns]", "title": "Getting started"}, {"location": "getting_started/#getting-started", "text": "", "title": "Getting started"}, {"location": "getting_started/#installation", "text": "Install ATOM's newest release easily via pip : pip install -U atom-ml or via conda : conda install -c conda-forge atom-ml Note Since atom was already taken, download the package under the name atom-ml ! Optional dependencies To install the optional dependencies , add [models] after the package's name. pip install -U atom-ml[models] Latest source Sometimes, new features and bug fixes are already implemented in the development branch, but waiting for the next release to be made available. If you can't wait for that, it's possible to install the package directly from git. pip install git+https://github.com/tvdboom/ATOM.git@development#egg=atom-ml Don't forget to include #egg=atom-ml to explicitly name the project, this way pip can track metadata for it without having to have run the setup.py script. Contributing If you are planning to contribute to the project, you'll need the development dependencies . Install them adding [dev] after the package's name. pip install -U atom-ml[dev] Click here for a complete list of package files for all versions published on PyPI.", "title": "Installation"}, {"location": "getting_started/#usage", "text": "ATOM contains a variety of classes and functions to perform data cleaning, feature engineering, model training, plotting and much more. The easiest way to use everything ATOM has to offer is through one of the main classes: ATOMClassifier for binary or multiclass classification tasks. ATOMRegressor for regression tasks. Let's walk you through an example. Click on the SageMaker Studio Lab badge on top of this section to run this example yourself. Make the necessary imports and load the data. >>> import pandas as pd >>> from atom import ATOMClassifier >>> # Load the Australian Weather dataset >>> X = pd . read_csv ( \"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\" ) >>> print ( X ) Location MinTemp MaxTemp ... Temp9am Temp3pm RainToday 0 MelbourneAirport 18.0 26.9 ... 18.5 26.0 Yes 1 Adelaide 17.2 23.4 ... 17.7 21.9 No 2 Cairns 18.6 24.6 ... 20.8 24.1 Yes 3 Portland 13.6 16.8 ... 15.6 16.0 Yes 4 Walpole 16.4 19.9 ... 17.4 18.1 No .. ... ... ... ... ... ... ... 995 Hobart 12.6 21.8 ... 18.0 18.7 No 996 PerthAirport 7.1 20.0 ... 14.3 19.7 No 997 WaggaWagga 10.0 25.9 ... 17.0 24.2 No 998 Albany 12.9 17.4 ... 15.6 16.8 No 999 Mildura -1.0 14.9 ... 4.1 14.5 No [1000 rows x 21 columns] Initialize the ATOMClassifier or ATOMRegressor class. These two classes are convenient wrappers for the whole machine learning pipeline. Contrary to sklearn's API, they are initialized providing the data you want to manipulate. You can either let atom split the dataset into a train and test set or provide the sets yourself. >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1000 , verbose = 2 ) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (1000, 22) Memory: 434.38 kB Scaled: False Missing values: 2131 (9.7%) Categorical features: 5 (23.8%) ------------------------------------- Train set size: 800 Test set size: 200 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 775 (3.4) | 620 (3.4) | 155 (3.4) | | 1 | 225 (1.0) | 180 (1.0) | 45 (1.0) | Data transformations are applied through atom's methods. For example, calling the impute method will initialize an Imputer instance, fit it on the training set and transform the whole dataset. The transformations are applied immediately after calling the method (no fit and transform commands necessary). >>> atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" ) >>> atom . encode ( strategy = \"LeaveOneOut\" , max_onehot = 8 ) Fitting Imputer... Imputing missing values... --> Imputing 1 missing values with median (12.0) in feature MinTemp. --> Imputing 2 missing values with median (22.8) in feature MaxTemp. --> Imputing 5 missing values with median (0.0) in feature Rainfall. --> Imputing 430 missing values with median (4.6) in feature Evaporation. --> Imputing 453 missing values with median (8.2) in feature Sunshine. --> Imputing 65 missing values with most_frequent (W) in feature WindGustDir. --> Imputing 65 missing values with median (39.0) in feature WindGustSpeed. --> Imputing 63 missing values with most_frequent (N) in feature WindDir9am. --> Imputing 24 missing values with most_frequent (WSW) in feature WindDir3pm. --> Imputing 8 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 19 missing values with median (19.0) in feature WindSpeed3pm. --> Imputing 10 missing values with median (70.0) in feature Humidity9am. --> Imputing 19 missing values with median (53.0) in feature Humidity3pm. --> Imputing 94 missing values with median (1017.4) in feature Pressure9am. --> Imputing 96 missing values with median (1015.15) in feature Pressure3pm. --> Imputing 369 missing values with median (6.0) in feature Cloud9am. --> Imputing 386 missing values with median (5.0) in feature Cloud3pm. --> Imputing 3 missing values with median (16.8) in feature Temp9am. --> Imputing 14 missing values with median (21.2) in feature Temp3pm. --> Imputing 5 missing values with most_frequent (No) in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 49 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. Similarly, models are trained and evaluated using the run method. Here, we fit both a LinearDiscriminantAnalysis and AdaBoost model, and apply hyperparameter tuning . >>> atom . run ( models = [ \"LDA\" , \"AdaB\" ], metric = \"auc\" , n_trials = 10 ) Training ========================= >> Models: LDA, AdaB Metric: roc_auc Running hyperparameter tuning for LinearDiscriminantAnalysis... | trial | solver | shrinkage | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | eigen | auto | 0.7888 | 0.7888 | 0.156s | 0.156s | COMPLETE | | 1 | lsqr | 0.9 | 0.7988 | 0.7988 | 0.141s | 0.297s | COMPLETE | | 2 | lsqr | 1.0 | 0.8125 | 0.8125 | 0.141s | 0.438s | COMPLETE | | 3 | lsqr | 0.6 | 0.858 | 0.858 | 0.125s | 0.563s | COMPLETE | | 4 | eigen | 1.0 | 0.782 | 0.858 | 0.125s | 0.688s | COMPLETE | | 5 | lsqr | 0.8 | 0.8396 | 0.858 | 0.141s | 0.828s | COMPLETE | | 6 | svd | --- | 0.7968 | 0.858 | 0.141s | 0.969s | COMPLETE | | 7 | lsqr | 0.7 | 0.8208 | 0.858 | 0.125s | 1.094s | COMPLETE | | 8 | eigen | 0.9 | 0.8548 | 0.858 | 0.141s | 1.234s | COMPLETE | | 9 | eigen | 0.7 | 0.8401 | 0.858 | 0.125s | 1.359s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> solver: lsqr --> shrinkage: 0.6 Best evaluation --> roc_auc: 0.858 Time elapsed: 1.359s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.8321 Test evaluation --> roc_auc: 0.8668 Time elapsed: 0.016s ------------------------------------------------- Total time: 1.375s Running hyperparameter tuning for AdaBoost... | trial | n_estimators | learning_rate | algorithm | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------------ | ------------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | 480 | 1.6346 | SAMME | 0.744 | 0.744 | 0.734s | 0.734s | COMPLETE | | 1 | 410 | 6.7512 | SAMME | 0.3454 | 0.744 | 0.125s | 0.859s | COMPLETE | | 2 | 480 | 7.4271 | SAMME.R | 0.3513 | 0.744 | 0.788s | 1.648s | COMPLETE | | 3 | 460 | 0.0238 | SAMME.R | 0.8365 | 0.8365 | 0.799s | 2.447s | COMPLETE | | 4 | 400 | 1.8333 | SAMME.R | 0.6328 | 0.8365 | 0.672s | 3.118s | COMPLETE | | 5 | 420 | 6.7105 | SAMME.R | 0.3772 | 0.8365 | 0.694s | 3.813s | COMPLETE | | 6 | 240 | 0.358 | SAMME.R | 0.7413 | 0.8365 | 0.469s | 4.282s | COMPLETE | | 7 | 320 | 0.2011 | SAMME | 0.8418 | 0.8418 | 0.531s | 4.813s | COMPLETE | | 8 | 260 | 0.1667 | SAMME | 0.808 | 0.8418 | 0.454s | 5.267s | COMPLETE | | 9 | 450 | 0.0464 | SAMME | 0.8001 | 0.8418 | 0.688s | 5.954s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 7 Best parameters: --> n_estimators: 320 --> learning_rate: 0.2011 --> algorithm: SAMME Best evaluation --> roc_auc: 0.8418 Time elapsed: 5.954s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9087 Test evaluation --> roc_auc: 0.7987 Time elapsed: 0.453s ------------------------------------------------- Total time: 6.407s Final results ==================== >> Total time: 8.017s ------------------------------------- LinearDiscriminantAnalysis --> roc_auc: 0.8668 ! AdaBoost --> roc_auc: 0.7987 And lastly, analyze the results. >>> atom . evaluate () accuracy average_precision ... recall roc_auc LDA 0.850 0.6893 ... 0.5333 0.8668 AdaB 0.825 0.6344 ... 0.3556 0.7987 [2 rows x 9 columns]", "title": "Usage"}, {"location": "license/", "text": "MIT License Copyright \u00a9 2022 Mavs Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "title": "License"}, {"location": "license/#mit-license", "text": "Copyright \u00a9 2022 Mavs Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "title": "MIT License"}, {"location": "API/ATOM/atomclassifier/", "text": "ATOMClassifier class atom.api. ATOMClassifier (*arrays, y=-1, index=False, shuffle=True, stratify=True, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Main class for binary and multiclass classification tasks. Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains. All data cleaning , feature engineering , model training and plotting functionality can be accessed from an instance of this class. Parameters *arrays: sequence of indexables Dataset containing features and target. Allowed formats are: X X, y train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) X, train, test: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. y: int, str or sequence, default=-1 Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. This parameter is ignored if the target column is provided through arrays . index: bool, int, str or sequence, default=False Handle the index in the resulting dataframe. If False: Reset to RangeIndex . If True: Use the provided index. If int: Position of the column to use as index. If str: Name of the column to use as index. If sequence: Array with shape=(n_samples,) to use as index. test_size: int or float, default=0.2 If <=1: Fraction of the dataset to include in the test set. If >1: Number of rows to include in the test set. This parameter is ignored if the test set is provided through arrays . holdout_size: int, float or None, default=None If None: No holdout data set is kept apart. If <=1: Fraction of the dataset to include in the holdout set. If >1: Number of rows to include in the holdout set. This parameter is ignored if the holdout set is provided through arrays . shuffle: bool, default=True Whether to shuffle the dataset before splitting the train and test set. Be aware that not shuffling the dataset can cause an unequal distribution of target classes over the sets. stratify: bool, int, str or sequence, default=True Handle stratification of the target classes over the data sets. If False: The data is split randomly. If True: The data is stratified over the target column. Else: Name or position of the columns to stratify by. The columns can't contain NaN values. This parameter is ignored if shuffle=False or if the test set is provided through arrays . n_rows: int or float, default=1 Random subsample of the dataset to use. The default value selects all rows. If <=1: Fraction of the dataset to select. If >1: Exact number of rows to select. Only if arrays is X or X, y. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Initialize atom >>> atom = ATOMClassifier ( X , y , logger = \"auto\" , n_jobs = 2 , verbose = 2 ) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 2 cores. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 160 (1.1%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | >>> # Apply data cleaning and feature engineering methods >>> atom . balance ( strategy = \"smote\" ) Oversampling with SMOTE... --> Adding 116 samples to class 0. >>> atom . feature_selection ( strategy = \"rfecv\" , solver = \"xgb\" , n_features = 22 ) Fitting FeatureSelector... Performing feature selection ... --> RFECV selected 26 features from the dataset. --> Dropping feature mean perimeter (rank 4). --> Dropping feature mean symmetry (rank 3). --> Dropping feature perimeter error (rank 2). --> Dropping feature worst compactness (rank 5). >>> # Train models >>> atom . run ( ... models = [ \"LR\" , \"RF\" , \"XGB\" ], ... metric = \"precision\" , ... n_bootstrap = 4 , ... ) Training ========================= >> Models: LR, RF, XGB Metric: precision Results for Logistic Regression: Fit --------------------------------------------- Train evaluation --> precision: 0.9895 Test evaluation --> precision: 0.9467 Time elapsed: 0.028s ------------------------------------------------- Total time: 0.028s Results for Random Forest: Fit --------------------------------------------- Train evaluation --> precision: 1.0 Test evaluation --> precision: 0.9221 Time elapsed: 0.181s ------------------------------------------------- Total time: 0.181s Results for XGBoost: Fit --------------------------------------------- Train evaluation --> precision: 1.0 Test evaluation --> precision: 0.9091 Time elapsed: 0.124s ------------------------------------------------- Total time: 0.124s Final results ==================== >> Total time: 0.333s ------------------------------------- Logistic Regression --> precision: 0.9467 ! Random Forest --> precision: 0.9221 XGBoost --> precision: 0.9091 >>> # Analyze the results >>> atom . evaluate () accuracy average_precision ... recall roc_auc LR 0.970588 0.995739 ... 0.981308 0.993324 RF 0.958824 0.982602 ... 0.962617 0.983459 XGB 0.964706 0.996047 ... 0.971963 0.993473 [3 rows x 9 columns] Magic methods The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch. __repr__: Prints an overview of atom's branches, models, metric and errors. __len__: Returns the length of the dataset. __iter__: Iterate over the pipeline's transformers. __contains__: Checks if the provided item is a column in the dataset. __getitem__: Access a branch, model, column or subset of the dataset. Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes pipeline: pd.Series Transformers fitted on the data. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. scaled: bool Whether the feature set is scaled. A data set is considered scaled when it has mean=0 and std=1, or when atom has a scaler in the pipeline. Returns None for sparse datasets . duplicates: pd.Series Number of duplicate rows in the dataset. missing: list Values that are considered \"missing\". These values are used by the clean and impute methods. Default values are: None, NaN, +inf, -inf, \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None, NaN, +inf and -inf are always considered missing since they are incompatible with sklearn estimators. nans: pd.Series Columns with the number of missing values in them. n_nans: int Number of samples containing missing values. numerical: pd.Series Names of the numerical features in the dataset. n_numerical: int Number of numerical features in the dataset. categorical: pd.Series Names of the categorical features in the dataset. n_categorical: int Number of categorical features in the dataset. outliers: pd.Series Columns in training set with amount of outlier values. n_outliers: int Number of samples in the training set containing outliers. classes: pd.DataFrame Distribution of target classes per data set. n_classes: int Number of classes in the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes branch: Branch Current active branch. Use the property's @setter to change from current branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use __from__ to split the new branch from any other existing branch. Read more in the user guide . models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Utility methods Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline. add Add a transformer to the pipeline. apply Apply a function to the dataset. automl Search for an optimized pipeline in an automated fashion. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. distribution Get statistics on column distributions. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. inverse_transform Inversely transform new data through the pipeline. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. report Create an extensive profile analysis report of the data. reset Reset the instance to it's initial state. reset_aesthetics Reset the plot aesthetics to their default values. save Save the instance to a pickle file. save_data Save the data in the current branch to a .csv file. shrink Converts the columns to the smallest possible matching dtype. stacking Add a Stacking model to the pipeline. stats Print basic information about the dataset. status Get an overview of the branches and models. transform Transform new data through the pipeline. voting Add a Voting model to the pipeline. method add (transformer, columns=None, train_only=False, **fit_params) [source] Add a transformer to the pipeline. If the transformer is not fitted, it is fitted on the complete training set. Afterwards, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom. Warning The transformer should have fit and/or transform methods with arguments X (accepting a dataframe-like object of shape=(n_samples, n_features)) and/or y (accepting a sequence of shape=(n_samples,)). The transform method should return a feature set as a dataframe-like object of shape=(n_samples, n_features) and/or a target column as a sequence of shape=(n_samples,). Note If the transform method doesn't return a dataframe: The column naming happens as follows. If the transformer has a get_feature_names or get_feature_names_out method, it is used. If not, and it returns the same number of columns, the names are kept equal. If the number of columns change, old columns will keep their name (as long as the column is unchanged) and new columns will receive the name x[N-1] , where N stands for the n-th feature. This means that a transformer should only transform, add or drop columns, not combinations of these. The index remains the same as before the transformation. This means that the transformer should not add, remove or shuffle rows unless it returns a dataframe. Note If the transformer has a n_jobs and/or random_state parameter that is left to its default value, it adopts atom's value. Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a transform method. columns: int, str, slice, sequence or None, default=None Names, indices or dtypes of the columns in the dataset to transform. If None, transform all columns. Add ! in front of a name or dtype to exclude that column, e.g. atom.add(Transformer(), columns=\"!Location\") transforms all columns except Location`. You can either include or exclude columns, not combinations of these. The target column is always included if required by the transformer. train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. **fit_params Additional keyword arguments for the transformer's fit method. method apply (func, inverse_func=None, kw_args=None, inv_kw_args=None, **kwargs) [source] Apply a function to the dataset. The function should have signature func(dataset, **kw_args) -> dataset . This method is useful for stateless transformations such as taking the log, doing custom scaling, etc... Note This approach is preferred over changing the dataset directly through the property's @setter since the transformation is stored in the pipeline. Tip Use atom . apply ( lambda df : df . drop ( \"column_name\" , axis = 1 )) to store the removal of columns in the pipeline. Parameters func: callable Function to apply. inverse_func: callable or None, default=None Inverse function of func . If None, the inverse_transform method returns the input unchanged. kw_args: dict or None, default=None Additional keyword arguments for the function. inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. method automl (**kwargs) [source] Search for an optimized pipeline in an automated fashion. Automated machine learning (AutoML) automates the selection, composition and parameterization of machine learning pipelines. Automating the machine learning often provides faster, more accurate outputs than hand-coded algorithms. ATOM uses the evalML package for AutoML optimization. The resulting transformers and final estimator are merged with atom's pipeline (check the pipeline and models attributes after the method finishes running). The created AutoMLSearch instance can be accessed through the evalml attribute. Warning AutoML algorithms aren't intended to run for only a few minutes. The method may need a very long time to achieve optimal results. Parameters **kwargs Additional keyword arguments for the AutoMLSearch instance. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method distribution (distributions=None, columns=None) [source] Get statistics on column distributions. Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored. Tip Use the plot_distribution method to plot a column's distribution. Parameters distributions: str, sequence or None, default=None Names of the distributions in scipy.stats to get the statistics on. If None, a selection of the most common ones is used. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to perform the test on. If None, select all numerical columns. Returns pd.DataFrame Statistic results with multiindex levels: dist: Name of the distribution. stat: Statistic results: score: KS-test score. p_value: Corresponding p-value. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method report (dataset=\"dataset\", n_rows=None, filename=None, **kwargs) [source] Create an extensive profile analysis report of the data. ATOM uses the pandas-profiling package for the analysis. The report is rendered directly in the notebook. The created ProfileReport instance can be accessed through the profile attribute. Warning This method can be slow for large datasets. Parameters dataset: str, default=\"dataset\" Data set to get the report from. n_rows: int or None, default=None Number of (randomly picked) rows to process. None to use all rows. filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ProfileReport instance. method reset () [source] Reset the instance to it's initial state. Deletes all branches and models. The dataset is also reset to its form after initialization. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method save_data (filename=\"auto\", dataset=\"dataset\") [source] Save the data in the current branch to a .csv file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. dataset: str, default=\"dataset\" Data set to save. method shrink (obj2cat=True, int2uint=False, dense2sparse=False, columns=None) [source] Converts the columns to the smallest possible matching dtype. Parameters obj2cat: bool, default=True Whether to convert object to category . Only if the number of categories would be less than 30% of the length of the column. int2uint: bool, default=False Whether to convert int to uint (unsigned integer). Only if the values in the column are strictly positive. dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to shrink. If None, transform all columns. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method stats (_vb=-2) [source] Print basic information about the dataset. Tip For classification tasks, the count and balance of classes is shown, followed by the ratio (between parentheses) of the class with respect to the rest of the classes in the same data set, i.e. the class with the fewest samples is followed by (1.0) . This information can be used to quickly assess if the data set is unbalanced. Parameters _vb: int, default=-2 Internal parameter to always print if called by user. method status () [source] Get an overview of the branches and models. This method prints the same information as the __repr__ and also saves it to the logger. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance. Data cleaning The data cleaning methods can help you scale the data, handle missing values, categorical columns, outliers and unbalanced datasets. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide . Tip Use the report method to examine the data and help you determine suitable parameters for the data cleaning methods. balance Balance the number of rows per class in the target column. clean Applies standard data cleaning steps on the dataset. discretize Bin continuous data into intervals. encode Perform encoding of categorical features. impute Handle missing values in the dataset. normalize Transform the data to follow a Normal/Gaussian distribution. prune Prune outliers from the training set. scale Scale the data. method balance (strategy=\"adasyn\", **kwargs) [source] Balance the number of rows per class in the target column. When oversampling, the newly created samples have an increasing integer index for numerical indices, and an index of the form [estimator]_N for non-numerical indices, where N stands for the N-th sample in the data set. See the Balancer class for a description of the parameters. Note This transformation is only applied to the training set in order to maintain the original distribution of target classes in the test set. Tip Use atom's classes attribute for an overview of the target class distribution per data set. method clean (drop_types=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs) [source] Applies standard data cleaning steps on the dataset. Use the parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column (can't be True for regression tasks). See the Cleaner class for a description of the parameters. method discretize (strategy=\"quantile\", bins=5, labels=None, **kwargs) [source] Bin continuous data into intervals. For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns. See the Discretizer class for a description of the parameters. Tip Use the plot_distribution method to visualize a column's distribution and decide on the bins. method encode (strategy=\"LeaveOneOut\", max_onehot=10, ordinal=None, rare_to_value=None, value=\"rare\", **kwargs) [source] Perform encoding of categorical features. The encoding type depends on the number of classes in the column: If n_classes=2 or ordinal feature, use Ordinal-encoding. If 2 < n_classes <= max_onehot , use OneHot-encoding. If n_classes > max_onehot , use strategy -encoding. Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality. See the Encoder class for a description of the parameters. Note This method only encodes the categorical features. It does not encode the target column! Use the clean method for that. Tip Use the categorical attribute for a list of the categorical features in the dataset. method impute (strat_num=\"drop\", strat_cat=\"drop\", max_nan_rows=None, max_nan_cols=None, **kwargs) [source] Handle missing values in the dataset. Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the missing attribute to customize what are considered \"missing values\". See the Imputer class for a description of the parameters. Tip Use the nans attribute to check the amount of missing values per column. method normalize (strategy=\"yeojohnson\", **kwargs) [source] Transform the data to follow a Normal/Gaussian distribution. This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns. See the Normalizer class for a description of the parameters. Tip Use the plot_distribution method to examine a column's distribution. method prune (strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs) [source] Prune outliers from the training set. Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns. See the Pruner class for a description of the parameters. Note This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set. Tip Use the outliers attribute to check the number of outliers per column. method scale (strategy=\"standard\", include_binary=False, **kwargs) [source] Scale the data. Apply one of sklearn's scalers. Categorical columns are ignored. See the Scaler class for a description of the parameters. Tip Use the scaled attribute to check whether the dataset is scaled. NLP The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called corpus . Read more in the user guide . textclean Applies standard text cleaning to the corpus. textnormalize Normalize the corpus. tokenize Tokenize the corpus. vectorize Vectorize the corpus. method textclean (decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs) [source] Applies standard text cleaning to the corpus. Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. See the TextCleaner class for a description of the parameters. method textnormalize (stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs) [source] Normalize the corpus. Convert words to a more uniform standard. The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces. See the TextNormalizer class for a description of the parameters. method tokenize (bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs) [source] Tokenize the corpus. Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g. \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named corpus . If there is no column with that name, an exception is raised. See the Tokenizer class for a description of the parameters. method vectorize (strategy=\"bow\", return_sparse=True, **kwargs) [source] Vectorize the corpus. Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named corpus . If there is no column with that name, an exception is raised. If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix corpus_ . If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column. See the Vectorizer class for a description of the parameters. Feature engineering To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide . feature_extraction Extract features from datetime columns. feature_generation Generate new features. feature_grouping Extract statistics from similar features. feature_selection Reduce the number of features in the data. method feature_extraction (features=['day', 'month', 'year'], fmt=None, encoding_type=\"ordinal\", drop_columns=True, **kwargs) [source] Extract features from datetime columns. Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype datetime64 are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used. See the FeatureExtractor class for a description of the parameters. method feature_generation (strategy=\"dfs\", n_features=None, operators=None, **kwargs) [source] Generate new features. Create new combinations of existing features to capture the non-linear relations between the original features. See the FeatureGenerator class for a description of the parameters. method feature_grouping (group, name=None, operators=None, drop_columns=True, **kwargs) [source] Extract statistics from similar features. Replace groups of features with related characteristics with new features that summarize statistical properties of te group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the groups method. See the FeatureGrouper class for a description of the parameters. method feature_selection (strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs) [source] Reduce the number of features in the data. Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low variance features. See the FeatureSelector class for a description of the parameters. Note When strategy=\"univariate\" and solver=None, f_classif or f_regression is used as default solver. When strategy is \"sfs\", \"rfecv\" or any of the advanced strategies and no scoring is specified, atom's metric (if it exists) is used as scoring. Training The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide . run Train and evaluate the models in a direct fashion. successive_halving Fit the models in a successive halving fashion. train_sizing Train and evaluate the models in a train sizing fashion. method run (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a direct fashion. Contrary to successive_halving and train_sizing , the direct approach only iterates once over the models, using the full dataset. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the DirectClassifier or DirectRegressor class for a description of the parameters. method successive_halving (models, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Fit the models in a successive halving fashion. The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g. only using tree-based models. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters. method train_sizing (models, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a train sizing fashion. When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.", "title": "ATOMClassifier"}, {"location": "API/ATOM/atomclassifier/#atomclassifier", "text": "class atom.api. ATOMClassifier (*arrays, y=-1, index=False, shuffle=True, stratify=True, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Main class for binary and multiclass classification tasks. Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains. All data cleaning , feature engineering , model training and plotting functionality can be accessed from an instance of this class. Parameters *arrays: sequence of indexables Dataset containing features and target. Allowed formats are: X X, y train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) X, train, test: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. y: int, str or sequence, default=-1 Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. This parameter is ignored if the target column is provided through arrays . index: bool, int, str or sequence, default=False Handle the index in the resulting dataframe. If False: Reset to RangeIndex . If True: Use the provided index. If int: Position of the column to use as index. If str: Name of the column to use as index. If sequence: Array with shape=(n_samples,) to use as index. test_size: int or float, default=0.2 If <=1: Fraction of the dataset to include in the test set. If >1: Number of rows to include in the test set. This parameter is ignored if the test set is provided through arrays . holdout_size: int, float or None, default=None If None: No holdout data set is kept apart. If <=1: Fraction of the dataset to include in the holdout set. If >1: Number of rows to include in the holdout set. This parameter is ignored if the holdout set is provided through arrays . shuffle: bool, default=True Whether to shuffle the dataset before splitting the train and test set. Be aware that not shuffling the dataset can cause an unequal distribution of target classes over the sets. stratify: bool, int, str or sequence, default=True Handle stratification of the target classes over the data sets. If False: The data is split randomly. If True: The data is stratified over the target column. Else: Name or position of the columns to stratify by. The columns can't contain NaN values. This parameter is ignored if shuffle=False or if the test set is provided through arrays . n_rows: int or float, default=1 Random subsample of the dataset to use. The default value selects all rows. If <=1: Fraction of the dataset to select. If >1: Exact number of rows to select. Only if arrays is X or X, y. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks.", "title": "ATOMClassifier"}, {"location": "API/ATOM/atomclassifier/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Initialize atom >>> atom = ATOMClassifier ( X , y , logger = \"auto\" , n_jobs = 2 , verbose = 2 ) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 2 cores. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 160 (1.1%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | >>> # Apply data cleaning and feature engineering methods >>> atom . balance ( strategy = \"smote\" ) Oversampling with SMOTE... --> Adding 116 samples to class 0. >>> atom . feature_selection ( strategy = \"rfecv\" , solver = \"xgb\" , n_features = 22 ) Fitting FeatureSelector... Performing feature selection ... --> RFECV selected 26 features from the dataset. --> Dropping feature mean perimeter (rank 4). --> Dropping feature mean symmetry (rank 3). --> Dropping feature perimeter error (rank 2). --> Dropping feature worst compactness (rank 5). >>> # Train models >>> atom . run ( ... models = [ \"LR\" , \"RF\" , \"XGB\" ], ... metric = \"precision\" , ... n_bootstrap = 4 , ... ) Training ========================= >> Models: LR, RF, XGB Metric: precision Results for Logistic Regression: Fit --------------------------------------------- Train evaluation --> precision: 0.9895 Test evaluation --> precision: 0.9467 Time elapsed: 0.028s ------------------------------------------------- Total time: 0.028s Results for Random Forest: Fit --------------------------------------------- Train evaluation --> precision: 1.0 Test evaluation --> precision: 0.9221 Time elapsed: 0.181s ------------------------------------------------- Total time: 0.181s Results for XGBoost: Fit --------------------------------------------- Train evaluation --> precision: 1.0 Test evaluation --> precision: 0.9091 Time elapsed: 0.124s ------------------------------------------------- Total time: 0.124s Final results ==================== >> Total time: 0.333s ------------------------------------- Logistic Regression --> precision: 0.9467 ! Random Forest --> precision: 0.9221 XGBoost --> precision: 0.9091 >>> # Analyze the results >>> atom . evaluate () accuracy average_precision ... recall roc_auc LR 0.970588 0.995739 ... 0.981308 0.993324 RF 0.958824 0.982602 ... 0.962617 0.983459 XGB 0.964706 0.996047 ... 0.971963 0.993473 [3 rows x 9 columns]", "title": "Example"}, {"location": "API/ATOM/atomclassifier/#magic-methods", "text": "The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch. __repr__: Prints an overview of atom's branches, models, metric and errors. __len__: Returns the length of the dataset. __iter__: Iterate over the pipeline's transformers. __contains__: Checks if the provided item is a column in the dataset. __getitem__: Access a branch, model, column or subset of the dataset.", "title": "Magic methods"}, {"location": "API/ATOM/atomclassifier/#attributes", "text": "", "title": "Attributes"}, {"location": "API/ATOM/atomclassifier/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes pipeline: pd.Series Transformers fitted on the data. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. scaled: bool Whether the feature set is scaled. A data set is considered scaled when it has mean=0 and std=1, or when atom has a scaler in the pipeline. Returns None for sparse datasets . duplicates: pd.Series Number of duplicate rows in the dataset. missing: list Values that are considered \"missing\". These values are used by the clean and impute methods. Default values are: None, NaN, +inf, -inf, \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None, NaN, +inf and -inf are always considered missing since they are incompatible with sklearn estimators. nans: pd.Series Columns with the number of missing values in them. n_nans: int Number of samples containing missing values. numerical: pd.Series Names of the numerical features in the dataset. n_numerical: int Number of numerical features in the dataset. categorical: pd.Series Names of the categorical features in the dataset. n_categorical: int Number of categorical features in the dataset. outliers: pd.Series Columns in training set with amount of outlier values. n_outliers: int Number of samples in the training set containing outliers. classes: pd.DataFrame Distribution of target classes per data set. n_classes: int Number of classes in the target column.", "title": "Data attributes"}, {"location": "API/ATOM/atomclassifier/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes branch: Branch Current active branch. Use the property's @setter to change from current branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use __from__ to split the new branch from any other existing branch. Read more in the user guide . models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/ATOM/atomclassifier/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/ATOM/atomclassifier/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/ATOM/atomclassifier/#utility-methods", "text": "Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline. add Add a transformer to the pipeline. apply Apply a function to the dataset. automl Search for an optimized pipeline in an automated fashion. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. distribution Get statistics on column distributions. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. inverse_transform Inversely transform new data through the pipeline. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. report Create an extensive profile analysis report of the data. reset Reset the instance to it's initial state. reset_aesthetics Reset the plot aesthetics to their default values. save Save the instance to a pickle file. save_data Save the data in the current branch to a .csv file. shrink Converts the columns to the smallest possible matching dtype. stacking Add a Stacking model to the pipeline. stats Print basic information about the dataset. status Get an overview of the branches and models. transform Transform new data through the pipeline. voting Add a Voting model to the pipeline. method add (transformer, columns=None, train_only=False, **fit_params) [source] Add a transformer to the pipeline. If the transformer is not fitted, it is fitted on the complete training set. Afterwards, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom. Warning The transformer should have fit and/or transform methods with arguments X (accepting a dataframe-like object of shape=(n_samples, n_features)) and/or y (accepting a sequence of shape=(n_samples,)). The transform method should return a feature set as a dataframe-like object of shape=(n_samples, n_features) and/or a target column as a sequence of shape=(n_samples,). Note If the transform method doesn't return a dataframe: The column naming happens as follows. If the transformer has a get_feature_names or get_feature_names_out method, it is used. If not, and it returns the same number of columns, the names are kept equal. If the number of columns change, old columns will keep their name (as long as the column is unchanged) and new columns will receive the name x[N-1] , where N stands for the n-th feature. This means that a transformer should only transform, add or drop columns, not combinations of these. The index remains the same as before the transformation. This means that the transformer should not add, remove or shuffle rows unless it returns a dataframe. Note If the transformer has a n_jobs and/or random_state parameter that is left to its default value, it adopts atom's value. Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a transform method. columns: int, str, slice, sequence or None, default=None Names, indices or dtypes of the columns in the dataset to transform. If None, transform all columns. Add ! in front of a name or dtype to exclude that column, e.g. atom.add(Transformer(), columns=\"!Location\") transforms all columns except Location`. You can either include or exclude columns, not combinations of these. The target column is always included if required by the transformer. train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. **fit_params Additional keyword arguments for the transformer's fit method. method apply (func, inverse_func=None, kw_args=None, inv_kw_args=None, **kwargs) [source] Apply a function to the dataset. The function should have signature func(dataset, **kw_args) -> dataset . This method is useful for stateless transformations such as taking the log, doing custom scaling, etc... Note This approach is preferred over changing the dataset directly through the property's @setter since the transformation is stored in the pipeline. Tip Use atom . apply ( lambda df : df . drop ( \"column_name\" , axis = 1 )) to store the removal of columns in the pipeline. Parameters func: callable Function to apply. inverse_func: callable or None, default=None Inverse function of func . If None, the inverse_transform method returns the input unchanged. kw_args: dict or None, default=None Additional keyword arguments for the function. inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. method automl (**kwargs) [source] Search for an optimized pipeline in an automated fashion. Automated machine learning (AutoML) automates the selection, composition and parameterization of machine learning pipelines. Automating the machine learning often provides faster, more accurate outputs than hand-coded algorithms. ATOM uses the evalML package for AutoML optimization. The resulting transformers and final estimator are merged with atom's pipeline (check the pipeline and models attributes after the method finishes running). The created AutoMLSearch instance can be accessed through the evalml attribute. Warning AutoML algorithms aren't intended to run for only a few minutes. The method may need a very long time to achieve optimal results. Parameters **kwargs Additional keyword arguments for the AutoMLSearch instance. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method distribution (distributions=None, columns=None) [source] Get statistics on column distributions. Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored. Tip Use the plot_distribution method to plot a column's distribution. Parameters distributions: str, sequence or None, default=None Names of the distributions in scipy.stats to get the statistics on. If None, a selection of the most common ones is used. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to perform the test on. If None, select all numerical columns. Returns pd.DataFrame Statistic results with multiindex levels: dist: Name of the distribution. stat: Statistic results: score: KS-test score. p_value: Corresponding p-value. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method report (dataset=\"dataset\", n_rows=None, filename=None, **kwargs) [source] Create an extensive profile analysis report of the data. ATOM uses the pandas-profiling package for the analysis. The report is rendered directly in the notebook. The created ProfileReport instance can be accessed through the profile attribute. Warning This method can be slow for large datasets. Parameters dataset: str, default=\"dataset\" Data set to get the report from. n_rows: int or None, default=None Number of (randomly picked) rows to process. None to use all rows. filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ProfileReport instance. method reset () [source] Reset the instance to it's initial state. Deletes all branches and models. The dataset is also reset to its form after initialization. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method save_data (filename=\"auto\", dataset=\"dataset\") [source] Save the data in the current branch to a .csv file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. dataset: str, default=\"dataset\" Data set to save. method shrink (obj2cat=True, int2uint=False, dense2sparse=False, columns=None) [source] Converts the columns to the smallest possible matching dtype. Parameters obj2cat: bool, default=True Whether to convert object to category . Only if the number of categories would be less than 30% of the length of the column. int2uint: bool, default=False Whether to convert int to uint (unsigned integer). Only if the values in the column are strictly positive. dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to shrink. If None, transform all columns. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method stats (_vb=-2) [source] Print basic information about the dataset. Tip For classification tasks, the count and balance of classes is shown, followed by the ratio (between parentheses) of the class with respect to the rest of the classes in the same data set, i.e. the class with the fewest samples is followed by (1.0) . This information can be used to quickly assess if the data set is unbalanced. Parameters _vb: int, default=-2 Internal parameter to always print if called by user. method status () [source] Get an overview of the branches and models. This method prints the same information as the __repr__ and also saves it to the logger. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Utility methods"}, {"location": "API/ATOM/atomclassifier/#data-cleaning", "text": "The data cleaning methods can help you scale the data, handle missing values, categorical columns, outliers and unbalanced datasets. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide . Tip Use the report method to examine the data and help you determine suitable parameters for the data cleaning methods. balance Balance the number of rows per class in the target column. clean Applies standard data cleaning steps on the dataset. discretize Bin continuous data into intervals. encode Perform encoding of categorical features. impute Handle missing values in the dataset. normalize Transform the data to follow a Normal/Gaussian distribution. prune Prune outliers from the training set. scale Scale the data. method balance (strategy=\"adasyn\", **kwargs) [source] Balance the number of rows per class in the target column. When oversampling, the newly created samples have an increasing integer index for numerical indices, and an index of the form [estimator]_N for non-numerical indices, where N stands for the N-th sample in the data set. See the Balancer class for a description of the parameters. Note This transformation is only applied to the training set in order to maintain the original distribution of target classes in the test set. Tip Use atom's classes attribute for an overview of the target class distribution per data set. method clean (drop_types=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs) [source] Applies standard data cleaning steps on the dataset. Use the parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column (can't be True for regression tasks). See the Cleaner class for a description of the parameters. method discretize (strategy=\"quantile\", bins=5, labels=None, **kwargs) [source] Bin continuous data into intervals. For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns. See the Discretizer class for a description of the parameters. Tip Use the plot_distribution method to visualize a column's distribution and decide on the bins. method encode (strategy=\"LeaveOneOut\", max_onehot=10, ordinal=None, rare_to_value=None, value=\"rare\", **kwargs) [source] Perform encoding of categorical features. The encoding type depends on the number of classes in the column: If n_classes=2 or ordinal feature, use Ordinal-encoding. If 2 < n_classes <= max_onehot , use OneHot-encoding. If n_classes > max_onehot , use strategy -encoding. Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality. See the Encoder class for a description of the parameters. Note This method only encodes the categorical features. It does not encode the target column! Use the clean method for that. Tip Use the categorical attribute for a list of the categorical features in the dataset. method impute (strat_num=\"drop\", strat_cat=\"drop\", max_nan_rows=None, max_nan_cols=None, **kwargs) [source] Handle missing values in the dataset. Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the missing attribute to customize what are considered \"missing values\". See the Imputer class for a description of the parameters. Tip Use the nans attribute to check the amount of missing values per column. method normalize (strategy=\"yeojohnson\", **kwargs) [source] Transform the data to follow a Normal/Gaussian distribution. This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns. See the Normalizer class for a description of the parameters. Tip Use the plot_distribution method to examine a column's distribution. method prune (strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs) [source] Prune outliers from the training set. Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns. See the Pruner class for a description of the parameters. Note This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set. Tip Use the outliers attribute to check the number of outliers per column. method scale (strategy=\"standard\", include_binary=False, **kwargs) [source] Scale the data. Apply one of sklearn's scalers. Categorical columns are ignored. See the Scaler class for a description of the parameters. Tip Use the scaled attribute to check whether the dataset is scaled.", "title": "Data cleaning"}, {"location": "API/ATOM/atomclassifier/#nlp", "text": "The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called corpus . Read more in the user guide . textclean Applies standard text cleaning to the corpus. textnormalize Normalize the corpus. tokenize Tokenize the corpus. vectorize Vectorize the corpus. method textclean (decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs) [source] Applies standard text cleaning to the corpus. Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. See the TextCleaner class for a description of the parameters. method textnormalize (stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs) [source] Normalize the corpus. Convert words to a more uniform standard. The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces. See the TextNormalizer class for a description of the parameters. method tokenize (bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs) [source] Tokenize the corpus. Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g. \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named corpus . If there is no column with that name, an exception is raised. See the Tokenizer class for a description of the parameters. method vectorize (strategy=\"bow\", return_sparse=True, **kwargs) [source] Vectorize the corpus. Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named corpus . If there is no column with that name, an exception is raised. If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix corpus_ . If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column. See the Vectorizer class for a description of the parameters.", "title": "NLP"}, {"location": "API/ATOM/atomclassifier/#feature-engineering", "text": "To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide . feature_extraction Extract features from datetime columns. feature_generation Generate new features. feature_grouping Extract statistics from similar features. feature_selection Reduce the number of features in the data. method feature_extraction (features=['day', 'month', 'year'], fmt=None, encoding_type=\"ordinal\", drop_columns=True, **kwargs) [source] Extract features from datetime columns. Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype datetime64 are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used. See the FeatureExtractor class for a description of the parameters. method feature_generation (strategy=\"dfs\", n_features=None, operators=None, **kwargs) [source] Generate new features. Create new combinations of existing features to capture the non-linear relations between the original features. See the FeatureGenerator class for a description of the parameters. method feature_grouping (group, name=None, operators=None, drop_columns=True, **kwargs) [source] Extract statistics from similar features. Replace groups of features with related characteristics with new features that summarize statistical properties of te group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the groups method. See the FeatureGrouper class for a description of the parameters. method feature_selection (strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs) [source] Reduce the number of features in the data. Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low variance features. See the FeatureSelector class for a description of the parameters. Note When strategy=\"univariate\" and solver=None, f_classif or f_regression is used as default solver. When strategy is \"sfs\", \"rfecv\" or any of the advanced strategies and no scoring is specified, atom's metric (if it exists) is used as scoring.", "title": "Feature engineering"}, {"location": "API/ATOM/atomclassifier/#training", "text": "The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide . run Train and evaluate the models in a direct fashion. successive_halving Fit the models in a successive halving fashion. train_sizing Train and evaluate the models in a train sizing fashion. method run (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a direct fashion. Contrary to successive_halving and train_sizing , the direct approach only iterates once over the models, using the full dataset. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the DirectClassifier or DirectRegressor class for a description of the parameters. method successive_halving (models, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Fit the models in a successive halving fashion. The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g. only using tree-based models. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters. method train_sizing (models, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a train sizing fashion. When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.", "title": "Training"}, {"location": "API/ATOM/atomloader/", "text": "ATOMLoader function atom.api. ATOMLoader (filename, data=None, transform_data=True, verbose=None) [source] Load a class instance from a pickle file. If the file is an atom instance that was saved using save_data=False , it's possible to load new data into it and apply all data transformations. Parameters filename: str Name of the pickle file to load. data: sequence of indexables or None, default=None Original dataset. Only use this parameter if the file is an atom instance that was saved using save_data=False . Allowed formats are: X X, y train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) X, train, test: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. transform_data: bool, default=True If False, the data is left as provided. If True, it is transformed through all the steps in the instance's pipeline. This parameter is ignored if the loaded pickle is not an atom instance. verbose: int or None, default=None Verbosity level of the transformations applied on the new data. If None, use the verbosity from the loaded instance. This parameter is ignored if transform_data=False . Returns class instance Unpickled instance. Example >>> from atom import ATOMClassifier , ATOMLoader >>> from sklearn.datasets import load_breast_cancer >>> atom = ATOMClassifier ( X , y ) >>> atom . scale () >>> atom . run ([ \"LR\" , \"RF\" , \"SGD\" ], metric = \"AP\" ) >>> atom . save ( \"atom\" , save_data = False ) # Save atom to a pickle file # Load the class and add the data to the new instance >>> atom_2 = ATOMLoader ( \"atom\" , data = ( X , y ), verbose = 2 ) Transforming data for branch master: Scaling features... ATOMClassifier successfully loaded. >>> print ( atom_2 . results ) score_train score_test time_fit time LR 0.998179 0.998570 0.016s 0.016s RF 1.000000 0.995568 0.141s 0.141s SGD 0.998773 0.994313 0.016s 0.016s", "title": "ATOMLoader"}, {"location": "API/ATOM/atomloader/#atomloader", "text": "function atom.api. ATOMLoader (filename, data=None, transform_data=True, verbose=None) [source] Load a class instance from a pickle file. If the file is an atom instance that was saved using save_data=False , it's possible to load new data into it and apply all data transformations. Parameters filename: str Name of the pickle file to load. data: sequence of indexables or None, default=None Original dataset. Only use this parameter if the file is an atom instance that was saved using save_data=False . Allowed formats are: X X, y train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) X, train, test: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. transform_data: bool, default=True If False, the data is left as provided. If True, it is transformed through all the steps in the instance's pipeline. This parameter is ignored if the loaded pickle is not an atom instance. verbose: int or None, default=None Verbosity level of the transformations applied on the new data. If None, use the verbosity from the loaded instance. This parameter is ignored if transform_data=False . Returns class instance Unpickled instance.", "title": "ATOMLoader"}, {"location": "API/ATOM/atomloader/#example", "text": ">>> from atom import ATOMClassifier , ATOMLoader >>> from sklearn.datasets import load_breast_cancer >>> atom = ATOMClassifier ( X , y ) >>> atom . scale () >>> atom . run ([ \"LR\" , \"RF\" , \"SGD\" ], metric = \"AP\" ) >>> atom . save ( \"atom\" , save_data = False ) # Save atom to a pickle file # Load the class and add the data to the new instance >>> atom_2 = ATOMLoader ( \"atom\" , data = ( X , y ), verbose = 2 ) Transforming data for branch master: Scaling features... ATOMClassifier successfully loaded. >>> print ( atom_2 . results ) score_train score_test time_fit time LR 0.998179 0.998570 0.016s 0.016s RF 1.000000 0.995568 0.141s 0.141s SGD 0.998773 0.994313 0.016s 0.016s", "title": "Example"}, {"location": "API/ATOM/atommodel/", "text": "ATOMModel function atom.api. ATOMModel (estimator, acronym=None, needs_scaling=False, has_validation=None) [source] Convert an estimator to a model that can be ingested by atom. This function adds the relevant attributes to the estimator so that they can be used by atom. Note that only estimators that follow sklearn's API are compatible. Read more about using custom models in the user guide . Parameters estimator: Predictor Custom estimator. Should implement a fit and predict method. acronym: str or None, default=None Model's acronym. Used to call the model from atom. If None, the capital letters in the estimator's __name__ are used (only if two or more, else it uses the entire __name__). needs_scaling: bool, default=False Whether the model needs scaled features. has_validation: str or None, default=None Whether the model allows in-training validation . If str, name of the estimator's parameter that states the number of iterations. If None, no support for in-training validation. Returns estimator Clone of the provided estimator with custom attributes. Example >>> from atom import ATOMRegressor , ATOMModel >>> from sklearn.linear_model import RANSACRegressor >>> ransac = ATOMModel ( ... estimator = RANSACRegressor (), ... acronym = \"RANSAC\" , ... needs_scaling = False , ... ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( ransac , verbose = 2 ) Training ========================= >> Models: RANSAC Metric: r2 Results for RANSACRegressor: Fit --------------------------------------------- Train evaluation --> r2: -2.1784 Test evaluation --> r2: -9.4592 Time elapsed: 0.072s ------------------------------------------------- Total time: 0.072s Final results ==================== >> Total time: 0.072s ------------------------------------- RANSACRegressor --> r2: -9.4592 ~", "title": "ATOMModel"}, {"location": "API/ATOM/atommodel/#atommodel", "text": "function atom.api. ATOMModel (estimator, acronym=None, needs_scaling=False, has_validation=None) [source] Convert an estimator to a model that can be ingested by atom. This function adds the relevant attributes to the estimator so that they can be used by atom. Note that only estimators that follow sklearn's API are compatible. Read more about using custom models in the user guide . Parameters estimator: Predictor Custom estimator. Should implement a fit and predict method. acronym: str or None, default=None Model's acronym. Used to call the model from atom. If None, the capital letters in the estimator's __name__ are used (only if two or more, else it uses the entire __name__). needs_scaling: bool, default=False Whether the model needs scaled features. has_validation: str or None, default=None Whether the model allows in-training validation . If str, name of the estimator's parameter that states the number of iterations. If None, no support for in-training validation. Returns estimator Clone of the provided estimator with custom attributes.", "title": "ATOMModel"}, {"location": "API/ATOM/atommodel/#example", "text": ">>> from atom import ATOMRegressor , ATOMModel >>> from sklearn.linear_model import RANSACRegressor >>> ransac = ATOMModel ( ... estimator = RANSACRegressor (), ... acronym = \"RANSAC\" , ... needs_scaling = False , ... ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( ransac , verbose = 2 ) Training ========================= >> Models: RANSAC Metric: r2 Results for RANSACRegressor: Fit --------------------------------------------- Train evaluation --> r2: -2.1784 Test evaluation --> r2: -9.4592 Time elapsed: 0.072s ------------------------------------------------- Total time: 0.072s Final results ==================== >> Total time: 0.072s ------------------------------------- RANSACRegressor --> r2: -9.4592 ~", "title": "Example"}, {"location": "API/ATOM/atomregressor/", "text": "ATOMRegressor class atom.api. ATOMRegressor (*arrays, y=-1, index=False, shuffle=True, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Main class for regression tasks. Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains. All data cleaning , feature engineering , model training and plotting functionality can be accessed from an instance of this class. Parameters *arrays: sequence of indexables Dataset containing features and target. Allowed formats are: X X, y train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) X, train, test: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. y: int, str or sequence, default=-1 Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. This parameter is ignored if the target column is provided through arrays . index: bool, int, str or sequence, default=False Handle the index in the resulting dataframe. If False: Reset to RangeIndex . If True: Use the provided index. If int: Position of the column to use as index. If str: Name of the column to use as index. If sequence: Array with shape=(n_samples,) to use as index. test_size: int or float, default=0.2 If <=1: Fraction of the dataset to include in the test set. If >1: Number of rows to include in the test set. This parameter is ignored if the test set is provided through arrays . holdout_size: int, float or None, default=None If None: No holdout data set is kept apart. If <=1: Fraction of the dataset to include in the holdout set. If >1: Number of rows to include in the holdout set. This parameter is ignored if the holdout set is provided through arrays . shuffle: bool, default=True Whether to shuffle the dataset before splitting the train and test set. Be aware that not shuffling the dataset can cause an unequal distribution of target classes over the sets. n_rows: int or float, default=1 Random subsample of the dataset to use. The default value selects all rows. If <=1: Fraction of the dataset to select. If >1: Exact number of rows to select. Only if arrays is X or X, y. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMClassifier Main class for binary and multiclass classification tasks. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import load_diabetes >>> X , y = load_diabetes ( return_X_y = True , as_frame = True ) >>> # Initialize atom >>> atom = ATOMRegressor ( X , y , logger = \"auto\" , n_jobs = 2 , verbose = 2 ) << ================== ATOM ================== >> Algorithm task: regression. Parallel processing with 2 cores. Dataset stats ==================== >> Shape: (442, 11) Memory: 39.02 kB Scaled: False Outlier values: 10 (0.3%) ------------------------------------- Train set size: 310 Test set size: 132 >>> # Apply data cleaning and feature engineering methods >>> atom . scale () Fitting Scaler... Scaling features... >>> atom . feature_selection ( strategy = \"rfecv\" , solver = \"xgb\" , n_features = 12 ) Fitting FeatureSelector... Performing feature selection ... --> rfecv selected 6 features from the dataset. --> Dropping feature age (rank 5). --> Dropping feature sex (rank 4). --> Dropping feature s1 (rank 2). --> Dropping feature s3 (rank 3). >>> # Train models >>> atom . run ( ... models = [ \"LR\" , \"RF\" , \"XGB\" ], ... metric = \"precision\" , ... n_bootstrap = 4 , ... ) Training ========================= >> Models: OLS, BR, RF Metric: r2 Results for Ordinary Least Squares: Fit --------------------------------------------- Train evaluation --> r2: 0.5223 Test evaluation --> r2: 0.4012 Time elapsed: 0.010s ------------------------------------------------- Total time: 0.010s Results for Bayesian Ridge: Fit --------------------------------------------- Train evaluation --> r2: 0.522 Test evaluation --> r2: 0.4037 Time elapsed: 0.010s ------------------------------------------------- Total time: 0.010s Results for Random Forest: Fit --------------------------------------------- Train evaluation --> r2: 0.9271 Test evaluation --> r2: 0.259 Time elapsed: 0.175s ------------------------------------------------- Total time: 0.175s Final results ==================== >> Total time: 0.195s ------------------------------------- Ordinary Least Squares --> r2: 0.4012 ~ Bayesian Ridge --> r2: 0.4037 ~ ! Random Forest --> r2: 0.259 ~ >>> # Analyze the results >>> atom . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS -43.756992 ... -54.984345 BR -43.734975 ... -54.869543 RF -48.327879 ... -61.167760 [3 rows x 7 columns] Magic methods The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch. __repr__: Prints an overview of atom's branches, models, metric and errors. __len__: Returns the length of the dataset. __iter__: Iterate over the pipeline's transformers. __contains__: Checks if the provided item is a column in the dataset. __getitem__: Access a branch, model, column or subset of the dataset. Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes pipeline: pd.Series Transformers fitted on the data. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. scaled: bool Whether the feature set is scaled. A data set is considered scaled when it has mean=0 and std=1, or when atom has a scaler in the pipeline. Returns None for sparse datasets . duplicates: pd.Series Number of duplicate rows in the dataset. missing: list Values that are considered \"missing\". These values are used by the clean and impute methods. Default values are: None, NaN, +inf, -inf, \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None, NaN, +inf and -inf are always considered missing since they are incompatible with sklearn estimators. nans: pd.Series Columns with the number of missing values in them. n_nans: int Number of samples containing missing values. numerical: pd.Series Names of the numerical features in the dataset. n_numerical: int Number of numerical features in the dataset. categorical: pd.Series Names of the categorical features in the dataset. n_categorical: int Number of categorical features in the dataset. outliers: pd.Series Columns in training set with amount of outlier values. n_outliers: int Number of samples in the training set containing outliers. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes branch: Branch Current active branch. Use the property's @setter to change from current branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use __from__ to split the new branch from any other existing branch. Read more in the user guide . models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Utility methods Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline. add Add a transformer to the pipeline. apply Apply a function to the dataset. automl Search for an optimized pipeline in an automated fashion. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. distribution Get statistics on column distributions. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. inverse_transform Inversely transform new data through the pipeline. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. report Create an extensive profile analysis report of the data. reset Reset the instance to it's initial state. reset_aesthetics Reset the plot aesthetics to their default values. save Save the instance to a pickle file. save_data Save the data in the current branch to a .csv file. shrink Converts the columns to the smallest possible matching dtype. stacking Add a Stacking model to the pipeline. stats Print basic information about the dataset. status Get an overview of the branches and models. transform Transform new data through the pipeline. voting Add a Voting model to the pipeline. method add (transformer, columns=None, train_only=False, **fit_params) [source] Add a transformer to the pipeline. If the transformer is not fitted, it is fitted on the complete training set. Afterwards, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom. Warning The transformer should have fit and/or transform methods with arguments X (accepting a dataframe-like object of shape=(n_samples, n_features)) and/or y (accepting a sequence of shape=(n_samples,)). The transform method should return a feature set as a dataframe-like object of shape=(n_samples, n_features) and/or a target column as a sequence of shape=(n_samples,). Note If the transform method doesn't return a dataframe: The column naming happens as follows. If the transformer has a get_feature_names or get_feature_names_out method, it is used. If not, and it returns the same number of columns, the names are kept equal. If the number of columns change, old columns will keep their name (as long as the column is unchanged) and new columns will receive the name x[N-1] , where N stands for the n-th feature. This means that a transformer should only transform, add or drop columns, not combinations of these. The index remains the same as before the transformation. This means that the transformer should not add, remove or shuffle rows unless it returns a dataframe. Note If the transformer has a n_jobs and/or random_state parameter that is left to its default value, it adopts atom's value. Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a transform method. columns: int, str, slice, sequence or None, default=None Names, indices or dtypes of the columns in the dataset to transform. If None, transform all columns. Add ! in front of a name or dtype to exclude that column, e.g. atom.add(Transformer(), columns=\"!Location\") transforms all columns except Location`. You can either include or exclude columns, not combinations of these. The target column is always included if required by the transformer. train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. **fit_params Additional keyword arguments for the transformer's fit method. method apply (func, inverse_func=None, kw_args=None, inv_kw_args=None, **kwargs) [source] Apply a function to the dataset. The function should have signature func(dataset, **kw_args) -> dataset . This method is useful for stateless transformations such as taking the log, doing custom scaling, etc... Note This approach is preferred over changing the dataset directly through the property's @setter since the transformation is stored in the pipeline. Tip Use atom . apply ( lambda df : df . drop ( \"column_name\" , axis = 1 )) to store the removal of columns in the pipeline. Parameters func: callable Function to apply. inverse_func: callable or None, default=None Inverse function of func . If None, the inverse_transform method returns the input unchanged. kw_args: dict or None, default=None Additional keyword arguments for the function. inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. method automl (**kwargs) [source] Search for an optimized pipeline in an automated fashion. Automated machine learning (AutoML) automates the selection, composition and parameterization of machine learning pipelines. Automating the machine learning often provides faster, more accurate outputs than hand-coded algorithms. ATOM uses the evalML package for AutoML optimization. The resulting transformers and final estimator are merged with atom's pipeline (check the pipeline and models attributes after the method finishes running). The created AutoMLSearch instance can be accessed through the evalml attribute. Warning AutoML algorithms aren't intended to run for only a few minutes. The method may need a very long time to achieve optimal results. Parameters **kwargs Additional keyword arguments for the AutoMLSearch instance. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method distribution (distributions=None, columns=None) [source] Get statistics on column distributions. Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored. Tip Use the plot_distribution method to plot a column's distribution. Parameters distributions: str, sequence or None, default=None Names of the distributions in scipy.stats to get the statistics on. If None, a selection of the most common ones is used. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to perform the test on. If None, select all numerical columns. Returns pd.DataFrame Statistic results with multiindex levels: dist: Name of the distribution. stat: Statistic results: score: KS-test score. p_value: Corresponding p-value. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method report (dataset=\"dataset\", n_rows=None, filename=None, **kwargs) [source] Create an extensive profile analysis report of the data. ATOM uses the pandas-profiling package for the analysis. The report is rendered directly in the notebook. The created ProfileReport instance can be accessed through the profile attribute. Warning This method can be slow for large datasets. Parameters dataset: str, default=\"dataset\" Data set to get the report from. n_rows: int or None, default=None Number of (randomly picked) rows to process. None to use all rows. filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ProfileReport instance. method reset () [source] Reset the instance to it's initial state. Deletes all branches and models. The dataset is also reset to its form after initialization. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method save_data (filename=\"auto\", dataset=\"dataset\") [source] Save the data in the current branch to a .csv file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. dataset: str, default=\"dataset\" Data set to save. method shrink (obj2cat=True, int2uint=False, dense2sparse=False, columns=None) [source] Converts the columns to the smallest possible matching dtype. Parameters obj2cat: bool, default=True Whether to convert object to category . Only if the number of categories would be less than 30% of the length of the column. int2uint: bool, default=False Whether to convert int to uint (unsigned integer). Only if the values in the column are strictly positive. dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to shrink. If None, transform all columns. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method stats (_vb=-2) [source] Print basic information about the dataset. Tip For classification tasks, the count and balance of classes is shown, followed by the ratio (between parentheses) of the class with respect to the rest of the classes in the same data set, i.e. the class with the fewest samples is followed by (1.0) . This information can be used to quickly assess if the data set is unbalanced. Parameters _vb: int, default=-2 Internal parameter to always print if called by user. method status () [source] Get an overview of the branches and models. This method prints the same information as the __repr__ and also saves it to the logger. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance. Data cleaning The data cleaning methods can help you scale the data, handle missing values, categorical columns and outliers. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide . Tip Use the report method to examine the data and help you determine suitable parameters for the data cleaning methods. clean Applies standard data cleaning steps on the dataset. discretize Bin continuous data into intervals. encode Perform encoding of categorical features. impute Handle missing values in the dataset. normalize Transform the data to follow a Normal/Gaussian distribution. prune Prune outliers from the training set. scale Scale the data. method clean (drop_types=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs) [source] Applies standard data cleaning steps on the dataset. Use the parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column (can't be True for regression tasks). See the Cleaner class for a description of the parameters. method discretize (strategy=\"quantile\", bins=5, labels=None, **kwargs) [source] Bin continuous data into intervals. For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns. See the Discretizer class for a description of the parameters. Tip Use the plot_distribution method to visualize a column's distribution and decide on the bins. method encode (strategy=\"LeaveOneOut\", max_onehot=10, ordinal=None, rare_to_value=None, value=\"rare\", **kwargs) [source] Perform encoding of categorical features. The encoding type depends on the number of classes in the column: If n_classes=2 or ordinal feature, use Ordinal-encoding. If 2 < n_classes <= max_onehot , use OneHot-encoding. If n_classes > max_onehot , use strategy -encoding. Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality. See the Encoder class for a description of the parameters. Note This method only encodes the categorical features. It does not encode the target column! Use the clean method for that. Tip Use the categorical attribute for a list of the categorical features in the dataset. method impute (strat_num=\"drop\", strat_cat=\"drop\", max_nan_rows=None, max_nan_cols=None, **kwargs) [source] Handle missing values in the dataset. Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the missing attribute to customize what are considered \"missing values\". See the Imputer class for a description of the parameters. Tip Use the nans attribute to check the amount of missing values per column. method normalize (strategy=\"yeojohnson\", **kwargs) [source] Transform the data to follow a Normal/Gaussian distribution. This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns. See the Normalizer class for a description of the parameters. Tip Use the plot_distribution method to examine a column's distribution. method prune (strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs) [source] Prune outliers from the training set. Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns. See the Pruner class for a description of the parameters. Note This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set. Tip Use the outliers attribute to check the number of outliers per column. method scale (strategy=\"standard\", include_binary=False, **kwargs) [source] Scale the data. Apply one of sklearn's scalers. Categorical columns are ignored. See the Scaler class for a description of the parameters. Tip Use the scaled attribute to check whether the dataset is scaled. NLP The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called corpus . Read more in the user guide . textclean Applies standard text cleaning to the corpus. textnormalize Normalize the corpus. tokenize Tokenize the corpus. vectorize Vectorize the corpus. method textclean (decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs) [source] Applies standard text cleaning to the corpus. Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. See the TextCleaner class for a description of the parameters. method textnormalize (stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs) [source] Normalize the corpus. Convert words to a more uniform standard. The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces. See the TextNormalizer class for a description of the parameters. method tokenize (bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs) [source] Tokenize the corpus. Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g. \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named corpus . If there is no column with that name, an exception is raised. See the Tokenizer class for a description of the parameters. method vectorize (strategy=\"bow\", return_sparse=True, **kwargs) [source] Vectorize the corpus. Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named corpus . If there is no column with that name, an exception is raised. If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix corpus_ . If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column. See the Vectorizer class for a description of the parameters. Feature engineering To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide . feature_extraction Extract features from datetime columns. feature_generation Generate new features. feature_grouping Extract statistics from similar features. feature_selection Reduce the number of features in the data. method feature_extraction (features=['day', 'month', 'year'], fmt=None, encoding_type=\"ordinal\", drop_columns=True, **kwargs) [source] Extract features from datetime columns. Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype datetime64 are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used. See the FeatureExtractor class for a description of the parameters. method feature_generation (strategy=\"dfs\", n_features=None, operators=None, **kwargs) [source] Generate new features. Create new combinations of existing features to capture the non-linear relations between the original features. See the FeatureGenerator class for a description of the parameters. method feature_grouping (group, name=None, operators=None, drop_columns=True, **kwargs) [source] Extract statistics from similar features. Replace groups of features with related characteristics with new features that summarize statistical properties of te group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the groups method. See the FeatureGrouper class for a description of the parameters. method feature_selection (strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs) [source] Reduce the number of features in the data. Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low variance features. See the FeatureSelector class for a description of the parameters. Note When strategy=\"univariate\" and solver=None, f_classif or f_regression is used as default solver. When strategy is \"sfs\", \"rfecv\" or any of the advanced strategies and no scoring is specified, atom's metric (if it exists) is used as scoring. Training The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide . run Train and evaluate the models in a direct fashion. successive_halving Fit the models in a successive halving fashion. train_sizing Train and evaluate the models in a train sizing fashion. method run (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a direct fashion. Contrary to successive_halving and train_sizing , the direct approach only iterates once over the models, using the full dataset. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the DirectClassifier or DirectRegressor class for a description of the parameters. method successive_halving (models, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Fit the models in a successive halving fashion. The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g. only using tree-based models. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters. method train_sizing (models, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a train sizing fashion. When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.", "title": "ATOMRegressor"}, {"location": "API/ATOM/atomregressor/#atomregressor", "text": "class atom.api. ATOMRegressor (*arrays, y=-1, index=False, shuffle=True, n_rows=1, test_size=0.2, holdout_size=None, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Main class for regression tasks. Apply all data transformations and model management provided by the package on a given dataset. Note that, contrary to sklearn's API, the instance contains the dataset on which to perform the analysis. Calling a method will automatically apply it on the dataset it contains. All data cleaning , feature engineering , model training and plotting functionality can be accessed from an instance of this class. Parameters *arrays: sequence of indexables Dataset containing features and target. Allowed formats are: X X, y train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) X, train, test: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. y: int, str or sequence, default=-1 Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. This parameter is ignored if the target column is provided through arrays . index: bool, int, str or sequence, default=False Handle the index in the resulting dataframe. If False: Reset to RangeIndex . If True: Use the provided index. If int: Position of the column to use as index. If str: Name of the column to use as index. If sequence: Array with shape=(n_samples,) to use as index. test_size: int or float, default=0.2 If <=1: Fraction of the dataset to include in the test set. If >1: Number of rows to include in the test set. This parameter is ignored if the test set is provided through arrays . holdout_size: int, float or None, default=None If None: No holdout data set is kept apart. If <=1: Fraction of the dataset to include in the holdout set. If >1: Number of rows to include in the holdout set. This parameter is ignored if the holdout set is provided through arrays . shuffle: bool, default=True Whether to shuffle the dataset before splitting the train and test set. Be aware that not shuffling the dataset can cause an unequal distribution of target classes over the sets. n_rows: int or float, default=1 Random subsample of the dataset to use. The default value selects all rows. If <=1: Fraction of the dataset to select. If >1: Exact number of rows to select. Only if arrays is X or X, y. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMClassifier Main class for binary and multiclass classification tasks.", "title": "ATOMRegressor"}, {"location": "API/ATOM/atomregressor/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import load_diabetes >>> X , y = load_diabetes ( return_X_y = True , as_frame = True ) >>> # Initialize atom >>> atom = ATOMRegressor ( X , y , logger = \"auto\" , n_jobs = 2 , verbose = 2 ) << ================== ATOM ================== >> Algorithm task: regression. Parallel processing with 2 cores. Dataset stats ==================== >> Shape: (442, 11) Memory: 39.02 kB Scaled: False Outlier values: 10 (0.3%) ------------------------------------- Train set size: 310 Test set size: 132 >>> # Apply data cleaning and feature engineering methods >>> atom . scale () Fitting Scaler... Scaling features... >>> atom . feature_selection ( strategy = \"rfecv\" , solver = \"xgb\" , n_features = 12 ) Fitting FeatureSelector... Performing feature selection ... --> rfecv selected 6 features from the dataset. --> Dropping feature age (rank 5). --> Dropping feature sex (rank 4). --> Dropping feature s1 (rank 2). --> Dropping feature s3 (rank 3). >>> # Train models >>> atom . run ( ... models = [ \"LR\" , \"RF\" , \"XGB\" ], ... metric = \"precision\" , ... n_bootstrap = 4 , ... ) Training ========================= >> Models: OLS, BR, RF Metric: r2 Results for Ordinary Least Squares: Fit --------------------------------------------- Train evaluation --> r2: 0.5223 Test evaluation --> r2: 0.4012 Time elapsed: 0.010s ------------------------------------------------- Total time: 0.010s Results for Bayesian Ridge: Fit --------------------------------------------- Train evaluation --> r2: 0.522 Test evaluation --> r2: 0.4037 Time elapsed: 0.010s ------------------------------------------------- Total time: 0.010s Results for Random Forest: Fit --------------------------------------------- Train evaluation --> r2: 0.9271 Test evaluation --> r2: 0.259 Time elapsed: 0.175s ------------------------------------------------- Total time: 0.175s Final results ==================== >> Total time: 0.195s ------------------------------------- Ordinary Least Squares --> r2: 0.4012 ~ Bayesian Ridge --> r2: 0.4037 ~ ! Random Forest --> r2: 0.259 ~ >>> # Analyze the results >>> atom . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS -43.756992 ... -54.984345 BR -43.734975 ... -54.869543 RF -48.327879 ... -61.167760 [3 rows x 7 columns]", "title": "Example"}, {"location": "API/ATOM/atomregressor/#magic-methods", "text": "The class contains some magic methods to help you access some of its elements faster. Note that methods that apply on the pipeline can return different results per branch. __repr__: Prints an overview of atom's branches, models, metric and errors. __len__: Returns the length of the dataset. __iter__: Iterate over the pipeline's transformers. __contains__: Checks if the provided item is a column in the dataset. __getitem__: Access a branch, model, column or subset of the dataset.", "title": "Magic methods"}, {"location": "API/ATOM/atomregressor/#attributes", "text": "", "title": "Attributes"}, {"location": "API/ATOM/atomregressor/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes pipeline: pd.Series Transformers fitted on the data. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. scaled: bool Whether the feature set is scaled. A data set is considered scaled when it has mean=0 and std=1, or when atom has a scaler in the pipeline. Returns None for sparse datasets . duplicates: pd.Series Number of duplicate rows in the dataset. missing: list Values that are considered \"missing\". These values are used by the clean and impute methods. Default values are: None, NaN, +inf, -inf, \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None, NaN, +inf and -inf are always considered missing since they are incompatible with sklearn estimators. nans: pd.Series Columns with the number of missing values in them. n_nans: int Number of samples containing missing values. numerical: pd.Series Names of the numerical features in the dataset. n_numerical: int Number of numerical features in the dataset. categorical: pd.Series Names of the categorical features in the dataset. n_categorical: int Number of categorical features in the dataset. outliers: pd.Series Columns in training set with amount of outlier values. n_outliers: int Number of samples in the training set containing outliers.", "title": "Data attributes"}, {"location": "API/ATOM/atomregressor/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes branch: Branch Current active branch. Use the property's @setter to change from current branch or to create a new one. If the value is the name of an existing branch, switch to that one. Else, create a new branch using that name. The new branch is split from the current branch. Use __from__ to split the new branch from any other existing branch. Read more in the user guide . models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/ATOM/atomregressor/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/ATOM/atomregressor/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/ATOM/atomregressor/#utility-methods", "text": "Next to the plotting methods, the class contains a variety of utility methods to handle the data and manage the pipeline. add Add a transformer to the pipeline. apply Apply a function to the dataset. automl Search for an optimized pipeline in an automated fashion. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. distribution Get statistics on column distributions. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. inverse_transform Inversely transform new data through the pipeline. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. report Create an extensive profile analysis report of the data. reset Reset the instance to it's initial state. reset_aesthetics Reset the plot aesthetics to their default values. save Save the instance to a pickle file. save_data Save the data in the current branch to a .csv file. shrink Converts the columns to the smallest possible matching dtype. stacking Add a Stacking model to the pipeline. stats Print basic information about the dataset. status Get an overview of the branches and models. transform Transform new data through the pipeline. voting Add a Voting model to the pipeline. method add (transformer, columns=None, train_only=False, **fit_params) [source] Add a transformer to the pipeline. If the transformer is not fitted, it is fitted on the complete training set. Afterwards, the data set is transformed and the estimator is added to atom's pipeline. If the estimator is a sklearn Pipeline, every estimator is merged independently with atom. Warning The transformer should have fit and/or transform methods with arguments X (accepting a dataframe-like object of shape=(n_samples, n_features)) and/or y (accepting a sequence of shape=(n_samples,)). The transform method should return a feature set as a dataframe-like object of shape=(n_samples, n_features) and/or a target column as a sequence of shape=(n_samples,). Note If the transform method doesn't return a dataframe: The column naming happens as follows. If the transformer has a get_feature_names or get_feature_names_out method, it is used. If not, and it returns the same number of columns, the names are kept equal. If the number of columns change, old columns will keep their name (as long as the column is unchanged) and new columns will receive the name x[N-1] , where N stands for the n-th feature. This means that a transformer should only transform, add or drop columns, not combinations of these. The index remains the same as before the transformation. This means that the transformer should not add, remove or shuffle rows unless it returns a dataframe. Note If the transformer has a n_jobs and/or random_state parameter that is left to its default value, it adopts atom's value. Parameters transformer: Transformer Estimator to add to the pipeline. Should implement a transform method. columns: int, str, slice, sequence or None, default=None Names, indices or dtypes of the columns in the dataset to transform. If None, transform all columns. Add ! in front of a name or dtype to exclude that column, e.g. atom.add(Transformer(), columns=\"!Location\") transforms all columns except Location`. You can either include or exclude columns, not combinations of these. The target column is always included if required by the transformer. train_only: bool, default=False Whether to apply the estimator only on the training set or on the complete dataset. Note that if True, the transformation is skipped when making predictions on new data. **fit_params Additional keyword arguments for the transformer's fit method. method apply (func, inverse_func=None, kw_args=None, inv_kw_args=None, **kwargs) [source] Apply a function to the dataset. The function should have signature func(dataset, **kw_args) -> dataset . This method is useful for stateless transformations such as taking the log, doing custom scaling, etc... Note This approach is preferred over changing the dataset directly through the property's @setter since the transformation is stored in the pipeline. Tip Use atom . apply ( lambda df : df . drop ( \"column_name\" , axis = 1 )) to store the removal of columns in the pipeline. Parameters func: callable Function to apply. inverse_func: callable or None, default=None Inverse function of func . If None, the inverse_transform method returns the input unchanged. kw_args: dict or None, default=None Additional keyword arguments for the function. inv_kw_args: dict or None, default=None Additional keyword arguments for the inverse function. method automl (**kwargs) [source] Search for an optimized pipeline in an automated fashion. Automated machine learning (AutoML) automates the selection, composition and parameterization of machine learning pipelines. Automating the machine learning often provides faster, more accurate outputs than hand-coded algorithms. ATOM uses the evalML package for AutoML optimization. The resulting transformers and final estimator are merged with atom's pipeline (check the pipeline and models attributes after the method finishes running). The created AutoMLSearch instance can be accessed through the evalml attribute. Warning AutoML algorithms aren't intended to run for only a few minutes. The method may need a very long time to achieve optimal results. Parameters **kwargs Additional keyword arguments for the AutoMLSearch instance. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method distribution (distributions=None, columns=None) [source] Get statistics on column distributions. Compute the Kolmogorov-Smirnov test for various distributions against columns in the dataset. Only for numerical columns. Missing values are ignored. Tip Use the plot_distribution method to plot a column's distribution. Parameters distributions: str, sequence or None, default=None Names of the distributions in scipy.stats to get the statistics on. If None, a selection of the most common ones is used. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to perform the test on. If None, select all numerical columns. Returns pd.DataFrame Statistic results with multiindex levels: dist: Name of the distribution. stat: Statistic results: score: KS-test score. p_value: Corresponding p-value. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be used to transform only the target column. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method report (dataset=\"dataset\", n_rows=None, filename=None, **kwargs) [source] Create an extensive profile analysis report of the data. ATOM uses the pandas-profiling package for the analysis. The report is rendered directly in the notebook. The created ProfileReport instance can be accessed through the profile attribute. Warning This method can be slow for large datasets. Parameters dataset: str, default=\"dataset\" Data set to get the report from. n_rows: int or None, default=None Number of (randomly picked) rows to process. None to use all rows. filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ProfileReport instance. method reset () [source] Reset the instance to it's initial state. Deletes all branches and models. The dataset is also reset to its form after initialization. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method save_data (filename=\"auto\", dataset=\"dataset\") [source] Save the data in the current branch to a .csv file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. dataset: str, default=\"dataset\" Data set to save. method shrink (obj2cat=True, int2uint=False, dense2sparse=False, columns=None) [source] Converts the columns to the smallest possible matching dtype. Parameters obj2cat: bool, default=True Whether to convert object to category . Only if the number of categories would be less than 30% of the length of the column. int2uint: bool, default=False Whether to convert int to uint (unsigned integer). Only if the values in the column are strictly positive. dense2sparse: bool, default=False Whether to convert all features to sparse format. The value that is compressed is the most frequent value in the column. columns: int, str, slice, sequence or None, default=None Names, positions or dtypes of the columns in the dataset to shrink. If None, transform all columns. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method stats (_vb=-2) [source] Print basic information about the dataset. Tip For classification tasks, the count and balance of classes is shown, followed by the ratio (between parentheses) of the class with respect to the rest of the classes in the same data set, i.e. the class with the fewest samples is followed by (1.0) . This information can be used to quickly assess if the data set is unbalanced. Parameters _vb: int, default=-2 Internal parameter to always print if called by user. method status () [source] Get an overview of the branches and models. This method prints the same information as the __repr__ and also saves it to the logger. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None Target column corresponding to X. - If None: y is ignored in the transformers. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Utility methods"}, {"location": "API/ATOM/atomregressor/#data-cleaning", "text": "The data cleaning methods can help you scale the data, handle missing values, categorical columns and outliers. All attributes of the data cleaning classes are attached to atom after running. Read more in the user guide . Tip Use the report method to examine the data and help you determine suitable parameters for the data cleaning methods. clean Applies standard data cleaning steps on the dataset. discretize Bin continuous data into intervals. encode Perform encoding of categorical features. impute Handle missing values in the dataset. normalize Transform the data to follow a Normal/Gaussian distribution. prune Prune outliers from the training set. scale Scale the data. method clean (drop_types=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, **kwargs) [source] Applies standard data cleaning steps on the dataset. Use the parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column (can't be True for regression tasks). See the Cleaner class for a description of the parameters. method discretize (strategy=\"quantile\", bins=5, labels=None, **kwargs) [source] Bin continuous data into intervals. For each feature, the bin edges are computed during fit and, together with the number of bins, they will define the intervals. Ignores numerical columns. See the Discretizer class for a description of the parameters. Tip Use the plot_distribution method to visualize a column's distribution and decide on the bins. method encode (strategy=\"LeaveOneOut\", max_onehot=10, ordinal=None, rare_to_value=None, value=\"rare\", **kwargs) [source] Perform encoding of categorical features. The encoding type depends on the number of classes in the column: If n_classes=2 or ordinal feature, use Ordinal-encoding. If 2 < n_classes <= max_onehot , use OneHot-encoding. If n_classes > max_onehot , use strategy -encoding. Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality. See the Encoder class for a description of the parameters. Note This method only encodes the categorical features. It does not encode the target column! Use the clean method for that. Tip Use the categorical attribute for a list of the categorical features in the dataset. method impute (strat_num=\"drop\", strat_cat=\"drop\", max_nan_rows=None, max_nan_cols=None, **kwargs) [source] Handle missing values in the dataset. Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the missing attribute to customize what are considered \"missing values\". See the Imputer class for a description of the parameters. Tip Use the nans attribute to check the amount of missing values per column. method normalize (strategy=\"yeojohnson\", **kwargs) [source] Transform the data to follow a Normal/Gaussian distribution. This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Ignores categorical columns. See the Normalizer class for a description of the parameters. Tip Use the plot_distribution method to examine a column's distribution. method prune (strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, **kwargs) [source] Prune outliers from the training set. Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns. See the Pruner class for a description of the parameters. Note This transformation is only applied to the training set in order to maintain the original distribution of samples in the test set. Tip Use the outliers attribute to check the number of outliers per column. method scale (strategy=\"standard\", include_binary=False, **kwargs) [source] Scale the data. Apply one of sklearn's scalers. Categorical columns are ignored. See the Scaler class for a description of the parameters. Tip Use the scaled attribute to check whether the dataset is scaled.", "title": "Data cleaning"}, {"location": "API/ATOM/atomregressor/#nlp", "text": "The Natural Language Processing (NLP) transformers help to convert raw text to meaningful numeric values, ready to be ingested by a model. All transformations are applied only on the column in the dataset called corpus . Read more in the user guide . textclean Applies standard text cleaning to the corpus. textnormalize Normalize the corpus. tokenize Tokenize the corpus. vectorize Vectorize the corpus. method textclean (decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, **kwargs) [source] Applies standard text cleaning to the corpus. Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. See the TextCleaner class for a description of the parameters. method textnormalize (stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, **kwargs) [source] Normalize the corpus. Convert words to a more uniform standard. The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces. See the TextNormalizer class for a description of the parameters. method tokenize (bigram_freq=None, trigram_freq=None, quadgram_freq=None, **kwargs) [source] Tokenize the corpus. Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g. \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named corpus . If there is no column with that name, an exception is raised. See the Tokenizer class for a description of the parameters. method vectorize (strategy=\"bow\", return_sparse=True, **kwargs) [source] Vectorize the corpus. Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named corpus . If there is no column with that name, an exception is raised. If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix corpus_ . If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column. See the Vectorizer class for a description of the parameters.", "title": "NLP"}, {"location": "API/ATOM/atomregressor/#feature-engineering", "text": "To further pre-process the data, it's possible to extract features from datetime columns, create new non-linear features transforming the existing ones, group similar features or, if the dataset is too large, remove features. Read more in the user guide . feature_extraction Extract features from datetime columns. feature_generation Generate new features. feature_grouping Extract statistics from similar features. feature_selection Reduce the number of features in the data. method feature_extraction (features=['day', 'month', 'year'], fmt=None, encoding_type=\"ordinal\", drop_columns=True, **kwargs) [source] Extract features from datetime columns. Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype datetime64 are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used. See the FeatureExtractor class for a description of the parameters. method feature_generation (strategy=\"dfs\", n_features=None, operators=None, **kwargs) [source] Generate new features. Create new combinations of existing features to capture the non-linear relations between the original features. See the FeatureGenerator class for a description of the parameters. method feature_grouping (group, name=None, operators=None, drop_columns=True, **kwargs) [source] Extract statistics from similar features. Replace groups of features with related characteristics with new features that summarize statistical properties of te group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the groups method. See the FeatureGrouper class for a description of the parameters. method feature_selection (strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, **kwargs) [source] Reduce the number of features in the data. Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low variance features. See the FeatureSelector class for a description of the parameters. Note When strategy=\"univariate\" and solver=None, f_classif or f_regression is used as default solver. When strategy is \"sfs\", \"rfecv\" or any of the advanced strategies and no scoring is specified, atom's metric (if it exists) is used as scoring.", "title": "Feature engineering"}, {"location": "API/ATOM/atomregressor/#training", "text": "The training methods are where the models are fitted to the data and their performance is evaluated against a selected metric. There are three methods to call the three different training approaches. Read more in the user guide . run Train and evaluate the models in a direct fashion. successive_halving Fit the models in a successive halving fashion. train_sizing Train and evaluate the models in a train sizing fashion. method run (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a direct fashion. Contrary to successive_halving and train_sizing , the direct approach only iterates once over the models, using the full dataset. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the DirectClassifier or DirectRegressor class for a description of the parameters. method successive_halving (models, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Fit the models in a successive halving fashion. The successive halving technique is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, it is recommended to only use this technique with similar models, e.g. only using tree-based models. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the SuccessiveHalvingClassifier or SuccessiveHalvingRegressor class for a description of the parameters. method train_sizing (models, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, **kwargs) [source] Train and evaluate the models in a train sizing fashion. When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. This method can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). See the TrainSizingClassifier or TrainSizingRegressor class for a description of the parameters.", "title": "Training"}, {"location": "API/data_cleaning/balancer/", "text": "Balancer class atom.data_cleaning. Balancer (strategy=\"ADASYN\", n_jobs=1, verbose=0, logger=None, random_state=None, **kwargs) [source] Balance the number of samples per class in the target column. When oversampling, the newly created samples have an increasing integer index for numerical indices, and an index of the form [estimator]_N for non-numerical indices, where N stands for the N-th sample in the data set. Use only for classification tasks. This class can be accessed from atom through the balance method. Read more in the user guide . Warning The clustercentroids estimator is unavailable because of incompatibilities of the APIs. Parameters strategy: str or estimator, default=\"ADASYN\" Type of algorithm with which to balance the dataset. Choose from the name of any estimator in the imbalanced-learn package or provide a custom instance of such. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 - value. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: imblearn estimator Object (lowercase strategy) used to balance the data, e.g. balancer.adasyn for the default strategy. mapping: dict Target values mapped to their respective encoded integer. See Also Encoder Perform encoding of categorical features. Imputer Handle missing values in the data. Pruner Prune outliers from the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . train ) mean radius mean texture ... worst fractal dimension target 0 18.030 16.85 ... 0.08225 0 1 10.950 21.35 ... 0.09606 0 2 14.250 22.15 ... 0.11320 0 3 17.570 15.05 ... 0.07919 0 4 10.600 18.95 ... 0.07587 1 .. ... ... ... ... ... 451 8.888 14.64 ... 0.10840 1 452 21.090 26.57 ... 0.12840 0 453 16.160 21.54 ... 0.07619 0 454 11.260 19.83 ... 0.07613 1 455 12.000 15.65 ... 0.07924 1 [456 rows x 31 columns] >>> atom . balance ( strategy = \"smote\" , verbose = 2 ) Oversampling with SMOTE... --> Adding 116 samples to class 0. >>> # Note that the number of rows has increased >>> print ( atom . train ) mean radius mean texture ... worst fractal dimension target 0 11.420000 20.380000 ... 0.173000 0 1 9.876000 17.270000 ... 0.073800 1 2 13.470000 14.060000 ... 0.093260 1 3 16.300000 15.700000 ... 0.072300 1 4 12.250000 17.940000 ... 0.081320 1 .. ... ... ... ... ... 567 12.975558 20.580996 ... 0.118509 0 568 11.786135 17.120749 ... 0.091266 0 569 16.194544 19.737215 ... 0.106434 0 570 16.780524 21.261883 ... 0.086889 0 571 20.705316 22.635645 ... 0.085362 0 [572 rows x 31 columns] >>> from atom.data_cleaning import Balancer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> balancer = Balancer ( strategy = \"smote\" , verbose = 2 ) >>> X , y = balancer . transform ( X , y ) Oversampling with SMOTE... --> Adding 145 samples to class 0. >>> # Note that the number of rows has increased >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.990000 10.380000 ... 0.460100 0.118900 1 20.570000 17.770000 ... 0.275000 0.089020 2 19.690000 21.250000 ... 0.361300 0.087580 3 11.420000 20.380000 ... 0.663800 0.173000 4 20.290000 14.340000 ... 0.236400 0.076780 .. ... ... ... ... ... 709 14.824550 17.497674 ... 0.345200 0.100678 710 20.170649 23.997572 ... 0.538881 0.099281 711 21.006050 22.305044 ... 0.277181 0.076740 712 20.791828 25.103989 ... 0.388202 0.122836 713 17.081185 23.560768 ... 0.342508 0.082558 [714 rows x 30 columns] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Balance the data. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=-1) [source] Balance the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence, default=-1 Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Balanced dataframe. pd.Series Transformed target column.", "title": "Balancer"}, {"location": "API/data_cleaning/balancer/#balancer", "text": "class atom.data_cleaning. Balancer (strategy=\"ADASYN\", n_jobs=1, verbose=0, logger=None, random_state=None, **kwargs) [source] Balance the number of samples per class in the target column. When oversampling, the newly created samples have an increasing integer index for numerical indices, and an index of the form [estimator]_N for non-numerical indices, where N stands for the N-th sample in the data set. Use only for classification tasks. This class can be accessed from atom through the balance method. Read more in the user guide . Warning The clustercentroids estimator is unavailable because of incompatibilities of the APIs. Parameters strategy: str or estimator, default=\"ADASYN\" Type of algorithm with which to balance the dataset. Choose from the name of any estimator in the imbalanced-learn package or provide a custom instance of such. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 - value. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: imblearn estimator Object (lowercase strategy) used to balance the data, e.g. balancer.adasyn for the default strategy. mapping: dict Target values mapped to their respective encoded integer. See Also Encoder Perform encoding of categorical features. Imputer Handle missing values in the data. Pruner Prune outliers from the data.", "title": "Balancer"}, {"location": "API/data_cleaning/balancer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . train ) mean radius mean texture ... worst fractal dimension target 0 18.030 16.85 ... 0.08225 0 1 10.950 21.35 ... 0.09606 0 2 14.250 22.15 ... 0.11320 0 3 17.570 15.05 ... 0.07919 0 4 10.600 18.95 ... 0.07587 1 .. ... ... ... ... ... 451 8.888 14.64 ... 0.10840 1 452 21.090 26.57 ... 0.12840 0 453 16.160 21.54 ... 0.07619 0 454 11.260 19.83 ... 0.07613 1 455 12.000 15.65 ... 0.07924 1 [456 rows x 31 columns] >>> atom . balance ( strategy = \"smote\" , verbose = 2 ) Oversampling with SMOTE... --> Adding 116 samples to class 0. >>> # Note that the number of rows has increased >>> print ( atom . train ) mean radius mean texture ... worst fractal dimension target 0 11.420000 20.380000 ... 0.173000 0 1 9.876000 17.270000 ... 0.073800 1 2 13.470000 14.060000 ... 0.093260 1 3 16.300000 15.700000 ... 0.072300 1 4 12.250000 17.940000 ... 0.081320 1 .. ... ... ... ... ... 567 12.975558 20.580996 ... 0.118509 0 568 11.786135 17.120749 ... 0.091266 0 569 16.194544 19.737215 ... 0.106434 0 570 16.780524 21.261883 ... 0.086889 0 571 20.705316 22.635645 ... 0.085362 0 [572 rows x 31 columns] >>> from atom.data_cleaning import Balancer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> balancer = Balancer ( strategy = \"smote\" , verbose = 2 ) >>> X , y = balancer . transform ( X , y ) Oversampling with SMOTE... --> Adding 145 samples to class 0. >>> # Note that the number of rows has increased >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.990000 10.380000 ... 0.460100 0.118900 1 20.570000 17.770000 ... 0.275000 0.089020 2 19.690000 21.250000 ... 0.361300 0.087580 3 11.420000 20.380000 ... 0.663800 0.173000 4 20.290000 14.340000 ... 0.236400 0.076780 .. ... ... ... ... ... 709 14.824550 17.497674 ... 0.345200 0.100678 710 20.170649 23.997572 ... 0.538881 0.099281 711 21.006050 22.305044 ... 0.277181 0.076740 712 20.791828 25.103989 ... 0.388202 0.122836 713 17.081185 23.560768 ... 0.342508 0.082558 [714 rows x 30 columns]", "title": "Example"}, {"location": "API/data_cleaning/balancer/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Balance the data. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=-1) [source] Balance the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence, default=-1 Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Balanced dataframe. pd.Series Transformed target column.", "title": "Methods"}, {"location": "API/data_cleaning/cleaner/", "text": "Cleaner class atom.data_cleaning. Cleaner (drop_types=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None) [source] Applies standard data cleaning steps on a dataset. Use the parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column. This class can be accessed from atom through the clean method. Read more in the user guide . Parameters drop_types: str, sequence or None, default=None Columns with these data types are dropped from the dataset. strip_categorical: bool, default=True Whether to strip spaces from the categorical columns. drop_duplicates: bool, default=False Whether to drop duplicate rows. Only the first occurrence of every duplicated row is kept. drop_missing_target: bool, default=True Whether to drop rows with missing values in the target column. This transformation is ignored if y is not provided. encode_target: bool, default=True Whether to Label-encode the target column. This transformation is ignored if y is not provided. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes missing: list Values that are considered \"missing\". Default values are: \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None , NaN , +inf and -inf are always considered missing since they are incompatible with sklearn estimators. mapping: dict Target values mapped to their respective encoded integer. Only available if encode_target=True. See Also Encoder Perform encoding of categorical features. Discretizer Bin continuous data into intervals. Scaler Scale the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> y = [ \"a\" if i else \"b\" for i in y ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . y ) 0 b 1 b 2 b 3 b 4 a .. 995 b 996 a 997 a 998 b 999 b Name: target, Length: 1000, dtype: object >>> atom . clean ( verbose = 2 ) Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. >>> print ( atom . y ) 0 1 1 1 2 1 3 1 4 0 .. 995 1 996 0 997 0 998 1 999 1 Name: target, Length: 1000, dtype: int32 >>> import numpy as np >>> from atom.data_cleaning import Cleaner >>> y = [ \"a\" if i else \"b\" for i in np . randint ( 100 )] >>> cleaner = Cleaner ( verbose = 2 ) >>> y = cleaner . fit_transform ( y = y ) Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. >>> print ( y ) 0 0 1 0 2 1 3 0 4 0 .. 95 1 96 1 97 0 98 0 99 0 Name: target, Length: 100, dtype: int32 Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Inversely transform the label encoding. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the data cleaning steps to the data. method fit (X=None, y=None) [source] Fit to data. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns Cleaner Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Inversely transform the label encoding. This method only inversely transforms the label encoding. The rest of the transformations can't be inverted. If encode_target=False , the data is returned as is. Parameters X: dataframe-like or None, default=None Does nothing. Implemented for continuity of the API. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Unchanged feature set. Only returned if provided. pd.Series Original target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X=None, y=None) [source] Apply the data cleaning steps to the data. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided.", "title": "Cleaner"}, {"location": "API/data_cleaning/cleaner/#cleaner", "text": "class atom.data_cleaning. Cleaner (drop_types=None, strip_categorical=True, drop_duplicates=False, drop_missing_target=True, encode_target=True, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None) [source] Applies standard data cleaning steps on a dataset. Use the parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column. This class can be accessed from atom through the clean method. Read more in the user guide . Parameters drop_types: str, sequence or None, default=None Columns with these data types are dropped from the dataset. strip_categorical: bool, default=True Whether to strip spaces from the categorical columns. drop_duplicates: bool, default=False Whether to drop duplicate rows. Only the first occurrence of every duplicated row is kept. drop_missing_target: bool, default=True Whether to drop rows with missing values in the target column. This transformation is ignored if y is not provided. encode_target: bool, default=True Whether to Label-encode the target column. This transformation is ignored if y is not provided. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes missing: list Values that are considered \"missing\". Default values are: \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None , NaN , +inf and -inf are always considered missing since they are incompatible with sklearn estimators. mapping: dict Target values mapped to their respective encoded integer. Only available if encode_target=True. See Also Encoder Perform encoding of categorical features. Discretizer Bin continuous data into intervals. Scaler Scale the data.", "title": "Cleaner"}, {"location": "API/data_cleaning/cleaner/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> y = [ \"a\" if i else \"b\" for i in y ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . y ) 0 b 1 b 2 b 3 b 4 a .. 995 b 996 a 997 a 998 b 999 b Name: target, Length: 1000, dtype: object >>> atom . clean ( verbose = 2 ) Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. >>> print ( atom . y ) 0 1 1 1 2 1 3 1 4 0 .. 995 1 996 0 997 0 998 1 999 1 Name: target, Length: 1000, dtype: int32 >>> import numpy as np >>> from atom.data_cleaning import Cleaner >>> y = [ \"a\" if i else \"b\" for i in np . randint ( 100 )] >>> cleaner = Cleaner ( verbose = 2 ) >>> y = cleaner . fit_transform ( y = y ) Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. >>> print ( y ) 0 0 1 0 2 1 3 0 4 0 .. 95 1 96 1 97 0 98 0 99 0 Name: target, Length: 100, dtype: int32", "title": "Example"}, {"location": "API/data_cleaning/cleaner/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Inversely transform the label encoding. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the data cleaning steps to the data. method fit (X=None, y=None) [source] Fit to data. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns Cleaner Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Inversely transform the label encoding. This method only inversely transforms the label encoding. The rest of the transformations can't be inverted. If encode_target=False , the data is returned as is. Parameters X: dataframe-like or None, default=None Does nothing. Implemented for continuity of the API. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Unchanged feature set. Only returned if provided. pd.Series Original target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X=None, y=None) [source] Apply the data cleaning steps to the data. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/data_cleaning/discretizer/", "text": "Discretizer class atom.data_cleaning. Discretizer (strategy=\"quantile\", bins=5, labels=None, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, random_state=None) [source] Bin continuous data into intervals. For each feature, the bin edges are computed during fit and, together with the number of bins, they define the intervals. Ignores categorical columns. This class can be accessed from atom through the discretize method. Read more in the user guide . Tip The transformation returns categorical columns. Use the Encoder class to convert them back to numerical types. Parameters strategy: str, default=\"quantile\" Strategy used to define the widths of the bins. Choose from: \"uniform\": All bins have identical widths. \"quantile\": All bins have the same number of points. \"kmeans\": Values in each bin have the same nearest center of a 1D k-means cluster. \"custom\": Use custom bin edges provided through bins . bins: int, sequence or dict, default=5 Bin number or bin edges in which to split every column. If int: Number of bins to produce for all columns. Only for strategy!=\"custom\". If sequence: For strategy!=\"custom\": Number of bins per column, allowing for non-uniform width. The n-th value corresponds to the n-th column that is transformed. Note that categorical columns are automatically ignored. For strategy=\"custom\": Bin edges with length=n_bins - 1. The outermost edges are always -inf and +inf , e.g. bins [1, 2] indicate (-inf, 1], (1, 2], (2, inf] . If dict: One of the aforementioned options per column, where the key is the column's name. labels: sequence, dict or None, default=None Label names with which to replace the binned intervals. If None: Use default labels of the form (min_edge, max_edge] . If sequence: Labels to use for all columns. If dict: Labels per column, where the key is the column's name. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . Only for strategy=\"quantile\". Attributes feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Encoder Perform encoding of categorical features. Imputer Handle missing values in the data. Normalizer Transform the data to follow a Normal/Gaussian distribution. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom [ \"mean radius\" ]) 0 17.99 1 20.57 2 19.69 3 11.42 4 20.29 ... 564 21.56 565 20.13 566 16.60 567 20.60 568 7.76 Name: mean radius, Length: 569, dtype: float64 >>> atom . discretize ( ... strategy = \"custom\" , ... bins = [ 13 , 18 ], ... labels = [ \"small\" , \"medium\" , \"large\" ], ... verbose = 2 , ... columns = \"mean radius\" , ... ) Fitting Discretizer... Binning the features... --> Discretizing feature mean radius in 3 bins. >>> print ( atom [ \"mean radius\" ]) 0 small 1 medium 2 medium 3 medium 4 small ... 564 large 565 small 566 large 567 small 568 small Name: mean radius, Length: 569, dtype: category Categories (3, object): ['small' < 'medium' < 'large'] >>> from atom.data_cleaning import Discretizer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> print ( X [ \"mean radius\" ]) 0 17.99 1 20.57 2 19.69 3 11.42 4 20.29 ... 564 21.56 565 20.13 566 16.60 567 20.60 568 7.76 Name: mean radius, Length: 569, dtype: float64 >>> disc = Discretizer ( ... strategy = \"custom\" , ... bins = [ 13 , 18 ], ... labels = [ \"small\" , \"medium\" , \"large\" ], ... verbose = 2 , ... ) >>> X [ \"mean radius\" ] = disc . fit_transform ( X [[ \"mean radius\" ]])[ \"mean radius\" ] Fitting Discretizer... Binning the features... --> Discretizing feature mean radius in 3 bins. >>> print ( X [ \"mean radius\" ]) 0 small 1 medium 2 medium 3 medium 4 small ... 564 large 565 small 566 large 567 small 568 small Name: mean radius, Length: 569, dtype: category Categories (3, object): ['small' < 'medium' < 'large'] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Bin the data into intervals. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Discretizer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Bin the data into intervals. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "Discretizer"}, {"location": "API/data_cleaning/discretizer/#discretizer", "text": "class atom.data_cleaning. Discretizer (strategy=\"quantile\", bins=5, labels=None, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, random_state=None) [source] Bin continuous data into intervals. For each feature, the bin edges are computed during fit and, together with the number of bins, they define the intervals. Ignores categorical columns. This class can be accessed from atom through the discretize method. Read more in the user guide . Tip The transformation returns categorical columns. Use the Encoder class to convert them back to numerical types. Parameters strategy: str, default=\"quantile\" Strategy used to define the widths of the bins. Choose from: \"uniform\": All bins have identical widths. \"quantile\": All bins have the same number of points. \"kmeans\": Values in each bin have the same nearest center of a 1D k-means cluster. \"custom\": Use custom bin edges provided through bins . bins: int, sequence or dict, default=5 Bin number or bin edges in which to split every column. If int: Number of bins to produce for all columns. Only for strategy!=\"custom\". If sequence: For strategy!=\"custom\": Number of bins per column, allowing for non-uniform width. The n-th value corresponds to the n-th column that is transformed. Note that categorical columns are automatically ignored. For strategy=\"custom\": Bin edges with length=n_bins - 1. The outermost edges are always -inf and +inf , e.g. bins [1, 2] indicate (-inf, 1], (1, 2], (2, inf] . If dict: One of the aforementioned options per column, where the key is the column's name. labels: sequence, dict or None, default=None Label names with which to replace the binned intervals. If None: Use default labels of the form (min_edge, max_edge] . If sequence: Labels to use for all columns. If dict: Labels per column, where the key is the column's name. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . Only for strategy=\"quantile\". Attributes feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Encoder Perform encoding of categorical features. Imputer Handle missing values in the data. Normalizer Transform the data to follow a Normal/Gaussian distribution.", "title": "Discretizer"}, {"location": "API/data_cleaning/discretizer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom [ \"mean radius\" ]) 0 17.99 1 20.57 2 19.69 3 11.42 4 20.29 ... 564 21.56 565 20.13 566 16.60 567 20.60 568 7.76 Name: mean radius, Length: 569, dtype: float64 >>> atom . discretize ( ... strategy = \"custom\" , ... bins = [ 13 , 18 ], ... labels = [ \"small\" , \"medium\" , \"large\" ], ... verbose = 2 , ... columns = \"mean radius\" , ... ) Fitting Discretizer... Binning the features... --> Discretizing feature mean radius in 3 bins. >>> print ( atom [ \"mean radius\" ]) 0 small 1 medium 2 medium 3 medium 4 small ... 564 large 565 small 566 large 567 small 568 small Name: mean radius, Length: 569, dtype: category Categories (3, object): ['small' < 'medium' < 'large'] >>> from atom.data_cleaning import Discretizer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> print ( X [ \"mean radius\" ]) 0 17.99 1 20.57 2 19.69 3 11.42 4 20.29 ... 564 21.56 565 20.13 566 16.60 567 20.60 568 7.76 Name: mean radius, Length: 569, dtype: float64 >>> disc = Discretizer ( ... strategy = \"custom\" , ... bins = [ 13 , 18 ], ... labels = [ \"small\" , \"medium\" , \"large\" ], ... verbose = 2 , ... ) >>> X [ \"mean radius\" ] = disc . fit_transform ( X [[ \"mean radius\" ]])[ \"mean radius\" ] Fitting Discretizer... Binning the features... --> Discretizing feature mean radius in 3 bins. >>> print ( X [ \"mean radius\" ]) 0 small 1 medium 2 medium 3 medium 4 small ... 564 large 565 small 566 large 567 small 568 small Name: mean radius, Length: 569, dtype: category Categories (3, object): ['small' < 'medium' < 'large']", "title": "Example"}, {"location": "API/data_cleaning/discretizer/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Bin the data into intervals. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Discretizer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Bin the data into intervals. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "Methods"}, {"location": "API/data_cleaning/encoder/", "text": "Encoder class atom.data_cleaning. Encoder (strategy=\"LeaveOneOut\", max_onehot=10, ordinal=None, rare_to_value=None, value=\"rare\", verbose=0, logger=None, **kwargs) [source] Perform encoding of categorical features. The encoding type depends on the number of classes in the column: If n_classes=2 or ordinal feature, use Ordinal-encoding. If 2 < n_classes <= max_onehot , use OneHot-encoding. If n_classes > max_onehot , use strategy -encoding. Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality. This class can be accessed from atom through the encode method. Read more in the user guide . Warning Two category-encoders estimators are unavailable: OneHotEncoder : Use the max_onehot parameter. HashingEncoder : Incompatibility of APIs. Parameters strategy: str or estimator, default=\"LeaveOneOut\" Type of encoding to use for high cardinality features. Choose from any of the estimators in the category-encoders package or provide a custom one. max_onehot: int or None, default=10 Maximum number of unique values in a feature to perform one-hot encoding. If None, strategy -encoding is always used for columns with more than two classes. ordinal: dict or None, default=None Order of ordinal features, where the dict key is the feature's name and the value is the class order, e.g. {\"salary\": [\"low\", \"medium\", \"high\"]} . rare_to_value: int, float or None, default=None Replaces rare class occurrences in categorical columns with the string in parameter value . This transformation is done before the encoding of the column. If None: Skip this step. If int: Minimum number of occurrences in a class. If float: Minimum fraction of occurrences in a class. value: str, default=\"rare\" Value with which to replace rare classes. This parameter is ignored if rare_to_value=None . verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. Attributes mapping: dict of dicts Encoded values and their respective mapping. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Cleaner Applies standard data cleaning steps on a dataset. Imputer Handle missing values in the data. Pruner Prune outliers from the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"cat_feature_1\" ] = [ f \"x { i } \" for i in randint ( 0 , 2 , len ( X ))] >>> X [ \"cat_feature_2\" ] = [ f \"x { i } \" for i in randint ( 0 , 3 , len ( X ))] >>> X [ \"cat_feature_3\" ] = [ f \"x { i } \" for i in randint ( 0 , 20 , len ( X ))] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . X ) mean radius mean texture ... cat_feature_2 cat_feature_3 0 13.62 23.23 ... x0 x0 1 14.86 16.94 ... x0 x5 2 16.74 21.59 ... x2 x15 3 13.37 16.39 ... x1 x18 4 11.37 18.89 ... x0 x13 .. ... ... ... ... ... 564 14.06 17.18 ... x2 x1 565 11.29 13.04 ... x0 x10 566 14.26 19.65 ... x0 x5 567 12.05 14.63 ... x2 x14 568 18.81 19.98 ... x1 x13 [569 rows x 33 columns] >>> atom . encode ( strategy = \"leaveoneout\" , max_onehot = 10 , verbose = 2 ) Fitting Encoder... Encoding categorical columns... --> Ordinal-encoding feature cat_feature_1. Contains 2 classes. --> OneHot-encoding feature cat_feature_2. Contains 3 classes. --> LeaveOneOut-encoding feature cat_feature_3. Contains 20 classes. >>> # Note the one-hot encoded column with name [feature]_[class] >>> print ( atom . X ) mean radius mean texture ... cat_feature_2_x2 cat_feature_3 0 13.62 23.23 ... 0.0 0.714286 1 14.86 16.94 ... 0.0 0.555556 2 16.74 21.59 ... 1.0 0.681818 3 13.37 16.39 ... 0.0 0.739130 4 11.37 18.89 ... 0.0 0.521739 .. ... ... ... ... ... 564 14.06 17.18 ... 1.0 0.772727 565 11.29 13.04 ... 0.0 0.766667 566 14.26 19.65 ... 0.0 0.555556 567 12.05 14.63 ... 1.0 0.411765 568 18.81 19.98 ... 0.0 0.521739 [569 rows x 35 columns] >>> from atom.data_cleaning import Encoder >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"cat_feature_1\" ] = [ f \"x { i } \" for i in randint ( 0 , 2 , len ( X ))] >>> X [ \"cat_feature_2\" ] = [ f \"x { i } \" for i in randint ( 0 , 3 , len ( X ))] >>> X [ \"cat_feature_3\" ] = [ f \"x { i } \" for i in randint ( 0 , 20 , len ( X ))] >>> print ( X ) mean radius mean texture ... cat_feature_2 cat_feature_3 0 13.62 23.23 ... x0 x0 1 14.86 16.94 ... x0 x5 2 16.74 21.59 ... x2 x15 3 13.37 16.39 ... x1 x18 4 11.37 18.89 ... x0 x13 .. ... ... ... ... ... 564 14.06 17.18 ... x2 x1 565 11.29 13.04 ... x0 x10 566 14.26 19.65 ... x0 x5 567 12.05 14.63 ... x2 x14 568 18.81 19.98 ... x1 x13 [569 rows x 33 columns] >>> encoder = Encoder ( strategy = \"leaveoneout\" , max_onehot = 10 , verbose = 2 ) >>> X = encoder . fit_transform ( X , y ) Fitting Encoder... Encoding categorical columns... --> Ordinal-encoding feature cat_feature_1. Contains 2 classes. --> OneHot-encoding feature cat_feature_2. Contains 3 classes. --> LeaveOneOut-encoding feature cat_feature_3. Contains 20 classes. >>> # Note the one-hot encoded column with name [feature]_[class] >>> print ( X ) mean radius mean texture ... cat_feature_2_x2 cat_feature_3 0 17.99 10.38 ... 1.0 0.379310 1 20.57 17.77 ... 1.0 0.714286 2 19.69 21.25 ... 0.0 0.586207 3 11.42 20.38 ... 0.0 0.678571 4 20.29 14.34 ... 0.0 0.714286 .. ... ... ... ... ... 564 21.56 22.39 ... 0.0 0.580645 565 20.13 28.25 ... 0.0 0.518519 566 16.60 28.08 ... 1.0 0.600000 567 20.60 29.33 ... 1.0 0.586207 568 7.76 24.54 ... 1.0 0.678571 [569 rows x 35 columns] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Encode the data. method fit (X, y=None) [source] Fit to data. Note that leaving y=None can lead to errors if the strategy encoder requires target values. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns Encoder Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Encode the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Encoded dataframe.", "title": "Encoder"}, {"location": "API/data_cleaning/encoder/#encoder", "text": "class atom.data_cleaning. Encoder (strategy=\"LeaveOneOut\", max_onehot=10, ordinal=None, rare_to_value=None, value=\"rare\", verbose=0, logger=None, **kwargs) [source] Perform encoding of categorical features. The encoding type depends on the number of classes in the column: If n_classes=2 or ordinal feature, use Ordinal-encoding. If 2 < n_classes <= max_onehot , use OneHot-encoding. If n_classes > max_onehot , use strategy -encoding. Missing values are propagated to the output column. Unknown classes encountered during transforming are imputed according to the selected strategy. Rare classes can be replaced with a value in order to prevent too high cardinality. This class can be accessed from atom through the encode method. Read more in the user guide . Warning Two category-encoders estimators are unavailable: OneHotEncoder : Use the max_onehot parameter. HashingEncoder : Incompatibility of APIs. Parameters strategy: str or estimator, default=\"LeaveOneOut\" Type of encoding to use for high cardinality features. Choose from any of the estimators in the category-encoders package or provide a custom one. max_onehot: int or None, default=10 Maximum number of unique values in a feature to perform one-hot encoding. If None, strategy -encoding is always used for columns with more than two classes. ordinal: dict or None, default=None Order of ordinal features, where the dict key is the feature's name and the value is the class order, e.g. {\"salary\": [\"low\", \"medium\", \"high\"]} . rare_to_value: int, float or None, default=None Replaces rare class occurrences in categorical columns with the string in parameter value . This transformation is done before the encoding of the column. If None: Skip this step. If int: Minimum number of occurrences in a class. If float: Minimum fraction of occurrences in a class. value: str, default=\"rare\" Value with which to replace rare classes. This parameter is ignored if rare_to_value=None . verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. Attributes mapping: dict of dicts Encoded values and their respective mapping. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Cleaner Applies standard data cleaning steps on a dataset. Imputer Handle missing values in the data. Pruner Prune outliers from the data.", "title": "Encoder"}, {"location": "API/data_cleaning/encoder/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"cat_feature_1\" ] = [ f \"x { i } \" for i in randint ( 0 , 2 , len ( X ))] >>> X [ \"cat_feature_2\" ] = [ f \"x { i } \" for i in randint ( 0 , 3 , len ( X ))] >>> X [ \"cat_feature_3\" ] = [ f \"x { i } \" for i in randint ( 0 , 20 , len ( X ))] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . X ) mean radius mean texture ... cat_feature_2 cat_feature_3 0 13.62 23.23 ... x0 x0 1 14.86 16.94 ... x0 x5 2 16.74 21.59 ... x2 x15 3 13.37 16.39 ... x1 x18 4 11.37 18.89 ... x0 x13 .. ... ... ... ... ... 564 14.06 17.18 ... x2 x1 565 11.29 13.04 ... x0 x10 566 14.26 19.65 ... x0 x5 567 12.05 14.63 ... x2 x14 568 18.81 19.98 ... x1 x13 [569 rows x 33 columns] >>> atom . encode ( strategy = \"leaveoneout\" , max_onehot = 10 , verbose = 2 ) Fitting Encoder... Encoding categorical columns... --> Ordinal-encoding feature cat_feature_1. Contains 2 classes. --> OneHot-encoding feature cat_feature_2. Contains 3 classes. --> LeaveOneOut-encoding feature cat_feature_3. Contains 20 classes. >>> # Note the one-hot encoded column with name [feature]_[class] >>> print ( atom . X ) mean radius mean texture ... cat_feature_2_x2 cat_feature_3 0 13.62 23.23 ... 0.0 0.714286 1 14.86 16.94 ... 0.0 0.555556 2 16.74 21.59 ... 1.0 0.681818 3 13.37 16.39 ... 0.0 0.739130 4 11.37 18.89 ... 0.0 0.521739 .. ... ... ... ... ... 564 14.06 17.18 ... 1.0 0.772727 565 11.29 13.04 ... 0.0 0.766667 566 14.26 19.65 ... 0.0 0.555556 567 12.05 14.63 ... 1.0 0.411765 568 18.81 19.98 ... 0.0 0.521739 [569 rows x 35 columns] >>> from atom.data_cleaning import Encoder >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"cat_feature_1\" ] = [ f \"x { i } \" for i in randint ( 0 , 2 , len ( X ))] >>> X [ \"cat_feature_2\" ] = [ f \"x { i } \" for i in randint ( 0 , 3 , len ( X ))] >>> X [ \"cat_feature_3\" ] = [ f \"x { i } \" for i in randint ( 0 , 20 , len ( X ))] >>> print ( X ) mean radius mean texture ... cat_feature_2 cat_feature_3 0 13.62 23.23 ... x0 x0 1 14.86 16.94 ... x0 x5 2 16.74 21.59 ... x2 x15 3 13.37 16.39 ... x1 x18 4 11.37 18.89 ... x0 x13 .. ... ... ... ... ... 564 14.06 17.18 ... x2 x1 565 11.29 13.04 ... x0 x10 566 14.26 19.65 ... x0 x5 567 12.05 14.63 ... x2 x14 568 18.81 19.98 ... x1 x13 [569 rows x 33 columns] >>> encoder = Encoder ( strategy = \"leaveoneout\" , max_onehot = 10 , verbose = 2 ) >>> X = encoder . fit_transform ( X , y ) Fitting Encoder... Encoding categorical columns... --> Ordinal-encoding feature cat_feature_1. Contains 2 classes. --> OneHot-encoding feature cat_feature_2. Contains 3 classes. --> LeaveOneOut-encoding feature cat_feature_3. Contains 20 classes. >>> # Note the one-hot encoded column with name [feature]_[class] >>> print ( X ) mean radius mean texture ... cat_feature_2_x2 cat_feature_3 0 17.99 10.38 ... 1.0 0.379310 1 20.57 17.77 ... 1.0 0.714286 2 19.69 21.25 ... 0.0 0.586207 3 11.42 20.38 ... 0.0 0.678571 4 20.29 14.34 ... 0.0 0.714286 .. ... ... ... ... ... 564 21.56 22.39 ... 0.0 0.580645 565 20.13 28.25 ... 0.0 0.518519 566 16.60 28.08 ... 1.0 0.600000 567 20.60 29.33 ... 1.0 0.586207 568 7.76 24.54 ... 1.0 0.678571 [569 rows x 35 columns]", "title": "Example"}, {"location": "API/data_cleaning/encoder/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Encode the data. method fit (X, y=None) [source] Fit to data. Note that leaving y=None can lead to errors if the strategy encoder requires target values. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns Encoder Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Encode the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Encoded dataframe.", "title": "Methods"}, {"location": "API/data_cleaning/imputer/", "text": "Imputer class atom.data_cleaning. Imputer (strat_num=\"drop\", strat_cat=\"drop\", max_nan_rows=None, max_nan_cols=None, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None) [source] Handle missing values in the data. Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the missing attribute to customize what are considered \"missing values\". This class can be accessed from atom through the impute method. Read more in the user guide . Parameters strat_num: str, int or float, default=\"drop\" Imputing strategy for numerical columns. Choose from: \"drop\": Drop rows containing missing values. \"mean\": Impute with mean of column. \"median\": Impute with median of column. \"knn\": Impute using a K-Nearest Neighbors approach. \"most_frequent\": Impute with most frequent value. int or float: Impute with provided numerical value. strat_cat: str, default=\"drop\" Imputing strategy for categorical columns. Choose from: \"drop\": Drop rows containing missing values. \"most_frequent\": Impute with most frequent value. str: Impute with provided string. max_nan_rows: int, float or None, default=None Maximum number or fraction of missing values in a row (if more, the row is removed). If None, ignore this step. max_nan_cols: int, float or None, default=None Maximum number or fraction of missing values in a column (if more, the column is removed). If None, ignore this step. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes missing: list Values that are considered \"missing\". Default values are: \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None , NaN , +inf and -inf are always considered missing since they are incompatible with sklearn estimators. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Balancer Balance the number of samples per class in the target column. Discretizer Bin continuous data into intervals. Encoder Perform encoding of categorical features. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Add some random missing values to the data >>> for i , j in zip ( randint ( 0 , X . shape [ 0 ], 600 ), randint ( 0 , 4 , 600 ]) >>> X . iat [ i , j ] = np . nan >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . nans ) mean radius 118 mean texture 134 mean perimeter 135 mean area 140 dtype: int64 >>> atom . impute ( strat_num = \"median\" , max_nan_rows = 0.1 , verbose = 2 ) Fitting Imputer... Imputing missing values... --> Dropping 3 samples for containing more than 3 missing values. --> Imputing 115 missing values with median (13.3) in feature mean radius. --> Imputing 131 missing values with median (18.8) in feature mean texture. --> Imputing 132 missing values with median (85.86) in feature mean perimeter. --> Imputing 137 missing values with median (561.3) in feature mean area. >>> print ( atom . n_nans ) 0 >>> from atom.data_cleaning import Imputer >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Add some random missing values to the data >>> for i , j in zip ( randint ( 0 , X . shape [ 0 ], 600 ), randint ( 0 , 4 , 600 ]) >>> X . iloc [ i , j ] = np . nan mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 NaN ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 NaN 20.38 ... 0.6638 0.17300 4 NaN 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 NaN 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 NaN NaN ... 0.2218 0.07820 567 NaN 29.33 ... 0.4087 0.12400 568 NaN 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> imputer = Imputer ( strat_num = \"median\" , max_nan_rows = 0.1 , verbose = 2 ) >>> X , y = imputer . fit_transform ( X , y ) Fitting Imputer... Imputing missing values... --> Imputing 135 missing values with median (13.42) in feature mean radius. --> Imputing 133 missing values with median (18.81) in feature mean texture. --> Imputing 129 missing values with median (86.14) in feature mean perimeter. --> Imputing 120 missing values with median (537.9) in feature mean area. >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.990 10.38 ... 0.4601 0.11890 1 13.415 17.77 ... 0.2750 0.08902 2 19.690 21.25 ... 0.3613 0.08758 3 11.420 20.38 ... 0.6638 0.17300 4 20.290 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.560 22.39 ... 0.2060 0.07115 565 20.130 28.25 ... 0.2572 0.06637 566 13.415 28.08 ... 0.2218 0.07820 567 13.415 18.81 ... 0.4087 0.12400 568 7.760 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Impute the missing values. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Imputer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Impute the missing values. Note that leaving y=None can lead to inconsistencies in data length between X and y if rows are dropped during the transformation. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Imputed dataframe. pd.Series Transformed target column. Only returned if provided.", "title": "Imputer"}, {"location": "API/data_cleaning/imputer/#imputer", "text": "class atom.data_cleaning. Imputer (strat_num=\"drop\", strat_cat=\"drop\", max_nan_rows=None, max_nan_cols=None, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None) [source] Handle missing values in the data. Impute or remove missing values according to the selected strategy. Also removes rows and columns with too many missing values. Use the missing attribute to customize what are considered \"missing values\". This class can be accessed from atom through the impute method. Read more in the user guide . Parameters strat_num: str, int or float, default=\"drop\" Imputing strategy for numerical columns. Choose from: \"drop\": Drop rows containing missing values. \"mean\": Impute with mean of column. \"median\": Impute with median of column. \"knn\": Impute using a K-Nearest Neighbors approach. \"most_frequent\": Impute with most frequent value. int or float: Impute with provided numerical value. strat_cat: str, default=\"drop\" Imputing strategy for categorical columns. Choose from: \"drop\": Drop rows containing missing values. \"most_frequent\": Impute with most frequent value. str: Impute with provided string. max_nan_rows: int, float or None, default=None Maximum number or fraction of missing values in a row (if more, the row is removed). If None, ignore this step. max_nan_cols: int, float or None, default=None Maximum number or fraction of missing values in a column (if more, the column is removed). If None, ignore this step. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes missing: list Values that are considered \"missing\". Default values are: \"\", \"?\", \"None\", \"NA\", \"nan\", \"NaN\" and \"inf\". Note that None , NaN , +inf and -inf are always considered missing since they are incompatible with sklearn estimators. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Balancer Balance the number of samples per class in the target column. Discretizer Bin continuous data into intervals. Encoder Perform encoding of categorical features.", "title": "Imputer"}, {"location": "API/data_cleaning/imputer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Add some random missing values to the data >>> for i , j in zip ( randint ( 0 , X . shape [ 0 ], 600 ), randint ( 0 , 4 , 600 ]) >>> X . iat [ i , j ] = np . nan >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . nans ) mean radius 118 mean texture 134 mean perimeter 135 mean area 140 dtype: int64 >>> atom . impute ( strat_num = \"median\" , max_nan_rows = 0.1 , verbose = 2 ) Fitting Imputer... Imputing missing values... --> Dropping 3 samples for containing more than 3 missing values. --> Imputing 115 missing values with median (13.3) in feature mean radius. --> Imputing 131 missing values with median (18.8) in feature mean texture. --> Imputing 132 missing values with median (85.86) in feature mean perimeter. --> Imputing 137 missing values with median (561.3) in feature mean area. >>> print ( atom . n_nans ) 0 >>> from atom.data_cleaning import Imputer >>> from sklearn.datasets import load_breast_cancer >>> from numpy.random import randint >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Add some random missing values to the data >>> for i , j in zip ( randint ( 0 , X . shape [ 0 ], 600 ), randint ( 0 , 4 , 600 ]) >>> X . iloc [ i , j ] = np . nan mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 NaN ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 NaN 20.38 ... 0.6638 0.17300 4 NaN 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 NaN 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 NaN NaN ... 0.2218 0.07820 567 NaN 29.33 ... 0.4087 0.12400 568 NaN 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> imputer = Imputer ( strat_num = \"median\" , max_nan_rows = 0.1 , verbose = 2 ) >>> X , y = imputer . fit_transform ( X , y ) Fitting Imputer... Imputing missing values... --> Imputing 135 missing values with median (13.42) in feature mean radius. --> Imputing 133 missing values with median (18.81) in feature mean texture. --> Imputing 129 missing values with median (86.14) in feature mean perimeter. --> Imputing 120 missing values with median (537.9) in feature mean area. >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.990 10.38 ... 0.4601 0.11890 1 13.415 17.77 ... 0.2750 0.08902 2 19.690 21.25 ... 0.3613 0.08758 3 11.420 20.38 ... 0.6638 0.17300 4 20.290 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.560 22.39 ... 0.2060 0.07115 565 20.130 28.25 ... 0.2572 0.06637 566 13.415 28.08 ... 0.2218 0.07820 567 13.415 18.81 ... 0.4087 0.12400 568 7.760 24.54 ... 0.2871 0.07039 [569 rows x 30 columns]", "title": "Example"}, {"location": "API/data_cleaning/imputer/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Impute the missing values. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Imputer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Impute the missing values. Note that leaving y=None can lead to inconsistencies in data length between X and y if rows are dropped during the transformation. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Imputed dataframe. pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/data_cleaning/normalizer/", "text": "Normalizer class atom.data_cleaning. Normalizer (strategy=\"yeojohnson\", device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, random_state=None, **kwargs) [source] Transform the data to follow a Normal/Gaussian distribution. This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Categorical columns are ignored. This class can be accessed from atom through the normalize method. Read more in the user guide . Warning The quantile strategy performs a non-linear transformation. This may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable. Note The yeojohnson and boxcox strategies scale the data after transforming. Use the kwargs to change this behaviour. Parameters strategy: str, default=\"yeojohnson\" The transforming strategy. Choose from: \" yeojohnson \" \" boxcox \" (only works with strictly positive values) \" quantile \": Transform features using quantiles information. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the quantile strategy. If None, the random number generator is the RandomState used by np.random . **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: sklearn transformer Object with which the data is transformed. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. NaN , +inf and -inf are always considered missing since they are incompatible with sklearn estimators. See Also Cleaner Applies standard data cleaning steps on a dataset. Pruner Prune outliers from the data. Scaler Scale the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 16.78 18.80 ... 0.07228 0 1 15.34 14.26 ... 0.09946 0 2 14.22 27.85 ... 0.07796 1 3 18.31 18.58 ... 0.06938 0 4 18.49 17.52 ... 0.09445 0 .. ... ... ... ... ... 564 13.44 21.58 ... 0.07146 0 565 20.47 20.67 ... 0.06386 0 566 12.98 19.35 ... 0.09166 1 567 14.61 15.69 ... 0.05695 1 568 23.27 22.04 ... 0.09187 0 [569 rows x 31 columns] >>> atom . plot_distribution ( columns = 0 ) ; >>> atom . normalize ( verbose = 2 ) Fitting Normalizer... Normalizing features... >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 0.868700 0.010820 ... -0.684572 0 1 0.513904 -1.257343 ... 1.019875 0 2 0.200435 1.773390 ... -0.226619 1 3 1.197448 -0.042755 ... -0.945047 0 4 1.233326 -0.310726 ... 0.786014 0 .. ... ... ... ... ... 564 -0.041166 0.635293 ... -0.756291 0 565 1.595052 0.440855 ... -1.497202 0 566 -0.193933 0.141884 ... 0.642613 1 567 0.313768 -0.816597 ... -2.307746 1 568 2.022355 0.730259 ... 0.653756 0 [569 rows x 31 columns] >>> atom . plot_distribution ( columns = 0 ) ; >>> from atom.data_cleaning import Normalizer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> normalizer = Normalizer ( verbose = 2 ) >>> X = normalizer . fit_transform ( X ) Fitting Normalizer... Normalizing features... >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 1.134881 -2.678666 ... 2.197206 1.723624 1 1.619346 -0.264377 ... -0.121997 0.537179 2 1.464796 0.547806 ... 1.218181 0.453955 3 -0.759262 0.357721 ... 3.250202 2.517606 4 1.571260 -1.233520 ... -0.943554 -0.279402 .. ... ... ... ... ... 564 1.781795 0.785604 ... -1.721528 -0.751459 565 1.543335 1.845150 ... -0.480093 -1.210527 566 0.828589 1.817618 ... -1.301164 -0.170872 567 1.624440 2.016299 ... 1.744693 1.850944 568 -2.699432 1.203224 ... 0.103122 -0.820663 [569 rows x 30 columns] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Apply the inverse transformation to the data. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the transformations to the data. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Normalizer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X, y=None) [source] Apply the inverse transformation to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Original dataframe. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Apply the transformations to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Normalized dataframe.", "title": "Normalizer"}, {"location": "API/data_cleaning/normalizer/#normalizer", "text": "class atom.data_cleaning. Normalizer (strategy=\"yeojohnson\", device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, random_state=None, **kwargs) [source] Transform the data to follow a Normal/Gaussian distribution. This transformation is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired. Missing values are disregarded in fit and maintained in transform. Categorical columns are ignored. This class can be accessed from atom through the normalize method. Read more in the user guide . Warning The quantile strategy performs a non-linear transformation. This may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable. Note The yeojohnson and boxcox strategies scale the data after transforming. Use the kwargs to change this behaviour. Parameters strategy: str, default=\"yeojohnson\" The transforming strategy. Choose from: \" yeojohnson \" \" boxcox \" (only works with strictly positive values) \" quantile \": Transform features using quantiles information. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the quantile strategy. If None, the random number generator is the RandomState used by np.random . **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: sklearn transformer Object with which the data is transformed. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. NaN , +inf and -inf are always considered missing since they are incompatible with sklearn estimators. See Also Cleaner Applies standard data cleaning steps on a dataset. Pruner Prune outliers from the data. Scaler Scale the data.", "title": "Normalizer"}, {"location": "API/data_cleaning/normalizer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 16.78 18.80 ... 0.07228 0 1 15.34 14.26 ... 0.09946 0 2 14.22 27.85 ... 0.07796 1 3 18.31 18.58 ... 0.06938 0 4 18.49 17.52 ... 0.09445 0 .. ... ... ... ... ... 564 13.44 21.58 ... 0.07146 0 565 20.47 20.67 ... 0.06386 0 566 12.98 19.35 ... 0.09166 1 567 14.61 15.69 ... 0.05695 1 568 23.27 22.04 ... 0.09187 0 [569 rows x 31 columns] >>> atom . plot_distribution ( columns = 0 ) ; >>> atom . normalize ( verbose = 2 ) Fitting Normalizer... Normalizing features... >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 0.868700 0.010820 ... -0.684572 0 1 0.513904 -1.257343 ... 1.019875 0 2 0.200435 1.773390 ... -0.226619 1 3 1.197448 -0.042755 ... -0.945047 0 4 1.233326 -0.310726 ... 0.786014 0 .. ... ... ... ... ... 564 -0.041166 0.635293 ... -0.756291 0 565 1.595052 0.440855 ... -1.497202 0 566 -0.193933 0.141884 ... 0.642613 1 567 0.313768 -0.816597 ... -2.307746 1 568 2.022355 0.730259 ... 0.653756 0 [569 rows x 31 columns] >>> atom . plot_distribution ( columns = 0 ) ; >>> from atom.data_cleaning import Normalizer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> normalizer = Normalizer ( verbose = 2 ) >>> X = normalizer . fit_transform ( X ) Fitting Normalizer... Normalizing features... >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 1.134881 -2.678666 ... 2.197206 1.723624 1 1.619346 -0.264377 ... -0.121997 0.537179 2 1.464796 0.547806 ... 1.218181 0.453955 3 -0.759262 0.357721 ... 3.250202 2.517606 4 1.571260 -1.233520 ... -0.943554 -0.279402 .. ... ... ... ... ... 564 1.781795 0.785604 ... -1.721528 -0.751459 565 1.543335 1.845150 ... -0.480093 -1.210527 566 0.828589 1.817618 ... -1.301164 -0.170872 567 1.624440 2.016299 ... 1.744693 1.850944 568 -2.699432 1.203224 ... 0.103122 -0.820663 [569 rows x 30 columns]", "title": "Example"}, {"location": "API/data_cleaning/normalizer/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Apply the inverse transformation to the data. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the transformations to the data. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Normalizer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X, y=None) [source] Apply the inverse transformation to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Original dataframe. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Apply the transformations to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Normalized dataframe.", "title": "Methods"}, {"location": "API/data_cleaning/pruner/", "text": "Pruner class atom.data_cleaning. Pruner (strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, **kwargs) [source] Prune outliers from the data. Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns. This class can be accessed from atom through the prune method. Read more in the user guide . Info The \"sklearnex\" and \"cuml\" engines are only supported for strategy=\"dbscan\". Parameters strategy: str or sequence, default=\"zscore\" Strategy with which to select the outliers. If sequence of strategies, only samples marked as outliers by all chosen strategies are dropped. Choose from: \"zscore\": Z-score of each data value. \" iforest \": Isolation Forest. \" ee \": Elliptic Envelope. \" lof \": Local Outlier Factor. \" svm \": One-class SVM. \" dbscan \": Density-Based Spatial Clustering. \" optics \": DBSCAN-like clustering approach. method: int, float or str, default=\"drop\" Method to apply on the outliers. Only the zscore strategy accepts another method than \"drop\". Choose from: \"drop\": Drop any sample with outlier values. \"min_max\": Replace outlier with the min/max of the column. Any numerical value with which to replace the outliers. max_sigma: int or float, default=3 Maximum allowed standard deviations from the mean of the column. If more, it is considered an outlier. Only if strategy=\"zscore\". include_target: bool, default=False Whether to include the target column in the search for outliers. This can be useful for regression tasks. Only if strategy=\"zscore\". device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. If sequence of strategies, the params should be provided in a dict with the strategy's name as key. Attributes [strategy]: sklearn estimator Object used to prune the data, e.g. pruner.iforest for the isolation forest strategy. See Also Balancer Balance the number of samples per class in the target column. Normalizer Transform the data to follow a Normal/Gaussian distribution. Scaler Scale the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 11.04 14.93 ... 0.07287 1 1 12.46 24.04 ... 0.20750 0 2 13.47 14.06 ... 0.09326 1 3 13.44 21.58 ... 0.07146 0 4 11.93 21.53 ... 0.08541 1 .. ... ... ... ... ... 564 14.54 27.54 ... 0.13410 0 565 18.66 17.12 ... 0.08456 0 566 10.95 21.35 ... 0.09606 0 567 17.01 20.26 ... 0.06469 0 568 12.40 17.68 ... 0.09359 1 [569 rows x 31 columns] >>> atom . prune ( stratgey = \"iforest\" , verbose = 2 ) Pruning outliers... --> Dropping 46 outliers. >>> # Note the reduced number of rows >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 11.04 14.93 ... 0.07287 1 1 13.47 14.06 ... 0.09326 1 2 13.44 21.58 ... 0.07146 0 3 11.93 21.53 ... 0.08541 1 4 13.21 25.25 ... 0.06788 1 .. ... ... ... ... ... 518 14.54 27.54 ... 0.13410 0 519 18.66 17.12 ... 0.08456 0 520 10.95 21.35 ... 0.09606 0 521 17.01 20.26 ... 0.06469 0 522 12.40 17.68 ... 0.09359 1 [523 rows x 31 columns] >>> atom . plot_distribution ( columns = 0 ) >>> from atom.data_cleaning import Normalizer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> normalizer = Normalizer ( verbose = 2 ) >>> X = normalizer . fit_transform ( X ) Fitting Pruner... Pruning outliers... --> Dropping 74 outliers. >>> # Note the reduced number of rows >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 4 20.29 14.34 ... 0.2364 0.07678 5 12.45 15.70 ... 0.3985 0.12440 6 18.25 19.98 ... 0.3063 0.08368 .. ... ... ... ... ... 560 14.05 27.15 ... 0.2250 0.08321 563 20.92 25.09 ... 0.2929 0.09873 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 [495 rows x 30 columns] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the outlier strategy on the data. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Apply the outlier strategy on the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. pd.Series Transformed target column. Only returned if provided.", "title": "Pruner"}, {"location": "API/data_cleaning/pruner/#pruner", "text": "class atom.data_cleaning. Pruner (strategy=\"zscore\", method=\"drop\", max_sigma=3, include_target=False, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, **kwargs) [source] Prune outliers from the data. Replace or remove outliers. The definition of outlier depends on the selected strategy and can greatly differ from one another. Ignores categorical columns. This class can be accessed from atom through the prune method. Read more in the user guide . Info The \"sklearnex\" and \"cuml\" engines are only supported for strategy=\"dbscan\". Parameters strategy: str or sequence, default=\"zscore\" Strategy with which to select the outliers. If sequence of strategies, only samples marked as outliers by all chosen strategies are dropped. Choose from: \"zscore\": Z-score of each data value. \" iforest \": Isolation Forest. \" ee \": Elliptic Envelope. \" lof \": Local Outlier Factor. \" svm \": One-class SVM. \" dbscan \": Density-Based Spatial Clustering. \" optics \": DBSCAN-like clustering approach. method: int, float or str, default=\"drop\" Method to apply on the outliers. Only the zscore strategy accepts another method than \"drop\". Choose from: \"drop\": Drop any sample with outlier values. \"min_max\": Replace outlier with the min/max of the column. Any numerical value with which to replace the outliers. max_sigma: int or float, default=3 Maximum allowed standard deviations from the mean of the column. If more, it is considered an outlier. Only if strategy=\"zscore\". include_target: bool, default=False Whether to include the target column in the search for outliers. This can be useful for regression tasks. Only if strategy=\"zscore\". device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. If sequence of strategies, the params should be provided in a dict with the strategy's name as key. Attributes [strategy]: sklearn estimator Object used to prune the data, e.g. pruner.iforest for the isolation forest strategy. See Also Balancer Balance the number of samples per class in the target column. Normalizer Transform the data to follow a Normal/Gaussian distribution. Scaler Scale the data.", "title": "Pruner"}, {"location": "API/data_cleaning/pruner/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 11.04 14.93 ... 0.07287 1 1 12.46 24.04 ... 0.20750 0 2 13.47 14.06 ... 0.09326 1 3 13.44 21.58 ... 0.07146 0 4 11.93 21.53 ... 0.08541 1 .. ... ... ... ... ... 564 14.54 27.54 ... 0.13410 0 565 18.66 17.12 ... 0.08456 0 566 10.95 21.35 ... 0.09606 0 567 17.01 20.26 ... 0.06469 0 568 12.40 17.68 ... 0.09359 1 [569 rows x 31 columns] >>> atom . prune ( stratgey = \"iforest\" , verbose = 2 ) Pruning outliers... --> Dropping 46 outliers. >>> # Note the reduced number of rows >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 11.04 14.93 ... 0.07287 1 1 13.47 14.06 ... 0.09326 1 2 13.44 21.58 ... 0.07146 0 3 11.93 21.53 ... 0.08541 1 4 13.21 25.25 ... 0.06788 1 .. ... ... ... ... ... 518 14.54 27.54 ... 0.13410 0 519 18.66 17.12 ... 0.08456 0 520 10.95 21.35 ... 0.09606 0 521 17.01 20.26 ... 0.06469 0 522 12.40 17.68 ... 0.09359 1 [523 rows x 31 columns] >>> atom . plot_distribution ( columns = 0 ) >>> from atom.data_cleaning import Normalizer >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> normalizer = Normalizer ( verbose = 2 ) >>> X = normalizer . fit_transform ( X ) Fitting Pruner... Pruning outliers... --> Dropping 74 outliers. >>> # Note the reduced number of rows >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 4 20.29 14.34 ... 0.2364 0.07678 5 12.45 15.70 ... 0.3985 0.12440 6 18.25 19.98 ... 0.3063 0.08368 .. ... ... ... ... ... 560 14.05 27.15 ... 0.2250 0.08321 563 20.92 25.09 ... 0.2929 0.09873 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 [495 rows x 30 columns]", "title": "Example"}, {"location": "API/data_cleaning/pruner/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the outlier strategy on the data. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Apply the outlier strategy on the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/data_cleaning/scaler/", "text": "Scaler class atom.data_cleaning. Scaler (strategy=\"standard\", include_binary=False, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, **kwargs) [source] Scale the data. Apply one of sklearn's scalers. Categorical columns are ignored. This class can be accessed from atom through the scale method. Read more in the user guide . Parameters strategy: str, default=\"standard\" Strategy with which to scale the data. Choose from: \" standard \": Remove mean and scale to unit variance. \" minmax \": Scale features to a given range. \" maxabs \": Scale features by their maximum absolute value. \" robust \": Scale using statistics that are robust to outliers. include_binary: bool, default=False Whether to scale binary columns (only 0s and 1s). device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: sklearn transformer Object with which the data is scaled. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Balancer Balance the number of samples per class in the target column. Normalizer Transform the data to follow a Normal/Gaussian distribution. Scaler Scale the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 17.99 10.38 ... 0.11890 0 1 12.25 17.94 ... 0.08132 1 2 13.87 20.70 ... 0.08492 1 3 12.06 12.74 ... 0.07898 1 4 12.62 17.15 ... 0.07330 1 .. ... ... ... ... ... 564 11.34 18.61 ... 0.06783 1 565 11.43 17.31 ... 0.08096 1 566 11.06 14.96 ... 0.09080 1 567 13.20 15.82 ... 0.08385 1 568 20.55 20.86 ... 0.07569 0 [569 rows x 31 columns] >>> atom . scale ( verbose = 2 ) Fitting Scaler... Scaling features... >>> # Note the reduced number of rows >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 1.052603 -2.089926 ... 1.952598 0 1 -0.529046 -0.336627 ... -0.114004 1 2 -0.082657 0.303467 ... 0.083968 1 3 -0.581401 -1.542600 ... -0.242685 1 4 -0.427093 -0.519842 ... -0.555040 1 .. ... ... ... ... ... 564 -0.779796 -0.181242 ... -0.855847 1 565 -0.754996 -0.482735 ... -0.133801 1 566 -0.856949 -1.027742 ... 0.407321 1 567 -0.267275 -0.828293 ... 0.025126 1 568 1.758008 0.340573 ... -0.423609 0 [569 rows x 31 columns] >>> from atom.data_cleaning import Scaler >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> scaler = Scaler ( verbose = 2 ) >>> X = scaler . fit_transform ( X ) Fitting Scaler... Scaling features... >>> # Note the reduced number of rows >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 1.097064 -2.073335 ... 2.750622 1.937015 1 1.829821 -0.353632 ... -0.243890 0.281190 2 1.579888 0.456187 ... 1.152255 0.201391 3 -0.768909 0.253732 ... 6.046041 4.935010 4 1.750297 -1.151816 ... -0.868353 -0.397100 .. ... ... ... ... ... 564 2.110995 0.721473 ... -1.360158 -0.709091 565 1.704854 2.085134 ... -0.531855 -0.973978 566 0.702284 2.045574 ... -1.104549 -0.318409 567 1.838341 2.336457 ... 1.919083 2.219635 568 -1.808401 1.221792 ... -0.048138 -0.751207 [569 rows x 30 columns] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Apply the inverse transformation to the data. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Perform standardization by centering and scaling. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Scaler Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X, y=None) [source] Apply the inverse transformation to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Scaled dataframe. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Perform standardization by centering and scaling. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Scaled dataframe.", "title": "Scaler"}, {"location": "API/data_cleaning/scaler/#scaler", "text": "class atom.data_cleaning. Scaler (strategy=\"standard\", include_binary=False, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, **kwargs) [source] Scale the data. Apply one of sklearn's scalers. Categorical columns are ignored. This class can be accessed from atom through the scale method. Read more in the user guide . Parameters strategy: str, default=\"standard\" Strategy with which to scale the data. Choose from: \" standard \": Remove mean and scale to unit variance. \" minmax \": Scale features to a given range. \" maxabs \": Scale features by their maximum absolute value. \" robust \": Scale using statistics that are robust to outliers. include_binary: bool, default=False Whether to scale binary columns (only 0s and 1s). device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: sklearn transformer Object with which the data is scaled. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also Balancer Balance the number of samples per class in the target column. Normalizer Transform the data to follow a Normal/Gaussian distribution. Scaler Scale the data.", "title": "Scaler"}, {"location": "API/data_cleaning/scaler/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 17.99 10.38 ... 0.11890 0 1 12.25 17.94 ... 0.08132 1 2 13.87 20.70 ... 0.08492 1 3 12.06 12.74 ... 0.07898 1 4 12.62 17.15 ... 0.07330 1 .. ... ... ... ... ... 564 11.34 18.61 ... 0.06783 1 565 11.43 17.31 ... 0.08096 1 566 11.06 14.96 ... 0.09080 1 567 13.20 15.82 ... 0.08385 1 568 20.55 20.86 ... 0.07569 0 [569 rows x 31 columns] >>> atom . scale ( verbose = 2 ) Fitting Scaler... Scaling features... >>> # Note the reduced number of rows >>> print ( atom . dataset ) mean radius mean texture ... worst fractal dimension target 0 1.052603 -2.089926 ... 1.952598 0 1 -0.529046 -0.336627 ... -0.114004 1 2 -0.082657 0.303467 ... 0.083968 1 3 -0.581401 -1.542600 ... -0.242685 1 4 -0.427093 -0.519842 ... -0.555040 1 .. ... ... ... ... ... 564 -0.779796 -0.181242 ... -0.855847 1 565 -0.754996 -0.482735 ... -0.133801 1 566 -0.856949 -1.027742 ... 0.407321 1 567 -0.267275 -0.828293 ... 0.025126 1 568 1.758008 0.340573 ... -0.423609 0 [569 rows x 31 columns] >>> from atom.data_cleaning import Scaler >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) mean radius mean texture ... worst symmetry worst fractal dimension 0 17.99 10.38 ... 0.4601 0.11890 1 20.57 17.77 ... 0.2750 0.08902 2 19.69 21.25 ... 0.3613 0.08758 3 11.42 20.38 ... 0.6638 0.17300 4 20.29 14.34 ... 0.2364 0.07678 .. ... ... ... ... ... 564 21.56 22.39 ... 0.2060 0.07115 565 20.13 28.25 ... 0.2572 0.06637 566 16.60 28.08 ... 0.2218 0.07820 567 20.60 29.33 ... 0.4087 0.12400 568 7.76 24.54 ... 0.2871 0.07039 [569 rows x 30 columns] >>> scaler = Scaler ( verbose = 2 ) >>> X = scaler . fit_transform ( X ) Fitting Scaler... Scaling features... >>> # Note the reduced number of rows >>> print ( X ) mean radius mean texture ... worst symmetry worst fractal dimension 0 1.097064 -2.073335 ... 2.750622 1.937015 1 1.829821 -0.353632 ... -0.243890 0.281190 2 1.579888 0.456187 ... 1.152255 0.201391 3 -0.768909 0.253732 ... 6.046041 4.935010 4 1.750297 -1.151816 ... -0.868353 -0.397100 .. ... ... ... ... ... 564 2.110995 0.721473 ... -1.360158 -0.709091 565 1.704854 2.085134 ... -0.531855 -0.973978 566 0.702284 2.045574 ... -1.104549 -0.318409 567 1.838341 2.336457 ... 1.919083 2.219635 568 -1.808401 1.221792 ... -0.048138 -0.751207 [569 rows x 30 columns]", "title": "Example"}, {"location": "API/data_cleaning/scaler/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Apply the inverse transformation to the data. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Perform standardization by centering and scaling. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Scaler Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X, y=None) [source] Apply the inverse transformation to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Scaled dataframe. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Perform standardization by centering and scaling. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Scaled dataframe.", "title": "Methods"}, {"location": "API/feature_engineering/featureextractor/", "text": "FeatureExtractor class atom.feature_engineering. FeatureExtractor (features=['day', 'month', 'year'], fmt=None, encoding_type=\"ordinal\", drop_columns=True, verbose=0, logger=None) [source] Extract features from datetime columns. Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype datetime64 are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used. This class can be accessed from atom through the feature_extraction method. Read more in the user guide . Warning Decision trees based algorithms build their split rules according to one feature at a time. This means that they will fail to correctly process cyclic features since the sin/cos features should be considered one single coordinate system. Parameters features: str or sequence, default=[\"day\", \"month\", \"year\"] Features to create from the datetime columns. Note that created features with zero variance (e.g. the feature hour in a column that only contains dates) are ignored. Allowed values are datetime attributes from pandas.Series.dt . fmt: str, sequence or None, default=None Format ( strptime ) of the categorical columns that need to be converted to datetime. If sequence, the n-th format corresponds to the n-th categorical column that can be successfully converted. If None, the format is inferred automatically from the first non NaN value. Values that can not be converted are returned as NaT . encoding_type: str, default=\"ordinal\" Type of encoding to use. Choose from: \"ordinal\": Encode features in increasing order. \"cyclic\": Encode features using sine and cosine to capture their cyclic nature. This approach creates two columns for every feature. Non-cyclic features still use ordinal encoding. drop_columns: bool, default=True Whether to drop the original columns after transformation. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureGenerator Generate new features. FeatureGrouper Extract statistics from similar features. FeatureSelector Reduce the number of features in the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"date\" ] = pd . date_range ( start = \"1/1/2018\" , periods = len ( X )) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_extraction ( features = [ \"day\" ], fmt = \" %d /%m/%Y\" , verbose = 2 ) Extracting datetime features... --> Extracting features from column date. --> Creating feature date_day. >>> # Note the date_day column >>> print ( atom . dataset ) mean radius mean texture ... date_day target 0 11.300 18.19 ... 31 1 1 16.460 20.11 ... 27 0 2 11.370 18.89 ... 17 1 3 8.598 20.98 ... 3 1 4 12.800 17.46 ... 2 1 .. ... ... ... ... ... 564 17.060 21.00 ... 2 0 565 11.940 20.76 ... 14 1 566 19.590 25.00 ... 28 0 567 12.360 18.54 ... 18 1 568 18.450 21.91 ... 15 0 [569 rows x 32 columns] >>> from atom.feature_engineering import FeatureExtractor >>> from sklearn.datasets import load_breast_cancer >>> X , _ = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"date\" ] = pd . date_range ( start = \"1/1/2018\" , periods = len ( X )) >>> fe = FeatureExtractor ( features = [ \"day\" ], fmt = \"%Y-%m- %d \" , verbose = 2 ) >>> X = fe . transform ( X ) Extracting datetime features... --> Extracting features from column date. --> Creating feature date_day. >>> # Note the date_day column >>> print ( X ) mean radius mean texture ... worst fractal dimension date_day 0 17.99 10.38 ... 0.11890 1 1 20.57 17.77 ... 0.08902 2 2 19.69 21.25 ... 0.08758 3 3 11.42 20.38 ... 0.17300 4 4 20.29 14.34 ... 0.07678 5 .. ... ... ... ... ... 564 21.56 22.39 ... 0.07115 19 565 20.13 28.25 ... 0.06637 20 566 16.60 28.08 ... 0.07820 21 567 20.60 29.33 ... 0.12400 22 568 7.76 24.54 ... 0.07039 23 [569 rows x 31 columns] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Extract the new features. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Extract the new features. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "FeatureExtractor"}, {"location": "API/feature_engineering/featureextractor/#featureextractor", "text": "class atom.feature_engineering. FeatureExtractor (features=['day', 'month', 'year'], fmt=None, encoding_type=\"ordinal\", drop_columns=True, verbose=0, logger=None) [source] Extract features from datetime columns. Create new features extracting datetime elements (day, month, year, etc...) from the provided columns. Columns of dtype datetime64 are used as is. Categorical columns that can be successfully converted to a datetime format (less than 30% NaT values after conversion) are also used. This class can be accessed from atom through the feature_extraction method. Read more in the user guide . Warning Decision trees based algorithms build their split rules according to one feature at a time. This means that they will fail to correctly process cyclic features since the sin/cos features should be considered one single coordinate system. Parameters features: str or sequence, default=[\"day\", \"month\", \"year\"] Features to create from the datetime columns. Note that created features with zero variance (e.g. the feature hour in a column that only contains dates) are ignored. Allowed values are datetime attributes from pandas.Series.dt . fmt: str, sequence or None, default=None Format ( strptime ) of the categorical columns that need to be converted to datetime. If sequence, the n-th format corresponds to the n-th categorical column that can be successfully converted. If None, the format is inferred automatically from the first non NaN value. Values that can not be converted are returned as NaT . encoding_type: str, default=\"ordinal\" Type of encoding to use. Choose from: \"ordinal\": Encode features in increasing order. \"cyclic\": Encode features using sine and cosine to capture their cyclic nature. This approach creates two columns for every feature. Non-cyclic features still use ordinal encoding. drop_columns: bool, default=True Whether to drop the original columns after transformation. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureGenerator Generate new features. FeatureGrouper Extract statistics from similar features. FeatureSelector Reduce the number of features in the data.", "title": "FeatureExtractor"}, {"location": "API/feature_engineering/featureextractor/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"date\" ] = pd . date_range ( start = \"1/1/2018\" , periods = len ( X )) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_extraction ( features = [ \"day\" ], fmt = \" %d /%m/%Y\" , verbose = 2 ) Extracting datetime features... --> Extracting features from column date. --> Creating feature date_day. >>> # Note the date_day column >>> print ( atom . dataset ) mean radius mean texture ... date_day target 0 11.300 18.19 ... 31 1 1 16.460 20.11 ... 27 0 2 11.370 18.89 ... 17 1 3 8.598 20.98 ... 3 1 4 12.800 17.46 ... 2 1 .. ... ... ... ... ... 564 17.060 21.00 ... 2 0 565 11.940 20.76 ... 14 1 566 19.590 25.00 ... 28 0 567 12.360 18.54 ... 18 1 568 18.450 21.91 ... 15 0 [569 rows x 32 columns] >>> from atom.feature_engineering import FeatureExtractor >>> from sklearn.datasets import load_breast_cancer >>> X , _ = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X [ \"date\" ] = pd . date_range ( start = \"1/1/2018\" , periods = len ( X )) >>> fe = FeatureExtractor ( features = [ \"day\" ], fmt = \"%Y-%m- %d \" , verbose = 2 ) >>> X = fe . transform ( X ) Extracting datetime features... --> Extracting features from column date. --> Creating feature date_day. >>> # Note the date_day column >>> print ( X ) mean radius mean texture ... worst fractal dimension date_day 0 17.99 10.38 ... 0.11890 1 1 20.57 17.77 ... 0.08902 2 2 19.69 21.25 ... 0.08758 3 3 11.42 20.38 ... 0.17300 4 4 20.29 14.34 ... 0.07678 5 .. ... ... ... ... ... 564 21.56 22.39 ... 0.07115 19 565 20.13 28.25 ... 0.06637 20 566 16.60 28.08 ... 0.07820 21 567 20.60 29.33 ... 0.12400 22 568 7.76 24.54 ... 0.07039 23 [569 rows x 31 columns]", "title": "Example"}, {"location": "API/feature_engineering/featureextractor/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Extract the new features. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Extract the new features. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "Methods"}, {"location": "API/feature_engineering/featuregenerator/", "text": "FeatureGenerator class atom.feature_engineering. FeatureGenerator (strategy=\"dfs\", n_features=None, operators=None, n_jobs=1, verbose=0, logger=None, random_state=None, **kwargs) [source] Generate new features. Create new combinations of existing features to capture the non-linear relations between the original features. This class can be accessed from atom through the feature_generation method. Read more in the user guide . Warning Using the div , log or sqrt operators can return new features with inf or NaN values. Check the warnings that may pop up or use atom's nans attribute. When using dfs with n_jobs>1 , make sure to protect your code with if __name__ == \"__main__\" . Featuretools uses dask , which uses python multiprocessing for parallelization. The spawn method on multiprocessing starts a new python process, which requires it to import the __main__ module before it can do its task. gfg can be slow for very large populations. Tip dfs can create many new features and not all of them will be useful. Use the FeatureSelector class to reduce the number of features. Parameters strategy: str, default=\"dfs\" Strategy to crate new features. Choose from: \" dfs \": Deep Feature Synthesis. \" gfg \": Genetic Feature Generation. n_features: int or None, default=None Maximum number of newly generated features to add to the dataset. If None, select all created features. operators: str, sequence or None, default=None Mathematical operators to apply on the features. None to use all. Choose from: add , sub , mul , div , abs , sqrt , log , inv , sin , cos , tan . n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . **kwargs Additional keyword arguments for the SymbolicTransformer instance. Only for the gfg strategy. Attributes gfg: SymbolicTransformer Object used to calculate the genetic features. Only for the gfg strategy. genetic_features: pd.DataFrame Information on the newly created non-linear features. Only for the gfg strategy. Columns include: name: Name of the feature (generated automatically). description: Operators used to create this feature. fitness: Fitness score. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureExtractor Extract features from datetime columns. FeatureGrouper Extract statistics from similar features. FeatureSelector Reduce the number of features in the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_generation ( strategy = \"dfs\" , n_features = 5 , verbose = 2 ) Fitting FeatureGenerator... Generating new features... --> 5 new features were added. >>> # Note the texture error / worst symmetry column >>> print ( atom . dataset ) mean radius mean texture ... texture error / worst symmetry target 0 15.75 19.22 ... 3.118963 0 1 12.10 17.72 ... 5.418170 1 2 20.16 19.66 ... 2.246481 0 3 12.88 18.22 ... 4.527498 1 4 13.03 18.42 ... 11.786613 1 .. ... ... ... ... ... 564 21.75 20.99 ... 4.772326 0 565 13.64 16.34 ... 3.936061 1 566 10.08 15.11 ... 4.323219 1 567 12.91 16.33 ... 3.004630 1 568 11.60 18.36 ... 2.385047 1 [569 rows x 36 columns] >>> from atom.feature_engineering import FeatureGenerator >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> fg = FeatureGenerator ( strategy = \"dfs\" , n_features = 5 , verbose = 2 ) >>> X = fg . fit_transform ( X , y ) Fitting FeatureGenerator... Generating new features... --> 5 new features were added. >>> # Note the radius error * worst smoothness column >>> print ( X ) mean radius ... radius error * worst smoothness 0 17.99 ... 0.177609 1 20.57 ... 0.067285 2 19.69 ... 0.107665 3 11.42 ... 0.103977 4 20.29 ... 0.104039 .. ... ... ... 564 21.56 ... 0.165816 565 20.13 ... 0.089257 566 16.60 ... 0.051984 567 20.60 ... 0.119790 568 7.76 ... 0.034698 [569 rows x 35 columns] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Generate new features. method fit (X, y) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Generate new features. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "FeatureGenerator"}, {"location": "API/feature_engineering/featuregenerator/#featuregenerator", "text": "class atom.feature_engineering. FeatureGenerator (strategy=\"dfs\", n_features=None, operators=None, n_jobs=1, verbose=0, logger=None, random_state=None, **kwargs) [source] Generate new features. Create new combinations of existing features to capture the non-linear relations between the original features. This class can be accessed from atom through the feature_generation method. Read more in the user guide . Warning Using the div , log or sqrt operators can return new features with inf or NaN values. Check the warnings that may pop up or use atom's nans attribute. When using dfs with n_jobs>1 , make sure to protect your code with if __name__ == \"__main__\" . Featuretools uses dask , which uses python multiprocessing for parallelization. The spawn method on multiprocessing starts a new python process, which requires it to import the __main__ module before it can do its task. gfg can be slow for very large populations. Tip dfs can create many new features and not all of them will be useful. Use the FeatureSelector class to reduce the number of features. Parameters strategy: str, default=\"dfs\" Strategy to crate new features. Choose from: \" dfs \": Deep Feature Synthesis. \" gfg \": Genetic Feature Generation. n_features: int or None, default=None Maximum number of newly generated features to add to the dataset. If None, select all created features. operators: str, sequence or None, default=None Mathematical operators to apply on the features. None to use all. Choose from: add , sub , mul , div , abs , sqrt , log , inv , sin , cos , tan . n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . **kwargs Additional keyword arguments for the SymbolicTransformer instance. Only for the gfg strategy. Attributes gfg: SymbolicTransformer Object used to calculate the genetic features. Only for the gfg strategy. genetic_features: pd.DataFrame Information on the newly created non-linear features. Only for the gfg strategy. Columns include: name: Name of the feature (generated automatically). description: Operators used to create this feature. fitness: Fitness score. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureExtractor Extract features from datetime columns. FeatureGrouper Extract statistics from similar features. FeatureSelector Reduce the number of features in the data.", "title": "FeatureGenerator"}, {"location": "API/feature_engineering/featuregenerator/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_generation ( strategy = \"dfs\" , n_features = 5 , verbose = 2 ) Fitting FeatureGenerator... Generating new features... --> 5 new features were added. >>> # Note the texture error / worst symmetry column >>> print ( atom . dataset ) mean radius mean texture ... texture error / worst symmetry target 0 15.75 19.22 ... 3.118963 0 1 12.10 17.72 ... 5.418170 1 2 20.16 19.66 ... 2.246481 0 3 12.88 18.22 ... 4.527498 1 4 13.03 18.42 ... 11.786613 1 .. ... ... ... ... ... 564 21.75 20.99 ... 4.772326 0 565 13.64 16.34 ... 3.936061 1 566 10.08 15.11 ... 4.323219 1 567 12.91 16.33 ... 3.004630 1 568 11.60 18.36 ... 2.385047 1 [569 rows x 36 columns] >>> from atom.feature_engineering import FeatureGenerator >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> fg = FeatureGenerator ( strategy = \"dfs\" , n_features = 5 , verbose = 2 ) >>> X = fg . fit_transform ( X , y ) Fitting FeatureGenerator... Generating new features... --> 5 new features were added. >>> # Note the radius error * worst smoothness column >>> print ( X ) mean radius ... radius error * worst smoothness 0 17.99 ... 0.177609 1 20.57 ... 0.067285 2 19.69 ... 0.107665 3 11.42 ... 0.103977 4 20.29 ... 0.104039 .. ... ... ... 564 21.56 ... 0.165816 565 20.13 ... 0.089257 566 16.60 ... 0.051984 567 20.60 ... 0.119790 568 7.76 ... 0.034698 [569 rows x 35 columns]", "title": "Example"}, {"location": "API/feature_engineering/featuregenerator/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Generate new features. method fit (X, y) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Generate new features. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "Methods"}, {"location": "API/feature_engineering/featuregrouper/", "text": "FeatureGrouper class atom.feature_engineering. FeatureGrouper (group, name=None, operators=None, drop_columns=True, verbose=0, logger=None) [source] Extract statistics from similar features. Replace groups of features with related characteristics with new features that summarize statistical properties of te group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the groups method. This class can be accessed from atom through the feature_grouping method. Read more in the user guide . Tip Use a regex pattern with the groups parameter to select groups easier, e.g. atom.feature_generation(features=\"var_.+\") to select all features that start with var_ . Parameters group: str, slice or sequence Features that belong to a group. Select them by name, position or regex pattern. A feature can belong to multiple groups. Use a sequence of sequences to define multiple groups. name: str, sequence or None, default=None Name of the group. The new features are named combining the operator used and the group's name, e.g. mean(group_1) . If specfified, the length should match with the number of groups defined in features . If None, default group names of the form group1 , group2 , etc... are used. operators: str, sequence or None, default=None Statistical operators to apply on the groups. Any operator from numpy or scipy.stats (checked in that order) that is applied on an array can be used. If None, it uses: min , max , mean , median , mode and std . drop_columns: bool, default=True Whether to drop the columns in groups after transformation. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes groups: dict Names and features of every created group. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureExtractor Extract features from datetime columns. FeatureGenerator Generate new features. FeatureSelector Reduce the number of features in the data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_grouping ( group = [ \"mean.+\" ], name = \"means\" , verbose = 2 ) Fitting FeatureGrouper... Grouping features... --> Group means successfully created. >>> # Note the mean features are gone and the new std(means) feature >>> print ( atom . dataset ) radius error texture error ... std(means) target 0 0.2949 1.6560 ... 137.553584 1 1 0.2351 2.0110 ... 79.830195 1 2 0.4302 2.8780 ... 80.330330 1 3 0.2345 1.2190 ... 151.858455 1 4 0.3511 0.9527 ... 145.769474 1 .. ... ... ... ... ... 564 0.4866 1.9050 ... 116.749243 1 565 0.5925 0.6863 ... 378.431333 0 566 0.2577 1.0950 ... 141.220243 1 567 0.4615 0.9197 ... 257.903846 0 568 0.5462 1.5110 ... 194.704033 1 [569 rows x 27 columns] >>> from atom.feature_engineering import FeatureGrouper >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Group all features that start with mean >>> fg = FeatureGrouper ( group = \"mean.+\" , name = \"means\" , verbose = 2 ) >>> X = fg . transform ( X ) Fitting FeatureGrouper... Grouping features... --> Group means successfully created. >>> # Note the mean features are gone and the new std(means) feature >>> print ( X ) radius error texture error ... mode(means) std(means) 0 1.0950 0.9053 ... 0.07871 297.404540 1 0.5435 0.7339 ... 0.05667 393.997131 2 0.7456 0.7869 ... 0.05999 357.203084 3 0.4956 1.1560 ... 0.09744 114.444620 4 0.7572 0.7813 ... 0.05883 385.450556 .. ... ... ... ... ... 564 1.1760 1.2560 ... 0.05623 439.441252 565 0.7655 2.4630 ... 0.05533 374.274845 566 0.4564 1.0750 ... 0.05302 254.320568 567 0.7260 1.5950 ... 0.07016 375.376476 568 0.3857 1.4280 ... 0.00000 53.739926 [569 rows x 26 columns] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Group features. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Group features. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "FeatureGrouper"}, {"location": "API/feature_engineering/featuregrouper/#featuregrouper", "text": "class atom.feature_engineering. FeatureGrouper (group, name=None, operators=None, drop_columns=True, verbose=0, logger=None) [source] Extract statistics from similar features. Replace groups of features with related characteristics with new features that summarize statistical properties of te group. The statistical operators are calculated over every row of the group. The group names and features can be accessed through the groups method. This class can be accessed from atom through the feature_grouping method. Read more in the user guide . Tip Use a regex pattern with the groups parameter to select groups easier, e.g. atom.feature_generation(features=\"var_.+\") to select all features that start with var_ . Parameters group: str, slice or sequence Features that belong to a group. Select them by name, position or regex pattern. A feature can belong to multiple groups. Use a sequence of sequences to define multiple groups. name: str, sequence or None, default=None Name of the group. The new features are named combining the operator used and the group's name, e.g. mean(group_1) . If specfified, the length should match with the number of groups defined in features . If None, default group names of the form group1 , group2 , etc... are used. operators: str, sequence or None, default=None Statistical operators to apply on the groups. Any operator from numpy or scipy.stats (checked in that order) that is applied on an array can be used. If None, it uses: min , max , mean , median , mode and std . drop_columns: bool, default=True Whether to drop the columns in groups after transformation. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes groups: dict Names and features of every created group. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureExtractor Extract features from datetime columns. FeatureGenerator Generate new features. FeatureSelector Reduce the number of features in the data.", "title": "FeatureGrouper"}, {"location": "API/feature_engineering/featuregrouper/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_grouping ( group = [ \"mean.+\" ], name = \"means\" , verbose = 2 ) Fitting FeatureGrouper... Grouping features... --> Group means successfully created. >>> # Note the mean features are gone and the new std(means) feature >>> print ( atom . dataset ) radius error texture error ... std(means) target 0 0.2949 1.6560 ... 137.553584 1 1 0.2351 2.0110 ... 79.830195 1 2 0.4302 2.8780 ... 80.330330 1 3 0.2345 1.2190 ... 151.858455 1 4 0.3511 0.9527 ... 145.769474 1 .. ... ... ... ... ... 564 0.4866 1.9050 ... 116.749243 1 565 0.5925 0.6863 ... 378.431333 0 566 0.2577 1.0950 ... 141.220243 1 567 0.4615 0.9197 ... 257.903846 0 568 0.5462 1.5110 ... 194.704033 1 [569 rows x 27 columns] >>> from atom.feature_engineering import FeatureGrouper >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Group all features that start with mean >>> fg = FeatureGrouper ( group = \"mean.+\" , name = \"means\" , verbose = 2 ) >>> X = fg . transform ( X ) Fitting FeatureGrouper... Grouping features... --> Group means successfully created. >>> # Note the mean features are gone and the new std(means) feature >>> print ( X ) radius error texture error ... mode(means) std(means) 0 1.0950 0.9053 ... 0.07871 297.404540 1 0.5435 0.7339 ... 0.05667 393.997131 2 0.7456 0.7869 ... 0.05999 357.203084 3 0.4956 1.1560 ... 0.09744 114.444620 4 0.7572 0.7813 ... 0.05883 385.450556 .. ... ... ... ... ... 564 1.1760 1.2560 ... 0.05623 439.441252 565 0.7655 2.4630 ... 0.05533 374.274845 566 0.4564 1.0750 ... 0.05302 254.320568 567 0.7260 1.5950 ... 0.07016 375.376476 568 0.3857 1.4280 ... 0.00000 53.739926 [569 rows x 26 columns]", "title": "Example"}, {"location": "API/feature_engineering/featuregrouper/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Group features. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Group features. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed feature set.", "title": "Methods"}, {"location": "API/feature_engineering/featureselector/", "text": "FeatureSelector class atom.feature_engineering. FeatureSelector (strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, random_state=None, **kwargs) [source] Reduce the number of features in the data. Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low variance features. This class can be accessed from atom through the feature_selection method. Read more in the user guide . Warning Ties between features with equal scores are broken in an unspecified way. For strategy=\"rfecv\", the n_features parameter is the minimum number of features to select, not the actual number of features that the transformer returns. It may very well be that it returns more! Info The \"sklearnex\" and \"cuml\" engines are only supported for strategy=\"pca\" with dense datasets. If strategy=\"pca\" and the data is dense and unscaled, it's scaled to mean=0 and std=1 before fitting the PCA transformer. If strategy=\"pca\" and the provided data is sparse, the used estimator is TruncatedSVD , which works more efficiently with sparse matrices. Tip Use the plot_feature_importance method to examine how much a specific feature contributes to the final predictions. If the model doesn't have a feature_importances_ attribute, use plot_permutation_importance instead. Parameters strategy: str or None, default=None Feature selection strategy to use. Choose from: None: Do not perform any feature selection strategy. \" univariate \": Univariate statistical F-test. \" pca \": Principal Component Analysis. \" sfm \": Select best features according to a model. \" sfs \": Sequential Feature Selection. \" rfe \": Recursive Feature Elimination. \" rfecv \": RFE with cross-validated selection. \" pso \": Particle Swarm Optimization. \" hho \": Harris Hawks Optimization. \" gwo \": Grey Wolf Optimization. \" dfo \": Dragonfly Optimization. \" go \": Genetic Optimization. solver: str, estimator or None, default=None Solver/estimator to use for the feature selection strategy. See the corresponding documentation for an extended description of the choices. If None, the default value is used (only if strategy=\"pca\"). Choose from: If strategy=\"univariate\": \" f_classif \" \" f_regression \" \" mutual_info_classif \" \" mutual_info_regression \" \" chi2 \" Any function with signature func(X, y) -> (scores, p-values) . If strategy=\"pca\": If data is dense: If engine=\"sklearn\": \"auto\" (default) \"full\" \"arpack\" \"randomized\" If engine=\"sklearnex\": \"full\" (default) If engine=\"cuml\": \"full\" (default) \"jacobi\" If data is sparse: \"randomized\" (default) \"arpack\" for the remaining strategies: The base estimator. For sfm, rfe and rfecv, it should have either a feature_importances_ or coef_ attribute after fitting. You can use one of the predefined models . Add _class or _reg after the model's name to specify a classification or regression task, e.g. solver=\"LGB_reg\" (not necessary if called from atom). No default option. n_features: int, float or None, default=None Number of features to select. If None: Select all features. If <1: Fraction of the total features to select. If >=1: Number of features to select. If strategy=\"sfm\" and the threshold parameter is not specified, the threshold is automatically set to -inf to select n_features number of features. If strategy=\"rfecv\", n_features is the minimum number of features to select. This parameter is ignored if any of the following strategies is selected: pso, hho, gwo, dfo, go. min_repeated: int, float or None, default=2 Remove categorical features if there isn't any repeated value in at least min_repeated rows. The default is to keep all features with non-maximum variance, i.e. remove the features which number of unique values is equal to the number of rows (usually the case for names, IDs, etc...). If None: No check for minimum repetition. If >1: Minimum repetition number. If <=1: Minimum repetition fraction. max_repeated: int, float or None, default=1.0 Remove categorical features with the same value in at least max_repeated rows. The default is to keep all features with non-zero variance, i.e. remove the features that have the same value in all samples. If None: No check for maximum repetition. If >1: Maximum number of repeated occurences. If <=1: Maximum fraction of repeated occurences. max_correlation: float or None, default=1.0 Minimum absolute Pearson correlation to identify correlated features. For each group, it removes all except the feature with the highest correlation to y (if provided, else it removes all but the first). The default value removes equal columns. If None, skip this step. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . **kwargs Any extra keyword argument for the strategy estimator. See the corresponding documentation for the available options. Attributes collinear: pd.DataFrame Information on the removed collinear features. Columns include: drop: Name of the dropped feature. corr_feature: Names of the correlated features. corr_value: Corresponding correlation coefficients. feature_importance: pd.Series Normalized importance scores calculated by the solver for the features kept by the transformer. The scores are extracted from the coef_ or feature_importances_ attribute, checked in that order. Only if strategy is one of univariate, sfm, rfe or rfecv. [strategy]: sklearn transformer Object used to transform the data, e.g. fs.pca for the pca strategy. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureExtractor Extract features from datetime columns. FeatureGenerator Generate new features. FeatureGrouper Extract statistics from similar features. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( strategy = \"pca\" , n_features = 12 , verbose = 2 ) Fitting FeatureSelector... Performing feature selection ... --> Applying Principal Component Analysis... --> Scaling features... --> Keeping 12 components. --> Explained variance ratio: 0.97 >>> # Note that the column names changed >>> print ( atom . dataset ) pca0 pca1 pca2 ... pca10 pca11 target 0 -2.493723 3.082653 1.318595 ... -0.182142 -0.591784 1 1 4.596102 -0.876940 -0.380685 ... 0.224170 1.155544 0 2 0.955979 -2.141057 -1.677736 ... 0.306153 0.099138 0 3 3.221488 4.209911 -2.818757 ... 0.808883 -0.531868 0 4 1.038000 2.451758 -1.753683 ... -0.312883 0.862319 1 .. ... ... ... ... ... ... ... 564 3.414827 -3.757253 -1.012369 ... 0.387175 0.283633 0 565 -1.191561 -1.276069 -0.871712 ... 0.106362 -0.449361 1 566 -2.757000 0.411997 -1.321697 ... 0.185550 -0.025368 1 567 -3.252533 0.074827 0.549622 ... 0.693073 -0.058251 1 568 1.607258 -2.076465 -1.025986 ... -0.385542 0.103603 0 [569 rows x 13 columns] >>> atom . plot_pca () ; >>> from atom.feature_engineering import FeatureSelector >>> from sklearn.datasets import load_breast_cancer >>> X , _ = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> fs = FeatureSelector ( strategy = \"pca\" , n_features = 12 , verbose = 2 ) >>> X = fs . fit_transform ( X ) Fitting FeatureSelector... Performing feature selection ... --> Applying Principal Component Analysis... --> Scaling features... --> Keeping 12 components. --> Explained variance ratio: 0.97 >>> # Note that the column names changed >>> print ( X ) pca0 pca1 pca2 ... pca9 pca10 pca11 0 9.192837 1.948583 -1.123166 ... -0.877402 0.262955 -0.859014 1 2.387802 -3.768172 -0.529293 ... 1.106995 0.813120 0.157923 2 5.733896 -1.075174 -0.551748 ... 0.454275 -0.605604 0.124387 3 7.122953 10.275589 -3.232790 ... -1.116975 -1.151514 1.011316 4 3.935302 -1.948072 1.389767 ... 0.377704 0.651360 -0.110515 .. ... ... ... ... ... ... ... 564 6.439315 -3.576817 2.459487 ... 0.256989 -0.062651 0.123342 565 3.793382 -3.584048 2.088476 ... -0.108632 0.244804 0.222753 566 1.256179 -1.902297 0.562731 ... 0.520877 -0.840512 0.096473 567 10.374794 1.672010 -1.877029 ... -0.089296 -0.178628 -0.697461 568 -5.475243 -0.670637 1.490443 ... -0.047726 -0.144094 -0.179496 [569 rows x 12 columns] Methods fit Fit the feature selector to the data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. plot_components Plot the explained variance ratio per component. plot_pca Plot the explained variance ratio vs number of components. plot_rfecv Plot the rfecv results. reset_aesthetics Reset the plot aesthetics to their default values. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Transform the data. update_layout Update the properties of the plot's layout. method fit (X, y=None) [source] Fit the feature selector to the data. The univariate, sfm (when model is not fitted), sfs, rfe and rfecv strategies need a target column. Leaving it None raises an exception. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method plot_components (show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the explained variance ratio per component. Kept components are colored and discarted components are transparent. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters show: int or None, default=None Number of components to show. None to show all. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of components shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . method plot_pca (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the explained variance ratio vs number of components. If the underlying estimator is PCA (for dense datasets), all possible components are plotted. If the underlying estimator is TruncatedSVD (for sparse datasets), it only shows the selected components. The star marks the number of components selected by the user. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . method plot_rfecv (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the rfecv results. Plot the scores obtained by the estimator fitted on every subset of the dataset. Only available when feature selection was applied with strategy=\"rfecv\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Transform the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Only for continuity of the API. Returns pd.DataFrame Transformed feature set. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated.", "title": "FeatureSelector"}, {"location": "API/feature_engineering/featureselector/#featureselector", "text": "class atom.feature_engineering. FeatureSelector (strategy=None, solver=None, n_features=None, min_repeated=2, max_repeated=1.0, max_correlation=1.0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, random_state=None, **kwargs) [source] Reduce the number of features in the data. Apply feature selection or dimensionality reduction, either to improve the estimators' accuracy or to boost their performance on very high-dimensional datasets. Additionally, remove multicollinear and low variance features. This class can be accessed from atom through the feature_selection method. Read more in the user guide . Warning Ties between features with equal scores are broken in an unspecified way. For strategy=\"rfecv\", the n_features parameter is the minimum number of features to select, not the actual number of features that the transformer returns. It may very well be that it returns more! Info The \"sklearnex\" and \"cuml\" engines are only supported for strategy=\"pca\" with dense datasets. If strategy=\"pca\" and the data is dense and unscaled, it's scaled to mean=0 and std=1 before fitting the PCA transformer. If strategy=\"pca\" and the provided data is sparse, the used estimator is TruncatedSVD , which works more efficiently with sparse matrices. Tip Use the plot_feature_importance method to examine how much a specific feature contributes to the final predictions. If the model doesn't have a feature_importances_ attribute, use plot_permutation_importance instead. Parameters strategy: str or None, default=None Feature selection strategy to use. Choose from: None: Do not perform any feature selection strategy. \" univariate \": Univariate statistical F-test. \" pca \": Principal Component Analysis. \" sfm \": Select best features according to a model. \" sfs \": Sequential Feature Selection. \" rfe \": Recursive Feature Elimination. \" rfecv \": RFE with cross-validated selection. \" pso \": Particle Swarm Optimization. \" hho \": Harris Hawks Optimization. \" gwo \": Grey Wolf Optimization. \" dfo \": Dragonfly Optimization. \" go \": Genetic Optimization. solver: str, estimator or None, default=None Solver/estimator to use for the feature selection strategy. See the corresponding documentation for an extended description of the choices. If None, the default value is used (only if strategy=\"pca\"). Choose from: If strategy=\"univariate\": \" f_classif \" \" f_regression \" \" mutual_info_classif \" \" mutual_info_regression \" \" chi2 \" Any function with signature func(X, y) -> (scores, p-values) . If strategy=\"pca\": If data is dense: If engine=\"sklearn\": \"auto\" (default) \"full\" \"arpack\" \"randomized\" If engine=\"sklearnex\": \"full\" (default) If engine=\"cuml\": \"full\" (default) \"jacobi\" If data is sparse: \"randomized\" (default) \"arpack\" for the remaining strategies: The base estimator. For sfm, rfe and rfecv, it should have either a feature_importances_ or coef_ attribute after fitting. You can use one of the predefined models . Add _class or _reg after the model's name to specify a classification or regression task, e.g. solver=\"LGB_reg\" (not necessary if called from atom). No default option. n_features: int, float or None, default=None Number of features to select. If None: Select all features. If <1: Fraction of the total features to select. If >=1: Number of features to select. If strategy=\"sfm\" and the threshold parameter is not specified, the threshold is automatically set to -inf to select n_features number of features. If strategy=\"rfecv\", n_features is the minimum number of features to select. This parameter is ignored if any of the following strategies is selected: pso, hho, gwo, dfo, go. min_repeated: int, float or None, default=2 Remove categorical features if there isn't any repeated value in at least min_repeated rows. The default is to keep all features with non-maximum variance, i.e. remove the features which number of unique values is equal to the number of rows (usually the case for names, IDs, etc...). If None: No check for minimum repetition. If >1: Minimum repetition number. If <=1: Minimum repetition fraction. max_repeated: int, float or None, default=1.0 Remove categorical features with the same value in at least max_repeated rows. The default is to keep all features with non-zero variance, i.e. remove the features that have the same value in all samples. If None: No check for maximum repetition. If >1: Maximum number of repeated occurences. If <=1: Maximum fraction of repeated occurences. max_correlation: float or None, default=1.0 Minimum absolute Pearson correlation to identify correlated features. For each group, it removes all except the feature with the highest correlation to y (if provided, else it removes all but the first). The default value removes equal columns. If None, skip this step. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . **kwargs Any extra keyword argument for the strategy estimator. See the corresponding documentation for the available options. Attributes collinear: pd.DataFrame Information on the removed collinear features. Columns include: drop: Name of the dropped feature. corr_feature: Names of the correlated features. corr_value: Corresponding correlation coefficients. feature_importance: pd.Series Normalized importance scores calculated by the solver for the features kept by the transformer. The scores are extracted from the coef_ or feature_importances_ attribute, checked in that order. Only if strategy is one of univariate, sfm, rfe or rfecv. [strategy]: sklearn transformer Object used to transform the data, e.g. fs.pca for the pca strategy. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also FeatureExtractor Extract features from datetime columns. FeatureGenerator Generate new features. FeatureGrouper Extract statistics from similar features.", "title": "FeatureSelector"}, {"location": "API/feature_engineering/featureselector/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( strategy = \"pca\" , n_features = 12 , verbose = 2 ) Fitting FeatureSelector... Performing feature selection ... --> Applying Principal Component Analysis... --> Scaling features... --> Keeping 12 components. --> Explained variance ratio: 0.97 >>> # Note that the column names changed >>> print ( atom . dataset ) pca0 pca1 pca2 ... pca10 pca11 target 0 -2.493723 3.082653 1.318595 ... -0.182142 -0.591784 1 1 4.596102 -0.876940 -0.380685 ... 0.224170 1.155544 0 2 0.955979 -2.141057 -1.677736 ... 0.306153 0.099138 0 3 3.221488 4.209911 -2.818757 ... 0.808883 -0.531868 0 4 1.038000 2.451758 -1.753683 ... -0.312883 0.862319 1 .. ... ... ... ... ... ... ... 564 3.414827 -3.757253 -1.012369 ... 0.387175 0.283633 0 565 -1.191561 -1.276069 -0.871712 ... 0.106362 -0.449361 1 566 -2.757000 0.411997 -1.321697 ... 0.185550 -0.025368 1 567 -3.252533 0.074827 0.549622 ... 0.693073 -0.058251 1 568 1.607258 -2.076465 -1.025986 ... -0.385542 0.103603 0 [569 rows x 13 columns] >>> atom . plot_pca () ; >>> from atom.feature_engineering import FeatureSelector >>> from sklearn.datasets import load_breast_cancer >>> X , _ = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> fs = FeatureSelector ( strategy = \"pca\" , n_features = 12 , verbose = 2 ) >>> X = fs . fit_transform ( X ) Fitting FeatureSelector... Performing feature selection ... --> Applying Principal Component Analysis... --> Scaling features... --> Keeping 12 components. --> Explained variance ratio: 0.97 >>> # Note that the column names changed >>> print ( X ) pca0 pca1 pca2 ... pca9 pca10 pca11 0 9.192837 1.948583 -1.123166 ... -0.877402 0.262955 -0.859014 1 2.387802 -3.768172 -0.529293 ... 1.106995 0.813120 0.157923 2 5.733896 -1.075174 -0.551748 ... 0.454275 -0.605604 0.124387 3 7.122953 10.275589 -3.232790 ... -1.116975 -1.151514 1.011316 4 3.935302 -1.948072 1.389767 ... 0.377704 0.651360 -0.110515 .. ... ... ... ... ... ... ... 564 6.439315 -3.576817 2.459487 ... 0.256989 -0.062651 0.123342 565 3.793382 -3.584048 2.088476 ... -0.108632 0.244804 0.222753 566 1.256179 -1.902297 0.562731 ... 0.520877 -0.840512 0.096473 567 10.374794 1.672010 -1.877029 ... -0.089296 -0.178628 -0.697461 568 -5.475243 -0.670637 1.490443 ... -0.047726 -0.144094 -0.179496 [569 rows x 12 columns]", "title": "Example"}, {"location": "API/feature_engineering/featureselector/#methods", "text": "fit Fit the feature selector to the data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. plot_components Plot the explained variance ratio per component. plot_pca Plot the explained variance ratio vs number of components. plot_rfecv Plot the rfecv results. reset_aesthetics Reset the plot aesthetics to their default values. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Transform the data. update_layout Update the properties of the plot's layout. method fit (X, y=None) [source] Fit the feature selector to the data. The univariate, sfm (when model is not fitted), sfs, rfe and rfecv strategies need a target column. Leaving it None raises an exception. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method plot_components (show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the explained variance ratio per component. Kept components are colored and discarted components are transparent. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters show: int or None, default=None Number of components to show. None to show all. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of components shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . method plot_pca (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the explained variance ratio vs number of components. If the underlying estimator is PCA (for dense datasets), all possible components are plotted. If the underlying estimator is TruncatedSVD (for sparse datasets), it only shows the selected components. The star marks the number of components selected by the user. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . method plot_rfecv (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the rfecv results. Plot the scores obtained by the estimator fitted on every subset of the dataset. Only available when feature selection was applied with strategy=\"rfecv\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Transform the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). y: int, str, dict, sequence or None, default=None Does nothing. Only for continuity of the API. Returns pd.DataFrame Transformed feature set. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated.", "title": "Methods"}, {"location": "API/models/adab/", "text": "AdaBoost AdaB accept sparse AdaBoost is a meta-estimator that begins by fitting a classifier/regressor on the original dataset and then fits additional copies of the algorithm on the same dataset but where the weights of instances are adjusted according to the error of the current prediction. Corresponding estimators are: AdaBoostClassifier for classification tasks. AdaBoostRegressor for regression tasks. Read more in sklearn's documentation . See Also GradientBoosting Gradient Boosting Machine. RandomForest Random Forest. XGBoost Extreme Gradient Boosting. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"AdaB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: AdaB Metric: f1 Results for AdaBoost: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9722 Time elapsed: 0.108s ------------------------------------------------- Total time: 0.108s Final results ==================== >> Total time: 0.109s ------------------------------------- AdaBoost --> f1: 0.9722 Hyperparameters classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=50, step=10) learning_rate FloatDistribution(high=10.0, log=True, low=0.01, step=None) algorithm CategoricalDistribution(choices=('SAMME.R', 'SAMME')) Parameters n_estimators IntDistribution(high=500, log=False, low=50, step=10) learning_rate FloatDistribution(high=10.0, log=True, low=0.01, step=None) loss CategoricalDistribution(choices=('linear', 'square', 'exponential')) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "AdaBoost"}, {"location": "API/models/adab/#adaboost", "text": "AdaB accept sparse AdaBoost is a meta-estimator that begins by fitting a classifier/regressor on the original dataset and then fits additional copies of the algorithm on the same dataset but where the weights of instances are adjusted according to the error of the current prediction. Corresponding estimators are: AdaBoostClassifier for classification tasks. AdaBoostRegressor for regression tasks. Read more in sklearn's documentation . See Also GradientBoosting Gradient Boosting Machine. RandomForest Random Forest. XGBoost Extreme Gradient Boosting.", "title": "AdaBoost"}, {"location": "API/models/adab/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"AdaB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: AdaB Metric: f1 Results for AdaBoost: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9722 Time elapsed: 0.108s ------------------------------------------------- Total time: 0.108s Final results ==================== >> Total time: 0.109s ------------------------------------- AdaBoost --> f1: 0.9722", "title": "Example"}, {"location": "API/models/adab/#hyperparameters", "text": "classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=50, step=10) learning_rate FloatDistribution(high=10.0, log=True, low=0.01, step=None) algorithm CategoricalDistribution(choices=('SAMME.R', 'SAMME')) Parameters n_estimators IntDistribution(high=500, log=False, low=50, step=10) learning_rate FloatDistribution(high=10.0, log=True, low=0.01, step=None) loss CategoricalDistribution(choices=('linear', 'square', 'exponential'))", "title": "Hyperparameters"}, {"location": "API/models/adab/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/adab/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/adab/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/adab/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/adab/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/ard/", "text": "AutomaticRelevanceDetermination ARD needs scaling Automatic Relevance Determination is very similar to BayesianRidge , but can lead to sparser coefficients. Fit the weights of a regression model, using an ARD prior. The weights of the regression model are assumed to be in Gaussian distributions. Corresponding estimators are: ARDRegression for regression tasks. Read more in sklearn's documentation . See Also BayesianRidge Bayesian ridge regression. GaussianProcess Gaussian process. LeastAngleRegression Least Angle Regression. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"ARD\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: ARD Metric: r2 Results for AutomaticRelevanceDetermination: Fit --------------------------------------------- Train evaluation --> r2: 0.7275 Test evaluation --> r2: 0.7792 Time elapsed: 0.059s ------------------------------------------------- Total time: 0.059s Final results ==================== >> Total time: 0.061s ------------------------------------- AutomaticRelevanceDetermination --> r2: 0.7792 Hyperparameters Parameters n_iter IntDistribution(high=1000, log=False, low=100, step=10) alpha_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) alpha_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "AutomaticRelevanceDetermination"}, {"location": "API/models/ard/#automaticrelevancedetermination", "text": "ARD needs scaling Automatic Relevance Determination is very similar to BayesianRidge , but can lead to sparser coefficients. Fit the weights of a regression model, using an ARD prior. The weights of the regression model are assumed to be in Gaussian distributions. Corresponding estimators are: ARDRegression for regression tasks. Read more in sklearn's documentation . See Also BayesianRidge Bayesian ridge regression. GaussianProcess Gaussian process. LeastAngleRegression Least Angle Regression.", "title": "AutomaticRelevanceDetermination"}, {"location": "API/models/ard/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"ARD\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: ARD Metric: r2 Results for AutomaticRelevanceDetermination: Fit --------------------------------------------- Train evaluation --> r2: 0.7275 Test evaluation --> r2: 0.7792 Time elapsed: 0.059s ------------------------------------------------- Total time: 0.059s Final results ==================== >> Total time: 0.061s ------------------------------------- AutomaticRelevanceDetermination --> r2: 0.7792", "title": "Example"}, {"location": "API/models/ard/#hyperparameters", "text": "Parameters n_iter IntDistribution(high=1000, log=False, low=100, step=10) alpha_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) alpha_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/ard/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/ard/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/ard/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/ard/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/ard/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/bag/", "text": "Bagging Bag accept sparse Bagging uses an ensemble meta-estimator that fits base predictors on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator by introducing randomization into its construction procedure and then making an ensemble out of it. Corresponding estimators are: BaggingClassifier for classification tasks. BaggingRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. LogisticRegression Logistic Regression. RandomForest Random Forest. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Bag\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Bag Metric: f1 Results for Bagging: Fit --------------------------------------------- Train evaluation --> f1: 0.9965 Test evaluation --> f1: 0.9722 Time elapsed: 0.051s ------------------------------------------------- Total time: 0.051s Final results ==================== >> Total time: 0.051s ------------------------------------- Bagging --> f1: 0.9722 Hyperparameters classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_samples FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) max_features FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) bootstrap CategoricalDistribution(choices=(True, False)) bootstrap_features CategoricalDistribution(choices=(True, False)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_samples FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) max_features FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) bootstrap CategoricalDistribution(choices=(True, False)) bootstrap_features CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Bagging"}, {"location": "API/models/bag/#bagging", "text": "Bag accept sparse Bagging uses an ensemble meta-estimator that fits base predictors on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator by introducing randomization into its construction procedure and then making an ensemble out of it. Corresponding estimators are: BaggingClassifier for classification tasks. BaggingRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. LogisticRegression Logistic Regression. RandomForest Random Forest.", "title": "Bagging"}, {"location": "API/models/bag/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Bag\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Bag Metric: f1 Results for Bagging: Fit --------------------------------------------- Train evaluation --> f1: 0.9965 Test evaluation --> f1: 0.9722 Time elapsed: 0.051s ------------------------------------------------- Total time: 0.051s Final results ==================== >> Total time: 0.051s ------------------------------------- Bagging --> f1: 0.9722", "title": "Example"}, {"location": "API/models/bag/#hyperparameters", "text": "classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_samples FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) max_features FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) bootstrap CategoricalDistribution(choices=(True, False)) bootstrap_features CategoricalDistribution(choices=(True, False)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_samples FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) max_features FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) bootstrap CategoricalDistribution(choices=(True, False)) bootstrap_features CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/bag/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/bag/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/bag/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/bag/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/bag/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/bnb/", "text": "BernoulliNB BNB accept sparse supports acceleration BernoulliNB implements the Naive Bayes algorithm for multivariate Bernoulli models. Like MultinomialNB , this classifier is suitable for discrete data. The difference is that while MNB works with occurrence counts, BNB is designed for binary/boolean features. Corresponding estimators are: BernoulliNB for classification tasks. Read more in sklearn's documentation . See Also ComplementNB Complement Naive Bayes. CategoricalNB Categorical Naive Bayes. MultinomialNB Multinomial Naive Bayes. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"BNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: BNB Metric: f1 Results for BernoulliNB: Fit --------------------------------------------- Train evaluation --> f1: 0.7709 Test evaluation --> f1: 0.7717 Time elapsed: 0.014s ------------------------------------------------- Total time: 0.014s Final results ==================== >> Total time: 0.015s ------------------------------------- BernoulliNB --> f1: 0.7717 Hyperparameters sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "BernoulliNB"}, {"location": "API/models/bnb/#bernoullinb", "text": "BNB accept sparse supports acceleration BernoulliNB implements the Naive Bayes algorithm for multivariate Bernoulli models. Like MultinomialNB , this classifier is suitable for discrete data. The difference is that while MNB works with occurrence counts, BNB is designed for binary/boolean features. Corresponding estimators are: BernoulliNB for classification tasks. Read more in sklearn's documentation . See Also ComplementNB Complement Naive Bayes. CategoricalNB Categorical Naive Bayes. MultinomialNB Multinomial Naive Bayes.", "title": "BernoulliNB"}, {"location": "API/models/bnb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"BNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: BNB Metric: f1 Results for BernoulliNB: Fit --------------------------------------------- Train evaluation --> f1: 0.7709 Test evaluation --> f1: 0.7717 Time elapsed: 0.014s ------------------------------------------------- Total time: 0.014s Final results ==================== >> Total time: 0.015s ------------------------------------- BernoulliNB --> f1: 0.7717", "title": "Example"}, {"location": "API/models/bnb/#hyperparameters", "text": "sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/bnb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/bnb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/bnb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/bnb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/bnb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/br/", "text": "BayesianRidge BR needs scaling Bayesian regression techniques can be used to include regularization parameters in the estimation procedure: the regularization parameter is not set in a hard sense but tuned to the data at hand. Corresponding estimators are: BayesianRidge for regression tasks. Read more in sklearn's documentation . See Also AutomaticRelevanceDetermination Automatic Relevance Determination. GaussianProcess Gaussian process. LeastAngleRegression Least Angle Regression. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"BR\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: BR Metric: r2 Results for BayesianRidge: Fit --------------------------------------------- Train evaluation --> r2: 0.7499 Test evaluation --> r2: 0.6873 Time elapsed: 0.040s ------------------------------------------------- Total time: 0.040s Final results ==================== >> Total time: 0.041s ------------------------------------- BayesianRidge --> r2: 0.6873 Hyperparameters Parameters n_iter IntDistribution(high=1000, log=False, low=100, step=10) alpha_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) alpha_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "BayesianRidge"}, {"location": "API/models/br/#bayesianridge", "text": "BR needs scaling Bayesian regression techniques can be used to include regularization parameters in the estimation procedure: the regularization parameter is not set in a hard sense but tuned to the data at hand. Corresponding estimators are: BayesianRidge for regression tasks. Read more in sklearn's documentation . See Also AutomaticRelevanceDetermination Automatic Relevance Determination. GaussianProcess Gaussian process. LeastAngleRegression Least Angle Regression.", "title": "BayesianRidge"}, {"location": "API/models/br/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"BR\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: BR Metric: r2 Results for BayesianRidge: Fit --------------------------------------------- Train evaluation --> r2: 0.7499 Test evaluation --> r2: 0.6873 Time elapsed: 0.040s ------------------------------------------------- Total time: 0.040s Final results ==================== >> Total time: 0.041s ------------------------------------- BayesianRidge --> r2: 0.6873", "title": "Example"}, {"location": "API/models/br/#hyperparameters", "text": "Parameters n_iter IntDistribution(high=1000, log=False, low=100, step=10) alpha_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) alpha_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_1 FloatDistribution(high=1.0, log=True, low=0.0001, step=None) lambda_2 FloatDistribution(high=1.0, log=True, low=0.0001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/br/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/br/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/br/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/br/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/br/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/catb/", "text": "CatBoost CatB needs scaling accept sparse allows validation supports acceleration CatBoost is a machine learning method based on gradient boosting over decision trees. Main advantages of CatBoost: Superior quality when compared with other GBDT models on many datasets. Best in class prediction speed. Corresponding estimators are: CatBoostClassifier for classification tasks. CatBoostRegressor for regression tasks. Read more in CatBoost's documentation . Warning In-training validation and pruning are disabled when device=\"gpu\" . Note ATOM uses CatBoost's n_estimators parameter instead of iterations to indicate the number of trees to fit. This is done to have consistent naming with the XGBoost and LightGBM models. See Also GradientBoosting Gradient Boosting Machine. LightGBM Light Gradient Boosting Machine. XGBoost Extreme Gradient Boosting. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"CatB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: CatB Metric: f1 Results for CatBoost: Fit --------------------------------------------- Train evaluation --> f1: 0.981 Test evaluation --> f1: 0.9859 Time elapsed: 14.789s ------------------------------------------------- Total time: 14.789s Final results ==================== >> Total time: 14.789s ------------------------------------- CatBoost --> f1: 0.9859 Hyperparameters classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) bootstrap_type CategoricalDistribution(choices=('Bayesian', 'Bernoulli')) bagging_temperature FloatDistribution(high=10.0, log=False, low=0.0, step=None) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) reg_lambda FloatDistribution(high=100.0, log=True, low=0.001, step=None) Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) bootstrap_type CategoricalDistribution(choices=('Bayesian', 'Bernoulli')) bagging_temperature FloatDistribution(high=10.0, log=False, low=0.0, step=None) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) reg_lambda FloatDistribution(high=100.0, log=True, low=0.001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "CatBoost"}, {"location": "API/models/catb/#catboost", "text": "CatB needs scaling accept sparse allows validation supports acceleration CatBoost is a machine learning method based on gradient boosting over decision trees. Main advantages of CatBoost: Superior quality when compared with other GBDT models on many datasets. Best in class prediction speed. Corresponding estimators are: CatBoostClassifier for classification tasks. CatBoostRegressor for regression tasks. Read more in CatBoost's documentation . Warning In-training validation and pruning are disabled when device=\"gpu\" . Note ATOM uses CatBoost's n_estimators parameter instead of iterations to indicate the number of trees to fit. This is done to have consistent naming with the XGBoost and LightGBM models. See Also GradientBoosting Gradient Boosting Machine. LightGBM Light Gradient Boosting Machine. XGBoost Extreme Gradient Boosting.", "title": "CatBoost"}, {"location": "API/models/catb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"CatB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: CatB Metric: f1 Results for CatBoost: Fit --------------------------------------------- Train evaluation --> f1: 0.981 Test evaluation --> f1: 0.9859 Time elapsed: 14.789s ------------------------------------------------- Total time: 14.789s Final results ==================== >> Total time: 14.789s ------------------------------------- CatBoost --> f1: 0.9859", "title": "Example"}, {"location": "API/models/catb/#hyperparameters", "text": "classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) bootstrap_type CategoricalDistribution(choices=('Bayesian', 'Bernoulli')) bagging_temperature FloatDistribution(high=10.0, log=False, low=0.0, step=None) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) reg_lambda FloatDistribution(high=100.0, log=True, low=0.001, step=None) Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) bootstrap_type CategoricalDistribution(choices=('Bayesian', 'Bernoulli')) bagging_temperature FloatDistribution(high=10.0, log=False, low=0.0, step=None) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) reg_lambda FloatDistribution(high=100.0, log=True, low=0.001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/catb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/catb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/catb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/catb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/catb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/catnb/", "text": "CategoricalNB CatNB accept sparse supports acceleration Categorical Naive Bayes implements the Naive Bayes algorithm for categorical features. Corresponding estimators are: CategoricalNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. ComplementNB Complement Naive Bayes. GaussianNB Gaussian Naive Bayes. Example >>> from atom import ATOMClassifier >>> import numpy as np >>> X = np . random . randint ( 5 , size = ( 100 , 100 )) >>> y = np . random . randint ( 2 , size = 100 ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"CatNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: CatNB Metric: f1 Results for CategoricalNB: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.5714 Time elapsed: 0.020s ------------------------------------------------- Total time: 0.020s Final results ==================== >> Total time: 0.020s ------------------------------------- CategoricalNB --> f1: 0.5714 ~ Hyperparameters sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "CategoricalNB"}, {"location": "API/models/catnb/#categoricalnb", "text": "CatNB accept sparse supports acceleration Categorical Naive Bayes implements the Naive Bayes algorithm for categorical features. Corresponding estimators are: CategoricalNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. ComplementNB Complement Naive Bayes. GaussianNB Gaussian Naive Bayes.", "title": "CategoricalNB"}, {"location": "API/models/catnb/#example", "text": ">>> from atom import ATOMClassifier >>> import numpy as np >>> X = np . random . randint ( 5 , size = ( 100 , 100 )) >>> y = np . random . randint ( 2 , size = 100 ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"CatNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: CatNB Metric: f1 Results for CategoricalNB: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.5714 Time elapsed: 0.020s ------------------------------------------------- Total time: 0.020s Final results ==================== >> Total time: 0.020s ------------------------------------- CategoricalNB --> f1: 0.5714 ~", "title": "Example"}, {"location": "API/models/catnb/#hyperparameters", "text": "sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/catnb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/catnb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/catnb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/catnb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/catnb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/cnb/", "text": "ComplementNB CNB accept sparse supports acceleration The Complement Naive Bayes classifier was designed to correct the \"severe assumptions\" made by the standard MultinomialNB classifier. It is particularly suited for imbalanced datasets. Corresponding estimators are: ComplementNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. CategoricalNB Categorical Naive Bayes. MultinomialNB Multinomial Naive Bayes. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"CNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: CNB Metric: f1 Results for ComplementNB: Fit --------------------------------------------- Train evaluation --> f1: 0.9223 Test evaluation --> f1: 0.9189 Time elapsed: 0.011s ------------------------------------------------- Total time: 0.011s Final results ==================== >> Total time: 0.012s ------------------------------------- ComplementNB --> f1: 0.9189 Hyperparameters sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) norm CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) norm CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "ComplementNB"}, {"location": "API/models/cnb/#complementnb", "text": "CNB accept sparse supports acceleration The Complement Naive Bayes classifier was designed to correct the \"severe assumptions\" made by the standard MultinomialNB classifier. It is particularly suited for imbalanced datasets. Corresponding estimators are: ComplementNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. CategoricalNB Categorical Naive Bayes. MultinomialNB Multinomial Naive Bayes.", "title": "ComplementNB"}, {"location": "API/models/cnb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"CNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: CNB Metric: f1 Results for ComplementNB: Fit --------------------------------------------- Train evaluation --> f1: 0.9223 Test evaluation --> f1: 0.9189 Time elapsed: 0.011s ------------------------------------------------- Total time: 0.011s Final results ==================== >> Total time: 0.012s ------------------------------------- ComplementNB --> f1: 0.9189", "title": "Example"}, {"location": "API/models/cnb/#hyperparameters", "text": "sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) norm CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) norm CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/cnb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/cnb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/cnb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/cnb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/cnb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/dummy/", "text": "Dummy Dummy When doing supervised learning, a simple sanity check consists of comparing one's estimator against simple rules of thumb. The prediction methods completely ignore the input data. Do not use this model for real problems. Use it only as a simple baseline to compare with other models. Corresponding estimators are: DummyClassifier for classification tasks. DummyRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. ExtraTree Extremely Randomized Tree. RandomForest Random Forest. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Dummy\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Dummy Metric: f1 Results for Dummy: Fit --------------------------------------------- Train evaluation --> f1: 0.7709 Test evaluation --> f1: 0.7717 Time elapsed: 0.006s ------------------------------------------------- Total time: 0.006s Final results ==================== >> Total time: 0.007s ------------------------------------- Dummy --> f1: 0.7717 Hyperparameters classification regression Parameters strategy CategoricalDistribution(choices=('most_frequent', 'prior', 'stratified', 'uniform')) Parameters strategy CategoricalDistribution(choices=('mean', 'median', 'quantile')) quantile FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Dummy"}, {"location": "API/models/dummy/#dummy", "text": "Dummy When doing supervised learning, a simple sanity check consists of comparing one's estimator against simple rules of thumb. The prediction methods completely ignore the input data. Do not use this model for real problems. Use it only as a simple baseline to compare with other models. Corresponding estimators are: DummyClassifier for classification tasks. DummyRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. ExtraTree Extremely Randomized Tree. RandomForest Random Forest.", "title": "Dummy"}, {"location": "API/models/dummy/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Dummy\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Dummy Metric: f1 Results for Dummy: Fit --------------------------------------------- Train evaluation --> f1: 0.7709 Test evaluation --> f1: 0.7717 Time elapsed: 0.006s ------------------------------------------------- Total time: 0.006s Final results ==================== >> Total time: 0.007s ------------------------------------- Dummy --> f1: 0.7717", "title": "Example"}, {"location": "API/models/dummy/#hyperparameters", "text": "classification regression Parameters strategy CategoricalDistribution(choices=('most_frequent', 'prior', 'stratified', 'uniform')) Parameters strategy CategoricalDistribution(choices=('mean', 'median', 'quantile')) quantile FloatDistribution(high=1.0, log=False, low=0.0, step=0.1)", "title": "Hyperparameters"}, {"location": "API/models/dummy/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/dummy/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/dummy/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/dummy/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/dummy/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/en/", "text": "ElasticNet EN needs scaling accept sparse supports acceleration Linear least squares with l1 and l2 regularization. Corresponding estimators are: ElasticNet for regression tasks. Read more in sklearn's documentation . See Also Lasso Linear Regression with lasso regularization. OrdinaryLeastSquares Linear Regression. Ridge Linear least squares with l2 regularization. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"EN\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: EN Metric: r2 Results for ElasticNet: Fit --------------------------------------------- Train evaluation --> r2: 0.6551 Test evaluation --> r2: 0.5929 Time elapsed: 0.021s ------------------------------------------------- Total time: 0.021s Final results ==================== >> Total time: 0.022s ------------------------------------- ElasticNet --> r2: 0.5929 Hyperparameters sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "ElasticNet"}, {"location": "API/models/en/#elasticnet", "text": "EN needs scaling accept sparse supports acceleration Linear least squares with l1 and l2 regularization. Corresponding estimators are: ElasticNet for regression tasks. Read more in sklearn's documentation . See Also Lasso Linear Regression with lasso regularization. OrdinaryLeastSquares Linear Regression. Ridge Linear least squares with l2 regularization.", "title": "ElasticNet"}, {"location": "API/models/en/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"EN\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: EN Metric: r2 Results for ElasticNet: Fit --------------------------------------------- Train evaluation --> r2: 0.6551 Test evaluation --> r2: 0.5929 Time elapsed: 0.021s ------------------------------------------------- Total time: 0.021s Final results ==================== >> Total time: 0.022s ------------------------------------- ElasticNet --> r2: 0.5929", "title": "Example"}, {"location": "API/models/en/#hyperparameters", "text": "sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) selection CategoricalDistribution(choices=('cyclic', 'random'))", "title": "Hyperparameters"}, {"location": "API/models/en/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/en/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/en/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/en/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/en/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/et/", "text": "ExtraTrees ET accept sparse Extra-Trees use a meta estimator that fits a number of randomized decision trees (a.k.a. extra-trees ) on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. Corresponding estimators are: ExtraTreesClassifier for classification tasks. ExtraTreesRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. ExtraTree Extremely Randomized Tree. RandomForest Random Forest. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"ET\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: ET Metric: f1 Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.993 Time elapsed: 0.095s ------------------------------------------------- Total time: 0.095s Final results ==================== >> Total time: 0.095s ------------------------------------- ExtraTrees --> f1: 0.993 Hyperparameters classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('gini', 'entropy')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('squared_error', 'absolute_error')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "ExtraTrees"}, {"location": "API/models/et/#extratrees", "text": "ET accept sparse Extra-Trees use a meta estimator that fits a number of randomized decision trees (a.k.a. extra-trees ) on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. Corresponding estimators are: ExtraTreesClassifier for classification tasks. ExtraTreesRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. ExtraTree Extremely Randomized Tree. RandomForest Random Forest.", "title": "ExtraTrees"}, {"location": "API/models/et/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"ET\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: ET Metric: f1 Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.993 Time elapsed: 0.095s ------------------------------------------------- Total time: 0.095s Final results ==================== >> Total time: 0.095s ------------------------------------- ExtraTrees --> f1: 0.993", "title": "Example"}, {"location": "API/models/et/#hyperparameters", "text": "classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('gini', 'entropy')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('squared_error', 'absolute_error')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005)", "title": "Hyperparameters"}, {"location": "API/models/et/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/et/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/et/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/et/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/et/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/etree/", "text": "ExtraTree ETree accept sparse Extra-trees differ from classic decision trees in the way they are built. When looking for the best split to separate the samples of a node into two groups, random splits are drawn for each of the max_features randomly selected features and the best split among those is chosen. When max_features is set 1, this amounts to building a totally random decision tree. Corresponding estimators are: ExtraTreeClassifier for classification tasks. ExtraTreeRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. ExtraTrees Extremely Randomized Trees. RandomForest Random Forest. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"ETree\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: ETree Metric: f1 Results for ExtraTree: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.942 Time elapsed: 0.016s ------------------------------------------------- Total time: 0.016s Final results ==================== >> Total time: 0.016s ------------------------------------- ExtraTree --> f1: 0.942 Hyperparameters classification regression Parameters criterion CategoricalDistribution(choices=('gini', 'entropy')) splitter CategoricalDistribution(choices=('random', 'best')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters criterion CategoricalDistribution(choices=('squared_error', 'absolute_error')) splitter CategoricalDistribution(choices=('random', 'best')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "ExtraTree"}, {"location": "API/models/etree/#extratree", "text": "ETree accept sparse Extra-trees differ from classic decision trees in the way they are built. When looking for the best split to separate the samples of a node into two groups, random splits are drawn for each of the max_features randomly selected features and the best split among those is chosen. When max_features is set 1, this amounts to building a totally random decision tree. Corresponding estimators are: ExtraTreeClassifier for classification tasks. ExtraTreeRegressor for regression tasks. Read more in sklearn's documentation . See Also DecisionTree Single Decision Tree. ExtraTrees Extremely Randomized Trees. RandomForest Random Forest.", "title": "ExtraTree"}, {"location": "API/models/etree/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"ETree\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: ETree Metric: f1 Results for ExtraTree: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.942 Time elapsed: 0.016s ------------------------------------------------- Total time: 0.016s Final results ==================== >> Total time: 0.016s ------------------------------------- ExtraTree --> f1: 0.942", "title": "Example"}, {"location": "API/models/etree/#hyperparameters", "text": "classification regression Parameters criterion CategoricalDistribution(choices=('gini', 'entropy')) splitter CategoricalDistribution(choices=('random', 'best')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters criterion CategoricalDistribution(choices=('squared_error', 'absolute_error')) splitter CategoricalDistribution(choices=('random', 'best')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005)", "title": "Hyperparameters"}, {"location": "API/models/etree/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/etree/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/etree/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/etree/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/etree/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/gbm/", "text": "GradientBoosting GBM accept sparse A Gradient Boosting Machine builds an additive model in a forward stage-wise fashion; it allows for the optimization of arbitrary differentiable loss functions. In each stage n_classes_ regression trees are fit on the negative gradient of the loss function, e.g. binary or multiclass log loss. Binary classification is a special case where only a single regression tree is induced. Corresponding estimators are: GradientBoostingClassifier for classification tasks. GradientBoostingRegressor for regression tasks. Read more in sklearn's documentation . Tip HistGradientBoosting is a much faster variant of this algorithm for intermediate datasets (n_samples >= 10k). See Also CatBoost Categorical Boosting Machine. HistGradientBoosting Histogram-based Gradient Boosting Machine. LightGBM Light Gradient Boosting Machine. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"GBM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: GBM Metric: f1 Results for GradientBoosting: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9726 Time elapsed: 0.275s ------------------------------------------------- Total time: 0.275s Final results ==================== >> Total time: 0.275s ------------------------------------- GradientBoosting --> f1: 0.9726 Hyperparameters classification regression Parameters loss CategoricalDistribution(choices=('log_loss', 'exponential')) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) n_estimators IntDistribution(high=500, log=False, low=10, step=10) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) criterion CategoricalDistribution(choices=('friedman_mse', 'squared_error')) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_depth IntDistribution(high=21, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters loss CategoricalDistribution(choices=('squared_error', 'absolute_error', 'huber', 'quantile')) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) n_estimators IntDistribution(high=500, log=False, low=10, step=10) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) criterion CategoricalDistribution(choices=('friedman_mse', 'squared_error')) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_depth IntDistribution(high=21, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) alpha FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "GradientBoostingMachine"}, {"location": "API/models/gbm/#gradientboosting", "text": "GBM accept sparse A Gradient Boosting Machine builds an additive model in a forward stage-wise fashion; it allows for the optimization of arbitrary differentiable loss functions. In each stage n_classes_ regression trees are fit on the negative gradient of the loss function, e.g. binary or multiclass log loss. Binary classification is a special case where only a single regression tree is induced. Corresponding estimators are: GradientBoostingClassifier for classification tasks. GradientBoostingRegressor for regression tasks. Read more in sklearn's documentation . Tip HistGradientBoosting is a much faster variant of this algorithm for intermediate datasets (n_samples >= 10k). See Also CatBoost Categorical Boosting Machine. HistGradientBoosting Histogram-based Gradient Boosting Machine. LightGBM Light Gradient Boosting Machine.", "title": "GradientBoosting"}, {"location": "API/models/gbm/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"GBM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: GBM Metric: f1 Results for GradientBoosting: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9726 Time elapsed: 0.275s ------------------------------------------------- Total time: 0.275s Final results ==================== >> Total time: 0.275s ------------------------------------- GradientBoosting --> f1: 0.9726", "title": "Example"}, {"location": "API/models/gbm/#hyperparameters", "text": "classification regression Parameters loss CategoricalDistribution(choices=('log_loss', 'exponential')) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) n_estimators IntDistribution(high=500, log=False, low=10, step=10) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) criterion CategoricalDistribution(choices=('friedman_mse', 'squared_error')) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_depth IntDistribution(high=21, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters loss CategoricalDistribution(choices=('squared_error', 'absolute_error', 'huber', 'quantile')) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) n_estimators IntDistribution(high=500, log=False, low=10, step=10) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) criterion CategoricalDistribution(choices=('friedman_mse', 'squared_error')) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_depth IntDistribution(high=21, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) alpha FloatDistribution(high=0.9, log=False, low=0.1, step=0.1)", "title": "Hyperparameters"}, {"location": "API/models/gbm/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/gbm/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/gbm/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/gbm/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/gbm/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/gnb/", "text": "GaussianNB GNB supports acceleration Gaussian Naive Bayes implements the Naive Bayes algorithm for classification. The likelihood of the features is assumed to be Gaussian. Corresponding estimators are: GaussianNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. CategoricalNB Categorical Naive Bayes. ComplementNB Complement Naive Bayes. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"GNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: GNB Metric: f1 Results for GaussianNB: Fit --------------------------------------------- Train evaluation --> f1: 0.9555 Test evaluation --> f1: 0.965 Time elapsed: 0.009s ------------------------------------------------- Total time: 0.009s Final results ==================== >> Total time: 0.010s ------------------------------------- GaussianNB --> f1: 0.965 Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "GaussianNB"}, {"location": "API/models/gnb/#gaussiannb", "text": "GNB supports acceleration Gaussian Naive Bayes implements the Naive Bayes algorithm for classification. The likelihood of the features is assumed to be Gaussian. Corresponding estimators are: GaussianNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. CategoricalNB Categorical Naive Bayes. ComplementNB Complement Naive Bayes.", "title": "GaussianNB"}, {"location": "API/models/gnb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"GNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: GNB Metric: f1 Results for GaussianNB: Fit --------------------------------------------- Train evaluation --> f1: 0.9555 Test evaluation --> f1: 0.965 Time elapsed: 0.009s ------------------------------------------------- Total time: 0.009s Final results ==================== >> Total time: 0.010s ------------------------------------- GaussianNB --> f1: 0.965", "title": "Example"}, {"location": "API/models/gnb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/gnb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/gnb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/gnb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/gnb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/gp/", "text": "GaussianProcess GP Gaussian Processes are a generic supervised learning method designed to solve regression and probabilistic classification problems. The advantages of Gaussian processes are: The prediction interpolates the observations. The prediction is probabilistic (Gaussian) so that one can compute empirical confidence intervals and decide based on those if one should refit (online fitting, adaptive fitting) the prediction in some region of interest. The disadvantages of Gaussian processes include: They are not sparse, i.e. they use the whole samples/features information to perform the prediction. They lose efficiency in high dimensional spaces, namely when the number of features exceeds a few dozens. Corresponding estimators are: GaussianProcessClassifier for classification tasks. GaussianProcessRegressor for regression tasks. Read more in sklearn's documentation . See Also GaussianNB Gaussian Naive Bayes. LinearDiscriminantAnalysis Linear Discriminant Analysis. PassiveAggressive Passive Aggressive. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"GP\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: GP Metric: f1 Results for GaussianProcess: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.0548 Time elapsed: 1.016s ------------------------------------------------- Total time: 1.016s Final results ==================== >> Total time: 1.017s ------------------------------------- GaussianProcess --> f1: 0.0548 ~ Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "GaussianProcess"}, {"location": "API/models/gp/#gaussianprocess", "text": "GP Gaussian Processes are a generic supervised learning method designed to solve regression and probabilistic classification problems. The advantages of Gaussian processes are: The prediction interpolates the observations. The prediction is probabilistic (Gaussian) so that one can compute empirical confidence intervals and decide based on those if one should refit (online fitting, adaptive fitting) the prediction in some region of interest. The disadvantages of Gaussian processes include: They are not sparse, i.e. they use the whole samples/features information to perform the prediction. They lose efficiency in high dimensional spaces, namely when the number of features exceeds a few dozens. Corresponding estimators are: GaussianProcessClassifier for classification tasks. GaussianProcessRegressor for regression tasks. Read more in sklearn's documentation . See Also GaussianNB Gaussian Naive Bayes. LinearDiscriminantAnalysis Linear Discriminant Analysis. PassiveAggressive Passive Aggressive.", "title": "GaussianProcess"}, {"location": "API/models/gp/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"GP\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: GP Metric: f1 Results for GaussianProcess: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.0548 Time elapsed: 1.016s ------------------------------------------------- Total time: 1.016s Final results ==================== >> Total time: 1.017s ------------------------------------- GaussianProcess --> f1: 0.0548 ~", "title": "Example"}, {"location": "API/models/gp/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/gp/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/gp/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/gp/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/gp/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/hgbm/", "text": "HistGradientBoosting hGBM This Histogram-based Gradient Boosting Machine is much faster than the standard GradientBoosting for big datasets (n_samples>=10k). This variation first bins the input samples into integer-valued bins which tremendously reduces the number of splitting points to consider, and allows the algorithm to leverage integer-based data structures (histograms) instead of relying on sorted continuous values when building the trees. Corresponding estimators are: HistGradientBoostingClassifier for classification tasks. HistGradientBoostingRegressor for regression tasks. Read more in sklearn's documentation . See Also CatBoost Categorical Boosting Machine. GradientBoosting Gradient Boosting Machine. XGBoost Extreme Gradient Boosting. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"hGBM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: hGBM Metric: f1 Results for HistGradientBoosting: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9655 Time elapsed: 1.044s ------------------------------------------------- Total time: 1.044s Final results ==================== >> Total time: 1.044s ------------------------------------- HistGradientBoosting --> f1: 0.9655 Hyperparameters classification regression Parameters learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_iter IntDistribution(high=500, log=False, low=10, step=10) max_leaf_nodes IntDistribution(high=50, log=False, low=10, step=1) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_leaf IntDistribution(high=30, log=False, low=10, step=1) l2_regularization FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Parameters loss CategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_iter IntDistribution(high=500, log=False, low=10, step=10) max_leaf_nodes IntDistribution(high=50, log=False, low=10, step=1) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_leaf IntDistribution(high=30, log=False, low=10, step=1) l2_regularization FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "HistGradientBoosting"}, {"location": "API/models/hgbm/#histgradientboosting", "text": "hGBM This Histogram-based Gradient Boosting Machine is much faster than the standard GradientBoosting for big datasets (n_samples>=10k). This variation first bins the input samples into integer-valued bins which tremendously reduces the number of splitting points to consider, and allows the algorithm to leverage integer-based data structures (histograms) instead of relying on sorted continuous values when building the trees. Corresponding estimators are: HistGradientBoostingClassifier for classification tasks. HistGradientBoostingRegressor for regression tasks. Read more in sklearn's documentation . See Also CatBoost Categorical Boosting Machine. GradientBoosting Gradient Boosting Machine. XGBoost Extreme Gradient Boosting.", "title": "HistGradientBoosting"}, {"location": "API/models/hgbm/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"hGBM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: hGBM Metric: f1 Results for HistGradientBoosting: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9655 Time elapsed: 1.044s ------------------------------------------------- Total time: 1.044s Final results ==================== >> Total time: 1.044s ------------------------------------- HistGradientBoosting --> f1: 0.9655", "title": "Example"}, {"location": "API/models/hgbm/#hyperparameters", "text": "classification regression Parameters learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_iter IntDistribution(high=500, log=False, low=10, step=10) max_leaf_nodes IntDistribution(high=50, log=False, low=10, step=1) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_leaf IntDistribution(high=30, log=False, low=10, step=1) l2_regularization FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Parameters loss CategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_iter IntDistribution(high=500, log=False, low=10, step=10) max_leaf_nodes IntDistribution(high=50, log=False, low=10, step=1) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_leaf IntDistribution(high=30, log=False, low=10, step=1) l2_regularization FloatDistribution(high=1.0, log=False, low=0.0, step=0.1)", "title": "Hyperparameters"}, {"location": "API/models/hgbm/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/hgbm/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/hgbm/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/hgbm/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/hgbm/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/huber/", "text": "HuberRegression Huber needs scaling Huber is a linear regression model that is robust to outliers. It makes sure that the loss function is not heavily influenced by the outliers while not completely ignoring their effect. Corresponding estimators are: HuberRegressor for regression tasks. Read more in sklearn's documentation . See Also AutomaticRelevanceDetermination Automatic Relevance Determination. LeastAngleRegression Least Angle Regression. OrdinaryLeastSquares Linear Regression. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Huber\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Huber Metric: r2 Results for HuberRegression: Fit --------------------------------------------- Train evaluation --> r2: 0.7262 Test evaluation --> r2: 0.7213 Time elapsed: 0.044s ------------------------------------------------- Total time: 0.044s Final results ==================== >> Total time: 0.046s ------------------------------------- HuberRegression --> r2: 0.7213 Hyperparameters Parameters epsilon FloatDistribution(high=10.0, log=True, low=1.0, step=None) max_iter IntDistribution(high=500, log=False, low=50, step=10) alpha FloatDistribution(high=1.0, log=True, low=0.0001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "HuberRegression"}, {"location": "API/models/huber/#huberregression", "text": "Huber needs scaling Huber is a linear regression model that is robust to outliers. It makes sure that the loss function is not heavily influenced by the outliers while not completely ignoring their effect. Corresponding estimators are: HuberRegressor for regression tasks. Read more in sklearn's documentation . See Also AutomaticRelevanceDetermination Automatic Relevance Determination. LeastAngleRegression Least Angle Regression. OrdinaryLeastSquares Linear Regression.", "title": "HuberRegression"}, {"location": "API/models/huber/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Huber\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Huber Metric: r2 Results for HuberRegression: Fit --------------------------------------------- Train evaluation --> r2: 0.7262 Test evaluation --> r2: 0.7213 Time elapsed: 0.044s ------------------------------------------------- Total time: 0.044s Final results ==================== >> Total time: 0.046s ------------------------------------- HuberRegression --> r2: 0.7213", "title": "Example"}, {"location": "API/models/huber/#hyperparameters", "text": "Parameters epsilon FloatDistribution(high=10.0, log=True, low=1.0, step=None) max_iter IntDistribution(high=500, log=False, low=50, step=10) alpha FloatDistribution(high=1.0, log=True, low=0.0001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/huber/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/huber/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/huber/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/huber/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/huber/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/knn/", "text": "KNearestNeighbors KNN needs scaling accept sparse supports acceleration K-Nearest Neighbors, as the name clearly indicates, implements the k-nearest neighbors vote. For regression, the target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set. Corresponding estimators are: KNeighborsClassifier for classification tasks. KNeighborsRegressor for classification tasks. Read more in sklearn's documentation . See Also LinearDiscriminantAnalysis Linear Discriminant Analysis. QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis. RadiusNearestNeighbors Radius Nearest Neighbors. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"KNN\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: KNN Metric: f1 Results for KNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 0.9845 Test evaluation --> f1: 0.9861 Time elapsed: 0.187s ------------------------------------------------- Total time: 0.187s Final results ==================== >> Total time: 0.189s ------------------------------------- KNearestNeighbors --> f1: 0.9861 Hyperparameters classification regression sklearn sklearnex cuml Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) cpu gpu Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) sklearn sklearnex cuml Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) cpu gpu Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "KNearestNeighbors"}, {"location": "API/models/knn/#knearestneighbors", "text": "KNN needs scaling accept sparse supports acceleration K-Nearest Neighbors, as the name clearly indicates, implements the k-nearest neighbors vote. For regression, the target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set. Corresponding estimators are: KNeighborsClassifier for classification tasks. KNeighborsRegressor for classification tasks. Read more in sklearn's documentation . See Also LinearDiscriminantAnalysis Linear Discriminant Analysis. QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis. RadiusNearestNeighbors Radius Nearest Neighbors.", "title": "KNearestNeighbors"}, {"location": "API/models/knn/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"KNN\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: KNN Metric: f1 Results for KNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 0.9845 Test evaluation --> f1: 0.9861 Time elapsed: 0.187s ------------------------------------------------- Total time: 0.187s Final results ==================== >> Total time: 0.189s ------------------------------------- KNearestNeighbors --> f1: 0.9861", "title": "Example"}, {"location": "API/models/knn/#hyperparameters", "text": "classification regression sklearn sklearnex cuml Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) cpu gpu Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) sklearn sklearnex cuml Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) cpu gpu Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1) weights CategoricalDistribution(choices=('uniform', 'distance')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters n_neighbors IntDistribution(high=100, log=False, low=1, step=1)", "title": "Hyperparameters"}, {"location": "API/models/knn/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/knn/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/knn/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/knn/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/knn/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/lars/", "text": "LeastAngleRegression Lars needs scaling Least-Angle Regression is a regression algorithm for high-dimensional data. Lars is similar to forward stepwise regression. At each step, it finds the feature most correlated with the target. When there are multiple features having equal correlation, instead of continuing along the same feature, it proceeds in a direction equiangular between the features. Corresponding estimators are: Lars for regression tasks. Read more in sklearn's documentation . See Also BayesianRidge Bayesian ridge regression. HuberRegression Huber regressor. OrdinaryLeastSquares Linear Regression. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Lars\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Lars Metric: r2 Results for LeastAngleRegression: Fit --------------------------------------------- Train evaluation --> r2: 0.7337 Test evaluation --> r2: 0.7468 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Final results ==================== >> Total time: 0.019s ------------------------------------- LeastAngleRegression --> r2: 0.7468 Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "LeastAngleRegression"}, {"location": "API/models/lars/#leastangleregression", "text": "Lars needs scaling Least-Angle Regression is a regression algorithm for high-dimensional data. Lars is similar to forward stepwise regression. At each step, it finds the feature most correlated with the target. When there are multiple features having equal correlation, instead of continuing along the same feature, it proceeds in a direction equiangular between the features. Corresponding estimators are: Lars for regression tasks. Read more in sklearn's documentation . See Also BayesianRidge Bayesian ridge regression. HuberRegression Huber regressor. OrdinaryLeastSquares Linear Regression.", "title": "LeastAngleRegression"}, {"location": "API/models/lars/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Lars\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Lars Metric: r2 Results for LeastAngleRegression: Fit --------------------------------------------- Train evaluation --> r2: 0.7337 Test evaluation --> r2: 0.7468 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Final results ==================== >> Total time: 0.019s ------------------------------------- LeastAngleRegression --> r2: 0.7468", "title": "Example"}, {"location": "API/models/lars/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/lars/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/lars/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/lars/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/lars/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/lasso/", "text": "Lasso Lasso needs scaling accept sparse supports acceleration Linear least squares with l1 regularization. Corresponding estimators are: Lasso for regression tasks. Read more in sklearn's documentation . See Also ElasticNet Linear Regression with elasticnet regularization. OrdinaryLeastSquares Linear Regression. Ridge Linear least squares with l2 regularization. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Lasso\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Lasso Metric: r2 Results for Lasso: Fit --------------------------------------------- Train evaluation --> r2: 0.6681 Test evaluation --> r2: 0.6466 Time elapsed: 0.020s ------------------------------------------------- Total time: 0.020s Final results ==================== >> Total time: 0.021s ------------------------------------- Lasso --> r2: 0.6466 Hyperparameters sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Lasso"}, {"location": "API/models/lasso/#lasso", "text": "Lasso needs scaling accept sparse supports acceleration Linear least squares with l1 regularization. Corresponding estimators are: Lasso for regression tasks. Read more in sklearn's documentation . See Also ElasticNet Linear Regression with elasticnet regularization. OrdinaryLeastSquares Linear Regression. Ridge Linear least squares with l2 regularization.", "title": "Lasso"}, {"location": "API/models/lasso/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Lasso\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Lasso Metric: r2 Results for Lasso: Fit --------------------------------------------- Train evaluation --> r2: 0.6681 Test evaluation --> r2: 0.6466 Time elapsed: 0.020s ------------------------------------------------- Total time: 0.020s Final results ==================== >> Total time: 0.021s ------------------------------------- Lasso --> r2: 0.6466", "title": "Example"}, {"location": "API/models/lasso/#hyperparameters", "text": "sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random')) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) selection CategoricalDistribution(choices=('cyclic', 'random'))", "title": "Hyperparameters"}, {"location": "API/models/lasso/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/lasso/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/lasso/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/lasso/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/lasso/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/lda/", "text": "LinearDiscriminantAnalysis LDA Linear Discriminant Analysis is a classifier with a linear decision boundary, generated by fitting class conditional densities to the data and using Bayes\u2019 rule. The model fits a Gaussian density to each class, assuming that all classes share the same covariance matrix. Corresponding estimators are: LinearDiscriminantAnalysis for classification tasks. Read more in sklearn's documentation . See Also LogisticRegression Logistic Regression. RadiusNearestNeighbors Radius Nearest Neighbors. QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"LDA\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: LDA Metric: f1 Results for LinearDiscriminantAnalysis: Fit --------------------------------------------- Train evaluation --> f1: 0.976 Test evaluation --> f1: 0.953 Time elapsed: 0.025s ------------------------------------------------- Total time: 0.025s Final results ==================== >> Total time: 0.025s ------------------------------------- LinearDiscriminantAnalysis --> f1: 0.953 Hyperparameters Parameters solver CategoricalDistribution(choices=('svd', 'lsqr', 'eigen')) shrinkage CategoricalDistribution(choices=(None, 'auto', 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "LinearDiscriminantAnalysis"}, {"location": "API/models/lda/#lineardiscriminantanalysis", "text": "LDA Linear Discriminant Analysis is a classifier with a linear decision boundary, generated by fitting class conditional densities to the data and using Bayes\u2019 rule. The model fits a Gaussian density to each class, assuming that all classes share the same covariance matrix. Corresponding estimators are: LinearDiscriminantAnalysis for classification tasks. Read more in sklearn's documentation . See Also LogisticRegression Logistic Regression. RadiusNearestNeighbors Radius Nearest Neighbors. QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis.", "title": "LinearDiscriminantAnalysis"}, {"location": "API/models/lda/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"LDA\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: LDA Metric: f1 Results for LinearDiscriminantAnalysis: Fit --------------------------------------------- Train evaluation --> f1: 0.976 Test evaluation --> f1: 0.953 Time elapsed: 0.025s ------------------------------------------------- Total time: 0.025s Final results ==================== >> Total time: 0.025s ------------------------------------- LinearDiscriminantAnalysis --> f1: 0.953", "title": "Example"}, {"location": "API/models/lda/#hyperparameters", "text": "Parameters solver CategoricalDistribution(choices=('svd', 'lsqr', 'eigen')) shrinkage CategoricalDistribution(choices=(None, 'auto', 0.5, 0.6, 0.7, 0.8, 0.9, 1.0))", "title": "Hyperparameters"}, {"location": "API/models/lda/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/lda/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/lda/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/lda/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/lda/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/lgb/", "text": "LightGBM LGB needs scaling accept sparse allows validation supports acceleration LightGBM is a gradient boosting model that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages: Faster training speed and higher efficiency. Lower memory usage. Better accuracy. Capable of handling large-scale data. Corresponding estimators are: LGBMClassifier for classification tasks. LGBMRegressor for regression tasks. Read more in LightGBM's documentation . Info Using LightGBM's GPU acceleration requires additional software dependencies . See Also CatBoost Categorical Boosting Machine. GradientBoosting Gradient Boosting Machine. XGBoost Extreme Gradient Boosting. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"LGB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: LGB Metric: f1 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.979 Time elapsed: 0.465s ------------------------------------------------- Total time: 0.465s Final results ==================== >> Total time: 0.466s ------------------------------------- LightGBM --> f1: 0.979 Hyperparameters classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=17, log=False, low=-1, step=2) num_leaves IntDistribution(high=40, log=False, low=20, step=1) min_child_weight FloatDistribution(high=100.0, log=True, low=0.0001, step=None) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None) Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=17, log=False, low=-1, step=2) num_leaves IntDistribution(high=40, log=False, low=20, step=1) min_child_weight FloatDistribution(high=100.0, log=True, low=0.0001, step=None) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "LightGBM"}, {"location": "API/models/lgb/#lightgbm", "text": "LGB needs scaling accept sparse allows validation supports acceleration LightGBM is a gradient boosting model that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages: Faster training speed and higher efficiency. Lower memory usage. Better accuracy. Capable of handling large-scale data. Corresponding estimators are: LGBMClassifier for classification tasks. LGBMRegressor for regression tasks. Read more in LightGBM's documentation . Info Using LightGBM's GPU acceleration requires additional software dependencies . See Also CatBoost Categorical Boosting Machine. GradientBoosting Gradient Boosting Machine. XGBoost Extreme Gradient Boosting.", "title": "LightGBM"}, {"location": "API/models/lgb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"LGB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: LGB Metric: f1 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.979 Time elapsed: 0.465s ------------------------------------------------- Total time: 0.465s Final results ==================== >> Total time: 0.466s ------------------------------------- LightGBM --> f1: 0.979", "title": "Example"}, {"location": "API/models/lgb/#hyperparameters", "text": "classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=17, log=False, low=-1, step=2) num_leaves IntDistribution(high=40, log=False, low=20, step=1) min_child_weight FloatDistribution(high=100.0, log=True, low=0.0001, step=None) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None) Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=17, log=False, low=-1, step=2) num_leaves IntDistribution(high=40, log=False, low=20, step=1) min_child_weight FloatDistribution(high=100.0, log=True, low=0.0001, step=None) min_child_samples IntDistribution(high=30, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/lgb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/lgb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/lgb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/lgb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/lgb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/lr/", "text": "LogisticRegression LR needs scaling accept sparse supports acceleration Logistic regression, despite its name, is a linear model for classification rather than regression. Logistic regression is also known in the literature as logit regression, maximum-entropy classification (MaxEnt) or the log-linear classifier. In this model, the probabilities describing the possible outcomes of a single trial are modeled using a logistic function. Corresponding estimators are: LogisticRegression for classification tasks. Read more in sklearn's documentation . See Also GaussianProcess Gaussian process. LinearDiscriminantAnalysis Linear Discriminant Analysis. PassiveAggressive Passive Aggressive. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"RF\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: LR Metric: f1 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> f1: 0.9895 Test evaluation --> f1: 0.993 Time elapsed: 0.028s ------------------------------------------------- Total time: 0.028s Final results ==================== >> Total time: 0.028s ------------------------------------- LogisticRegression --> f1: 0.993 Hyperparameters sklearn sklearnex cuml Parameters penalty CategoricalDistribution(choices=('l1', 'l2', 'elasticnet', 'none')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) cpu gpu Parameters penalty CategoricalDistribution(choices=('l1', 'l2', 'elasticnet', 'none')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('lbfgs', 'newton-cg')) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "LogisticRegression"}, {"location": "API/models/lr/#logisticregression", "text": "LR needs scaling accept sparse supports acceleration Logistic regression, despite its name, is a linear model for classification rather than regression. Logistic regression is also known in the literature as logit regression, maximum-entropy classification (MaxEnt) or the log-linear classifier. In this model, the probabilities describing the possible outcomes of a single trial are modeled using a logistic function. Corresponding estimators are: LogisticRegression for classification tasks. Read more in sklearn's documentation . See Also GaussianProcess Gaussian process. LinearDiscriminantAnalysis Linear Discriminant Analysis. PassiveAggressive Passive Aggressive.", "title": "LogisticRegression"}, {"location": "API/models/lr/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"RF\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: LR Metric: f1 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> f1: 0.9895 Test evaluation --> f1: 0.993 Time elapsed: 0.028s ------------------------------------------------- Total time: 0.028s Final results ==================== >> Total time: 0.028s ------------------------------------- LogisticRegression --> f1: 0.993", "title": "Example"}, {"location": "API/models/lr/#hyperparameters", "text": "sklearn sklearnex cuml Parameters penalty CategoricalDistribution(choices=('l1', 'l2', 'elasticnet', 'none')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga')) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) cpu gpu Parameters penalty CategoricalDistribution(choices=('l1', 'l2', 'elasticnet', 'none')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('lbfgs', 'newton-cg')) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) max_iter IntDistribution(high=1000, log=False, low=100, step=10) l1_ratio FloatDistribution(high=1.0, log=False, low=0.0, step=0.1)", "title": "Hyperparameters"}, {"location": "API/models/lr/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/lr/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/lr/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/lr/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/lr/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/lsvm/", "text": "LinearSVM lSVM needs scaling accept sparse supports acceleration Similar to SupportVectorMachine but with a linear kernel. Implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples. Corresponding estimators are: LinearSVC for classification tasks. LinearSVR for classification tasks. Read more in sklearn's documentation . See Also KNearestNeighbors K-Nearest Neighbors. StochasticGradientDescent Stochastic Gradient Descent. SupportVectorMachine Support Vector Machine. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"lSVM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: lSVM Metric: f1 Results for LinearSVM: Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9861 Time elapsed: 0.021s ------------------------------------------------- Total time: 0.021s Final results ==================== >> Total time: 0.021s ------------------------------------- LinearSVM --> f1: 0.9861 Hyperparameters classification regression sklearn cuml Parameters penalty CategoricalDistribution(choices=('l1', 'l2')) loss CategoricalDistribution(choices=('hinge', 'squared_hinge')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) dual CategoricalDistribution(choices=(True, False)) Parameters penalty CategoricalDistribution(choices=('l1', 'l2')) loss CategoricalDistribution(choices=('hinge', 'squared_hinge')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) sklearn cuml Parameters loss CategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) dual CategoricalDistribution(choices=(True, False)) Parameters loss CategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "LinearSVM"}, {"location": "API/models/lsvm/#linearsvm", "text": "lSVM needs scaling accept sparse supports acceleration Similar to SupportVectorMachine but with a linear kernel. Implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples. Corresponding estimators are: LinearSVC for classification tasks. LinearSVR for classification tasks. Read more in sklearn's documentation . See Also KNearestNeighbors K-Nearest Neighbors. StochasticGradientDescent Stochastic Gradient Descent. SupportVectorMachine Support Vector Machine.", "title": "LinearSVM"}, {"location": "API/models/lsvm/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"lSVM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: lSVM Metric: f1 Results for LinearSVM: Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9861 Time elapsed: 0.021s ------------------------------------------------- Total time: 0.021s Final results ==================== >> Total time: 0.021s ------------------------------------- LinearSVM --> f1: 0.9861", "title": "Example"}, {"location": "API/models/lsvm/#hyperparameters", "text": "classification regression sklearn cuml Parameters penalty CategoricalDistribution(choices=('l1', 'l2')) loss CategoricalDistribution(choices=('hinge', 'squared_hinge')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) dual CategoricalDistribution(choices=(True, False)) Parameters penalty CategoricalDistribution(choices=('l1', 'l2')) loss CategoricalDistribution(choices=('hinge', 'squared_hinge')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) sklearn cuml Parameters loss CategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None) dual CategoricalDistribution(choices=(True, False)) Parameters loss CategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) C FloatDistribution(high=100.0, log=True, low=0.001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/lsvm/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/lsvm/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/lsvm/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/lsvm/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/lsvm/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/mlp/", "text": "MultiLayerPerceptron MLP needs scaling accept sparse allows validation Multi-layer Perceptron is a supervised learning algorithm that learns a function by training on a dataset. Given a set of features and a target, it can learn a non-linear function approximator for either classification or regression. It is different from logistic regression, in that between the input and the output layer, there can be one or more non-linear layers, called hidden layers. Corresponding estimators are: MLPClassifier for classification tasks. MLPRegressor for regression tasks. Read more in sklearn's documentation . See Also PassiveAggressive Passive Aggressive. Perceptron Linear Perceptron classification. StochasticGradientDescent Stochastic Gradient Descent. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"MLP\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: MLP Metric: f1 Results for MultiLayerPerceptron: Fit --------------------------------------------- Train evaluation --> f1: 0.9965 Test evaluation --> f1: 0.979 Time elapsed: 1.600s ------------------------------------------------- Total time: 1.600s Final results ==================== >> Total time: 1.600s ------------------------------------- MultiLayerPerceptron --> f1: 0.979 Hyperparameters classification regression Parameters hidden_layer_1 IntDistribution(high=100, log=False, low=10, step=1) hidden_layer_2 IntDistribution(high=100, log=False, low=0, step=1) hidden_layer_3 IntDistribution(high=10, log=False, low=0, step=1) activation CategoricalDistribution(choices=('identity', 'logistic', 'tanh', 'relu')) solver CategoricalDistribution(choices=('lbfgs', 'sgd', 'adam')) alpha FloatDistribution(high=0.1, log=True, low=0.0001, step=None) batch_size CategoricalDistribution(choices=('auto', 8, 16, 32, 64, 128, 256)) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'adaptive')) learning_rate_init FloatDistribution(high=0.1, log=True, low=0.001, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=500, log=False, low=50, step=10) Parameters hidden_layer_1 IntDistribution(high=100, log=False, low=10, step=1) hidden_layer_2 IntDistribution(high=100, log=False, low=0, step=1) hidden_layer_3 IntDistribution(high=10, log=False, low=0, step=1) activation CategoricalDistribution(choices=('identity', 'logistic', 'tanh', 'relu')) solver CategoricalDistribution(choices=('lbfgs', 'sgd', 'adam')) alpha FloatDistribution(high=0.1, log=True, low=0.0001, step=None) batch_size CategoricalDistribution(choices=('auto', 8, 16, 32, 64, 128, 256)) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'adaptive')) learning_rate_init FloatDistribution(high=0.1, log=True, low=0.001, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=500, log=False, low=50, step=10) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "MultiLayerPerceptron"}, {"location": "API/models/mlp/#multilayerperceptron", "text": "MLP needs scaling accept sparse allows validation Multi-layer Perceptron is a supervised learning algorithm that learns a function by training on a dataset. Given a set of features and a target, it can learn a non-linear function approximator for either classification or regression. It is different from logistic regression, in that between the input and the output layer, there can be one or more non-linear layers, called hidden layers. Corresponding estimators are: MLPClassifier for classification tasks. MLPRegressor for regression tasks. Read more in sklearn's documentation . See Also PassiveAggressive Passive Aggressive. Perceptron Linear Perceptron classification. StochasticGradientDescent Stochastic Gradient Descent.", "title": "MultiLayerPerceptron"}, {"location": "API/models/mlp/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"MLP\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: MLP Metric: f1 Results for MultiLayerPerceptron: Fit --------------------------------------------- Train evaluation --> f1: 0.9965 Test evaluation --> f1: 0.979 Time elapsed: 1.600s ------------------------------------------------- Total time: 1.600s Final results ==================== >> Total time: 1.600s ------------------------------------- MultiLayerPerceptron --> f1: 0.979", "title": "Example"}, {"location": "API/models/mlp/#hyperparameters", "text": "classification regression Parameters hidden_layer_1 IntDistribution(high=100, log=False, low=10, step=1) hidden_layer_2 IntDistribution(high=100, log=False, low=0, step=1) hidden_layer_3 IntDistribution(high=10, log=False, low=0, step=1) activation CategoricalDistribution(choices=('identity', 'logistic', 'tanh', 'relu')) solver CategoricalDistribution(choices=('lbfgs', 'sgd', 'adam')) alpha FloatDistribution(high=0.1, log=True, low=0.0001, step=None) batch_size CategoricalDistribution(choices=('auto', 8, 16, 32, 64, 128, 256)) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'adaptive')) learning_rate_init FloatDistribution(high=0.1, log=True, low=0.001, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=500, log=False, low=50, step=10) Parameters hidden_layer_1 IntDistribution(high=100, log=False, low=10, step=1) hidden_layer_2 IntDistribution(high=100, log=False, low=0, step=1) hidden_layer_3 IntDistribution(high=10, log=False, low=0, step=1) activation CategoricalDistribution(choices=('identity', 'logistic', 'tanh', 'relu')) solver CategoricalDistribution(choices=('lbfgs', 'sgd', 'adam')) alpha FloatDistribution(high=0.1, log=True, low=0.0001, step=None) batch_size CategoricalDistribution(choices=('auto', 8, 16, 32, 64, 128, 256)) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'adaptive')) learning_rate_init FloatDistribution(high=0.1, log=True, low=0.001, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=500, log=False, low=50, step=10)", "title": "Hyperparameters"}, {"location": "API/models/mlp/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/mlp/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/mlp/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/mlp/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/mlp/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/mnb/", "text": "MultinomialNB MNB accept sparse supports acceleration MultinomialNB implements the Naive Bayes algorithm for multinomially distributed data, and is one of the two classic Naive Bayes variants used in text classification (where the data are typically represented as word vector counts, although tf-idf vectors are also known to work well in practice). Corresponding estimators are: MultinomialNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. ComplementNB Complement Naive Bayes. GaussianNB Gaussian Naive Bayes. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"MNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: MNB Metric: f1 Results for MultinomialNB: Fit --------------------------------------------- Train evaluation --> f1: 0.916 Test evaluation --> f1: 0.9371 Time elapsed: 0.011s ------------------------------------------------- Total time: 0.011s Final results ==================== >> Total time: 0.011s ------------------------------------- MultinomialNB --> f1: 0.9371 Hyperparameters sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "MultinomialNB"}, {"location": "API/models/mnb/#multinomialnb", "text": "MNB accept sparse supports acceleration MultinomialNB implements the Naive Bayes algorithm for multinomially distributed data, and is one of the two classic Naive Bayes variants used in text classification (where the data are typically represented as word vector counts, although tf-idf vectors are also known to work well in practice). Corresponding estimators are: MultinomialNB for classification tasks. Read more in sklearn's documentation . See Also BernoulliNB Bernoulli Naive Bayes. ComplementNB Complement Naive Bayes. GaussianNB Gaussian Naive Bayes.", "title": "MultinomialNB"}, {"location": "API/models/mnb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"MNB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: MNB Metric: f1 Results for MultinomialNB: Fit --------------------------------------------- Train evaluation --> f1: 0.916 Test evaluation --> f1: 0.9371 Time elapsed: 0.011s ------------------------------------------------- Total time: 0.011s Final results ==================== >> Total time: 0.011s ------------------------------------- MultinomialNB --> f1: 0.9371", "title": "Example"}, {"location": "API/models/mnb/#hyperparameters", "text": "sklearn cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False)) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.01, step=None) fit_prior CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/mnb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/mnb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/mnb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/mnb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/mnb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/ols/", "text": "OrdinaryLeastSquares OLS needs scaling accept sparse supports acceleration Ordinary Least Squares is just linear regression without any regularization. It fits a linear model with coefficients w=(w1, ..., wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation. Corresponding estimators are: LinearRegression for regression tasks. Read more in sklearn's documentation . See Also ElasticNet Linear Regression with elasticnet regularization. Lasso Linear Regression with lasso regularization. Ridge Linear least squares with l2 regularization. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"OLS\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: OLS Metric: r2 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7489 Test evaluation --> r2: 0.706 Time elapsed: 0.023s ------------------------------------------------- Total time: 0.023s Final results ==================== >> Total time: 0.024s ------------------------------------- OrdinaryLeastSquares --> r2: 0.706 Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "OrdinaryLeastSquares"}, {"location": "API/models/ols/#ordinaryleastsquares", "text": "OLS needs scaling accept sparse supports acceleration Ordinary Least Squares is just linear regression without any regularization. It fits a linear model with coefficients w=(w1, ..., wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation. Corresponding estimators are: LinearRegression for regression tasks. Read more in sklearn's documentation . See Also ElasticNet Linear Regression with elasticnet regularization. Lasso Linear Regression with lasso regularization. Ridge Linear least squares with l2 regularization.", "title": "OrdinaryLeastSquares"}, {"location": "API/models/ols/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"OLS\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: OLS Metric: r2 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7489 Test evaluation --> r2: 0.706 Time elapsed: 0.023s ------------------------------------------------- Total time: 0.023s Final results ==================== >> Total time: 0.024s ------------------------------------- OrdinaryLeastSquares --> r2: 0.706", "title": "Example"}, {"location": "API/models/ols/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/ols/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/ols/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/ols/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/ols/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/omp/", "text": "OrthogonalMatchingPursuit OMP needs scaling Orthogonal Matching Pursuit implements the OMP algorithm for approximating the fit of a linear model with constraints imposed on the number of non-zero coefficients. Corresponding estimators are: OrthogonalMatchingPursuit for regression tasks. Read more in sklearn's documentation . See Also Lasso Linear Regression with lasso regularization. LeastAngleRegression Least Angle Regression. OrdinaryLeastSquares Linear Regression. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"OMP\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: OMP Metric: r2 Train evaluation --> r2: 0.4751 Test evaluation --> r2: 0.4668 Time elapsed: 0.028s ------------------------------------------------- Total time: 0.028s Final results ==================== >> Total time: 0.028s ------------------------------------- OrthogonalMatchingPursuit --> r2: 0.4668 Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "OrthogonalMatchingPursuit"}, {"location": "API/models/omp/#orthogonalmatchingpursuit", "text": "OMP needs scaling Orthogonal Matching Pursuit implements the OMP algorithm for approximating the fit of a linear model with constraints imposed on the number of non-zero coefficients. Corresponding estimators are: OrthogonalMatchingPursuit for regression tasks. Read more in sklearn's documentation . See Also Lasso Linear Regression with lasso regularization. LeastAngleRegression Least Angle Regression. OrdinaryLeastSquares Linear Regression.", "title": "OrthogonalMatchingPursuit"}, {"location": "API/models/omp/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"OMP\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: OMP Metric: r2 Train evaluation --> r2: 0.4751 Test evaluation --> r2: 0.4668 Time elapsed: 0.028s ------------------------------------------------- Total time: 0.028s Final results ==================== >> Total time: 0.028s ------------------------------------- OrthogonalMatchingPursuit --> r2: 0.4668", "title": "Example"}, {"location": "API/models/omp/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/omp/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/omp/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/omp/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/omp/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/pa/", "text": "PassiveAggressive PA needs scaling accept sparse allows validation The passive-aggressive algorithms are a family of algorithms for large-scale learning. They are similar to the Perceptron in that they do not require a learning rate. However, contrary to the Perceptron , they include a regularization parameter C . Corresponding estimators are: PassiveAggressiveClassifier for classification tasks. PassiveAggressiveRegressor for classification tasks. Read more in sklearn's documentation . See Also MultiLayerPerceptron Multi-layer Perceptron. Perceptron Linear Perceptron classification. StochasticGradientDescent Stochastic Gradient Descent. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"PA\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: PA Metric: f1 Results for PassiveAggressive: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9655 Time elapsed: 4.549s ------------------------------------------------- Total time: 4.549s Final results ==================== >> Total time: 4.550s ------------------------------------- PassiveAggressive --> f1: 0.9655 Hyperparameters classification regression Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) loss CategoricalDistribution(choices=('hinge', 'squared_hinge')) average CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) loss CategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) average CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "PassiveAggressive"}, {"location": "API/models/pa/#passiveaggressive", "text": "PA needs scaling accept sparse allows validation The passive-aggressive algorithms are a family of algorithms for large-scale learning. They are similar to the Perceptron in that they do not require a learning rate. However, contrary to the Perceptron , they include a regularization parameter C . Corresponding estimators are: PassiveAggressiveClassifier for classification tasks. PassiveAggressiveRegressor for classification tasks. Read more in sklearn's documentation . See Also MultiLayerPerceptron Multi-layer Perceptron. Perceptron Linear Perceptron classification. StochasticGradientDescent Stochastic Gradient Descent.", "title": "PassiveAggressive"}, {"location": "API/models/pa/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"PA\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: PA Metric: f1 Results for PassiveAggressive: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9655 Time elapsed: 4.549s ------------------------------------------------- Total time: 4.549s Final results ==================== >> Total time: 4.550s ------------------------------------- PassiveAggressive --> f1: 0.9655", "title": "Example"}, {"location": "API/models/pa/#hyperparameters", "text": "classification regression Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) loss CategoricalDistribution(choices=('hinge', 'squared_hinge')) average CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) loss CategoricalDistribution(choices=('epsilon_insensitive', 'squared_epsilon_insensitive')) average CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/pa/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/pa/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/pa/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/pa/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/pa/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/perc/", "text": "Perceptron Perc needs scaling allows validation The Perceptron is a simple classification algorithm suitable for large scale learning. By default: It does not require a learning rate. It is not regularized (penalized). It updates its model only on mistakes. The last characteristic implies that the Perceptron is slightly faster to train than StochasticGradientDescent with the hinge loss and that the resulting models are sparser. Corresponding estimators are: Perceptron for classification tasks. Read more in sklearn's documentation . See Also MultiLayerPerceptron Multi-layer Perceptron. PassiveAggressive Passive Aggressive. StochasticGradientDescent Stochastic Gradient Descent. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Perc\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Perc Metric: f1 Results for Perceptron: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9787 Time elapsed: 4.109s ------------------------------------------------- Total time: 4.109s Final results ==================== >> Total time: 4.110s ------------------------------------- Perceptron --> f1: 0.9787 Hyperparameters Parameters penalty CategoricalDistribution(choices=(None, 'l2', 'l1', 'elasticnet')) alpha FloatDistribution(high=10.0, log=True, low=0.0001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=1500, log=False, low=500, step=50) eta0 FloatDistribution(high=10.0, log=True, low=0.01, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Perceptron"}, {"location": "API/models/perc/#perceptron", "text": "Perc needs scaling allows validation The Perceptron is a simple classification algorithm suitable for large scale learning. By default: It does not require a learning rate. It is not regularized (penalized). It updates its model only on mistakes. The last characteristic implies that the Perceptron is slightly faster to train than StochasticGradientDescent with the hinge loss and that the resulting models are sparser. Corresponding estimators are: Perceptron for classification tasks. Read more in sklearn's documentation . See Also MultiLayerPerceptron Multi-layer Perceptron. PassiveAggressive Passive Aggressive. StochasticGradientDescent Stochastic Gradient Descent.", "title": "Perceptron"}, {"location": "API/models/perc/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Perc\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Perc Metric: f1 Results for Perceptron: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9787 Time elapsed: 4.109s ------------------------------------------------- Total time: 4.109s Final results ==================== >> Total time: 4.110s ------------------------------------- Perceptron --> f1: 0.9787", "title": "Example"}, {"location": "API/models/perc/#hyperparameters", "text": "Parameters penalty CategoricalDistribution(choices=(None, 'l2', 'l1', 'elasticnet')) alpha FloatDistribution(high=10.0, log=True, low=0.0001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=1500, log=False, low=500, step=50) eta0 FloatDistribution(high=10.0, log=True, low=0.01, step=None)", "title": "Hyperparameters"}, {"location": "API/models/perc/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/perc/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/perc/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/perc/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/perc/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/qda/", "text": "QuadraticDiscriminantAnalysis QDA Quadratic Discriminant Analysis is a classifier with a quadratic decision boundary, generated by fitting class conditional densities to the data and using Bayes\u2019 rule. The model fits a Gaussian density to each class, assuming that all classes share the same covariance matrix. Corresponding estimators are: QuadraticDiscriminantAnalysis for classification tasks. Read more in sklearn's documentation . See Also LinearDiscriminantAnalysis Linear Discriminant Analysis. LogisticRegression Logistic Regression. RadiusNearestNeighbors Radius Nearest Neighbors. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"QDA\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: QDA Metric: f1 Results for QuadraticDiscriminantAnalysis: Fit --------------------------------------------- Train evaluation --> f1: 0.9758 Test evaluation --> f1: 0.9718 Time elapsed: 0.019s ------------------------------------------------- Total time: 0.019s Final results ==================== >> Total time: 0.020s ------------------------------------- QuadraticDiscriminantAnalysis --> f1: 0.9718 Hyperparameters Parameters reg_param FloatDistribution(high=1.0, log=False, low=0.0, step=0.1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "QuadraticDiscriminantAnalysis"}, {"location": "API/models/qda/#quadraticdiscriminantanalysis", "text": "QDA Quadratic Discriminant Analysis is a classifier with a quadratic decision boundary, generated by fitting class conditional densities to the data and using Bayes\u2019 rule. The model fits a Gaussian density to each class, assuming that all classes share the same covariance matrix. Corresponding estimators are: QuadraticDiscriminantAnalysis for classification tasks. Read more in sklearn's documentation . See Also LinearDiscriminantAnalysis Linear Discriminant Analysis. LogisticRegression Logistic Regression. RadiusNearestNeighbors Radius Nearest Neighbors.", "title": "QuadraticDiscriminantAnalysis"}, {"location": "API/models/qda/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"QDA\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: QDA Metric: f1 Results for QuadraticDiscriminantAnalysis: Fit --------------------------------------------- Train evaluation --> f1: 0.9758 Test evaluation --> f1: 0.9718 Time elapsed: 0.019s ------------------------------------------------- Total time: 0.019s Final results ==================== >> Total time: 0.020s ------------------------------------- QuadraticDiscriminantAnalysis --> f1: 0.9718", "title": "Example"}, {"location": "API/models/qda/#hyperparameters", "text": "Parameters reg_param FloatDistribution(high=1.0, log=False, low=0.0, step=0.1)", "title": "Hyperparameters"}, {"location": "API/models/qda/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/qda/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/qda/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/qda/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/qda/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/rf/", "text": "RandomForest RF accept sparse supports acceleration Random forests are an ensemble learning method that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random forests correct for decision trees' habit of overfitting to their training set. Corresponding estimators are: RandomForestClassifier for classification tasks. RandomForestRegressor for regression tasks. Read more in sklearn's documentation . Warning cuML's implementation of RandomForestClassifier only supports predictions on dtype float32 . Convert all dtypes before calling atom's run method to avoid exceptions. See Also DecisionTree Single Decision Tree. ExtraTrees Extremely Randomized Trees. HistGradientBoosting Histogram-based Gradient Boosting Machine. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"RF\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: RF Metric: f1 Results for Random Forest: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9722 Time elapsed: 2.815s ------------------------------------------------- Total time: 2.815s Final results ==================== >> Total time: 2.968s ------------------------------------- Random Forest --> f1: 0.9722 Hyperparameters classification regression sklearn sklearnex cuml Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('gini', 'entropy')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) cpu gpu Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) split_criterion CategoricalDistribution(choices=('gini', 'entropy')) max_depth IntDistribution(high=17, log=False, low=1, step=1) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=('sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples FloatDistribution(high=0.9, log=False, low=0.5, step=0.1) sklearn sklearnex cuml Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) cpu gpu Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) split_criterion CategoricalDistribution(choices=('mse', 'poisson', 'gamma', 'inverse_gaussian')) max_depth IntDistribution(high=17, log=False, low=1, step=1) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=('sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples FloatDistribution(high=0.9, log=False, low=0.5, step=0.1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "RandomForest"}, {"location": "API/models/rf/#randomforest", "text": "RF accept sparse supports acceleration Random forests are an ensemble learning method that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random forests correct for decision trees' habit of overfitting to their training set. Corresponding estimators are: RandomForestClassifier for classification tasks. RandomForestRegressor for regression tasks. Read more in sklearn's documentation . Warning cuML's implementation of RandomForestClassifier only supports predictions on dtype float32 . Convert all dtypes before calling atom's run method to avoid exceptions. See Also DecisionTree Single Decision Tree. ExtraTrees Extremely Randomized Trees. HistGradientBoosting Histogram-based Gradient Boosting Machine.", "title": "RandomForest"}, {"location": "API/models/rf/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"RF\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: RF Metric: f1 Results for Random Forest: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9722 Time elapsed: 2.815s ------------------------------------------------- Total time: 2.815s Final results ==================== >> Total time: 2.968s ------------------------------------- Random Forest --> f1: 0.9722", "title": "Example"}, {"location": "API/models/rf/#hyperparameters", "text": "classification regression sklearn sklearnex cuml Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('gini', 'entropy')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) cpu gpu Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) split_criterion CategoricalDistribution(choices=('gini', 'entropy')) max_depth IntDistribution(high=17, log=False, low=1, step=1) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=('sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples FloatDistribution(high=0.9, log=False, low=0.5, step=0.1) sklearn sklearnex cuml Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) criterion CategoricalDistribution(choices=('squared_error', 'absolute_error', 'poisson')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) cpu gpu Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples CategoricalDistribution(choices=(None, 0.5, 0.6, 0.7, 0.8, 0.9)) Parameters n_estimators IntDistribution(high=500, log=False, low=10, step=10) split_criterion CategoricalDistribution(choices=('mse', 'poisson', 'gamma', 'inverse_gaussian')) max_depth IntDistribution(high=17, log=False, low=1, step=1) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=('sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) bootstrap CategoricalDistribution(choices=(True, False)) max_samples FloatDistribution(high=0.9, log=False, low=0.5, step=0.1)", "title": "Hyperparameters"}, {"location": "API/models/rf/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/rf/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/rf/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/rf/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/rf/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/ridge/", "text": "Ridge Ridge needs scaling accept sparse supports acceleration If classifier, it first converts the target values into {-1, 1} and then treats the problem as a regression task. Corresponding estimators are: RidgeClassifier for classification tasks. Ridge for regression tasks. Read more in sklearn's documentation . Warning Engines sklearnex and cuml are only available for regression tasks. See Also BayesianRidge Bayesian ridge regression. ElasticNet Linear Regression with elasticnet regularization. Lasso Linear Regression with lasso regularization. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Ridge\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Ridge Metric: r2 Results for Ridge: Fit --------------------------------------------- Train evaluation --> r2: 0.7331 Test evaluation --> r2: 0.7512 Time elapsed: 0.021s ------------------------------------------------- Total time: 0.021s Final results ==================== >> Total time: 0.021s ------------------------------------- Ridge --> r2: 0.7512 Hyperparameters classification regression sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('eig', 'svd', 'cd')) sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('eig', 'svd', 'cd')) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Ridge"}, {"location": "API/models/ridge/#ridge", "text": "Ridge needs scaling accept sparse supports acceleration If classifier, it first converts the target values into {-1, 1} and then treats the problem as a regression task. Corresponding estimators are: RidgeClassifier for classification tasks. Ridge for regression tasks. Read more in sklearn's documentation . Warning Engines sklearnex and cuml are only available for regression tasks. See Also BayesianRidge Bayesian ridge regression. ElasticNet Linear Regression with elasticnet regularization. Lasso Linear Regression with lasso regularization.", "title": "Ridge"}, {"location": "API/models/ridge/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import fetch_california_housing >>> X , y = fetch_california_housing ( return_X_y = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( models = \"Ridge\" , metric = \"r2\" , verbose = 2 ) Training ========================= >> Models: Ridge Metric: r2 Results for Ridge: Fit --------------------------------------------- Train evaluation --> r2: 0.7331 Test evaluation --> r2: 0.7512 Time elapsed: 0.021s ------------------------------------------------- Total time: 0.021s Final results ==================== >> Total time: 0.021s ------------------------------------- Ridge --> r2: 0.7512", "title": "Example"}, {"location": "API/models/ridge/#hyperparameters", "text": "classification regression sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('eig', 'svd', 'cd')) sklearn sklearnex cuml Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga')) cpu gpu Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) Parameters alpha FloatDistribution(high=10.0, log=True, low=0.001, step=None) solver CategoricalDistribution(choices=('eig', 'svd', 'cd'))", "title": "Hyperparameters"}, {"location": "API/models/ridge/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/ridge/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/ridge/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/ridge/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/ridge/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/rnn/", "text": "RadiusNearestNeighbors RNN needs scaling accept sparse Radius Nearest Neighbors implements the nearest neighbors vote, where the neighbors are selected from within a given radius. For regression, the target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set. Warning The radius parameter should be tuned to the data at hand or the model will perform poorly. If outliers are detected, the estimator raises an exception unless est_params={\"outlier_label\": \"most_frequent\"} is used. Corresponding estimators are: RadiusNeighborsClassifier for classification tasks. RadiusNeighborsRegressor for regression tasks. Read more in sklearn's documentation . See Also KNearestNeighbors K-Nearest Neighbors. LinearDiscriminantAnalysis Linear Discriminant Analysis. QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( ... models = \"RNN\" , ... metric = \"f1\" , ... est_params = { \"outlier_label\" : \"most_frequent\" }, ... verbose = 2 , ... ) Training ========================= >> Models: RNN Metric: f1 Results for RadiusNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.7717 Time elapsed: 0.032s ------------------------------------------------- Total time: 0.032s Final results ==================== >> Total time: 0.032s ------------------------------------- RadiusNearestNeighbors --> f1: 0.7717 ~ Hyperparameters classification regression Parameters radius FloatDistribution(high=100.0, log=False, low=0.01, step=None) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters radius FloatDistribution(high=100.0, log=False, low=0.01, step=None) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "RadiusNearestNeighbors"}, {"location": "API/models/rnn/#radiusnearestneighbors", "text": "RNN needs scaling accept sparse Radius Nearest Neighbors implements the nearest neighbors vote, where the neighbors are selected from within a given radius. For regression, the target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set. Warning The radius parameter should be tuned to the data at hand or the model will perform poorly. If outliers are detected, the estimator raises an exception unless est_params={\"outlier_label\": \"most_frequent\"} is used. Corresponding estimators are: RadiusNeighborsClassifier for classification tasks. RadiusNeighborsRegressor for regression tasks. Read more in sklearn's documentation . See Also KNearestNeighbors K-Nearest Neighbors. LinearDiscriminantAnalysis Linear Discriminant Analysis. QuadraticDiscriminantAnalysis Quadratic Discriminant Analysis.", "title": "RadiusNearestNeighbors"}, {"location": "API/models/rnn/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( ... models = \"RNN\" , ... metric = \"f1\" , ... est_params = { \"outlier_label\" : \"most_frequent\" }, ... verbose = 2 , ... ) Training ========================= >> Models: RNN Metric: f1 Results for RadiusNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.7717 Time elapsed: 0.032s ------------------------------------------------- Total time: 0.032s Final results ==================== >> Total time: 0.032s ------------------------------------- RadiusNearestNeighbors --> f1: 0.7717 ~", "title": "Example"}, {"location": "API/models/rnn/#hyperparameters", "text": "classification regression Parameters radius FloatDistribution(high=100.0, log=False, low=0.01, step=None) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1) Parameters radius FloatDistribution(high=100.0, log=False, low=0.01, step=None) weights CategoricalDistribution(choices=('uniform', 'distance')) algorithm CategoricalDistribution(choices=('auto', 'ball_tree', 'kd_tree', 'brute')) leaf_size IntDistribution(high=40, log=False, low=20, step=1) p IntDistribution(high=2, log=False, low=1, step=1)", "title": "Hyperparameters"}, {"location": "API/models/rnn/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/rnn/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/rnn/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/rnn/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/rnn/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/sgd/", "text": "StochasticGradientDescent SGD needs scaling accept sparse allows validation Stochastic Gradient Descent is a simple yet very efficient approach to fitting linear classifiers and regressors under convex loss functions. Even though SGD has been around in the machine learning community for a long time, it has received a considerable amount of attention just recently in the context of large-scale learning. Corresponding estimators are: SGDClassifier for classification tasks. SGDRegressor for regression tasks. Read more in sklearn's documentation . See Also MultiLayerPerceptron Multi-layer Perceptron. PassiveAggressive Passive Aggressive. SupportVectorMachine Support Vector Machine. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"SGD\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: SGD Metric: f1 Results for StochasticGradientDescent: Fit --------------------------------------------- Train evaluation --> f1: 0.993 Test evaluation --> f1: 0.9929 Time elapsed: 4.561s ------------------------------------------------- Total time: 4.561s Final results ==================== >> Total time: 4.562s ------------------------------------- StochasticGradientDescent --> f1: 0.9929 Hyperparameters classification regression Parameters loss CategoricalDistribution(choices=('hinge', 'log_loss', 'modified_huber', 'squared_hinge', 'perceptron', 'squared_error', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive')) penalty CategoricalDistribution(choices=('none', 'l1', 'l2', 'elasticnet')) alpha FloatDistribution(high=1.0, log=True, low=0.0001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=1500, log=False, low=500, step=50) epsilon FloatDistribution(high=1.0, log=True, low=0.0001, step=None) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'optimal', 'adaptive')) eta0 FloatDistribution(high=10.0, log=True, low=0.01, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) average CategoricalDistribution(choices=(True, False)) Parameters loss CategoricalDistribution(choices=('squared_error', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive')) penalty CategoricalDistribution(choices=('none', 'l1', 'l2', 'elasticnet')) alpha FloatDistribution(high=1.0, log=True, low=0.0001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=1500, log=False, low=500, step=50) epsilon FloatDistribution(high=1.0, log=True, low=0.0001, step=None) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'optimal', 'adaptive')) eta0 FloatDistribution(high=10.0, log=True, low=0.01, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) average CategoricalDistribution(choices=(True, False)) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "StochasticGradientDescent"}, {"location": "API/models/sgd/#stochasticgradientdescent", "text": "SGD needs scaling accept sparse allows validation Stochastic Gradient Descent is a simple yet very efficient approach to fitting linear classifiers and regressors under convex loss functions. Even though SGD has been around in the machine learning community for a long time, it has received a considerable amount of attention just recently in the context of large-scale learning. Corresponding estimators are: SGDClassifier for classification tasks. SGDRegressor for regression tasks. Read more in sklearn's documentation . See Also MultiLayerPerceptron Multi-layer Perceptron. PassiveAggressive Passive Aggressive. SupportVectorMachine Support Vector Machine.", "title": "StochasticGradientDescent"}, {"location": "API/models/sgd/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"SGD\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: SGD Metric: f1 Results for StochasticGradientDescent: Fit --------------------------------------------- Train evaluation --> f1: 0.993 Test evaluation --> f1: 0.9929 Time elapsed: 4.561s ------------------------------------------------- Total time: 4.561s Final results ==================== >> Total time: 4.562s ------------------------------------- StochasticGradientDescent --> f1: 0.9929", "title": "Example"}, {"location": "API/models/sgd/#hyperparameters", "text": "classification regression Parameters loss CategoricalDistribution(choices=('hinge', 'log_loss', 'modified_huber', 'squared_hinge', 'perceptron', 'squared_error', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive')) penalty CategoricalDistribution(choices=('none', 'l1', 'l2', 'elasticnet')) alpha FloatDistribution(high=1.0, log=True, low=0.0001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=1500, log=False, low=500, step=50) epsilon FloatDistribution(high=1.0, log=True, low=0.0001, step=None) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'optimal', 'adaptive')) eta0 FloatDistribution(high=10.0, log=True, low=0.01, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) average CategoricalDistribution(choices=(True, False)) Parameters loss CategoricalDistribution(choices=('squared_error', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive')) penalty CategoricalDistribution(choices=('none', 'l1', 'l2', 'elasticnet')) alpha FloatDistribution(high=1.0, log=True, low=0.0001, step=None) l1_ratio FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) max_iter IntDistribution(high=1500, log=False, low=500, step=50) epsilon FloatDistribution(high=1.0, log=True, low=0.0001, step=None) learning_rate CategoricalDistribution(choices=('constant', 'invscaling', 'optimal', 'adaptive')) eta0 FloatDistribution(high=10.0, log=True, low=0.01, step=None) power_t FloatDistribution(high=0.9, log=False, low=0.1, step=0.1) average CategoricalDistribution(choices=(True, False))", "title": "Hyperparameters"}, {"location": "API/models/sgd/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/sgd/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/sgd/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/sgd/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/sgd/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/svm/", "text": "SupportVectorMachine SVM needs scaling accept sparse supports acceleration The implementation of the Support Vector Machine is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples. For large datasets consider using a LinearSVM or a StochasticGradientDescent model instead. Corresponding estimators are: SVC for classification tasks. SVR for classification tasks. Read more in sklearn's documentation . See Also LinearSVM Linear Support Vector Machine. MultiLayerPerceptron Multi-layer Perceptron. StochasticGradientDescent Stochastic Gradient Descent. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"SVM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: SVM Metric: f1 Results for SupportVectorMachine: Fit --------------------------------------------- Train evaluation --> f1: 0.9896 Test evaluation --> f1: 0.9645 Time elapsed: 0.027s ------------------------------------------------- Total time: 0.027s Final results ==================== >> Total time: 0.027s ------------------------------------- SupportVectorMachine --> f1: 0.9645 Hyperparameters classification regression sklearn sklearnex cuml Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) cpu gpu Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) sklearn sklearnex cuml Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) cpu gpu Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "SupportVectorMachine"}, {"location": "API/models/svm/#supportvectormachine", "text": "SVM needs scaling accept sparse supports acceleration The implementation of the Support Vector Machine is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples. For large datasets consider using a LinearSVM or a StochasticGradientDescent model instead. Corresponding estimators are: SVC for classification tasks. SVR for classification tasks. Read more in sklearn's documentation . See Also LinearSVM Linear Support Vector Machine. MultiLayerPerceptron Multi-layer Perceptron. StochasticGradientDescent Stochastic Gradient Descent.", "title": "SupportVectorMachine"}, {"location": "API/models/svm/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"SVM\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: SVM Metric: f1 Results for SupportVectorMachine: Fit --------------------------------------------- Train evaluation --> f1: 0.9896 Test evaluation --> f1: 0.9645 Time elapsed: 0.027s ------------------------------------------------- Total time: 0.027s Final results ==================== >> Total time: 0.027s ------------------------------------- SupportVectorMachine --> f1: 0.9645", "title": "Example"}, {"location": "API/models/svm/#hyperparameters", "text": "classification regression sklearn sklearnex cuml Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) cpu gpu Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) sklearn sklearnex cuml Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) cpu gpu Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None) epsilon FloatDistribution(high=100.0, log=True, low=0.001, step=None) shrinking CategoricalDistribution(choices=(True, False)) Parameters C FloatDistribution(high=100.0, log=True, low=0.001, step=None) kernel CategoricalDistribution(choices=('linear', 'poly', 'rbf', 'sigmoid')) degree IntDistribution(high=5, log=False, low=2, step=1) gamma CategoricalDistribution(choices=('scale', 'auto')) coef0 FloatDistribution(high=1.0, log=False, low=-1.0, step=None)", "title": "Hyperparameters"}, {"location": "API/models/svm/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/svm/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/svm/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/svm/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes decision_function_train: pd.Series or pd.DataFrame Confidence scores on the training set. decision_function_test: pd.Series or pd.DataFrame Confidence scores on the test set. decision_function_holdout: pd.Series, pd.DataFrame or None Confidence scores on the holdout set. predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/svm/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/tree/", "text": "DecisionTree Tree accept sparse A single decision tree classifier/regressor. Corresponding estimators are: DecisionTreeClassifier for classification tasks. DecisionTreeRegressor for regression tasks. Read more in sklearn's documentation . See Also ExtraTree Extremely Randomized Tree. ExtraTrees Extremely Randomized Trees. RandomForest Random Forest. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Tree\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Tree Metric: f1 Results for DecisionTree: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9275 Time elapsed: 0.014s ------------------------------------------------- Total time: 0.014s Final results ==================== >> Total time: 0.014s ------------------------------------- DecisionTree --> f1: 0.9275 Hyperparameters classification regression Parameters criterion CategoricalDistribution(choices=('gini', 'entropy')) splitter CategoricalDistribution(choices=('best', 'random')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters criterion CategoricalDistribution(choices=('squared_error', 'absolute_error', 'friedman_mse', 'poisson')) splitter CategoricalDistribution(choices=('best', 'random')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "DecisionTree"}, {"location": "API/models/tree/#decisiontree", "text": "Tree accept sparse A single decision tree classifier/regressor. Corresponding estimators are: DecisionTreeClassifier for classification tasks. DecisionTreeRegressor for regression tasks. Read more in sklearn's documentation . See Also ExtraTree Extremely Randomized Tree. ExtraTrees Extremely Randomized Trees. RandomForest Random Forest.", "title": "DecisionTree"}, {"location": "API/models/tree/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"Tree\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: Tree Metric: f1 Results for DecisionTree: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9275 Time elapsed: 0.014s ------------------------------------------------- Total time: 0.014s Final results ==================== >> Total time: 0.014s ------------------------------------- DecisionTree --> f1: 0.9275", "title": "Example"}, {"location": "API/models/tree/#hyperparameters", "text": "classification regression Parameters criterion CategoricalDistribution(choices=('gini', 'entropy')) splitter CategoricalDistribution(choices=('best', 'random')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005) Parameters criterion CategoricalDistribution(choices=('squared_error', 'absolute_error', 'friedman_mse', 'poisson')) splitter CategoricalDistribution(choices=('best', 'random')) max_depth CategoricalDistribution(choices=(None, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) min_samples_split IntDistribution(high=20, log=False, low=2, step=1) min_samples_leaf IntDistribution(high=20, log=False, low=1, step=1) max_features CategoricalDistribution(choices=(None, 'sqrt', 'log2', 0.5, 0.6, 0.7, 0.8, 0.9)) ccp_alpha FloatDistribution(high=0.035, log=False, low=0.0, step=0.005)", "title": "Hyperparameters"}, {"location": "API/models/tree/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/tree/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/tree/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/tree/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/tree/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/models/xgb/", "text": "XGBoost XGB needs scaling accept sparse allows validation supports acceleration XGBoost is an optimized distributed gradient boosting model designed to be highly efficient, flexible and portable. XGBoost provides a parallel tree boosting that solve many data science problems in a fast and accurate way. Corresponding estimators are: XGBClassifier for classification tasks. XGBRegressor for regression tasks. Read more in XGBoost's documentation . See Also CatBoost Categorical Boosting Machine. GradientBoosting Gradient Boosting Machine. LightGBM Light Gradient Boosting Machine. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"XGB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: XGB Metric: f1 Results for XGBoost: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9726 Time elapsed: 0.359s ------------------------------------------------- Total time: 0.359s Final results ==================== >> Total time: 0.359s ------------------------------------- XGBoost --> f1: 0.9726 Hyperparameters classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=20, log=False, low=1, step=1) gamma FloatDistribution(high=1.0, log=False, low=0.0, step=None) min_child_weight IntDistribution(high=10, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None) Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=20, log=False, low=1, step=1) gamma FloatDistribution(high=1.0, log=False, low=0.0, step=None) min_child_weight IntDistribution(high=10, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None) Attributes Data attributes Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run. Prediction attributes The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set. Methods The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "XGBoost"}, {"location": "API/models/xgb/#xgboost", "text": "XGB needs scaling accept sparse allows validation supports acceleration XGBoost is an optimized distributed gradient boosting model designed to be highly efficient, flexible and portable. XGBoost provides a parallel tree boosting that solve many data science problems in a fast and accurate way. Corresponding estimators are: XGBClassifier for classification tasks. XGBRegressor for regression tasks. Read more in XGBoost's documentation . See Also CatBoost Categorical Boosting Machine. GradientBoosting Gradient Boosting Machine. LightGBM Light Gradient Boosting Machine.", "title": "XGBoost"}, {"location": "API/models/xgb/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( models = \"XGB\" , metric = \"f1\" , verbose = 2 ) Training ========================= >> Models: XGB Metric: f1 Results for XGBoost: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.9726 Time elapsed: 0.359s ------------------------------------------------- Total time: 0.359s Final results ==================== >> Total time: 0.359s ------------------------------------- XGBoost --> f1: 0.9726", "title": "Example"}, {"location": "API/models/xgb/#hyperparameters", "text": "classification regression Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=20, log=False, low=1, step=1) gamma FloatDistribution(high=1.0, log=False, low=0.0, step=None) min_child_weight IntDistribution(high=10, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None) Parameters n_estimators IntDistribution(high=500, log=False, low=20, step=10) learning_rate FloatDistribution(high=1.0, log=True, low=0.01, step=None) max_depth IntDistribution(high=20, log=False, low=1, step=1) gamma FloatDistribution(high=1.0, log=False, low=0.0, step=None) min_child_weight IntDistribution(high=10, log=False, low=1, step=1) subsample FloatDistribution(high=1.0, log=False, low=0.5, step=0.1) colsample_bytree FloatDistribution(high=1.0, log=False, low=0.4, step=0.1) reg_alpha FloatDistribution(high=100.0, log=True, low=0.0001, step=None) reg_lambda FloatDistribution(high=100.0, log=True, low=0.0001, step=None)", "title": "Hyperparameters"}, {"location": "API/models/xgb/#attributes", "text": "", "title": "Attributes"}, {"location": "API/models/xgb/#data-attributes", "text": "Attributes pipeline: (self) Transformers fitted on the data. Models that used automated feature scaling have the scaler added. Use this attribute only to access the individual instances. To visualize the pipeline, use the plot_pipeline method. mapping: dict Encoded values and their respective mapped values. The column name is the key to its mapping dictionary. Only for columns mapped to a single column (e.g. Ordinal, Leave-one-out, etc...). dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/models/xgb/#utility-attributes", "text": "Attributes name: str Name of the model. Use the property's @setter to change the model's name. The acronym always stays at the beginning of the model's name. If the model is being tracked by mlflow , the name of the corresponding run also changes. study: Study or None Optuna study used for hyperparameter tuning . trials: pd.DataFrame or None Overview of the trials' results. All durations are in seconds. Columns include: params: Parameters used for this trial. estimator: Estimator used for this trial. score: Objective score(s) of the trial. time_trial: Duration of the trial. time_ht: Duration of the hyperparameter tuning. state: Trial's state (COMPLETE, PRUNED, FAIL). best_trial: Trial or None Trial that returned the highest score. For multi-metric runs , the best trial is the trial that performed best on the main metric. Use the property's @setter to change the best trial. See here an example. best_params: dict Hyperparameters used by the best trial . score_ht: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Metric score obtained by the best trial . time_ht: int or None Duration of the hyperparameter tuning (in seconds). estimator: Predictor Estimator fitted on the training set. evals: dict Scores obtained per iteration of the training. Only the scores of the main metric are tracked. Included keys are: train and test. Read more in the user guide . score_train: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the training set. score_test: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the test set. score_holdout: Union[float, numpy.floating, List[Union[float, numpy.floating]]] Metric score on the holdout set. time_fit: int Duration of the model fitting on the train set (in seconds). bootstrap: pd.DataFrame or None Overview of the bootstrapping scores. The dataframe has shape=(n_bootstrap, metric) and shows the score obtained by every bootstrapped sample for every metric. Using atom.bootstrap.mean() yields the same values as score_bootstrap . score_bootstrap: Union[float, numpy.floating, List[Union[float, numpy.floating]], NoneType] Mean metric score on the bootstrapped samples. time_bootstrap: int or None Duration of the bootstrapping (in seconds). time: int Total duration of the run (in seconds). feature_importance: pd.Series or None Normalized feature importance scores. The sum of importances for all features is 1. The scores are extracted from the estimator's scores_ , coef_ or feature_importances_ attribute, checked in that order. Returns None for estimators without any of those attributes. results: pd.Series Overview of the training results. All durations are in seconds. Values include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the run.", "title": "Utility attributes"}, {"location": "API/models/xgb/#prediction-attributes", "text": "The prediction attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to calculate attributes that are never used, saving time and memory. Attributes predict_train: pd.Series Class predictions on the training set. predict_test: pd.Series Class predictions on the test set. predict_holdout: pd.Series or None Class predictions on the holdout set. predict_log_proba_train: pd.DataFrame Class log-probabilities predictions on the training set. predict_log_proba_test: pd.DataFrame Class log-probabilities predictions on the test set. predict_log_proba_holdout: pd.DataFrame or None Class log-probabilities predictions on the holdout set. predict_proba_train: pd.DataFrame Class probabilities predictions on the training set. predict_proba_test: pd.DataFrame Class probabilities predictions on the test set. predict_proba_holdout: pd.DataFrame or None Class probabilities predictions on the holdout set.", "title": "Prediction attributes"}, {"location": "API/models/xgb/#methods", "text": "The plots and prediction methods can be called directly from the model. The remaining utility methods can be found hereunder. bootstrapping Apply a bootstrap algorithm. calibrate Calibrate the model. clear Clear attributes from the model. create_app Create an interactive app to test model predictions. create_dashboard Create an interactive dashboard to analyze the model. cross_validate Evaluate the model using cross-validation. delete Delete the model. evaluate Get the model's scores for the provided metrics. export_pipeline Export the model's pipeline to a sklearn-like object. fit Fit and validate the model. full_train Train the estimator on the complete dataset. hyperparameter_tuning Run the hyperparameter tuning algorithm. inverse_transform Inversely transform new data through the pipeline. save_estimator Save the estimator to a pickle file. transform Transform new data through the pipeline. method bootstrapping (n_bootstrap, reset=False) [source] Apply a bootstrap algorithm. Take bootstrapped samples from the training set and test them on the test set to get a distribution of the model's results. Parameters n_bootstrap: int umber of bootstrapped samples to fit on. reset: bool, default=False Whether to start a new run or continue the existing one. method calibrate (**kwargs) [source] Calibrate the model. Applies probability calibration on the model. The estimator is trained via cross-validation on a subset of the training data, using the rest to fit the calibrator. The new classifier will replace the estimator attribute. If there is an active mlflow experiment, a new run is started using the name [model_name]_calibrate . Since the estimator changed, the model is cleared. Only for classifiers. Parameters **kwargs Additional keyword arguments for sklearn's CCV. Using cv=\"prefit\" will use the trained model and fit the calibrator on the test set. Use this only if you have another, independent set for testing. method clear () [source] Clear attributes from the model. Reset the model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes are: In-training validation scores. Metric scores Prediction attributes Shap values App instance Dashboard instance method create_app (**kwargs) [source] Create an interactive app to test model predictions. Demo your machine learning model with a friendly web interface. This app launches directly in the notebook or on an external browser page. The created Interface instance can be accessed through the app attribute. Parameters **kwargs Additional keyword arguments for the Interface instance or the Interface.launch method. method create_dashboard (dataset=\"test\", filename=None, **kwargs) [source] Create an interactive dashboard to analyze the model. ATOM uses the explainerdashboard package to provide a quick and easy way to analyze and explain the predictions and workings of the model. The dashboard allows you to investigate SHAP values, permutation importances, interaction effects, partial dependence plots, all kinds of performance plots, and even individual decision trees. By default, the dashboard renders in a new tab in your default browser, but if preferable, you can render it inside the notebook using the mode=\"inline\" parameter. The created ExplainerDashboard instance can be accessed through the dashboard attribute. Note Plots displayed by the dashboard are not created by ATOM and can differ from those retrieved through this package. Parameters dataset: str, default=\"test\" Data set to get the report from. Choose from: \"train\", \"test\", \"both\" (train and test) or \"holdout\". filename: str or None, default=None Name to save the file with (as .html). None to not save anything. **kwargs Additional keyword arguments for the ExplainerDashboard instance. method cross_validate (**kwargs) [source] Evaluate the model using cross-validation. This method cross-validates the whole pipeline on the complete dataset. Use it to assess the robustness of the solution's performance. Parameters **kwargs Additional keyword arguments for sklearn's cross_validate function. If the scoring method is not specified, it uses atom's metric. Returns pd.DataFrame Overview of the results. method delete () [source] Delete the model. If it's the last model in atom, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving. The model is not removed from any active mlflow experiment. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get the model's scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metrics to calculate. If None, a selection of the most common metrics per task are used. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.Series Scores of the model. method export_pipeline (memory=None, verbose=None) [source] Export the model's pipeline to a sklearn-like object. The returned pipeline is already fitted on the training set. Note that, if the model used automated feature scaling , the Scaler is added to the pipeline. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Current branch as a sklearn-like Pipeline object. method fit (X=None, y=None) [source] Fit and validate the model. The estimator is fitted using the best hyperparameters found during hyperparameter tuning. Afterwards, the estimator is evaluated on the test set. Only use this method to re-fit the model after having continued the study. Parameters X: pd.DataFrame or None Feature set with shape=(n_samples, n_features). If None, self.X_train is used. y: pd.Series or None Target column corresponding to X. If None, self.y_train is used. method full_train (include_holdout=False) [source] Train the estimator on the complete dataset. In some cases it might be desirable to use all available data to train a final model. Note that doing this means that the estimator can no longer be evaluated on the test set. The newly retrained estimator will replace the estimator attribute. If there is an active mlflow experiment, a new run is started with the name [model_name]_full_train . Since the estimator changed, the model is cleared. Warning Although the model is trained on the complete dataset, the pipeline is not. To get a fully trained pipeline, use: pipeline = atom.export_pipeline().fit(atom.X, atom.y) . Parameters include_holdout: bool, default=False Whether to include the holdout set (if available) in the training of the estimator. It's discouraged to use this option since it means the model can no longer be evaluated on any set. method hyperparameter_tuning (n_trials, reset=False) [source] Run the hyperparameter tuning algorithm. Search for the best combination of hyperparameters. The function to optimize is evaluated either with a K-fold cross-validation on the training set or using a random train and validation split every trial. Use this method to continue the optimization. Parameters n_trials: int Number of trials for the hyperparameter tuning. reset: bool, default=False Whether to start a new study or continue the existing one. method inverse_transform (X=None, y=None, verbose=None) [source] Inversely transform new data through the pipeline. Transformers that are only applied on the training set are skipped. The rest should all implement a inverse_transform method. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, inversely transform only the target column. If called from a model that used automated feature scaling, the scaling is inversed as well. Parameters X: dataframe-like or None, default=None Transformed feature set with shape=(n_samples, n_features). If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Original feature set. Only returned if provided. y: pd.Series Original target column. Only returned if provided. method save_estimator (filename=\"auto\") [source] Save the estimator to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. method transform (X=None, y=None, verbose=None) [source] Transform new data through the pipeline. Transformers that are only applied on the training set are skipped. If only X or only y is provided, it ignores transformers that require the other parameter. This can be of use to, for example, transform only the target column. If called from a model that used automated feature scaling, the data is scaled as well. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. If None, X is ignored in the transformers. y: int, str, dict, sequence or None, default=None If None: y is ignored in the transformers. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. verbose: int or None, default=None Verbosity level for the transformers. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Transformed feature set. Only returned if provided. y: pd.Series Transformed target column. Only returned if provided.", "title": "Methods"}, {"location": "API/nlp/textcleaner/", "text": "TextCleaner class atom.nlp. TextCleaner (decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, verbose=0, logger=None) [source] Applies standard text cleaning to the corpus. Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. This class can be accessed from atom through the textclean method. Read more in the user guide . Parameters decode: bool, default=True Whether to decode unicode characters to their ascii representations. lower_case: bool, default=True Whether to convert all characters to lower case. drop_email: bool, default=True Whether to drop email addresses from the text. regex_email: str, default=None Regex used to search for email addresses. If None, it uses r\"[\\w.-]+@[\\w-]+\\.[\\w.-]+\" . drop_url: bool, default=True Whether to drop URL links from the text. regex_url: str, default=None Regex used to search for URLs. If None, it uses r\"https?://\\S+|www\\.\\S+\" . drop_html: bool, default=True Whether to drop HTML tags from the text. This option is particularly useful if the data was scraped from a website. regex_html: str, default=None Regex used to search for html tags. If None, it uses r\"<.*?>\" . drop_emoji: bool, default=True Whether to drop emojis from the text. regex_emoji: str, default=None Regex used to search for emojis. If None, it uses r\":[a-z_]+:\" . drop_number: bool, default=True Whether to drop numbers from the text. regex_number: str, default=None Regex used to search for numbers. If None, it uses r\"\b\\d+\b\". Note that numbers adjacent to letters are not removed. drop_punctuation: bool, default=True Whether to drop punctuations from the text. Characters considered punctuation are !\"#$%&'()*+,-./:;<=>?@[\\]^_ ~`. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes drops: pd.DataFrame Encountered regex matches. The row indices correspond to the document index from which the occurrence was dropped. See Also TextNormalizer Normalize the corpus. Tokenizer Tokenize the corpus. Vectorizer Vectorize text data. Example atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) 0 From: thssjxy@iitmax.iit.edu (Smile) Subject:... 2 1 From: nancyo@fraser.sfu.ca (Nancy Patricia O'C... 0 2 From: beck@irzr17.inf.tu-dresden.de (Andre Bec... 1 3 From: keith@cco.caltech.edu (Keith Allan Schne... 0 4 From: strom@Watson.Ibm.Com (Rob Strom) Subjec... 0 ... ... 2841 From: dreitman@oregon.uoregon.edu (Daniel R. R... 3 2842 From: ethan@cs.columbia.edu (Ethan Solomita) ... 1 2843 From: r0506048@cml3 (Chun-Hung Lin) Subject: ... 1 2844 From: eshneken@ux4.cso.uiuc.edu (Edward A Shne... 2 2845 From: ibeshir@nyx.cs.du.edu (Ibrahim) Subject... 2 [2846 rows x 2 columns] >>> atom . textclean ( verbose = 2 ) Fitting TextCleaner... Cleaning the corpus... --> Decoding unicode characters to ascii. --> Converting text to lower case. --> Dropping 10012 emails from 2830 documents. --> Dropping 0 URL links from 0 documents. --> Dropping 2214 HTML tags from 1304 documents. --> Dropping 2 emojis from 1 documents. --> Dropping 31222 numbers from 2843 documents. --> Dropping punctuation from the text. >>> print ( atom . dataset ) corpus target 0 from smile subject forsale used guitar amp... 2 1 from nancy patricia oconnor subject re amusi... 0 2 from andre beck subject re animation with xp... 1 3 from keith allan schneider subject re moralt... 0 4 from rob strom subject re socmotss et al pri... 0 ... ... 2841 from daniel r reitman attorney to be subject... 3 2842 from ethan solomita subject forcing a window... 1 2843 from r0506048cml3 chunhung lin subject re xma... 1 2844 from edward a shnekendorf subject airline ti... 2 2845 from ibrahim subject terminal for sale orga... 2 [2846 rows x 2 columns] >>> from atom.nlp import TextCleaner >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> textcleaner = TextCleaner ( verbose = 2 ) >>> X = textcleaner . transform ( X ) Cleaning the corpus... --> Decoding unicode characters to ascii. --> Converting text to lower case. --> Dropping 10012 emails from 2830 documents. --> Dropping 0 URL links from 0 documents. --> Dropping 2214 HTML tags from 1304 documents. --> Dropping 2 emojis from 1 documents. --> Dropping 31222 numbers from 2843 documents. --> Dropping punctuation from the text. >>> print ( X ) corpus 0 from donald mackie subject re barbecued food... 1 from david stockton subject re krillean phot... 2 from julia miller subject posix message cata... 3 from subject re yet more rushdie re islamic... 4 from joseph a muller subject jfk autograph f... ... 2841 from joel reymont subject motif maling list\\... 2842 from daniel paul checkman subject re is msg ... 2843 from ad absurdum per aspera subject re its a... 2844 from ralf subject items for sale organizati... 2845 from walter g seefeld subject klipsch kg1 sp... [2846 rows x 1 columns] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the transformations to the data. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Apply the transformations to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "TextCleaner"}, {"location": "API/nlp/textcleaner/#textcleaner", "text": "class atom.nlp. TextCleaner (decode=True, lower_case=True, drop_email=True, regex_email=None, drop_url=True, regex_url=None, drop_html=True, regex_html=None, drop_emoji=True, regex_emoji=None, drop_number=True, regex_number=None, drop_punctuation=True, verbose=0, logger=None) [source] Applies standard text cleaning to the corpus. Transformations include normalizing characters and dropping noise from the text (emails, HTML tags, URLs, etc...). The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. This class can be accessed from atom through the textclean method. Read more in the user guide . Parameters decode: bool, default=True Whether to decode unicode characters to their ascii representations. lower_case: bool, default=True Whether to convert all characters to lower case. drop_email: bool, default=True Whether to drop email addresses from the text. regex_email: str, default=None Regex used to search for email addresses. If None, it uses r\"[\\w.-]+@[\\w-]+\\.[\\w.-]+\" . drop_url: bool, default=True Whether to drop URL links from the text. regex_url: str, default=None Regex used to search for URLs. If None, it uses r\"https?://\\S+|www\\.\\S+\" . drop_html: bool, default=True Whether to drop HTML tags from the text. This option is particularly useful if the data was scraped from a website. regex_html: str, default=None Regex used to search for html tags. If None, it uses r\"<.*?>\" . drop_emoji: bool, default=True Whether to drop emojis from the text. regex_emoji: str, default=None Regex used to search for emojis. If None, it uses r\":[a-z_]+:\" . drop_number: bool, default=True Whether to drop numbers from the text. regex_number: str, default=None Regex used to search for numbers. If None, it uses r\"\b\\d+\b\". Note that numbers adjacent to letters are not removed. drop_punctuation: bool, default=True Whether to drop punctuations from the text. Characters considered punctuation are !\"#$%&'()*+,-./:;<=>?@[\\]^_ ~`. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes drops: pd.DataFrame Encountered regex matches. The row indices correspond to the document index from which the occurrence was dropped. See Also TextNormalizer Normalize the corpus. Tokenizer Tokenize the corpus. Vectorizer Vectorize text data.", "title": "TextCleaner"}, {"location": "API/nlp/textcleaner/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) 0 From: thssjxy@iitmax.iit.edu (Smile) Subject:... 2 1 From: nancyo@fraser.sfu.ca (Nancy Patricia O'C... 0 2 From: beck@irzr17.inf.tu-dresden.de (Andre Bec... 1 3 From: keith@cco.caltech.edu (Keith Allan Schne... 0 4 From: strom@Watson.Ibm.Com (Rob Strom) Subjec... 0 ... ... 2841 From: dreitman@oregon.uoregon.edu (Daniel R. R... 3 2842 From: ethan@cs.columbia.edu (Ethan Solomita) ... 1 2843 From: r0506048@cml3 (Chun-Hung Lin) Subject: ... 1 2844 From: eshneken@ux4.cso.uiuc.edu (Edward A Shne... 2 2845 From: ibeshir@nyx.cs.du.edu (Ibrahim) Subject... 2 [2846 rows x 2 columns] >>> atom . textclean ( verbose = 2 ) Fitting TextCleaner... Cleaning the corpus... --> Decoding unicode characters to ascii. --> Converting text to lower case. --> Dropping 10012 emails from 2830 documents. --> Dropping 0 URL links from 0 documents. --> Dropping 2214 HTML tags from 1304 documents. --> Dropping 2 emojis from 1 documents. --> Dropping 31222 numbers from 2843 documents. --> Dropping punctuation from the text. >>> print ( atom . dataset ) corpus target 0 from smile subject forsale used guitar amp... 2 1 from nancy patricia oconnor subject re amusi... 0 2 from andre beck subject re animation with xp... 1 3 from keith allan schneider subject re moralt... 0 4 from rob strom subject re socmotss et al pri... 0 ... ... 2841 from daniel r reitman attorney to be subject... 3 2842 from ethan solomita subject forcing a window... 1 2843 from r0506048cml3 chunhung lin subject re xma... 1 2844 from edward a shnekendorf subject airline ti... 2 2845 from ibrahim subject terminal for sale orga... 2 [2846 rows x 2 columns] >>> from atom.nlp import TextCleaner >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> textcleaner = TextCleaner ( verbose = 2 ) >>> X = textcleaner . transform ( X ) Cleaning the corpus... --> Decoding unicode characters to ascii. --> Converting text to lower case. --> Dropping 10012 emails from 2830 documents. --> Dropping 0 URL links from 0 documents. --> Dropping 2214 HTML tags from 1304 documents. --> Dropping 2 emojis from 1 documents. --> Dropping 31222 numbers from 2843 documents. --> Dropping punctuation from the text. >>> print ( X ) corpus 0 from donald mackie subject re barbecued food... 1 from david stockton subject re krillean phot... 2 from julia miller subject posix message cata... 3 from subject re yet more rushdie re islamic... 4 from joseph a muller subject jfk autograph f... ... 2841 from joel reymont subject motif maling list\\... 2842 from daniel paul checkman subject re is msg ... 2843 from ad absurdum per aspera subject re its a... 2844 from ralf subject items for sale organizati... 2845 from walter g seefeld subject klipsch kg1 sp... [2846 rows x 1 columns]", "title": "Example"}, {"location": "API/nlp/textcleaner/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Apply the transformations to the data. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Apply the transformations to the data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "Methods"}, {"location": "API/nlp/textnormalizer/", "text": "TextNormalizer class atom.nlp. TextNormalizer (stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, verbose=0, logger=None) [source] Normalize the corpus. Convert words to a more uniform standard. The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces. This class can be accessed from atom through the textnormalize method. Read more in the user guide . Parameters stopwords: bool or str, default=True Whether to remove a predefined dictionary of stopwords. If False: Don't remove any predefined stopwords. If True: Drop predefined english stopwords from the text. If str: Language from nltk.corpus.stopwords.words . custom_stopwords: sequence or None, default=None Custom stopwords to remove from the text. stem: bool or str, default=False Whether to apply stemming using SnowballStemmer . If False: Don't apply stemming. If True: Apply stemmer based on the english language. If str: Language from SnowballStemmer.languages . lemmatize: bool, default=True Whether to apply lemmatization using WordNetLemmatizer. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. See Also TextCleaner Applies standard text cleaning to the corpus. Tokenizer Tokenize the corpus. Vectorizer Vectorize text data. Example atom stand-alone >>> from atom import ATOMClassifier >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) corpus target 0 running the test 0 1 hi there this is a test! 1 2 this is a test 0 3 new york is larger than washington 1 4 New york is nice 0 5 I \u00e0m in ne'w york 1 6 another line... 1 7 new york 0 >>> atom . textnormalize ( stopwords = \"english\" , lemmatize = True , verbose = 2 ) Fitting TextNormalizer... Normalizing the corpus... --> Dropping stopwords. --> Applying lemmatization. >>> print ( atom . dataset ) corpus target 0 [run, test] 0 1 [hi, test!] 1 2 [test] 0 3 [new, york, large, washington] 1 4 [New, york, nice] 0 5 [I, \u00e0m, ne'w, york] 1 6 [another, line...] 1 7 [new, york] 0 >>> from atom.nlp import TextNormalizer >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> textnormalizer = TextNormalizer ( ... stopwords = \"english\" , ... lemmatize = True , ... verbose = 2 , ... ) >>> X = textnormalizer . transform ( X ) Fitting TextNormalizer... Normalizing the corpus... --> Dropping stopwords. --> Applying lemmatization. >>> print ( X ) corpus 0 [I, \u00e0m, ne'w, york] 1 [New, york, nice] 2 [new, york] 3 [hi, test!] 4 [another, line...] 5 [new, york, large, washington] 6 [run, test] 7 [test] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Normalize the text. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Normalize the text. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "TextNormalizer"}, {"location": "API/nlp/textnormalizer/#textnormalizer", "text": "class atom.nlp. TextNormalizer (stopwords=True, custom_stopwords=None, stem=False, lemmatize=True, verbose=0, logger=None) [source] Normalize the corpus. Convert words to a more uniform standard. The transformations are applied on the column named corpus , in the same order the parameters are presented. If there is no column with that name, an exception is raised. If the provided documents are strings, words are separated by spaces. This class can be accessed from atom through the textnormalize method. Read more in the user guide . Parameters stopwords: bool or str, default=True Whether to remove a predefined dictionary of stopwords. If False: Don't remove any predefined stopwords. If True: Drop predefined english stopwords from the text. If str: Language from nltk.corpus.stopwords.words . custom_stopwords: sequence or None, default=None Custom stopwords to remove from the text. stem: bool or str, default=False Whether to apply stemming using SnowballStemmer . If False: Don't apply stemming. If True: Apply stemmer based on the english language. If str: Language from SnowballStemmer.languages . lemmatize: bool, default=True Whether to apply lemmatization using WordNetLemmatizer. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. See Also TextCleaner Applies standard text cleaning to the corpus. Tokenizer Tokenize the corpus. Vectorizer Vectorize text data.", "title": "TextNormalizer"}, {"location": "API/nlp/textnormalizer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) corpus target 0 running the test 0 1 hi there this is a test! 1 2 this is a test 0 3 new york is larger than washington 1 4 New york is nice 0 5 I \u00e0m in ne'w york 1 6 another line... 1 7 new york 0 >>> atom . textnormalize ( stopwords = \"english\" , lemmatize = True , verbose = 2 ) Fitting TextNormalizer... Normalizing the corpus... --> Dropping stopwords. --> Applying lemmatization. >>> print ( atom . dataset ) corpus target 0 [run, test] 0 1 [hi, test!] 1 2 [test] 0 3 [new, york, large, washington] 1 4 [New, york, nice] 0 5 [I, \u00e0m, ne'w, york] 1 6 [another, line...] 1 7 [new, york] 0 >>> from atom.nlp import TextNormalizer >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> textnormalizer = TextNormalizer ( ... stopwords = \"english\" , ... lemmatize = True , ... verbose = 2 , ... ) >>> X = textnormalizer . transform ( X ) Fitting TextNormalizer... Normalizing the corpus... --> Dropping stopwords. --> Applying lemmatization. >>> print ( X ) corpus 0 [I, \u00e0m, ne'w, york] 1 [New, york, nice] 2 [new, york] 3 [hi, test!] 4 [another, line...] 5 [new, york, large, washington] 6 [run, test] 7 [test]", "title": "Example"}, {"location": "API/nlp/textnormalizer/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Normalize the text. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Normalize the text. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "Methods"}, {"location": "API/nlp/tokenizer/", "text": "Tokenizer class atom.nlp. Tokenizer (bigram_freq=None, trigram_freq=None, quadgram_freq=None, verbose=0, logger=None) [source] Tokenize the corpus. Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g. \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named corpus . If there is no column with that name, an exception is raised. This class can be accessed from atom through the tokenize method. Read more in the user guide . Parameters bigram_freq: int, float or None, default=None Frequency threshold for bigram creation. If None: Don't create any bigrams. If int: Minimum number of occurrences to make a bigram. If float: Minimum frequency fraction to make a bigram. trigram_freq: int, float or None, default=None Frequency threshold for trigram creation. If None: Don't create any trigrams. If int: Minimum number of occurrences to make a trigram. If float: Minimum frequency fraction to make a trigram. quadgram_freq: int, float or None, default=None Frequency threshold for quadgram creation. If None: Don't create any quadgrams. If int: Minimum number of occurrences to make a quadgram. If float: Minimum frequency fraction to make a quadgram. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes bigrams: pd.DataFrame Created bigrams and their frequencies. trigrams: pd.DataFrame Created trigrams and their frequencies. quadgrams: pd.DataFrame Created quadgrams and their frequencies. See Also TextCleaner Applies standard text cleaning to the corpus. TextNormalizer Normalize the corpus. Vectorizer Vectorize text data. Example atom stand-alone >>> from atom import ATOMClassifier >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) corpus target 0 new york 0 1 new york is larger than washington 1 2 New york is nice 0 3 I \u00e0m in ne'w york 1 4 this is a test 0 5 another line... 1 6 running the test 0 7 hi there this is a test! 1 >>> atom . tokenize ( verbose = 2 ) Fitting Tokenizer... Tokenizing the corpus... >>> print ( atom . dataset ) corpus target 0 [new, york] 0 1 [new, york, is, larger, than, washington] 1 2 [New, york, is, nice] 0 3 [I, \u00e0m, in, ne, ', w, york] 1 4 [this, is, a, test] 0 5 [another, line, ...] 1 6 [running, the, test] 0 7 [hi, there, this, is, a, test, !] 1 >>> from atom.nlp import Tokenizer >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> tokenizer = Tokenizer ( bigram_freq = 2 , verbose = 2 ) >>> X = tokenizer . transform ( X ) Fitting Tokenizer... Tokenizing the corpus... --> Creating 5 bigrams on 10 locations. >>> print ( X ) corpus 0 [I, \u00e0m, in, ne, ', w, york] 1 [New, york_is, nice] 2 [new_york] 3 [hi, there, this_is, a_test, !] 4 [another, line, ...] 5 [new, york_is, larger, than, washington] 6 [running, the, test] 7 [this_is, a_test] Methods fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Tokenize the text. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Tokenize the text. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "Tokenizer"}, {"location": "API/nlp/tokenizer/#tokenizer", "text": "class atom.nlp. Tokenizer (bigram_freq=None, trigram_freq=None, quadgram_freq=None, verbose=0, logger=None) [source] Tokenize the corpus. Convert documents into sequences of words. Additionally, create n-grams (represented by words united with underscores, e.g. \"New_York\") based on their frequency in the corpus. The transformations are applied on the column named corpus . If there is no column with that name, an exception is raised. This class can be accessed from atom through the tokenize method. Read more in the user guide . Parameters bigram_freq: int, float or None, default=None Frequency threshold for bigram creation. If None: Don't create any bigrams. If int: Minimum number of occurrences to make a bigram. If float: Minimum frequency fraction to make a bigram. trigram_freq: int, float or None, default=None Frequency threshold for trigram creation. If None: Don't create any trigrams. If int: Minimum number of occurrences to make a trigram. If float: Minimum frequency fraction to make a trigram. quadgram_freq: int, float or None, default=None Frequency threshold for quadgram creation. If None: Don't create any quadgrams. If int: Minimum number of occurrences to make a quadgram. If float: Minimum frequency fraction to make a quadgram. verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. Attributes bigrams: pd.DataFrame Created bigrams and their frequencies. trigrams: pd.DataFrame Created trigrams and their frequencies. quadgrams: pd.DataFrame Created quadgrams and their frequencies. See Also TextCleaner Applies standard text cleaning to the corpus. TextNormalizer Normalize the corpus. Vectorizer Vectorize text data.", "title": "Tokenizer"}, {"location": "API/nlp/tokenizer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) corpus target 0 new york 0 1 new york is larger than washington 1 2 New york is nice 0 3 I \u00e0m in ne'w york 1 4 this is a test 0 5 another line... 1 6 running the test 0 7 hi there this is a test! 1 >>> atom . tokenize ( verbose = 2 ) Fitting Tokenizer... Tokenizing the corpus... >>> print ( atom . dataset ) corpus target 0 [new, york] 0 1 [new, york, is, larger, than, washington] 1 2 [New, york, is, nice] 0 3 [I, \u00e0m, in, ne, ', w, york] 1 4 [this, is, a, test] 0 5 [another, line, ...] 1 6 [running, the, test] 0 7 [hi, there, this, is, a, test, !] 1 >>> from atom.nlp import Tokenizer >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> tokenizer = Tokenizer ( bigram_freq = 2 , verbose = 2 ) >>> X = tokenizer . transform ( X ) Fitting Tokenizer... Tokenizing the corpus... --> Creating 5 bigrams on 10 locations. >>> print ( X ) corpus 0 [I, \u00e0m, in, ne, ', w, york] 1 [New, york_is, nice] 2 [new_york] 3 [hi, there, this_is, a_test, !] 4 [another, line, ...] 5 [new, york_is, larger, than, washington] 6 [running, the, test] 7 [this_is, a_test]", "title": "Example"}, {"location": "API/nlp/tokenizer/#methods", "text": "fit Does nothing. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Tokenize the text. method fit (X=None, y=None, **fit_params) [source] Does nothing. Implemented for continuity of the API. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns self Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Tokenize the text. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "Methods"}, {"location": "API/nlp/vectorizer/", "text": "Vectorizer class atom.nlp. Vectorizer (strategy=\"bow\", return_sparse=True, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, **kwargs) [source] Vectorize text data. Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named corpus . If there is no column with that name, an exception is raised. If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix corpus_ . If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column. This class can be accessed from atom through the vectorize method. Read more in the user guide . Parameters strategy: str, default=\"bow\" Strategy with which to vectorize the text. Choose from: \" bow \": Bag of Words. \" tfidf \": Term Frequency - Inverse Document Frequency. \" hashing \": Vectorize to a matrix of token occurrences. return_sparse: bool, default=True Whether to return the transformation output as a dataframe of sparse arrays. Must be False when there are other columns in X (besides corpus ) that are non-sparse. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: sklearn transformer Estimator instance (lowercase strategy) used to vectorize the corpus, e.g. vectorizer.tfidf for the tfidf strategy. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also TextCleaner Applies standard text cleaning to the corpus. TextNormalizer Normalize the corpus. Tokenizer Tokenize the corpus. Example atom stand-alone >>> from atom import ATOMClassifier >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) corpus target 0 new york 0 1 I \u00e0m in ne'w york 1 2 this is a test 0 3 running the test 0 4 another line... 1 5 hi there this is a test! 1 6 New york is nice 0 7 new york is larger than washington 1 >>> atom . vectorize ( strategy = \"tfidf\" , verbose = 2 ) Fitting Vectorizer... Vectorizing the corpus... >>> print ( atom . dataset ) corpus_another corpus_in corpus_is ... corpus_york corpus_\u00e0m target 0 0.000000 0.000000 0.000000 ... 0.627914 0.000000 0 1 0.000000 0.523358 0.000000 ... 0.422242 0.523358 1 2 0.000000 0.000000 0.614189 ... 0.000000 0.000000 0 3 0.000000 0.000000 0.000000 ... 0.000000 0.000000 0 4 0.707107 0.000000 0.000000 ... 0.000000 0.000000 1 5 0.000000 0.000000 0.614189 ... 0.000000 0.000000 1 6 0.000000 0.000000 0.614189 ... 0.495524 0.000000 0 7 0.000000 0.000000 0.614189 ... 0.495524 0.000000 1 [8 rows x 13 columns] >>> from atom.nlp import Vectorizer >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> vectorizer = Vectorizer ( strategy = \"tfidf\" , verbose = 2 ) >>> X = vectorizer . fit_transform ( X ) Fitting Vectorizer... Vectorizing the corpus... >>> print ( X ) corpus_another corpus_hi ... corpus_york corpus_\u00e0m 0 0.000000 0.000000 ... 0.343774 0.542162 1 0.000000 0.000000 ... 0.415657 0.000000 2 0.000000 0.000000 ... 0.659262 0.000000 3 0.000000 0.525049 ... 0.000000 0.000000 4 0.707107 0.000000 ... 0.000000 0.000000 5 0.000000 0.000000 ... 0.304821 0.000000 6 0.000000 0.000000 ... 0.000000 0.000000 7 0.000000 0.000000 ... 0.000000 0.000000 [8 rows x 18 columns] Methods fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Vectorize the text. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Vectorizer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Vectorize the text. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "Vectorizer"}, {"location": "API/nlp/vectorizer/#vectorizer", "text": "class atom.nlp. Vectorizer (strategy=\"bow\", return_sparse=True, device=\"cpu\", engine=\"sklearn\", verbose=0, logger=None, **kwargs) [source] Vectorize text data. Transform the corpus into meaningful vectors of numbers. The transformation is applied on the column named corpus . If there is no column with that name, an exception is raised. If strategy=\"bow\" or \"tfidf\", the transformed columns are named after the word they are embedding with the prefix corpus_ . If strategy=\"hashing\", the columns are named hash[N], where N stands for the n-th hashed column. This class can be accessed from atom through the vectorize method. Read more in the user guide . Parameters strategy: str, default=\"bow\" Strategy with which to vectorize the text. Choose from: \" bow \": Bag of Words. \" tfidf \": Term Frequency - Inverse Document Frequency. \" hashing \": Vectorize to a matrix of token occurrences. return_sparse: bool, default=True Whether to return the transformation output as a dataframe of sparse arrays. Must be False when there are other columns in X (besides corpus ) that are non-sparse. device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic naming. Else: Python logging.Logger instance. **kwargs Additional keyword arguments for the strategy estimator. Attributes [strategy]: sklearn transformer Estimator instance (lowercase strategy) used to vectorize the corpus, e.g. vectorizer.tfidf for the tfidf strategy. feature_names_in_: np.array Names of features seen during fit. n_features_in_: int Number of features seen during fit. See Also TextCleaner Applies standard text cleaning to the corpus. TextNormalizer Normalize the corpus. Tokenizer Tokenize the corpus.", "title": "Vectorizer"}, {"location": "API/nlp/vectorizer/#example", "text": "atom stand-alone >>> from atom import ATOMClassifier >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> atom = ATOMClassifier ( X , y ) >>> print ( atom . dataset ) corpus target 0 new york 0 1 I \u00e0m in ne'w york 1 2 this is a test 0 3 running the test 0 4 another line... 1 5 hi there this is a test! 1 6 New york is nice 0 7 new york is larger than washington 1 >>> atom . vectorize ( strategy = \"tfidf\" , verbose = 2 ) Fitting Vectorizer... Vectorizing the corpus... >>> print ( atom . dataset ) corpus_another corpus_in corpus_is ... corpus_york corpus_\u00e0m target 0 0.000000 0.000000 0.000000 ... 0.627914 0.000000 0 1 0.000000 0.523358 0.000000 ... 0.422242 0.523358 1 2 0.000000 0.000000 0.614189 ... 0.000000 0.000000 0 3 0.000000 0.000000 0.000000 ... 0.000000 0.000000 0 4 0.707107 0.000000 0.000000 ... 0.000000 0.000000 1 5 0.000000 0.000000 0.614189 ... 0.000000 0.000000 1 6 0.000000 0.000000 0.614189 ... 0.495524 0.000000 0 7 0.000000 0.000000 0.614189 ... 0.495524 0.000000 1 [8 rows x 13 columns] >>> from atom.nlp import Vectorizer >>> X = [ ... [ \"I \u00e0m in ne'w york\" ], ... [ \"New york is nice\" ], ... [ \"new york\" ], ... [ \"hi there this is a test!\" ], ... [ \"another line...\" ], ... [ \"new york is larger than washington\" ], ... [ \"running the test\" ], ... [ \"this is a test\" ], ... ] >>> y = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] >>> vectorizer = Vectorizer ( strategy = \"tfidf\" , verbose = 2 ) >>> X = vectorizer . fit_transform ( X ) Fitting Vectorizer... Vectorizing the corpus... >>> print ( X ) corpus_another corpus_hi ... corpus_york corpus_\u00e0m 0 0.000000 0.000000 ... 0.343774 0.542162 1 0.000000 0.000000 ... 0.415657 0.000000 2 0.000000 0.000000 ... 0.659262 0.000000 3 0.000000 0.525049 ... 0.000000 0.000000 4 0.707107 0.000000 ... 0.000000 0.000000 5 0.000000 0.000000 ... 0.304821 0.000000 6 0.000000 0.000000 ... 0.000000 0.000000 7 0.000000 0.000000 ... 0.000000 0.000000 [8 rows x 18 columns]", "title": "Example"}, {"location": "API/nlp/vectorizer/#methods", "text": "fit Fit to data. fit_transform Fit to data, then transform it. get_params Get parameters for this estimator. inverse_transform Does nothing. log Print message and save to log file. save Save the instance to a pickle file. set_params Set the parameters of this estimator. transform Vectorize the text. method fit (X, y=None) [source] Fit to data. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns Vectorizer Estimator instance. method fit_transform (X=None, y=None, **fit_params) [source] Fit to data, then transform it. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. **fit_params Additional keyword arguments for the fit method. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method inverse_transform (X=None, y=None) [source] Does nothing. Parameters X: dataframe-like or None, default=None Feature set with shape=(n_samples, n_features). If None, X is ignored. y: int, str, dict, sequence or None, default=None Target column corresponding to X. If None: y is ignored. If int: Position of the target column in X. If str: Name of the target column in X. Else: Array with shape=(n_samples,) to use as target. Returns pd.DataFrame Transformed feature set. Only returned if provided. pd.Series Transformed target column. Only returned if provided. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method transform (X, y=None) [source] Vectorize the text. Parameters X: dataframe-like Feature set with shape=(n_samples, n_features). If X is not a pd.DataFrame, it should be composed of a single feature containing the text documents. y: int, str, dict, sequence or None, default=None Does nothing. Implemented for continuity of the API. Returns pd.DataFrame Transformed corpus.", "title": "Methods"}, {"location": "API/plots/plot_calibration/", "text": "plot_calibration method plot_calibration (models=None, n_bins=10, title=None, legend=\"upper left\", figsize=(900, 900), filename=None, display=True) [source] Plot the calibration curve for a binary classifier. Well calibrated classifiers are probabilistic classifiers for which the output of the predict_proba method can be directly interpreted as a confidence level. For instance a well calibrated (binary) classifier should classify the samples such that among the samples to which it gave a predict_proba value close to 0.8, approx. 80% actually belong to the positive class. Read more in sklearn's documentation . This figure shows two plots: the calibration curve, where the x-axis represents the average predicted probability in each bin and the y-axis is the fraction of positives, i.e. the proportion of samples whose class is the positive class (in each bin); and a distribution of all predicted probabilities of the classifier. Only available for binary classification tasks. Tip Use the calibrate method to calibrate the winning model. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. n_bins: int, default=10 Number of bins used for calibration. Minimum of 5 required. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_lift Plot the lift curve. plot_prc Plot the precision-recall curve. plot_roc Plot the Receiver Operating Characteristics curve. Example >>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"RF\" , \"LGB\" ]) >>> atom . plot_calibration () ;", "title": "plot_calibration"}, {"location": "API/plots/plot_calibration/#plot_calibration", "text": "method plot_calibration (models=None, n_bins=10, title=None, legend=\"upper left\", figsize=(900, 900), filename=None, display=True) [source] Plot the calibration curve for a binary classifier. Well calibrated classifiers are probabilistic classifiers for which the output of the predict_proba method can be directly interpreted as a confidence level. For instance a well calibrated (binary) classifier should classify the samples such that among the samples to which it gave a predict_proba value close to 0.8, approx. 80% actually belong to the positive class. Read more in sklearn's documentation . This figure shows two plots: the calibration curve, where the x-axis represents the average predicted probability in each bin and the y-axis is the fraction of positives, i.e. the proportion of samples whose class is the positive class (in each bin); and a distribution of all predicted probabilities of the classifier. Only available for binary classification tasks. Tip Use the calibrate method to calibrate the winning model. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. n_bins: int, default=10 Number of bins used for calibration. Minimum of 5 required. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_lift Plot the lift curve. plot_prc Plot the precision-recall curve. plot_roc Plot the Receiver Operating Characteristics curve.", "title": "plot_calibration"}, {"location": "API/plots/plot_calibration/#example", "text": ">>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"RF\" , \"LGB\" ]) >>> atom . plot_calibration () ;", "title": "Example"}, {"location": "API/plots/plot_components/", "text": "plot_components method plot_components (show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the explained variance ratio per component. Kept components are colored and discarted components are transparent. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters show: int or None, default=None Number of components to show. None to show all. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of components shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_pca Plot the explained variance ratio vs number of components. plot_rfecv Plot the rfecv results. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( \"pca\" , n_features = 5 ) >>> atom . plot_components ( show = 10 ) ;", "title": "plot_components"}, {"location": "API/plots/plot_components/#plot_components", "text": "method plot_components (show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the explained variance ratio per component. Kept components are colored and discarted components are transparent. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters show: int or None, default=None Number of components to show. None to show all. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of components shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_pca Plot the explained variance ratio vs number of components. plot_rfecv Plot the rfecv results.", "title": "plot_components"}, {"location": "API/plots/plot_components/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( \"pca\" , n_features = 5 ) >>> atom . plot_components ( show = 10 ) ;", "title": "Example"}, {"location": "API/plots/plot_confusion_matrix/", "text": "plot_confusion_matrix method plot_confusion_matrix (models=None, dataset=\"test\", title=None, legend=\"upper right\", figsize=None, filename=None, display=True) [source] Plot a model's confusion matrix. For one model, the plot shows a heatmap. For multiple models, it compares TP, FP, FN and TN in a barplot (not implemented for multiclass classification tasks). This plot is available only for classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the confusion matrix. Choose from:` \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the plot's type. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_calibration Plot the calibration curve for a binary classifier. plot_threshold Plot metric performances against threshold values. Example >>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . lr . plot_confusion_matrix () # For one model ; >>> atom . plot_confusion_matrix () # For multiple models ;", "title": "plot_confusion_matrix"}, {"location": "API/plots/plot_confusion_matrix/#plot_confusion_matrix", "text": "method plot_confusion_matrix (models=None, dataset=\"test\", title=None, legend=\"upper right\", figsize=None, filename=None, display=True) [source] Plot a model's confusion matrix. For one model, the plot shows a heatmap. For multiple models, it compares TP, FP, FN and TN in a barplot (not implemented for multiclass classification tasks). This plot is available only for classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the confusion matrix. Choose from:` \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the plot's type. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_calibration Plot the calibration curve for a binary classifier. plot_threshold Plot metric performances against threshold values.", "title": "plot_confusion_matrix"}, {"location": "API/plots/plot_confusion_matrix/#example", "text": ">>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . lr . plot_confusion_matrix () # For one model ; >>> atom . plot_confusion_matrix () # For multiple models ;", "title": "Example"}, {"location": "API/plots/plot_correlation/", "text": "plot_correlation method plot_correlation (columns=None, method=\"pearson\", title=None, legend=None, figsize=(800, 700), filename=None, display=True) [source] Plot a correlation matrix. Displays a heatmap showing the correlation between columns in the dataset. The colors red, blue and white stand for positive, negative, and no correlation respectively. Parameters columns: slice, sequence or None, default=None Columns to plot. If None, plot all columns in the dataset. Selected categorical columns are ignored. method: str, default=\"pearson\" Method of correlation. Choose from: pearson, kendall or spearman. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(800, 700) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_distribution Plot column distributions. plot_qq Plot a quantile-quantile plot. plot_relationships Plot pairwise relationships in a dataset. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_correlation () ;", "title": "plot_correlation"}, {"location": "API/plots/plot_correlation/#plot_correlation", "text": "method plot_correlation (columns=None, method=\"pearson\", title=None, legend=None, figsize=(800, 700), filename=None, display=True) [source] Plot a correlation matrix. Displays a heatmap showing the correlation between columns in the dataset. The colors red, blue and white stand for positive, negative, and no correlation respectively. Parameters columns: slice, sequence or None, default=None Columns to plot. If None, plot all columns in the dataset. Selected categorical columns are ignored. method: str, default=\"pearson\" Method of correlation. Choose from: pearson, kendall or spearman. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(800, 700) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_distribution Plot column distributions. plot_qq Plot a quantile-quantile plot. plot_relationships Plot pairwise relationships in a dataset.", "title": "plot_correlation"}, {"location": "API/plots/plot_correlation/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_correlation () ;", "title": "Example"}, {"location": "API/plots/plot_det/", "text": "plot_det method plot_det (models=None, dataset=\"test\", title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True) [source] Plot the Detection Error Tradeoff curve. Read more about DET in sklearn's documentation. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_gains Plot the cumulative gains curve. plot_roc Plot the Receiver Operating Characteristics curve. plot_prc Plot the precision-recall curve. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_det () ;", "title": "plot_det"}, {"location": "API/plots/plot_det/#plot_det", "text": "method plot_det (models=None, dataset=\"test\", title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True) [source] Plot the Detection Error Tradeoff curve. Read more about DET in sklearn's documentation. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_gains Plot the cumulative gains curve. plot_roc Plot the Receiver Operating Characteristics curve. plot_prc Plot the precision-recall curve.", "title": "plot_det"}, {"location": "API/plots/plot_det/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_det () ;", "title": "Example"}, {"location": "API/plots/plot_distribution/", "text": "plot_distribution method plot_distribution (columns=0, distributions=None, show=None, title=None, legend=\"upper right\", figsize=None, filename=None, display=True) [source] Plot column distributions. For numerical columns, plot the probability density distribution. Additionally, it's possible to plot any of scipy.stats distributions fitted to the column. For categorical columns, plot the class distribution. Only one categorical column can be plotted at the same time. Tip Use atom's distribution method to check which distribution fits the column best. Parameters columns: int, str, slice or sequence, default=0 Columns to plot. I's only possible to plot one categorical column. If more than one categorical columns are selected, all categorical columns are ignored. distributions: str, sequence or None, default=None Names of the scipy.stats distributions to fit to the columns. If None, a Gaussian kde distribution is showed. Only for numerical columns. show: int or None, default=None Number of classes (ordered by number of occurrences) to show in the plot. If None, it shows all classes. Only for categorical columns. title: str, dict or None, default=None Title for the plot. If None: No title is shown. If str: Text for the title. If dict: title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the plot's type. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_correlation Plot a correlation matrix. plot_qq Plot a quantile-quantile plot. plot_relationships Plot pairwise relationships in a dataset. Example >>> from atom import ATOMClassifier >>> import numpy as np >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Add a categorical feature >>> animals = [ \"cat\" , \"dog\" , \"bird\" , \"lion\" , \"zebra\" ] >>> probabilities = [ 0.001 , 0.1 , 0.2 , 0.3 , 0.399 ] >>> X [ \"animals\" ] = np . random . choice ( animals , size = len ( X ), p = probabilities ) >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_distribution ( columns = [ 0 , 1 ]) ; >>> atom . plot_distribution ( columns = 0 , distributions = [ \"norm\" , \"invgauss\" ]) ; >>> atom . plot_distribution ( columns = \"animals\" , legend = \"lower right\" ) ;", "title": "plot_distribution"}, {"location": "API/plots/plot_distribution/#plot_distribution", "text": "method plot_distribution (columns=0, distributions=None, show=None, title=None, legend=\"upper right\", figsize=None, filename=None, display=True) [source] Plot column distributions. For numerical columns, plot the probability density distribution. Additionally, it's possible to plot any of scipy.stats distributions fitted to the column. For categorical columns, plot the class distribution. Only one categorical column can be plotted at the same time. Tip Use atom's distribution method to check which distribution fits the column best. Parameters columns: int, str, slice or sequence, default=0 Columns to plot. I's only possible to plot one categorical column. If more than one categorical columns are selected, all categorical columns are ignored. distributions: str, sequence or None, default=None Names of the scipy.stats distributions to fit to the columns. If None, a Gaussian kde distribution is showed. Only for numerical columns. show: int or None, default=None Number of classes (ordered by number of occurrences) to show in the plot. If None, it shows all classes. Only for categorical columns. title: str, dict or None, default=None Title for the plot. If None: No title is shown. If str: Text for the title. If dict: title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the plot's type. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_correlation Plot a correlation matrix. plot_qq Plot a quantile-quantile plot. plot_relationships Plot pairwise relationships in a dataset.", "title": "plot_distribution"}, {"location": "API/plots/plot_distribution/#example", "text": ">>> from atom import ATOMClassifier >>> import numpy as np >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> # Add a categorical feature >>> animals = [ \"cat\" , \"dog\" , \"bird\" , \"lion\" , \"zebra\" ] >>> probabilities = [ 0.001 , 0.1 , 0.2 , 0.3 , 0.399 ] >>> X [ \"animals\" ] = np . random . choice ( animals , size = len ( X ), p = probabilities ) >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_distribution ( columns = [ 0 , 1 ]) ; >>> atom . plot_distribution ( columns = 0 , distributions = [ \"norm\" , \"invgauss\" ]) ; >>> atom . plot_distribution ( columns = \"animals\" , legend = \"lower right\" ) ;", "title": "Example"}, {"location": "API/plots/plot_edf/", "text": "plot_edf method plot_edf (models=None, metric=None, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True) [source] Plot the Empirical Distribution Function of a study. Use this plot to analyze and improve hyperparameter search spaces. The EDF assumes that the value of the objective function is in accordance with the uniform distribution over the objective space. This plot is only available for models that ran hyperparameter tuning . Note Only complete trials are considered when plotting the EDF. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). If str, add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_hyperparameters Plot hyperparameter relationships in a study. plot_trials Plot the hyperparameter tuning trials. Example >>> from atom import ATOMClassifier >>> from optuna.distributions import IntDistribution >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () # We run three models with different search spaces >>> atom . run ( ... models = \"RF1\" , ... n_trials = 200 , ... ht_params = { \"distributions\" : { \"n_estimators\" : IntDistribution ( 10 , 20 )}}, ... ) >>> atom . run ( ... models = \"RF1\" , ... n_trials = 200 , ... ht_params = { \"distributions\" : { \"n_estimators\" : IntDistribution ( 50 , 80 )}}, ... ) >>> atom . run ( ... models = \"RF1\" , ... n_trials = 200 , ... ht_params = { \"distributions\" : { \"n_estimators\" : IntDistribution ( 100 , 200 )}}, ... ) >>> atom . plot_edf () ;", "title": "plot_edf"}, {"location": "API/plots/plot_edf/#plot_edf", "text": "method plot_edf (models=None, metric=None, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True) [source] Plot the Empirical Distribution Function of a study. Use this plot to analyze and improve hyperparameter search spaces. The EDF assumes that the value of the objective function is in accordance with the uniform distribution over the objective space. This plot is only available for models that ran hyperparameter tuning . Note Only complete trials are considered when plotting the EDF. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). If str, add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_hyperparameters Plot hyperparameter relationships in a study. plot_trials Plot the hyperparameter tuning trials.", "title": "plot_edf"}, {"location": "API/plots/plot_edf/#example", "text": ">>> from atom import ATOMClassifier >>> from optuna.distributions import IntDistribution >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () # We run three models with different search spaces >>> atom . run ( ... models = \"RF1\" , ... n_trials = 200 , ... ht_params = { \"distributions\" : { \"n_estimators\" : IntDistribution ( 10 , 20 )}}, ... ) >>> atom . run ( ... models = \"RF1\" , ... n_trials = 200 , ... ht_params = { \"distributions\" : { \"n_estimators\" : IntDistribution ( 50 , 80 )}}, ... ) >>> atom . run ( ... models = \"RF1\" , ... n_trials = 200 , ... ht_params = { \"distributions\" : { \"n_estimators\" : IntDistribution ( 100 , 200 )}}, ... ) >>> atom . plot_edf () ;", "title": "Example"}, {"location": "API/plots/plot_errors/", "text": "plot_errors method plot_errors (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot a model's prediction errors. Plot the actual targets from a set against the predicted values generated by the regressor. A linear fit is made on the data. The gray, intersected line shows the identity line. This plot can be useful to detect noise or heteroscedasticity along a range of the target domain. It's only available for regression tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_residuals Plot a model's residuals. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import load_diabetes >>> X , y = load_diabetes ( return_X_y = True , as_frame = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ([ \"OLS\" , \"LGB\" ]) >>> atom . plot_errors () ;", "title": "plot_errors"}, {"location": "API/plots/plot_errors/#plot_errors", "text": "method plot_errors (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot a model's prediction errors. Plot the actual targets from a set against the predicted values generated by the regressor. A linear fit is made on the data. The gray, intersected line shows the identity line. This plot can be useful to detect noise or heteroscedasticity along a range of the target domain. It's only available for regression tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_residuals Plot a model's residuals.", "title": "plot_errors"}, {"location": "API/plots/plot_errors/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import load_diabetes >>> X , y = load_diabetes ( return_X_y = True , as_frame = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ([ \"OLS\" , \"LGB\" ]) >>> atom . plot_errors () ;", "title": "Example"}, {"location": "API/plots/plot_evals/", "text": "plot_evals method plot_evals (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot evaluation curves. The evaluation curves are the main metric scores achieved by the models at every iteration of the training process. This plot is only available for models that allow in-training validation . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the evaluation curves. Use a sequence or add + between options to select more than one. Choose from: \"train\" or \"test\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_trials Plot the hyperparameter tuning trials. Example >>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"XGB\" , \"LGB\" ]) >>> atom . plot_evals () ;", "title": "plot_evals"}, {"location": "API/plots/plot_evals/#plot_evals", "text": "method plot_evals (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot evaluation curves. The evaluation curves are the main metric scores achieved by the models at every iteration of the training process. This plot is only available for models that allow in-training validation . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the evaluation curves. Use a sequence or add + between options to select more than one. Choose from: \"train\" or \"test\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_trials Plot the hyperparameter tuning trials.", "title": "plot_evals"}, {"location": "API/plots/plot_evals/#example", "text": ">>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"XGB\" , \"LGB\" ]) >>> atom . plot_evals () ;", "title": "Example"}, {"location": "API/plots/plot_feature_importance/", "text": "plot_feature_importance method plot_feature_importance (models=None, show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot a model's feature importance. The sum of importances for all features (per model) is 1. Only available for models whose estimator has a scores_ , feature_importances_ or coef attribute. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_parshap Plot the partial correlation of shap values. plot_partial_dependence Plot the partial dependence of features. plot_permutation_importance Plot the feature permutation importance of models. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_feature_importance ( show = 10 ) ;", "title": "plot_feature_importance"}, {"location": "API/plots/plot_feature_importance/#plot_feature_importance", "text": "method plot_feature_importance (models=None, show=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot a model's feature importance. The sum of importances for all features (per model) is 1. Only available for models whose estimator has a scores_ , feature_importances_ or coef attribute. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_parshap Plot the partial correlation of shap values. plot_partial_dependence Plot the partial dependence of features. plot_permutation_importance Plot the feature permutation importance of models.", "title": "plot_feature_importance"}, {"location": "API/plots/plot_feature_importance/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_feature_importance ( show = 10 ) ;", "title": "Example"}, {"location": "API/plots/plot_gains/", "text": "plot_gains method plot_gains (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the cumulative gains curve. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_det Plot the Detection Error Tradeoff curve. plot_lift Plot the lift curve. plot_roc Plot the Receiver Operating Characteristics curve. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_gains () ;", "title": "plot_gains"}, {"location": "API/plots/plot_gains/#plot_gains", "text": "method plot_gains (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the cumulative gains curve. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_det Plot the Detection Error Tradeoff curve. plot_lift Plot the lift curve. plot_roc Plot the Receiver Operating Characteristics curve.", "title": "plot_gains"}, {"location": "API/plots/plot_gains/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_gains () ;", "title": "Example"}, {"location": "API/plots/plot_hyperparameter_importance/", "text": "plot_hyperparameter_importance method plot_hyperparameter_importance (models=None, metric=0, show=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot a model's hyperparameter importance. The hyperparameter importance are calculated using the fANOVA importance evaluator. The sum of importances for all parameters (per model) is 1. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. metric: int or str, default=0 Metric to plot (only for multi-metric runs). show: int or None, default=None Number of hyperparameters (ordered by importance) to show. None to show all. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_hyperparameters Plot hyperparameter relationships in a study. plot_trials Plot the hyperparameter tuning trials. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ], n_trials = 15 ) >>> atom . plot_hyperparameter_importance () ;", "title": "plot_hyperparameter_importance"}, {"location": "API/plots/plot_hyperparameter_importance/#plot_hyperparameter_importance", "text": "method plot_hyperparameter_importance (models=None, metric=0, show=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot a model's hyperparameter importance. The hyperparameter importance are calculated using the fANOVA importance evaluator. The sum of importances for all parameters (per model) is 1. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. metric: int or str, default=0 Metric to plot (only for multi-metric runs). show: int or None, default=None Number of hyperparameters (ordered by importance) to show. None to show all. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_hyperparameters Plot hyperparameter relationships in a study. plot_trials Plot the hyperparameter tuning trials.", "title": "plot_hyperparameter_importance"}, {"location": "API/plots/plot_hyperparameter_importance/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ], n_trials = 15 ) >>> atom . plot_hyperparameter_importance () ;", "title": "Example"}, {"location": "API/plots/plot_hyperparameters/", "text": "plot_hyperparameters method plot_hyperparameters (models=None, params=(0, 1), metric=0, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot hyperparameter relationships in a study. A model's hyperparameters are plotted against each other. The corresponding metric scores are displayed in a contour plot. The markers are the trials in the study. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_hyperparameters() . params: str, slice or sequence, default=(0, 1) Hyperparameters to plot. Use a sequence or add + between options to select more than one. metric: int or str, default=0 Metric to plot (only for multi-metric runs). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_hyperparameter_importance Plot a model's hyperparameter importance. plot_parallel_coordinate Plot high-dimensional parameter relationships in a study. plot_trials Plot the hyperparameter tuning trials. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" ) >>> atom . plot_hyperparameters ( params = ( 0 , 1 , 2 )) ;", "title": "plot_hyperparameters"}, {"location": "API/plots/plot_hyperparameters/#plot_hyperparameters", "text": "method plot_hyperparameters (models=None, params=(0, 1), metric=0, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot hyperparameter relationships in a study. A model's hyperparameters are plotted against each other. The corresponding metric scores are displayed in a contour plot. The markers are the trials in the study. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_hyperparameters() . params: str, slice or sequence, default=(0, 1) Hyperparameters to plot. Use a sequence or add + between options to select more than one. metric: int or str, default=0 Metric to plot (only for multi-metric runs). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_hyperparameter_importance Plot a model's hyperparameter importance. plot_parallel_coordinate Plot high-dimensional parameter relationships in a study. plot_trials Plot the hyperparameter tuning trials.", "title": "plot_hyperparameters"}, {"location": "API/plots/plot_hyperparameters/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" ) >>> atom . plot_hyperparameters ( params = ( 0 , 1 , 2 )) ;", "title": "Example"}, {"location": "API/plots/plot_learning_curve/", "text": "plot_learning_curve method plot_learning_curve (models=None, metric=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the learning curve: score vs number of training samples. Only use with models fitted using train sizing . Ensembles are ignored. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Use a sequence or add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_results Plot the model results. plot_successive_halving Plot scores per iteration of the successive halving. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . train_sizing ([ \"LR\" , \"RF\" ], n_bootstrap = 5 ) >>> atom . plot_learning_curve () ;", "title": "plot_learning_curve"}, {"location": "API/plots/plot_learning_curve/#plot_learning_curve", "text": "method plot_learning_curve (models=None, metric=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the learning curve: score vs number of training samples. Only use with models fitted using train sizing . Ensembles are ignored. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Use a sequence or add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_results Plot the model results. plot_successive_halving Plot scores per iteration of the successive halving.", "title": "plot_learning_curve"}, {"location": "API/plots/plot_learning_curve/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . train_sizing ([ \"LR\" , \"RF\" ], n_bootstrap = 5 ) >>> atom . plot_learning_curve () ;", "title": "Example"}, {"location": "API/plots/plot_lift/", "text": "plot_lift method plot_lift (models=None, dataset=\"test\", title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True) [source] Plot the lift curve. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_det Plot the Detection Error Tradeoff curve. plot_gains Plot the cumulative gains curve. plot_prc Plot the precision-recall curve. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_lift () ;", "title": "plot_lift"}, {"location": "API/plots/plot_lift/#plot_lift", "text": "method plot_lift (models=None, dataset=\"test\", title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True) [source] Plot the lift curve. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_det Plot the Detection Error Tradeoff curve. plot_gains Plot the cumulative gains curve. plot_prc Plot the precision-recall curve.", "title": "plot_lift"}, {"location": "API/plots/plot_lift/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_lift () ;", "title": "Example"}, {"location": "API/plots/plot_ngrams/", "text": "plot_ngrams method plot_ngrams (ngram=\"bigram\", index=None, show=10, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot n-gram frequencies. The text for the plot is extracted from the column named corpus . If there is no column with that name, an exception is raised. If the documents are not tokenized, the words are separated by spaces. Tip Use atom's tokenize method to separate the words creating n-grams based on their frequency in the corpus. Parameters ngram: str or int, default=\"bigram\" Number of contiguous words to search for (size of n-gram). Choose from: words (1), bigrams (2), trigrams (3), quadgrams (4). index: int, str, slice, sequence or None, default=None Documents in the corpus to include in the search. If None, it selects all documents in the dataset. show: int, default=10 Number of n-grams (ordered by number of occurrences) to show in the plot. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of n-grams shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_wordcloud Plot a wordcloud from the corpus. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> atom = ATOMClassifier ( X , y ) >>> atom . textclean () >>> atom . textnormalize () >>> atom . plot_ngrams () ;", "title": "plot_ngrams"}, {"location": "API/plots/plot_ngrams/#plot_ngrams", "text": "method plot_ngrams (ngram=\"bigram\", index=None, show=10, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot n-gram frequencies. The text for the plot is extracted from the column named corpus . If there is no column with that name, an exception is raised. If the documents are not tokenized, the words are separated by spaces. Tip Use atom's tokenize method to separate the words creating n-grams based on their frequency in the corpus. Parameters ngram: str or int, default=\"bigram\" Number of contiguous words to search for (size of n-gram). Choose from: words (1), bigrams (2), trigrams (3), quadgrams (4). index: int, str, slice, sequence or None, default=None Documents in the corpus to include in the search. If None, it selects all documents in the dataset. show: int, default=10 Number of n-grams (ordered by number of occurrences) to show in the plot. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of n-grams shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_wordcloud Plot a wordcloud from the corpus.", "title": "plot_ngrams"}, {"location": "API/plots/plot_ngrams/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> atom = ATOMClassifier ( X , y ) >>> atom . textclean () >>> atom . textnormalize () >>> atom . plot_ngrams () ;", "title": "Example"}, {"location": "API/plots/plot_parallel_coordinate/", "text": "plot_parallel_coordinate method plot_parallel_coordinate (models=None, params=None, metric=0, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot high-dimensional parameter relationships in a study. Every line of the plot represents one trial. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_parallel_coordinate() . params: str, slice, sequence or None, default=None Hyperparameters to plot. Use a sequence or add + between options to select more than one. If None, all the model's hyperparameters are selected. metric: int or str, default=0 Metric to plot (only for multi-metric runs). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_edf Plot the Empirical Distribution Function of a study. plot_hyperparameter_importance Plot a model's hyperparameter importance. plot_hyperparameters Plot hyperparameter relationships in a study. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" , n_trials = 15 ) >>> atom . plot_parallel_coordinate ( params = slice ( 1 , 5 )) ;", "title": "plot_parallel_coordinate"}, {"location": "API/plots/plot_parallel_coordinate/#plot_parallel_coordinate", "text": "method plot_parallel_coordinate (models=None, params=None, metric=0, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot high-dimensional parameter relationships in a study. Every line of the plot represents one trial. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_parallel_coordinate() . params: str, slice, sequence or None, default=None Hyperparameters to plot. Use a sequence or add + between options to select more than one. If None, all the model's hyperparameters are selected. metric: int or str, default=0 Metric to plot (only for multi-metric runs). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_edf Plot the Empirical Distribution Function of a study. plot_hyperparameter_importance Plot a model's hyperparameter importance. plot_hyperparameters Plot hyperparameter relationships in a study.", "title": "plot_parallel_coordinate"}, {"location": "API/plots/plot_parallel_coordinate/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" , n_trials = 15 ) >>> atom . plot_parallel_coordinate ( params = slice ( 1 , 5 )) ;", "title": "Example"}, {"location": "API/plots/plot_pareto_front/", "text": "plot_pareto_front method plot_pareto_front (models=None, metric=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot the Pareto front of a study. Shows the trial scores plotted against each other. The marker's colors indicate the trial number. This plot is only available for models that ran multi-metric runs with hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_pareto_front() . metric: str, sequence or None, default=None Metrics to plot. Use a sequence or add + between options to select more than one. If None, the metrics used to run the pipeline are selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of metrics shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_edf Plot the Empirical Distribution Function of a study. plot_slice Plot the parameter relationship in a study. plot_trials Plot the hyperparameter tuning trials. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" , metric = [ \"f1\" , \"accuracy\" , \"recall\" ], n_trials = 15 ) >>> atom . plot_pareto_front () ;", "title": "plot_pareto_front"}, {"location": "API/plots/plot_pareto_front/#plot_pareto_front", "text": "method plot_pareto_front (models=None, metric=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot the Pareto front of a study. Shows the trial scores plotted against each other. The marker's colors indicate the trial number. This plot is only available for models that ran multi-metric runs with hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_pareto_front() . metric: str, sequence or None, default=None Metrics to plot. Use a sequence or add + between options to select more than one. If None, the metrics used to run the pipeline are selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of metrics shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_edf Plot the Empirical Distribution Function of a study. plot_slice Plot the parameter relationship in a study. plot_trials Plot the hyperparameter tuning trials.", "title": "plot_pareto_front"}, {"location": "API/plots/plot_pareto_front/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" , metric = [ \"f1\" , \"accuracy\" , \"recall\" ], n_trials = 15 ) >>> atom . plot_pareto_front () ;", "title": "Example"}, {"location": "API/plots/plot_parshap/", "text": "plot_parshap method plot_parshap (models=None, columns=None, target=1, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True) [source] Plot the partial correlation of shap values. Plots the train and test correlation between the shap value of every feature with its target value, after removing the effect of all other features (partial correlation). This plot is useful to identify the features that are contributing most to overfitting. Features that lie below the bisector (diagonal line) performed worse on the test set than on the training set. If the estimator has a scores_ , feature_importances_ or coef_ attribute, its normalized values are shown in a color map. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. columns: int, str, slice, sequence or None, default=None Features to plot. If None, it plots all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_partial_dependence Plot the partial dependence of features. plot_permutation_importance Plot the feature permutation importance of models. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"GNB\" , \"RF\" ]) >>> atom . rf . plot_parshap ( legend = None ) ; >>> atom . plot_parshap ( columns = slice ( 5 , 10 )) ;", "title": "plot_parshap"}, {"location": "API/plots/plot_parshap/#plot_parshap", "text": "method plot_parshap (models=None, columns=None, target=1, title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True) [source] Plot the partial correlation of shap values. Plots the train and test correlation between the shap value of every feature with its target value, after removing the effect of all other features (partial correlation). This plot is useful to identify the features that are contributing most to overfitting. Features that lie below the bisector (diagonal line) performed worse on the test set than on the training set. If the estimator has a scores_ , feature_importances_ or coef_ attribute, its normalized values are shown in a color map. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. columns: int, str, slice, sequence or None, default=None Features to plot. If None, it plots all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_partial_dependence Plot the partial dependence of features. plot_permutation_importance Plot the feature permutation importance of models.", "title": "plot_parshap"}, {"location": "API/plots/plot_parshap/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"GNB\" , \"RF\" ]) >>> atom . rf . plot_parshap ( legend = None ) ; >>> atom . plot_parshap ( columns = slice ( 5 , 10 )) ;", "title": "Example"}, {"location": "API/plots/plot_partial_dependence/", "text": "plot_partial_dependence method plot_partial_dependence (models=None, columns=None, kind=\"average\", pair=None, target=1, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the partial dependence of features. The partial dependence of a feature (or a set of features) corresponds to the response of the model for each possible value of the feature. The plot can take two forms: If pair is None: Single feature partial dependence lines. The deciles of the feature values are shown with tick marks on the bottom. If pair is defined: Two-way partial dependence plots are plotted as contour plots (only allowed for a single model). Read more about partial dependence on sklearn's documentation . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. columns: int, str, slice, sequence or None, default=None Features to get the partial dependence from. If None, it uses the first 3 features in the dataset. kind: str, default=\"average\" Kind of depedence to plot. Add + between options to select more than one. Choose from: \"average\": Partial dependence averaged across all samples in the dataset. \"individual\": Partial dependence for up to 50 random samples (Individual Conditional Expectation). This parameter is ignored when plotting feature pairs. pair: int, str or None, default=None Feature with which to pair the features selected by columns . If specified, the resulting figure displays contour plots. Only allowed when plotting a single model. If None, the plots show the partial dependece of single features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_parshap Plot the partial correlation of shap values. plot_permutation_importance Plot the feature permutation importance of models. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_partial_dependence ( kind = \"average+individual\" , legend = \"upper left\" ) ; >>> atom . rf . plot_partial_dependence ( columns = ( 3 , 4 ), pair = 2 ) ;", "title": "plot_partial_dependence"}, {"location": "API/plots/plot_partial_dependence/#plot_partial_dependence", "text": "method plot_partial_dependence (models=None, columns=None, kind=\"average\", pair=None, target=1, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the partial dependence of features. The partial dependence of a feature (or a set of features) corresponds to the response of the model for each possible value of the feature. The plot can take two forms: If pair is None: Single feature partial dependence lines. The deciles of the feature values are shown with tick marks on the bottom. If pair is defined: Two-way partial dependence plots are plotted as contour plots (only allowed for a single model). Read more about partial dependence on sklearn's documentation . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. columns: int, str, slice, sequence or None, default=None Features to get the partial dependence from. If None, it uses the first 3 features in the dataset. kind: str, default=\"average\" Kind of depedence to plot. Add + between options to select more than one. Choose from: \"average\": Partial dependence averaged across all samples in the dataset. \"individual\": Partial dependence for up to 50 random samples (Individual Conditional Expectation). This parameter is ignored when plotting feature pairs. pair: int, str or None, default=None Feature with which to pair the features selected by columns . If specified, the resulting figure displays contour plots. Only allowed when plotting a single model. If None, the plots show the partial dependece of single features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_parshap Plot the partial correlation of shap values. plot_permutation_importance Plot the feature permutation importance of models.", "title": "plot_partial_dependence"}, {"location": "API/plots/plot_partial_dependence/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_partial_dependence ( kind = \"average+individual\" , legend = \"upper left\" ) ; >>> atom . rf . plot_partial_dependence ( columns = ( 3 , 4 ), pair = 2 ) ;", "title": "Example"}, {"location": "API/plots/plot_pca/", "text": "plot_pca method plot_pca (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the explained variance ratio vs number of components. If the underlying estimator is PCA (for dense datasets), all possible components are plotted. If the underlying estimator is TruncatedSVD (for sparse datasets), it only shows the selected components. The star marks the number of components selected by the user. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_components Plot the explained variance ratio per component. plot_rfecv Plot the rfecv results. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( \"pca\" , n_features = 5 ) >>> atom . plot_pca () ;", "title": "plot_pca"}, {"location": "API/plots/plot_pca/#plot_pca", "text": "method plot_pca (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the explained variance ratio vs number of components. If the underlying estimator is PCA (for dense datasets), all possible components are plotted. If the underlying estimator is TruncatedSVD (for sparse datasets), it only shows the selected components. The star marks the number of components selected by the user. This plot is available only when feature selection was applied with strategy=\"pca\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_components Plot the explained variance ratio per component. plot_rfecv Plot the rfecv results.", "title": "plot_pca"}, {"location": "API/plots/plot_pca/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( \"pca\" , n_features = 5 ) >>> atom . plot_pca () ;", "title": "Example"}, {"location": "API/plots/plot_permutation_importance/", "text": "plot_permutation_importance method plot_permutation_importance (models=None, show=None, n_repeats=10, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the feature permutation importance of models. Calculating permutations can be time-consuming, especially if n_repeats is high. For this reason, the permutations are stored under the permutations attribute. If the plot is called again for the same model with the same n_repeats , it will use the stored values, making the method considerably faster. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. n_repeats: int, default=10 Number of times to permute each feature. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_partial_dependence Plot the partial dependence of features. plot_parshap Plot the partial correlation of shap values. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_permutation_importance ( show = 10 , n_repeats = 7 ) ;", "title": "plot_permutation_importance"}, {"location": "API/plots/plot_permutation_importance/#plot_permutation_importance", "text": "method plot_permutation_importance (models=None, show=None, n_repeats=10, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the feature permutation importance of models. Calculating permutations can be time-consuming, especially if n_repeats is high. For this reason, the permutations are stored under the permutations attribute. If the plot is called again for the same model with the same n_repeats , it will use the stored values, making the method considerably faster. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. n_repeats: int, default=10 Number of times to permute each feature. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_feature_importance Plot a model's feature importance. plot_partial_dependence Plot the partial dependence of features. plot_parshap Plot the partial correlation of shap values.", "title": "plot_permutation_importance"}, {"location": "API/plots/plot_permutation_importance/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_permutation_importance ( show = 10 , n_repeats = 7 ) ;", "title": "Example"}, {"location": "API/plots/plot_pipeline/", "text": "plot_pipeline method plot_pipeline (models=None, draw_hyperparameter_tuning=True, color_branches=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot a diagram of the pipeline. Warning This plot uses the schemdraw package, which is incompatible with plotly . The returned plot is therefore a matplotlib figure . Parameters models: int, str, Model, slice, sequence or None, default=None Models for which to draw the pipeline. If None, all pipelines are plotted. draw_hyperparameter_tuning: bool, default=True Whether to draw if the models used Hyperparameter Tuning. color_branches: bool or None, default=None Whether to draw every branch in a different color. If None, branches are colored when there is more than one. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the pipeline drawn. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_wordcloud Plot a wordcloud from the corpus. Example >>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . scale () >>> atom . run ([ \"GNB\" , \"RNN\" , \"SGD\" , \"MLP\" ]) >>> atom . voting ( models = atom . winners [: 2 ]) >>> atom . plot_pipeline () >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . scale () >>> atom . prune () >>> atom . run ( \"RF\" , n_trials = 30 ) >>> atom . branch = \"undersample\" >>> atom . balance ( \"nearmiss\" ) >>> atom . run ( \"RF_undersample\" ) >>> atom . branch = \"oversample_from_master\" >>> atom . balance ( \"smote\" ) >>> atom . run ( \"RF_oversample\" ) >>> atom . plot_pipeline ()", "title": "plot_pipeline"}, {"location": "API/plots/plot_pipeline/#plot_pipeline", "text": "method plot_pipeline (models=None, draw_hyperparameter_tuning=True, color_branches=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot a diagram of the pipeline. Warning This plot uses the schemdraw package, which is incompatible with plotly . The returned plot is therefore a matplotlib figure . Parameters models: int, str, Model, slice, sequence or None, default=None Models for which to draw the pipeline. If None, all pipelines are plotted. draw_hyperparameter_tuning: bool, default=True Whether to draw if the models used Hyperparameter Tuning. color_branches: bool or None, default=None Whether to draw every branch in a different color. If None, branches are colored when there is more than one. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the pipeline drawn. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_wordcloud Plot a wordcloud from the corpus.", "title": "plot_pipeline"}, {"location": "API/plots/plot_pipeline/#example", "text": ">>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . scale () >>> atom . run ([ \"GNB\" , \"RNN\" , \"SGD\" , \"MLP\" ]) >>> atom . voting ( models = atom . winners [: 2 ]) >>> atom . plot_pipeline () >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . scale () >>> atom . prune () >>> atom . run ( \"RF\" , n_trials = 30 ) >>> atom . branch = \"undersample\" >>> atom . balance ( \"nearmiss\" ) >>> atom . run ( \"RF_undersample\" ) >>> atom . branch = \"oversample_from_master\" >>> atom . balance ( \"smote\" ) >>> atom . run ( \"RF_oversample\" ) >>> atom . plot_pipeline ()", "title": "Example"}, {"location": "API/plots/plot_prc/", "text": "plot_prc method plot_prc (models=None, dataset=\"test\", title=None, legend=\"lower left\", figsize=(900, 600), filename=None, display=True) [source] Plot the precision-recall curve. Read more about PRC in sklearn's documentation. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_det Plot the Detection Error Tradeoff curve. plot_lift Plot the lift curve. plot_roc Plot the Receiver Operating Characteristics curve. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_prc () ;", "title": "plot_prc"}, {"location": "API/plots/plot_prc/#plot_prc", "text": "method plot_prc (models=None, dataset=\"test\", title=None, legend=\"lower left\", figsize=(900, 600), filename=None, display=True) [source] Plot the precision-recall curve. Read more about PRC in sklearn's documentation. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_det Plot the Detection Error Tradeoff curve. plot_lift Plot the lift curve. plot_roc Plot the Receiver Operating Characteristics curve.", "title": "plot_prc"}, {"location": "API/plots/plot_prc/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_prc () ;", "title": "Example"}, {"location": "API/plots/plot_probabilities/", "text": "plot_probabilities method plot_probabilities (models=None, dataset=\"test\", target=1, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True) [source] Plot the probability distribution of the target classes. Only available for classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". target: int or str, default=1 Probability of being that class in the target column (only for multiclass classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_confusion_matrix Plot a model's confusion matrix. plot_results Plot the model results. plot_threshold Plot metric performances against threshold values. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_probabilities () ;", "title": "plot_probabilities"}, {"location": "API/plots/plot_probabilities/#plot_probabilities", "text": "method plot_probabilities (models=None, dataset=\"test\", target=1, title=None, legend=\"upper right\", figsize=(900, 600), filename=None, display=True) [source] Plot the probability distribution of the target classes. Only available for classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". target: int or str, default=1 Probability of being that class in the target column (only for multiclass classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_confusion_matrix Plot a model's confusion matrix. plot_results Plot the model results. plot_threshold Plot metric performances against threshold values.", "title": "plot_probabilities"}, {"location": "API/plots/plot_probabilities/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_probabilities () ;", "title": "Example"}, {"location": "API/plots/plot_qq/", "text": "plot_qq method plot_qq (columns=0, distributions=\"norm\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot a quantile-quantile plot. Columns are distinguished by color and the distributions are distinguished by marker type. Missing values are ignored. Parameters columns: int, str, slice or sequence, default=0 Columns to plot. Selected categorical columns are ignored. distributions: str or sequence, default=\"norm\" Names of the scipy.stats distributions to fit to the columns. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_correlation Plot a correlation matrix. plot_distribution Plot column distributions. plot_relationships Plot pairwise relationships in a dataset. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_qq ( columns = [ 5 , 6 ]) ; >>> atom . plot_qq ( columns = 0 , distributions = [ \"norm\" , \"invgauss\" , \"triang\" ]) ;", "title": "plot_qq"}, {"location": "API/plots/plot_qq/#plot_qq", "text": "method plot_qq (columns=0, distributions=\"norm\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot a quantile-quantile plot. Columns are distinguished by color and the distributions are distinguished by marker type. Missing values are ignored. Parameters columns: int, str, slice or sequence, default=0 Columns to plot. Selected categorical columns are ignored. distributions: str or sequence, default=\"norm\" Names of the scipy.stats distributions to fit to the columns. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_correlation Plot a correlation matrix. plot_distribution Plot column distributions. plot_relationships Plot pairwise relationships in a dataset.", "title": "plot_qq"}, {"location": "API/plots/plot_qq/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_qq ( columns = [ 5 , 6 ]) ; >>> atom . plot_qq ( columns = 0 , distributions = [ \"norm\" , \"invgauss\" , \"triang\" ]) ;", "title": "Example"}, {"location": "API/plots/plot_relationships/", "text": "plot_relationships method plot_relationships (columns=[0, 1, 2], title=None, legend=None, figsize=(900, 900), filename=None, display=True) [source] Plot pairwise relationships in a dataset. Creates a grid of axes such that each numerical column appears once on the x-axes and once on the y-axes. The bottom triangle contains scatter plots (max 250 random samples), the diagonal plots contain column distributions, and the upper triangle contains contour histograms for all samples in the columns. Parameters columns: slice or sequence, default=[0, 1, 2] Columns to plot. Selected categorical columns are ignored. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_correlation Plot a correlation matrix. plot_distribution Plot column distributions. plot_qq Plot a quantile-quantile plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_relationships ( columns = [ 0 , 4 , 5 ]) ;", "title": "plot_relationships"}, {"location": "API/plots/plot_relationships/#plot_relationships", "text": "method plot_relationships (columns=[0, 1, 2], title=None, legend=None, figsize=(900, 900), filename=None, display=True) [source] Plot pairwise relationships in a dataset. Creates a grid of axes such that each numerical column appears once on the x-axes and once on the y-axes. The bottom triangle contains scatter plots (max 250 random samples), the diagonal plots contain column distributions, and the upper triangle contains contour histograms for all samples in the columns. Parameters columns: slice or sequence, default=[0, 1, 2] Columns to plot. Selected categorical columns are ignored. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 900) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_correlation Plot a correlation matrix. plot_distribution Plot column distributions. plot_qq Plot a quantile-quantile plot.", "title": "plot_relationships"}, {"location": "API/plots/plot_relationships/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . plot_relationships ( columns = [ 0 , 4 , 5 ]) ;", "title": "Example"}, {"location": "API/plots/plot_residuals/", "text": "plot_residuals method plot_residuals (models=None, dataset=\"test\", title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True) [source] Plot a model's residuals. The plot shows the residuals (difference between the predicted and the true value) on the vertical axis and the independent variable on the horizontal axis. The gray, intersected line shows the identity line. This plot can be useful to analyze the variance of the error of the regressor. If the points are randomly dispersed around the horizontal axis, a linear regression model is appropriate for the data; otherwise, a non-linear model is more appropriate. This plot is only available for regression tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_errors Plot a model's prediction errors. Example >>> from atom import ATOMRegressor >>> from sklearn.datasets import load_diabetes >>> X , y = load_diabetes ( return_X_y = True , as_frame = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ([ \"OLS\" , \"LGB\" ]) >>> atom . plot_residuals () ;", "title": "plot_residuals"}, {"location": "API/plots/plot_residuals/#plot_residuals", "text": "method plot_residuals (models=None, dataset=\"test\", title=None, legend=\"upper left\", figsize=(900, 600), filename=None, display=True) [source] Plot a model's residuals. The plot shows the residuals (difference between the predicted and the true value) on the vertical axis and the independent variable on the horizontal axis. The gray, intersected line shows the identity line. This plot can be useful to analyze the variance of the error of the regressor. If the points are randomly dispersed around the horizontal axis, a linear regression model is appropriate for the data; otherwise, a non-linear model is more appropriate. This plot is only available for regression tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_errors Plot a model's prediction errors.", "title": "plot_residuals"}, {"location": "API/plots/plot_residuals/#example", "text": ">>> from atom import ATOMRegressor >>> from sklearn.datasets import load_diabetes >>> X , y = load_diabetes ( return_X_y = True , as_frame = True ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ([ \"OLS\" , \"LGB\" ]) >>> atom . plot_residuals () ;", "title": "Example"}, {"location": "API/plots/plot_results/", "text": "plot_results method plot_results (models=None, metric=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the model results. If all models applied bootstrap, the plot is a boxplot. If not, the plot is a barplot. Models are ordered based on their score from the top down. The score is either the score_bootstrap or score_test attribute of the model, selected in that order. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Other available options are \"time_bo\", \"time_fit\", \"time_bootstrap\" and \"time\". If str, add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of models. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_confusion_matrix Plot a model's confusion matrix. plot_probabilities Plot the probability distribution of the target classes. plot_threshold Plot metric performances against threshold values. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"GNB\" , \"LR\" , \"RF\" , \"LGB\" ], metric = [ \"f1\" , \"recall\" ]) >>> atom . plot_results () ; >>> atom . run ([ \"GNB\" , \"LR\" , \"RF\" , \"LGB\" ], metric = [ \"f1\" , \"recall\" ], n_bootstrap = 5 ) >>> atom . plot_results () ; >>> atom . plot_results ( metric = \"time_fit+time\" ) ;", "title": "plot_results"}, {"location": "API/plots/plot_results/#plot_results", "text": "method plot_results (models=None, metric=None, title=None, legend=\"lower right\", figsize=None, filename=None, display=True) [source] Plot the model results. If all models applied bootstrap, the plot is a boxplot. If not, the plot is a barplot. Models are ordered based on their score from the top down. The score is either the score_bootstrap or score_test attribute of the model, selected in that order. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Other available options are \"time_bo\", \"time_fit\", \"time_bootstrap\" and \"time\". If str, add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of models. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_confusion_matrix Plot a model's confusion matrix. plot_probabilities Plot the probability distribution of the target classes. plot_threshold Plot metric performances against threshold values.", "title": "plot_results"}, {"location": "API/plots/plot_results/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"GNB\" , \"LR\" , \"RF\" , \"LGB\" ], metric = [ \"f1\" , \"recall\" ]) >>> atom . plot_results () ; >>> atom . run ([ \"GNB\" , \"LR\" , \"RF\" , \"LGB\" ], metric = [ \"f1\" , \"recall\" ], n_bootstrap = 5 ) >>> atom . plot_results () ; >>> atom . plot_results ( metric = \"time_fit+time\" ) ;", "title": "Example"}, {"location": "API/plots/plot_rfecv/", "text": "plot_rfecv method plot_rfecv (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the rfecv results. Plot the scores obtained by the estimator fitted on every subset of the dataset. Only available when feature selection was applied with strategy=\"rfecv\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_components Plot the explained variance ratio per component. plot_pca Plot the explained variance ratio vs number of components. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( \"rfecv\" , solver = \"Tree\" ) >>> atom . plot_rfecv () ;", "title": "plot_rfecv"}, {"location": "API/plots/plot_rfecv/#plot_rfecv", "text": "method plot_rfecv (title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot the rfecv results. Plot the scores obtained by the estimator fitted on every subset of the dataset. Only available when feature selection was applied with strategy=\"rfecv\". Parameters title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_components Plot the explained variance ratio per component. plot_pca Plot the explained variance ratio vs number of components.", "title": "plot_rfecv"}, {"location": "API/plots/plot_rfecv/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . feature_selection ( \"rfecv\" , solver = \"Tree\" ) >>> atom . plot_rfecv () ;", "title": "Example"}, {"location": "API/plots/plot_roc/", "text": "plot_roc method plot_roc (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the Receiver Operating Characteristics curve. Read more about ROC in sklearn's documentation. Only available for classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_gains Plot the cumulative gains curve. plot_lift Plot the lift curve. plot_prc Plot the precision-recall curve. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_roc () ;", "title": "plot_roc"}, {"location": "API/plots/plot_roc/#plot_roc", "text": "method plot_roc (models=None, dataset=\"test\", title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot the Receiver Operating Characteristics curve. Read more about ROC in sklearn's documentation. Only available for classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. dataset: str or sequence, default=\"test\" Data set on which to calculate the metric. Use a sequence or add + between options to select more than one. Choose from: \"train\", \"test\" or \"holdout\". title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_gains Plot the cumulative gains curve. plot_lift Plot the lift curve. plot_prc Plot the precision-recall curve.", "title": "plot_roc"}, {"location": "API/plots/plot_roc/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_roc () ;", "title": "Example"}, {"location": "API/plots/plot_shap_bar/", "text": "plot_shap_bar method plot_shap_bar (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's bar plot. Create a bar plot of a set of SHAP values. If a single sample is passed, then the SHAP values are plotted. If many samples are passed, then the mean absolute value for each feature column is plotted. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_bar() . index: int, str, slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_parshap Plot the partial correlation of shap values. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_scatter Plot SHAP's scatter plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_bar ( show = 10 )", "title": "plot_shap_bar"}, {"location": "API/plots/plot_shap_bar/#plot_shap_bar", "text": "method plot_shap_bar (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's bar plot. Create a bar plot of a set of SHAP values. If a single sample is passed, then the SHAP values are plotted. If many samples are passed, then the mean absolute value for each feature column is plotted. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_bar() . index: int, str, slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_parshap Plot the partial correlation of shap values. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_scatter Plot SHAP's scatter plot.", "title": "plot_shap_bar"}, {"location": "API/plots/plot_shap_bar/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_bar ( show = 10 )", "title": "Example"}, {"location": "API/plots/plot_shap_beeswarm/", "text": "plot_shap_beeswarm method plot_shap_beeswarm (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's beeswarm plot. The plot is colored by feature values. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_beeswarm() . index: tuple, slice or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The beeswarm plot does not support plotting a single sample. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_parshap Plot the partial correlation of shap values. plot_shap_bar Plot SHAP's bar plot. plot_shap_scatter Plot SHAP's scatter plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_beeswarm ( show = 10 )", "title": "plot_shap_beeswarm"}, {"location": "API/plots/plot_shap_beeswarm/#plot_shap_beeswarm", "text": "method plot_shap_beeswarm (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's beeswarm plot. The plot is colored by feature values. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_beeswarm() . index: tuple, slice or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The beeswarm plot does not support plotting a single sample. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_parshap Plot the partial correlation of shap values. plot_shap_bar Plot SHAP's bar plot. plot_shap_scatter Plot SHAP's scatter plot.", "title": "plot_shap_beeswarm"}, {"location": "API/plots/plot_shap_beeswarm/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_beeswarm ( show = 10 )", "title": "Example"}, {"location": "API/plots/plot_shap_decision/", "text": "plot_shap_decision method plot_shap_decision (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's decision plot. Visualize model decisions using cumulative SHAP values. Each plotted line explains a single model prediction. If a single prediction is plotted, feature values are printed in the plot (if supplied). If multiple predictions are plotted together, feature values will not be printed. Plotting too many predictions together will make the plot unintelligible. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_decision() . index: int, str, slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_bar Plot SHAP's bar plot. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_force Plot SHAP's force plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_decision ( show = 10 ) >>> atom . plot_shap_decision ( index =- 1 , show = 10 )", "title": "plot_shap_decision"}, {"location": "API/plots/plot_shap_decision/#plot_shap_decision", "text": "method plot_shap_decision (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's decision plot. Visualize model decisions using cumulative SHAP values. Each plotted line explains a single model prediction. If a single prediction is plotted, feature values are printed in the plot (if supplied). If multiple predictions are plotted together, feature values will not be printed. Plotting too many predictions together will make the plot unintelligible. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_decision() . index: int, str, slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_bar Plot SHAP's bar plot. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_force Plot SHAP's force plot.", "title": "plot_shap_decision"}, {"location": "API/plots/plot_shap_decision/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_decision ( show = 10 ) >>> atom . plot_shap_decision ( index =- 1 , show = 10 )", "title": "Example"}, {"location": "API/plots/plot_shap_force/", "text": "plot_shap_force method plot_shap_force (models=None, index=None, target=1, title=None, legend=None, figsize=(900, 300), filename=None, display=True, **kwargs) [source] Plot SHAP's force plot. Visualize the given SHAP values with an additive force layout. Note that by default this plot will render using javascript. For a regular figure use matplotlib=True (this option is only available when only a single sample is plotted). Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_force() . index: int, str, slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=(900, 300) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. **kwargs Additional keyword arguments for shap.plots.force . Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_scatter Plot SHAP's scatter plot. plot_shap_decision Plot SHAP's decision plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_force ( index =- 2 , matplotlib = True , figsize = ( 1800 , 300 ))", "title": "plot_shap_force"}, {"location": "API/plots/plot_shap_force/#plot_shap_force", "text": "method plot_shap_force (models=None, index=None, target=1, title=None, legend=None, figsize=(900, 300), filename=None, display=True, **kwargs) [source] Plot SHAP's force plot. Visualize the given SHAP values with an additive force layout. Note that by default this plot will render using javascript. For a regular figure use matplotlib=True (this option is only available when only a single sample is plotted). Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_force() . index: int, str, slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=(900, 300) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. **kwargs Additional keyword arguments for shap.plots.force . Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_scatter Plot SHAP's scatter plot. plot_shap_decision Plot SHAP's decision plot.", "title": "plot_shap_force"}, {"location": "API/plots/plot_shap_force/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_force ( index =- 2 , matplotlib = True , figsize = ( 1800 , 300 ))", "title": "Example"}, {"location": "API/plots/plot_shap_heatmap/", "text": "plot_shap_heatmap method plot_shap_heatmap (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's heatmap plot. This plot is designed to show the population substructure of a dataset using supervised clustering and a heatmap. Supervised clustering involves clustering data points not by their original feature values but by their explanations. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_heatmap() . index: slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The plot_shap_heatmap method does not support plotting a single sample. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_decision Plot SHAP's decision plot. plot_shap_force Plot SHAP's force plot. plot_shap_waterfall Plot SHAP's waterfall plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_heatmap ( show = 10 )", "title": "plot_shap_heatmap"}, {"location": "API/plots/plot_shap_heatmap/#plot_shap_heatmap", "text": "method plot_shap_heatmap (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's heatmap plot. This plot is designed to show the population substructure of a dataset using supervised clustering and a heatmap. Supervised clustering involves clustering data points not by their original feature values but by their explanations. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_heatmap() . index: slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The plot_shap_heatmap method does not support plotting a single sample. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_decision Plot SHAP's decision plot. plot_shap_force Plot SHAP's force plot. plot_shap_waterfall Plot SHAP's waterfall plot.", "title": "plot_shap_heatmap"}, {"location": "API/plots/plot_shap_heatmap/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_heatmap ( show = 10 )", "title": "Example"}, {"location": "API/plots/plot_shap_scatter/", "text": "plot_shap_scatter method plot_shap_scatter (models=None, index=None, columns=0, target=1, title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot SHAP's scatter plot. Plots the value of the feature on the x-axis and the SHAP value of the same feature on the y-axis. This shows how the model depends on the given feature, and is like a richer extension of the classical partial dependence plots. Vertical dispersion of the data points represents interaction effects. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_scatter() . index: slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The plot_shap_scatter method does not support plotting a single sample. columns: int or str, default=0 Column to plot. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_decision Plot SHAP's decision plot. plot_shap_force Plot SHAP's force plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_scatter ( columns = \"symmetry error\" )", "title": "plot_shap_scatter"}, {"location": "API/plots/plot_shap_scatter/#plot_shap_scatter", "text": "method plot_shap_scatter (models=None, index=None, columns=0, target=1, title=None, legend=None, figsize=(900, 600), filename=None, display=True) [source] Plot SHAP's scatter plot. Plots the value of the feature on the x-axis and the SHAP value of the same feature on the y-axis. This shows how the model depends on the given feature, and is like a richer extension of the classical partial dependence plots. Vertical dispersion of the data points represents interaction effects. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_scatter() . index: slice, sequence or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The plot_shap_scatter method does not support plotting a single sample. columns: int or str, default=0 Column to plot. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_decision Plot SHAP's decision plot. plot_shap_force Plot SHAP's force plot.", "title": "plot_shap_scatter"}, {"location": "API/plots/plot_shap_scatter/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_scatter ( columns = \"symmetry error\" )", "title": "Example"}, {"location": "API/plots/plot_shap_waterfall/", "text": "plot_shap_waterfall method plot_shap_waterfall (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's waterfall plot. The SHAP value of a feature represents the impact of the evidence provided by that feature on the model\u2019s output. The waterfall plot is designed to visually display how the SHAP values (evidence) of each feature move the model output from our prior expectation under the background data distribution, to the final model prediction given the evidence of all the features. Features are sorted by the magnitude of their SHAP values with the smallest magnitude features grouped together at the bottom of the plot when the number of features in the models exceeds the show parameter. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_waterfall() . index: int, str or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The plot_shap_waterfall method does not support plotting multiple samples. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_bar Plot SHAP's bar plot. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_heatmap Plot SHAP's heatmap plot. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_waterfall ()", "title": "plot_shap_waterfall"}, {"location": "API/plots/plot_shap_waterfall/#plot_shap_waterfall", "text": "method plot_shap_waterfall (models=None, index=None, show=None, target=1, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot SHAP's waterfall plot. The SHAP value of a feature represents the impact of the evidence provided by that feature on the model\u2019s output. The waterfall plot is designed to visually display how the SHAP values (evidence) of each feature move the model output from our prior expectation under the background data distribution, to the final model prediction given the evidence of all the features. Features are sorted by the magnitude of their SHAP values with the smallest magnitude features grouped together at the bottom of the plot when the number of features in the models exceeds the show parameter. Read more about SHAP plots in the user guide . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_shap_waterfall() . index: int, str or None, default=None Rows in the dataset to plot. If None, it selects all rows in the test set. The plot_shap_waterfall method does not support plotting multiple samples. show: int or None, default=None Number of features (ordered by importance) to show. If None, it shows all features. target: int or str, default=1 Class in the target column to look at (only for multi-class classification tasks). title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of features shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns plt.Figure or None Plot object. Only returned if display=None . See Also plot_shap_bar Plot SHAP's bar plot. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_heatmap Plot SHAP's heatmap plot.", "title": "plot_shap_waterfall"}, {"location": "API/plots/plot_shap_waterfall/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"LR\" ) >>> atom . plot_shap_waterfall ()", "title": "Example"}, {"location": "API/plots/plot_slice/", "text": "plot_slice method plot_slice (models=None, params=None, metric=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot the parameter relationship in a study. The color of the markers indicate the trial. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_slice() . params: str, slice, sequence or None, default=None Hyperparameters to plot. Use a sequence or add + between options to select more than one. If None, all the model's hyperparameters are selected. metric: int or str, default=None Metric to plot (only for multi-metric runs). If str, add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_edf Plot the Empirical Distribution Function of a study. plot_hyperparameters Plot hyperparameter relationships in a study. plot_parallel_coordinate Plot high-dimensional parameter relationships in a study. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" , metric = [ \"f1\" , \"recall\" ], n_trials = 15 ) >>> atom . plot_slice ( params = ( 0 , 1 , 2 )) ;", "title": "plot_slice"}, {"location": "API/plots/plot_slice/#plot_slice", "text": "method plot_slice (models=None, params=None, metric=None, title=None, legend=None, figsize=None, filename=None, display=True) [source] Plot the parameter relationship in a study. The color of the markers indicate the trial. This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model or None, default=None Model to plot. If None, all models are selected. Note that leaving the default option could raise an exception if there are multiple models. To avoid this, call the plot directly from a model, e.g. atom.lr.plot_slice() . params: str, slice, sequence or None, default=None Hyperparameters to plot. Use a sequence or add + between options to select more than one. If None, all the model's hyperparameters are selected. metric: int or str, default=None Metric to plot (only for multi-metric runs). If str, add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of hyperparameters shown. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_edf Plot the Empirical Distribution Function of a study. plot_hyperparameters Plot hyperparameter relationships in a study. plot_parallel_coordinate Plot high-dimensional parameter relationships in a study.", "title": "plot_slice"}, {"location": "API/plots/plot_slice/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . run ( \"RF\" , metric = [ \"f1\" , \"recall\" ], n_trials = 15 ) >>> atom . plot_slice ( params = ( 0 , 1 , 2 )) ;", "title": "Example"}, {"location": "API/plots/plot_successive_halving/", "text": "plot_successive_halving method plot_successive_halving (models=None, metric=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot scores per iteration of the successive halving. Only use with models fitted using successive halving . Ensembles are ignored. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Use a sequence or add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_learning_curve Plot the learning curve: score vs number of training samples. plot_results Plot the model results. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . successive_halving ([ \"Tree\" , \"Bag\" , \"RF\" , \"LGB\" ], n_bootstrap = 5 ) >>> atom . plot_successive_halving () ;", "title": "plot_successive_halving"}, {"location": "API/plots/plot_successive_halving/#plot_successive_halving", "text": "method plot_successive_halving (models=None, metric=None, title=None, legend=\"lower right\", figsize=(900, 600), filename=None, display=True) [source] Plot scores per iteration of the successive halving. Only use with models fitted using successive halving . Ensembles are ignored. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Use a sequence or add + between options to select more than one. If None, the metric used to run the pipeline is selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower right\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_learning_curve Plot the learning curve: score vs number of training samples. plot_results Plot the model results.", "title": "plot_successive_halving"}, {"location": "API/plots/plot_successive_halving/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> atom = ATOMClassifier ( X , y ) >>> atom . successive_halving ([ \"Tree\" , \"Bag\" , \"RF\" , \"LGB\" ], n_bootstrap = 5 ) >>> atom . plot_successive_halving () ;", "title": "Example"}, {"location": "API/plots/plot_threshold/", "text": "plot_threshold method plot_threshold (models=None, metric=None, dataset=\"test\", steps=100, title=None, legend=\"lower left\", figsize=(900, 600), filename=None, display=True) [source] Plot metric performances against threshold values. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: str, func, scorer, sequence or None, default=None Metric to plot. Choose from any of sklearn's scorers, a function with signature metric(y_true, y_pred) , a scorer object or a sequence of these. Use a sequence or add + between options to select more than one. If None, the metric used to run the pipeline is selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". steps: int, default=100 Number of thresholds measured. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_calibration Plot the calibration curve for a binary classifier. plot_confusion_matrix Plot a model's confusion matrix. plot_probabilities Plot the probability distribution of the target classes. Example >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_threshold () ;", "title": "plot_threshold"}, {"location": "API/plots/plot_threshold/#plot_threshold", "text": "method plot_threshold (models=None, metric=None, dataset=\"test\", steps=100, title=None, legend=\"lower left\", figsize=(900, 600), filename=None, display=True) [source] Plot metric performances against threshold values. Only available for binary classification tasks. Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models are selected. metric: str, func, scorer, sequence or None, default=None Metric to plot. Choose from any of sklearn's scorers, a function with signature metric(y_true, y_pred) , a scorer object or a sequence of these. Use a sequence or add + between options to select more than one. If None, the metric used to run the pipeline is selected. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". steps: int, default=100 Number of thresholds measured. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"lower left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_calibration Plot the calibration curve for a binary classifier. plot_confusion_matrix Plot a model's confusion matrix. plot_probabilities Plot the probability distribution of the target classes.", "title": "plot_threshold"}, {"location": "API/plots/plot_threshold/#example", "text": ">>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ]) >>> atom . plot_threshold () ;", "title": "Example"}, {"location": "API/plots/plot_trials/", "text": "plot_trials method plot_trials (models=None, metric=None, title=None, legend=\"upper left\", figsize=(900, 800), filename=None, display=True) [source] Plot the hyperparameter tuning trials. Creates a figure with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. The best trial is indicated with a star. This is the same plot as produced by ht_params={\"plot\": True} . This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Add + between options to select more than one. If None, all metrics are selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 800) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_evals Plot evaluation curves. plot_hyperparameters Plot hyperparameter relationships in a study. plot_results Plot the model results. Example >>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ], n_trials = 15 ) >>> atom . plot_trials () ;", "title": "plot_trials"}, {"location": "API/plots/plot_trials/#plot_trials", "text": "method plot_trials (models=None, metric=None, title=None, legend=\"upper left\", figsize=(900, 800), filename=None, display=True) [source] Plot the hyperparameter tuning trials. Creates a figure with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. The best trial is indicated with a star. This is the same plot as produced by ht_params={\"plot\": True} . This plot is only available for models that ran hyperparameter tuning . Parameters models: int, str, Model, slice, sequence or None, default=None Models to plot. If None, all models that used hyperparameter tuning are selected. metric: int, str, sequence or None, default=None Metric to plot (only for multi-metric runs). Add + between options to select more than one. If None, all metrics are selected. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=\"upper left\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple, default=(900, 800) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_evals Plot evaluation curves. plot_hyperparameters Plot hyperparameter relationships in a study. plot_results Plot the model results.", "title": "plot_trials"}, {"location": "API/plots/plot_trials/#example", "text": ">>> from atom import ATOMClassifier >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1e4 ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"LR\" , \"RF\" ], n_trials = 15 ) >>> atom . plot_trials () ;", "title": "Example"}, {"location": "API/plots/plot_wordcloud/", "text": "plot_wordcloud method plot_wordcloud (index=None, title=None, legend=None, figsize=(900, 600), filename=None, display=True, **kwargs) [source] Plot a wordcloud from the corpus. The text for the plot is extracted from the column named corpus . If there is no column with that name, an exception is raised. Parameters index: int, str, slice, sequence or None, default=None Documents in the corpus to include in the wordcloud. If None, it selects all documents in the dataset. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. **kwargs Additional keyword arguments for the Wordcloud object. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_ngrams Plot n-gram frequencies. plot_pipeline Plot a diagram of the pipeline. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> atom = ATOMClassifier ( X , y ) >>> atom . textclean () >>> atom . textnormalize () >>> atom . plot_wordcloud () ;", "title": "plot_wordcloud"}, {"location": "API/plots/plot_wordcloud/#plot_wordcloud", "text": "method plot_wordcloud (index=None, title=None, legend=None, figsize=(900, 600), filename=None, display=True, **kwargs) [source] Plot a wordcloud from the corpus. The text for the plot is extracted from the column named corpus . If there is no column with that name, an exception is raised. Parameters index: int, str, slice, sequence or None, default=None Documents in the corpus to include in the wordcloud. If None, it selects all documents in the dataset. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: str, dict or None, default=None Does nothing. Implemented for continuity of the API. figsize: tuple, default=(900, 600) Figure's size in pixels, format as (x, y). filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool or None, default=True Whether to render the plot. If None, it returns the figure. **kwargs Additional keyword arguments for the Wordcloud object. Returns go.Figure or None Plot object. Only returned if display=None . See Also plot_ngrams Plot n-gram frequencies. plot_pipeline Plot a diagram of the pipeline.", "title": "plot_wordcloud"}, {"location": "API/plots/plot_wordcloud/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import fetch_20newsgroups >>> X , y = fetch_20newsgroups ( ... return_X_y = True , ... categories = [ ... 'alt.atheism' , ... 'sci.med' , ... 'comp.windows.x' , ... ], ... shuffle = True , ... random_state = 1 , ... ) >>> X = np . array ( X ) . reshape ( - 1 , 1 ) >>> atom = ATOMClassifier ( X , y ) >>> atom . textclean () >>> atom . textnormalize () >>> atom . plot_wordcloud () ;", "title": "Example"}, {"location": "API/predicting/decision_function/", "text": "decision_function method decision_function (X, verbose=None) [source] Get confidence scores on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a decision_function method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.Series or pd.DataFrame Predicted confidence scores, with shape=(n_samples,) for binary classification tasks and (n_samples, n_classes) for multiclass classification tasks. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . lr . decision_function ( X_new ) 0 -20.872124 1 -13.856470 2 -4.496618 3 -23.196171 4 10.066044 Name: decision_function, dtype: float64 >>> # Using indices >>> atom . lr . decision_function ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 23 -15.286529 25 -4.457036 dtype: float64", "title": "decision_function"}, {"location": "API/predicting/decision_function/#decision_function", "text": "method decision_function (X, verbose=None) [source] Get confidence scores on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a decision_function method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.Series or pd.DataFrame Predicted confidence scores, with shape=(n_samples,) for binary classification tasks and (n_samples, n_classes) for multiclass classification tasks.", "title": "decision_function"}, {"location": "API/predicting/decision_function/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . lr . decision_function ( X_new ) 0 -20.872124 1 -13.856470 2 -4.496618 3 -23.196171 4 10.066044 Name: decision_function, dtype: float64 >>> # Using indices >>> atom . lr . decision_function ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 23 -15.286529 25 -4.457036 dtype: float64", "title": "Example"}, {"location": "API/predicting/predict/", "text": "predict method predict (X, verbose=None) [source] Get class predictions on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a predict method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.Series Predicted classes with shape=(n_samples,). Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . predict ( X_new ) 0 0 1 0 2 0 3 0 4 1 Name: predict, dtype: int32 >>> # Using indices >>> atom . predict ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 23 1 25 1 dtype: int32", "title": "predict"}, {"location": "API/predicting/predict/#predict", "text": "method predict (X, verbose=None) [source] Get class predictions on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a predict method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.Series Predicted classes with shape=(n_samples,).", "title": "predict"}, {"location": "API/predicting/predict/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . predict ( X_new ) 0 0 1 0 2 0 3 0 4 1 Name: predict, dtype: int32 >>> # Using indices >>> atom . predict ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 23 1 25 1 dtype: int32", "title": "Example"}, {"location": "API/predicting/predict_log_proba/", "text": "predict_log_proba method predict_log_proba (X, verbose=None) [source] Get class log-probabilities on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a predict_log_proba method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Predicted class log-probabilities with shape=(n_samples, n_classes). Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . predict_log_proba ( X_new ) 0 1 0 -6.024211e-10 -21.230064 1 -3.525172e-07 -14.858167 2 -1.285206e-02 -4.360670 3 -6.837442e-11 -23.406023 4 -1.076932e+01 -0.000021 >>> # Using indices >>> atom . predict_log_proba ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 0 1 23 -4.191844 -0.015234 25 -5.207398 -0.005491", "title": "predict_log_proba"}, {"location": "API/predicting/predict_log_proba/#predict_log_proba", "text": "method predict_log_proba (X, verbose=None) [source] Get class log-probabilities on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a predict_log_proba method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Predicted class log-probabilities with shape=(n_samples, n_classes).", "title": "predict_log_proba"}, {"location": "API/predicting/predict_log_proba/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . predict_log_proba ( X_new ) 0 1 0 -6.024211e-10 -21.230064 1 -3.525172e-07 -14.858167 2 -1.285206e-02 -4.360670 3 -6.837442e-11 -23.406023 4 -1.076932e+01 -0.000021 >>> # Using indices >>> atom . predict_log_proba ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 0 1 23 -4.191844 -0.015234 25 -5.207398 -0.005491", "title": "Example"}, {"location": "API/predicting/predict_proba/", "text": "predict_proba method predict_proba (X, verbose=None) [source] Get class probabilities on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a predict_proba method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Predicted class probabilities with shape=(n_samples, n_classes). Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . predict_proba ( X_new ) 0 1 0 1.000000 4.036791e-10 1 1.000000 4.856420e-07 2 0.981879 1.812090e-02 3 1.000000 6.081561e-11 4 0.000025 9.999746e-01 >>> # Using indices >>> atom . predict_proba ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 0 1 23 0.000892 0.999108 25 0.975733 0.024267", "title": "predict_proba"}, {"location": "API/predicting/predict_proba/#predict_proba", "text": "method predict_proba (X, verbose=None) [source] Get class probabilities on new data or rows in the dataset. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. The estimator must have a predict_proba method. Read more in the user guide . Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns pd.DataFrame Predicted class probabilities with shape=(n_samples, n_classes).", "title": "predict_proba"}, {"location": "API/predicting/predict_proba/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" ) >>> # Using new data >>> atom . predict_proba ( X_new ) 0 1 0 1.000000 4.036791e-10 1 1.000000 4.856420e-07 2 0.981879 1.812090e-02 3 1.000000 6.081561e-11 4 0.000025 9.999746e-01 >>> # Using indices >>> atom . predict_proba ([ 23 , 25 ]) # Retrieve prediction of rows 23 and 25 0 1 23 0.000892 0.999108 25 0.975733 0.024267", "title": "Example"}, {"location": "API/predicting/score/", "text": "score method score (X, y=None, metric=None, sample_weight=None, verbose=None) [source] Get a metric score on new data. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. If called from atom, the best model (under the winner attribute) is used. If called from a model, that model is used. Read more in the user guide . Info If the metric parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators. Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature metric(y_true, y_pred) -> score or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs ). sample_weight: sequence or None, default=None Sample weights corresponding to y. verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns float Metric score of X with respect to y. Example >>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" , metric = \"f1\" ) >>> # Using new data >>> atom . score ( X_new , y_new ) 1.0 >>> # Using indices >>> atom . score ( slice ( 10 , 92 )) 0.975609756097561 >>> # Using a custom metric >>> atom . score ( slice ( 10 , 92 )) 0.9824561403508771 # f1 score", "title": "score"}, {"location": "API/predicting/score/#score", "text": "method score (X, y=None, metric=None, sample_weight=None, verbose=None) [source] Get a metric score on new data. New data is first transformed through the model's pipeline. Transformers that are only applied on the training set are skipped. If called from atom, the best model (under the winner attribute) is used. If called from a model, that model is used. Read more in the user guide . Info If the metric parameter is left to its default value, the method returns atom's metric score, not the metric returned by sklearn's score method for estimators. Parameters X: int, str, slice, sequence or dataframe-like Names or indices of rows in the dataset, or new feature set with shape=(n_samples, n_features). y: int, str or sequence Target column corresponding to X. - If int: Position of the target column in X. - If str: Name of the target column in X. - Else: Array with shape=(n_samples,) to use as target. metric: str, func, scorer or None, default=None Metric to calculate. Choose from any of sklearn's scorers, a function with signature metric(y_true, y_pred) -> score or a scorer object. If None, it uses atom's metric (the main metric for multi-metric runs ). sample_weight: sequence or None, default=None Sample weights corresponding to y. verbose: int or None, default=None Verbosity level of the output. If None, it uses the transformer's own verbosity. Returns float Metric score of X with respect to y.", "title": "score"}, {"location": "API/predicting/score/#example", "text": ">>> from atom import ATOMClassifier >>> from sklearn.datasets import load_breast_cancer >>> # Load data and separate last 5 rows for predictions >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> X_new , y_new = X . iloc [ - 5 :], y . iloc [ - 5 :] >>> X , y = X . iloc [: - 5 ], y . iloc [: - 5 ] >>> atom = ATOMClassifier ( data ) >>> atom . run ( \"LR\" , metric = \"f1\" ) >>> # Using new data >>> atom . score ( X_new , y_new ) 1.0 >>> # Using indices >>> atom . score ( slice ( 10 , 92 )) 0.975609756097561 >>> # Using a custom metric >>> atom . score ( slice ( 10 , 92 )) 0.9824561403508771 # f1 score", "title": "Example"}, {"location": "API/training/directclassifier/", "text": "DirectClassifier class atom.training. DirectClassifier (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a direct fashion. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMClassifier Main class for binary and multiclass classification tasks. SuccessiveHalvingClassifier Train and evaluate the models in a successive halving fashion. TrainSizingClassifier Train and evaluate the models in a train sizing fashion. Example >>> from atom.training import DirectClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = DirectClassifier ( models = [ \"LR\" , \"RF\" ], metric = \"auc\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Models: LR, RF Metric: roc_auc Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9925 Test evaluation --> roc_auc: 0.9871 Time elapsed: 0.035s ------------------------------------------------- Total time: 0.035s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9807 Time elapsed: 0.137s ------------------------------------------------- Total time: 0.137s Final results ==================== >> Total time: 0.173s ------------------------------------- LogisticRegression --> roc_auc: 0.9871 ! RandomForest --> roc_auc: 0.9807 >>> # Analyze the results >>> runner . evaluate () accuracy average_precision ... precision recall roc_auc LR 0.9357 0.9923 ... 0.9533 0.9444 0.9325 RF 0.9532 0.9810 ... 0.9464 0.9815 0.9431 [2 rows x 9 columns] Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Methods Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "DirectClassifier"}, {"location": "API/training/directclassifier/#directclassifier", "text": "class atom.training. DirectClassifier (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a direct fashion. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMClassifier Main class for binary and multiclass classification tasks. SuccessiveHalvingClassifier Train and evaluate the models in a successive halving fashion. TrainSizingClassifier Train and evaluate the models in a train sizing fashion.", "title": "DirectClassifier"}, {"location": "API/training/directclassifier/#example", "text": ">>> from atom.training import DirectClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = DirectClassifier ( models = [ \"LR\" , \"RF\" ], metric = \"auc\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Models: LR, RF Metric: roc_auc Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9925 Test evaluation --> roc_auc: 0.9871 Time elapsed: 0.035s ------------------------------------------------- Total time: 0.035s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9807 Time elapsed: 0.137s ------------------------------------------------- Total time: 0.137s Final results ==================== >> Total time: 0.173s ------------------------------------- LogisticRegression --> roc_auc: 0.9871 ! RandomForest --> roc_auc: 0.9807 >>> # Analyze the results >>> runner . evaluate () accuracy average_precision ... precision recall roc_auc LR 0.9357 0.9923 ... 0.9533 0.9444 0.9325 RF 0.9532 0.9810 ... 0.9464 0.9815 0.9431 [2 rows x 9 columns]", "title": "Example"}, {"location": "API/training/directclassifier/#attributes", "text": "", "title": "Attributes"}, {"location": "API/training/directclassifier/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/training/directclassifier/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/training/directclassifier/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/training/directclassifier/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/training/directclassifier/#methods", "text": "Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Methods"}, {"location": "API/training/directregressor/", "text": "DirectRegressor class atom.training. DirectRegressor (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a direct fashion. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion. TrainSizingRegressor Train and evaluate the models in a train sizing fashion. Example >>> from atom.training import DirectRegressor >>> from sklearn.datasets import load_digits >>> X , y = load_digits ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = DirectClassifier ( models = [ \"OLS\" , \"RF\" ], metric = \"r2\" , verbose = 2 ) >>> runner . run ( train , test ) Models: OLS, RF Metric: r2 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.5881 Test evaluation --> r2: 0.6029 Time elapsed: 0.022s ------------------------------------------------- Total time: 0.022s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> r2: 0.981 Test evaluation --> r2: 0.8719 Time elapsed: 0.838s ------------------------------------------------- Total time: 0.838s Final results ==================== >> Total time: 0.862s ------------------------------------- OrdinaryLeastSquares --> r2: 0.6029 RandomForest --> r2: 0.8719 ! >>> # Analyze the results >>> runner . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS -1.4124 ... -1.8109 RF -0.6569 ... -1.0692 [2 rows x 6 columns] Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Methods Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "DirectRegressor"}, {"location": "API/training/directregressor/#directregressor", "text": "class atom.training. DirectRegressor (models=None, metric=None, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a direct fashion. The following steps are applied to every model: Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion. TrainSizingRegressor Train and evaluate the models in a train sizing fashion.", "title": "DirectRegressor"}, {"location": "API/training/directregressor/#example", "text": ">>> from atom.training import DirectRegressor >>> from sklearn.datasets import load_digits >>> X , y = load_digits ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = DirectClassifier ( models = [ \"OLS\" , \"RF\" ], metric = \"r2\" , verbose = 2 ) >>> runner . run ( train , test ) Models: OLS, RF Metric: r2 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.5881 Test evaluation --> r2: 0.6029 Time elapsed: 0.022s ------------------------------------------------- Total time: 0.022s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> r2: 0.981 Test evaluation --> r2: 0.8719 Time elapsed: 0.838s ------------------------------------------------- Total time: 0.838s Final results ==================== >> Total time: 0.862s ------------------------------------- OrdinaryLeastSquares --> r2: 0.6029 RandomForest --> r2: 0.8719 ! >>> # Analyze the results >>> runner . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS -1.4124 ... -1.8109 RF -0.6569 ... -1.0692 [2 rows x 6 columns]", "title": "Example"}, {"location": "API/training/directregressor/#attributes", "text": "", "title": "Attributes"}, {"location": "API/training/directregressor/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/training/directregressor/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/training/directregressor/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/training/directregressor/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/training/directregressor/#methods", "text": "Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Methods"}, {"location": "API/training/successivehalvingclassifier/", "text": "SuccessiveHalvingClassifier class atom.training. SuccessiveHalvingClassifier (models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a successive halving fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression skip_runs: int, default=0 Skip last skip_runs runs of the successive halving. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMClassifier Main class for binary and multiclass classification tasks. DirectClassifier Train and evaluate the models in a direct fashion. TrainSizingClassifier Train and evaluate the models in a train sizing fashion. Example >>> from atom.training import SuccessiveHalvingClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = SuccessiveHalvingClassifier ([ \"LR\" , \"RF\" ], metric = \"auc\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: roc_auc Run: 0 ================================ >> Models: LR2, RF2 Size of training set: 398 (50%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.984 Test evaluation --> roc_auc: 0.9793 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9805 Time elapsed: 0.113s ------------------------------------------------- Total time: 0.113s Final results ==================== >> Total time: 0.131s ------------------------------------- LogisticRegression --> roc_auc: 0.9793 RandomForest --> roc_auc: 0.9805 ! Run: 1 ================================ >> Models: RF1 Size of training set: 398 (100%) Size of test set: 171 Results for RandomForest: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9806 Time elapsed: 0.137s ------------------------------------------------- Total time: 0.137s Final results ==================== >> Total time: 0.137s ------------------------------------- RandomForest --> roc_auc: 0.9806 >>> # Analyze the results >>> runner . evaluate () accuracy average_precision ... precision recall roc_auc LR2 0.9006 0.9878 ... 0.9099 0.9352 0.9793 RF2 0.9474 0.9800 ... 0.9381 0.9815 0.9805 RF1 0.9532 0.9806 ... 0.9545 0.9722 0.9806 [3 rows x 9 columns] Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Methods Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "SuccessiveHalvingClassifier"}, {"location": "API/training/successivehalvingclassifier/#successivehalvingclassifier", "text": "class atom.training. SuccessiveHalvingClassifier (models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a successive halving fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression skip_runs: int, default=0 Skip last skip_runs runs of the successive halving. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMClassifier Main class for binary and multiclass classification tasks. DirectClassifier Train and evaluate the models in a direct fashion. TrainSizingClassifier Train and evaluate the models in a train sizing fashion.", "title": "SuccessiveHalvingClassifier"}, {"location": "API/training/successivehalvingclassifier/#example", "text": ">>> from atom.training import SuccessiveHalvingClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = SuccessiveHalvingClassifier ([ \"LR\" , \"RF\" ], metric = \"auc\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: roc_auc Run: 0 ================================ >> Models: LR2, RF2 Size of training set: 398 (50%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.984 Test evaluation --> roc_auc: 0.9793 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9805 Time elapsed: 0.113s ------------------------------------------------- Total time: 0.113s Final results ==================== >> Total time: 0.131s ------------------------------------- LogisticRegression --> roc_auc: 0.9793 RandomForest --> roc_auc: 0.9805 ! Run: 1 ================================ >> Models: RF1 Size of training set: 398 (100%) Size of test set: 171 Results for RandomForest: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9806 Time elapsed: 0.137s ------------------------------------------------- Total time: 0.137s Final results ==================== >> Total time: 0.137s ------------------------------------- RandomForest --> roc_auc: 0.9806 >>> # Analyze the results >>> runner . evaluate () accuracy average_precision ... precision recall roc_auc LR2 0.9006 0.9878 ... 0.9099 0.9352 0.9793 RF2 0.9474 0.9800 ... 0.9381 0.9815 0.9805 RF1 0.9532 0.9806 ... 0.9545 0.9722 0.9806 [3 rows x 9 columns]", "title": "Example"}, {"location": "API/training/successivehalvingclassifier/#attributes", "text": "", "title": "Attributes"}, {"location": "API/training/successivehalvingclassifier/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/training/successivehalvingclassifier/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/training/successivehalvingclassifier/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/training/successivehalvingclassifier/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/training/successivehalvingclassifier/#methods", "text": "Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Methods"}, {"location": "API/training/successivehalvingregressor/", "text": "SuccessiveHalvingRegressor class atom.training. SuccessiveHalvingRegressor (models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a successive halving fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression skip_runs: int, default=0 Skip last skip_runs runs of the successive halving. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. DirectRegressor Train and evaluate the models in a direct fashion. TrainSizingRegressor Train and evaluate the models in a train sizing fashion. Example >>> from atom.training import SuccessiveHalvingRegressor >>> from sklearn.datasets import load_digits >>> X , y = load_digits ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = SuccessiveHalvingRegressor ([ \"OLS\" , \"RF\" ], metric = \"r2\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: r2 Run: 0 =========================== >> Models: OLS2, RF2 Size of training set: 398 (50%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7878 Test evaluation --> r2: 0.6764 Time elapsed: 0.007s ------------------------------------------------- Total time: 0.007s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> r2: 0.9755 Test evaluation --> r2: 0.8189 Time elapsed: 0.132s ------------------------------------------------- Total time: 0.132s Final results ==================== >> Total time: 0.140s ------------------------------------- OrdinaryLeastSquares --> r2: 0.6764 RandomForest --> r2: 0.8189 ! Run: 1 =========================== >> Models: RF1 Size of training set: 398 (100%) Size of test set: 171 Results for RandomForest: Fit --------------------------------------------- Train evaluation --> r2: 0.9803 Test evaluation --> r2: 0.8092 Time elapsed: 0.217s ------------------------------------------------- Total time: 0.217s Final results ==================== >> Total time: 0.217s ------------------------------------- RandomForest --> r2: 0.8092 >>> # Analyze the results >>> runner . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS2 -0.1982 ... -0.2744 RF2 -0.0970 ... -0.2053 RF1 -0.0974 ... -0.2107 [3 rows x 6 columns] Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Methods Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "SuccessiveHalvingRegressor"}, {"location": "API/training/successivehalvingregressor/#successivehalvingregressor", "text": "class atom.training. SuccessiveHalvingRegressor (models=None, metric=None, skip_runs=0, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a successive halving fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression skip_runs: int, default=0 Skip last skip_runs runs of the successive halving. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. DirectRegressor Train and evaluate the models in a direct fashion. TrainSizingRegressor Train and evaluate the models in a train sizing fashion.", "title": "SuccessiveHalvingRegressor"}, {"location": "API/training/successivehalvingregressor/#example", "text": ">>> from atom.training import SuccessiveHalvingRegressor >>> from sklearn.datasets import load_digits >>> X , y = load_digits ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = SuccessiveHalvingRegressor ([ \"OLS\" , \"RF\" ], metric = \"r2\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: r2 Run: 0 =========================== >> Models: OLS2, RF2 Size of training set: 398 (50%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7878 Test evaluation --> r2: 0.6764 Time elapsed: 0.007s ------------------------------------------------- Total time: 0.007s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> r2: 0.9755 Test evaluation --> r2: 0.8189 Time elapsed: 0.132s ------------------------------------------------- Total time: 0.132s Final results ==================== >> Total time: 0.140s ------------------------------------- OrdinaryLeastSquares --> r2: 0.6764 RandomForest --> r2: 0.8189 ! Run: 1 =========================== >> Models: RF1 Size of training set: 398 (100%) Size of test set: 171 Results for RandomForest: Fit --------------------------------------------- Train evaluation --> r2: 0.9803 Test evaluation --> r2: 0.8092 Time elapsed: 0.217s ------------------------------------------------- Total time: 0.217s Final results ==================== >> Total time: 0.217s ------------------------------------- RandomForest --> r2: 0.8092 >>> # Analyze the results >>> runner . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS2 -0.1982 ... -0.2744 RF2 -0.0970 ... -0.2053 RF1 -0.0974 ... -0.2107 [3 rows x 6 columns]", "title": "Example"}, {"location": "API/training/successivehalvingregressor/#attributes", "text": "", "title": "Attributes"}, {"location": "API/training/successivehalvingregressor/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/training/successivehalvingregressor/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/training/successivehalvingregressor/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/training/successivehalvingregressor/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/training/successivehalvingregressor/#methods", "text": "Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Methods"}, {"location": "API/training/trainsizingclassifier/", "text": "TrainSizingClassifier class atom.training. TrainSizingClassifier (models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a train sizing fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression train_sizes: int or sequence, default=5 Sequence of training set sizes used to run the trainings. If int: Number of equally distributed splits, i.e. for a value N , it's equal to np.linspace(1.0/N, 1.0, N) . If sequence: Fraction of the training set when <=1, else total number of samples. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. DirectRegressor Train and evaluate the models in a direct fashion. SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion. Example >>> from atom.training import TrainSizingClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = TrainSizingClassifier ( models = \"LR\" , metric = \"auc\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: roc_auc Run: 0 =========================== >> Models: LR02 Size of training set: 79 (20%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9846 Test evaluation --> roc_auc: 0.9737 Time elapsed: 0.017s ------------------------------------------------- Total time: 0.017s Final results ==================== >> Total time: 0.018s ------------------------------------- LogisticRegression --> roc_auc: 0.9737 Run: 1 =========================== >> Models: LR04 Size of training set: 159 (40%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9855 Test evaluation --> roc_auc: 0.9838 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Final results ==================== >> Total time: 0.019s ------------------------------------- LogisticRegression --> roc_auc: 0.9838 Run: 2 =========================== >> Models: LR06 Size of training set: 238 (60%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9898 Test evaluation --> roc_auc: 0.9813 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Final results ==================== >> Total time: 0.018s ------------------------------------- LogisticRegression --> roc_auc: 0.9813 Run: 3 =========================== >> Models: LR08 Size of training set: 318 (80%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9936 Test evaluation --> roc_auc: 0.9816 Time elapsed: 0.038s ------------------------------------------------- Total time: 0.038s Final results ==================== >> Total time: 0.038s ------------------------------------- LogisticRegression --> roc_auc: 0.9816 Run: 4 =========================== >> Models: LR10 Size of training set: 398 (100%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9925 Test evaluation --> roc_auc: 0.9871 Time elapsed: 0.040s ------------------------------------------------- Total time: 0.040s Final results ==================== >> Total time: 0.041s ------------------------------------- LogisticRegression --> roc_auc: 0.9871 >>> # Analyze the results >>> runner . evaluate () accuracy average_precision ... recall roc_auc LR02 0.8947 0.9835 ... 0.8981 0.9737 LR04 0.9181 0.9907 ... 0.9352 0.9838 LR06 0.9415 0.9888 ... 0.9444 0.9813 LR08 0.9474 0.9878 ... 0.9630 0.9816 LR10 0.9357 0.9923 ... 0.9444 0.9871 [5 rows x 9 columns] Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Methods Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "TrainSizingClassifier"}, {"location": "API/training/trainsizingclassifier/#trainsizingclassifier", "text": "class atom.training. TrainSizingClassifier (models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a train sizing fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression train_sizes: int or sequence, default=5 Sequence of training set sizes used to run the trainings. If int: Number of equally distributed splits, i.e. for a value N , it's equal to np.linspace(1.0/N, 1.0, N) . If sequence: Fraction of the training set when <=1, else total number of samples. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. DirectRegressor Train and evaluate the models in a direct fashion. SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion.", "title": "TrainSizingClassifier"}, {"location": "API/training/trainsizingclassifier/#example", "text": ">>> from atom.training import TrainSizingClassifier >>> from sklearn.datasets import load_breast_cancer >>> X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = TrainSizingClassifier ( models = \"LR\" , metric = \"auc\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: roc_auc Run: 0 =========================== >> Models: LR02 Size of training set: 79 (20%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9846 Test evaluation --> roc_auc: 0.9737 Time elapsed: 0.017s ------------------------------------------------- Total time: 0.017s Final results ==================== >> Total time: 0.018s ------------------------------------- LogisticRegression --> roc_auc: 0.9737 Run: 1 =========================== >> Models: LR04 Size of training set: 159 (40%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9855 Test evaluation --> roc_auc: 0.9838 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Final results ==================== >> Total time: 0.019s ------------------------------------- LogisticRegression --> roc_auc: 0.9838 Run: 2 =========================== >> Models: LR06 Size of training set: 238 (60%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9898 Test evaluation --> roc_auc: 0.9813 Time elapsed: 0.018s ------------------------------------------------- Total time: 0.018s Final results ==================== >> Total time: 0.018s ------------------------------------- LogisticRegression --> roc_auc: 0.9813 Run: 3 =========================== >> Models: LR08 Size of training set: 318 (80%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9936 Test evaluation --> roc_auc: 0.9816 Time elapsed: 0.038s ------------------------------------------------- Total time: 0.038s Final results ==================== >> Total time: 0.038s ------------------------------------- LogisticRegression --> roc_auc: 0.9816 Run: 4 =========================== >> Models: LR10 Size of training set: 398 (100%) Size of test set: 171 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9925 Test evaluation --> roc_auc: 0.9871 Time elapsed: 0.040s ------------------------------------------------- Total time: 0.040s Final results ==================== >> Total time: 0.041s ------------------------------------- LogisticRegression --> roc_auc: 0.9871 >>> # Analyze the results >>> runner . evaluate () accuracy average_precision ... recall roc_auc LR02 0.8947 0.9835 ... 0.8981 0.9737 LR04 0.9181 0.9907 ... 0.9352 0.9838 LR06 0.9415 0.9888 ... 0.9444 0.9813 LR08 0.9474 0.9878 ... 0.9630 0.9816 LR10 0.9357 0.9923 ... 0.9444 0.9871 [5 rows x 9 columns]", "title": "Example"}, {"location": "API/training/trainsizingclassifier/#attributes", "text": "", "title": "Attributes"}, {"location": "API/training/trainsizingclassifier/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/training/trainsizingclassifier/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/training/trainsizingclassifier/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/training/trainsizingclassifier/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/training/trainsizingclassifier/#methods", "text": "Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Methods"}, {"location": "API/training/trainsizingregressor/", "text": "TrainSizingRegressor class atom.training. TrainSizingRegressor (models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a train sizing fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression train_sizes: int or sequence, default=5 Sequence of training set sizes used to run the trainings. If int: Number of equally distributed splits, i.e. for a value N , it's equal to np.linspace(1.0/N, 1.0, N) . If sequence: Fraction of the training set when <=1, else total number of samples. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. DirectRegressor Train and evaluate the models in a direct fashion. SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion. Example >>> from atom.training import TrainSizingRegressor >>> from sklearn.datasets import load_digits >>> X , y = load_digits ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = TrainSizingRegressor ( models = \"OLS\" , metric = \"r2\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: r2 Run: 0 =========================== >> Models: OLS02 Size of training set: 79 (20%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.8554 Test evaluation --> r2: 0.4273 Time elapsed: 0.008s ------------------------------------------------- Total time: 0.008s Final results ==================== >> Total time: 0.107s ------------------------------------- OrdinaryLeastSquares --> r2: 0.4273 ~ Run: 1 =========================== >> Models: OLS04 Size of training set: 159 (40%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7987 Test evaluation --> r2: 0.653 Time elapsed: 0.008s ------------------------------------------------- Total time: 0.008s Final results ==================== >> Total time: 0.129s ------------------------------------- OrdinaryLeastSquares --> r2: 0.653 Run: 2 =========================== >> Models: OLS06 Size of training set: 238 (60%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7828 Test evaluation --> r2: 0.7161 Time elapsed: 0.008s ------------------------------------------------- Total time: 0.008s Final results ==================== >> Total time: 0.156s ------------------------------------- OrdinaryLeastSquares --> r2: 0.7161 Run: 3 =========================== >> Models: OLS08 Size of training set: 318 (80%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7866 Test evaluation --> r2: 0.7306 Time elapsed: 0.009s ------------------------------------------------- Total time: 0.009s Final results ==================== >> Total time: 0.187s ------------------------------------- OrdinaryLeastSquares --> r2: 0.7306 Run: 4 =========================== >> Models: OLS10 Size of training set: 398 (100%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7798 Test evaluation --> r2: 0.7394 Time elapsed: 0.009s ------------------------------------------------- Total time: 0.009s Final results ==================== >> Total time: 0.226s ------------------------------------- OrdinaryLeastSquares --> r2: 0.7394 >>> # Analyze the results >>> runner . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS02 -0.2766 ... -0.3650 OLS04 -0.2053 ... -0.2841 OLS06 -0.1957 ... -0.2570 OLS08 -0.1928 ... -0.2504 OLS10 -0.1933 ... -0.2463 [5 rows x 6 columns] Attributes Data attributes The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column. Utility attributes The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run. Tracking attributes The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline. Plot attributes The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes. Methods Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "TrainSizingRegressor"}, {"location": "API/training/trainsizingregressor/#trainsizingregressor", "text": "class atom.training. TrainSizingRegressor (models=None, metric=None, train_sizes=5, est_params=None, n_trials=0, ht_params=None, n_bootstrap=0, n_jobs=1, device=\"cpu\", engine=\"sklearn\", verbose=0, warnings=False, logger=None, experiment=None, random_state=None) [source] Train and evaluate the models in a train sizing fashion. The following steps are applied to every model (per iteration): Apply hyperparameter tuning (optional). Fit the model on the training set using the best combination of hyperparameters found. Evaluate the model on the test set. Train the estimator on various bootstrapped samples of the training set and evaluate again on the test set (optional). Parameters models: str, estimator or sequence, default=None Models to fit to the data. Allowed inputs are: an acronym from any of the predefined models , an ATOMModel or a custom predictor as class or instance. If None, all the predefined models are used. metric: str, func, scorer, sequence or None, default=None Metric on which to fit the models. Choose from any of sklearn's scorers , a function with signature function(y_true, y_pred) -> score , a scorer object or a sequence of these. If None, a default metric is selected for every task: \"f1\" for binary classification \"f1_weighted\" for multiclass classification \"r2\" for regression train_sizes: int or sequence, default=5 Sequence of training set sizes used to run the trainings. If int: Number of equally distributed splits, i.e. for a value N , it's equal to np.linspace(1.0/N, 1.0, N) . If sequence: Fraction of the training set when <=1, else total number of samples. n_trials: int or sequence, default=0 Maximum number of iterations for the hyperparameter tuning . If 0, skip the tuning and fit the model on its default parameters. If sequence, the n-th value applies to the n-th model. est_params: dict or None, default=None Additional parameters for the models. See their corresponding documentation for the available options. For multiple models, use the acronyms as key (or 'all' for all models) and a dict of the parameters as value. Add _fit to the parameter's name to pass it to the estimator's fit method instead of the constructor. ht_params: dict or None, default=None Additional parameters for the hyperparameter tuning. If None, it uses the same parameters as the first run. Can include: cv: int, dict or sequence, default=1 Number of folds for the cross-validation. If 1, the training set is randomly split in a subtrain and validation set. plot: bool, dict or sequence, default=False Whether to plot the optimization's progress as it runs. Creates a canvas with two plots: the first plot shows the score of every trial and the second shows the distance between the last consecutive steps. See the plot_trials method. distributions: dict, sequence or None, default=None Custom hyperparameter distributions. If None, it uses the model's predefined distributions. Read more in the user guide . tags: dict, sequence or None, default=None Custom tags for the model's trial and mlflow run . **kwargs Additional Keyword arguments for the constructor of the study class or the optimize method. n_bootstrap: int or sequence, default=0 Number of data sets to use for bootstrapping . If 0, no bootstrapping is performed. If sequence, the n-th value applies to the n-th model. n_jobs: int, default=1 Number of cores to use for parallel processing. If >0: Number of cores to use. If -1: Use all available cores. If <-1: Use number of cores - 1 + n_jobs . device: str, default=\"cpu\" Device on which to train the estimators. Use any string that follows the SYCL_DEVICE_FILTER filter selector, e.g. device=\"gpu\" to use the GPU. Read more in the user guide . engine: str, default=\"sklearn\" Execution engine to use for the estimators. Refer to the user guide for an explanation regarding every choice. Choose from: \"sklearn\" (only if device=\"cpu\") \"sklearnex\" \"cuml\" (only if device=\"gpu\") verbose: int, default=0 Verbosity level of the class. Choose from: 0 to not print anything. 1 to print basic information. 2 to print detailed information. warnings: bool or str, default=False If True: Default warning action (equal to \"default\"). If False: Suppress all warnings (equal to \"ignore\"). If str: One of python's warnings filters . Changing this parameter affects the PYTHONWARNINGS environment. ATOM can't manage warnings that go from C/C++ code to stdout. logger: str, Logger or None, default=None If None: Doesn't save a logging file. If str: Name of the log file. Use \"auto\" for automatic name. Else: Python logging.Logger instance. experiment: str or None, default=None Name of the mlflow experiment to use for tracking. If None, no mlflow tracking is performed. random_state: int or None, default=None Seed used by the random number generator. If None, the random number generator is the RandomState used by np.random . See Also ATOMRegressor Main class for regression tasks. DirectRegressor Train and evaluate the models in a direct fashion. SuccessiveHalvingRegressor Train and evaluate the models in a successive halving fashion.", "title": "TrainSizingRegressor"}, {"location": "API/training/trainsizingregressor/#example", "text": ">>> from atom.training import TrainSizingRegressor >>> from sklearn.datasets import load_digits >>> X , y = load_digits ( return_X_y = True , as_frame = True ) >>> train , test = train_test_split ( ... X . merge ( y . to_frame (), left_index = True , right_index = True ), ... test_size = 0.3 , ... ) >>> runner = TrainSizingRegressor ( models = \"OLS\" , metric = \"r2\" , verbose = 2 ) >>> runner . run ( train , test ) Training ========================= >> Metric: r2 Run: 0 =========================== >> Models: OLS02 Size of training set: 79 (20%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.8554 Test evaluation --> r2: 0.4273 Time elapsed: 0.008s ------------------------------------------------- Total time: 0.008s Final results ==================== >> Total time: 0.107s ------------------------------------- OrdinaryLeastSquares --> r2: 0.4273 ~ Run: 1 =========================== >> Models: OLS04 Size of training set: 159 (40%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7987 Test evaluation --> r2: 0.653 Time elapsed: 0.008s ------------------------------------------------- Total time: 0.008s Final results ==================== >> Total time: 0.129s ------------------------------------- OrdinaryLeastSquares --> r2: 0.653 Run: 2 =========================== >> Models: OLS06 Size of training set: 238 (60%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7828 Test evaluation --> r2: 0.7161 Time elapsed: 0.008s ------------------------------------------------- Total time: 0.008s Final results ==================== >> Total time: 0.156s ------------------------------------- OrdinaryLeastSquares --> r2: 0.7161 Run: 3 =========================== >> Models: OLS08 Size of training set: 318 (80%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7866 Test evaluation --> r2: 0.7306 Time elapsed: 0.009s ------------------------------------------------- Total time: 0.009s Final results ==================== >> Total time: 0.187s ------------------------------------- OrdinaryLeastSquares --> r2: 0.7306 Run: 4 =========================== >> Models: OLS10 Size of training set: 398 (100%) Size of test set: 171 Results for OrdinaryLeastSquares: Fit --------------------------------------------- Train evaluation --> r2: 0.7798 Test evaluation --> r2: 0.7394 Time elapsed: 0.009s ------------------------------------------------- Total time: 0.009s Final results ==================== >> Total time: 0.226s ------------------------------------- OrdinaryLeastSquares --> r2: 0.7394 >>> # Analyze the results >>> runner . evaluate () neg_mean_absolute_error ... neg_root_mean_squared_error OLS02 -0.2766 ... -0.3650 OLS04 -0.2053 ... -0.2841 OLS06 -0.1957 ... -0.2570 OLS08 -0.1928 ... -0.2504 OLS10 -0.1933 ... -0.2463 [5 rows x 6 columns]", "title": "Example"}, {"location": "API/training/trainsizingregressor/#attributes", "text": "", "title": "Attributes"}, {"location": "API/training/trainsizingregressor/#data-attributes", "text": "The data attributes are used to access the dataset and its properties. Updating the dataset will automatically update the response of these attributes accordingly. Attributes dataset: pd.DataFrame Complete data set. train: pd.DataFrame Training set. test: pd.DataFrame Test set. X: pd.DataFrame Feature set. y: pd.Series Target column. X_train: pd.DataFrame Features of the training set. y_train: pd.Series Target column of the training set. X_test: pd.DataFrame Features of the test set. y_test: pd.Series Target column of the test set. shape: tuple Shape of the dataset (n_rows, n_cols). columns: pd.Series Name of all the columns. n_columns: int Number of columns. features: pd.Series Name of the features. n_features: int Number of features. target: str Name of the target column.", "title": "Data attributes"}, {"location": "API/training/trainsizingregressor/#utility-attributes", "text": "The utility attributes are used to access information about the models in the instance after training . Attributes models: str or list Name of the model(s). metric: str or list Name of the metric(s). errors: dict Errors encountered during model training. The key is the model's name and the value is the exception object that was raised. Use the __traceback__ attribute to investigate the error. winners: list Models ordered by performance. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. winner: model Best performing model. Performance is measured as the highest score on the model's score_bootstrap or score_test attributes, checked in that order. For multi-metric runs , only the main metric is compared. results: pd.DataFrame Overview of the training results. All durations are in seconds. Columns include: score_ht: Score obtained by the hyperparameter tuning. time_ht: Duration of the hyperparameter tuning. score_train: Metric score on the train set. score_test: Metric score on the test set. time_fit: Duration of the model fitting on the train set. score_bootstrap: Mean score on the bootstrapped samples. time_bootstrap: Duration of the bootstrapping. time: Total duration of the model run.", "title": "Utility attributes"}, {"location": "API/training/trainsizingregressor/#tracking-attributes", "text": "The tracking attributes are used to customize what elements of the experiment are tracked. Read more in the user guide . Attributes log_ht: bool Whether to track every trial of the hyperparameter tuning. log_model: bool Whether to save the model's estimator after fitting. log_plots: bool Whether to save plots as artifacts. log_data: bool Whether to save the train and test sets. log_pipeline: bool Whether to save the model's pipeline.", "title": "Tracking attributes"}, {"location": "API/training/trainsizingregressor/#plot-attributes", "text": "The plot attributes are used to customize the plot's aesthetics. Read more in the user guide . Attributes palette: str or sequence Color palette. Specify one of plotly's built-in palettes or create a custom one, e.g. atom.palette = [\"red\", \"green\", \"blue\"] . title_fontsize: int Fontsize for the plot's title. label_fontsize: int Fontsize for the labels, legend and hover information. tick_fontsize: int Fontsize for the ticks along the plot's axes.", "title": "Plot attributes"}, {"location": "API/training/trainsizingregressor/#methods", "text": "Next to the plotting methods, the class contains a variety of methods to handle the data, run the training, and manage the pipeline. available_models Give an overview of the available predefined models. canvas Create a figure with multiple plots. clear Clear attributes from all models. delete Delete models. evaluate Get all models' scores for the provided metrics. export_pipeline Export the pipeline to a sklearn-like object. get_class_weight Return class weights for a balanced dataset. get_params Get parameters for this estimator. log Print message and save to log file. merge Merge another instance of the same class into this one. update_layout Update the properties of the plot's layout. reset_aesthetics Reset the plot aesthetics to their default values. run Train and evaluate the models. save Save the instance to a pickle file. set_params Set the parameters of this estimator. stacking Add a Stacking model to the pipeline. voting Add a Voting model to the pipeline. method available_models () [source] Give an overview of the available predefined models. Returns pd.DataFrame Information about the available predefined models . Columns include: acronym: Model's acronym (used to call the model). model: Name of the model's class. estimator: The model's underlying estimator. module: The estimator's module. needs_scaling: Whether the model requires feature scaling. accepts_sparse: Whether the model accepts sparse matrices. has_validation: Whether the model has in-training validation . supports_engines: List of engines supported by the model. method canvas (rows=1, cols=2, horizontal_spacing=0.05, vertical_spacing=0.07, title=None, legend=\"out\", figsize=None, filename=None, display=True) [source] Create a figure with multiple plots. This @contextmanager allows you to draw many plots in one figure. The default option is to add two plots side by side. See the user guide for an example. Parameters rows: int, default=1 Number of plots in length. cols: int, default=2 Number of plots in width. horizontal_spacing: float, default=0.05 Space between subplot rows in normalized plot coordinates. The spacing is relative to the figure's size. vertical_spacing: float, default=0.07 Space between subplot cols in normalized plot coordinates. The spacing is relative to the figure's size. title: str, dict or None, default=None Title for the plot. If None, no title is shown. If str, text for the title. If dict, title configuration . legend: bool, str or dict, default=\"out\" Legend for the plot. See the user guide for an extended description of the choices. If None: No legend is shown. If str: Location where to show the legend. If dict: Legend configuration. figsize: tuple or None, default=None Figure's size in pixels, format as (x, y). If None, it adapts the size to the number of plots in the canvas. filename: str or None, default=None Save the plot using this name. Use \"auto\" for automatic naming. The type of the file depends on the provided name (.html, .png, .pdf, etc...). If filename has no file type, the plot is saved as html. If None, the plot is not saved. display: bool, default=True Whether to render the plot. Yields go.Figure Plot object. method clear () [source] Clear attributes from all models. Reset all model attributes to their initial state, deleting potentially large data arrays. Use this method to free some memory before saving the instance. The cleared attributes per model are: Prediction attributes Metric scores Shap values App instance Dashboard instance method delete (models=None) [source] Delete models. If all models are removed, the metric is reset. Use this method to drop unwanted models from the pipeline or to free some memory before saving . Deleted models are not removed from any active mlflow experiment . Parameters models: int, str, slice, Model, sequence or None, default=None Models to delete. If None, all models are deleted. method evaluate (metric=None, dataset=\"test\", threshold=0.5, sample_weight=None) [source] Get all models' scores for the provided metrics. Parameters metric: str, func, scorer, sequence or None, default=None Metric to calculate. If None, it returns an overview of the most common metrics per task. dataset: str, default=\"test\" Data set on which to calculate the metric. Choose from: \"train\", \"test\" or \"holdout\". threshold: float, default=0.5 Threshold between 0 and 1 to convert predicted probabilities to class labels. Only used when: The task is binary classification. The model has a predict_proba method. The metric evaluates predicted target values. sample_weight: sequence or None, default=None Sample weights corresponding to y in dataset . Returns pd.DataFrame Scores of the models. method export_pipeline (model=None, memory=None, verbose=None) [source] Export the pipeline to a sklearn-like object. Optionally, you can add a model as final estimator. The returned pipeline is already fitted on the training set. Info The returned pipeline behaves similarly to sklearn's Pipeline , and additionally: Accepts transformers that change the target column. Accepts transformers that drop rows. Accepts transformers that only are fitted on a subset of the provided dataset. Always returns pandas objects. Uses transformers that are only applied on the training set to fit the pipeline, not to make predictions. Parameters model: str, Model or None, default=None Model for which to export the pipeline. If the model used automated feature scaling , the Scaler is added to the pipeline. If None, the pipeline in the current branch is exported. memory: bool, str, Memory or None, default=None Used to cache the fitted transformers of the pipeline. - If None or False: No caching is performed. - If True: A default temp directory is used. - If str: Path to the caching directory. - If Memory: Object with the joblib.Memory interface. verbose: int or None, default=None Verbosity level of the transformers in the pipeline. If None, it leaves them to their original verbosity. Note that this is not the pipeline's own verbose parameter. To change that, use the set_params method. Returns Pipeline Sklearn-like Pipeline object with all transformers in the current branch. method get_class_weight (dataset=\"train\") [source] Return class weights for a balanced dataset. Statistically, the class weights re-balance the data set so that the sampled data set represents the target population as closely as possible. The returned weights are inversely proportional to the class frequencies in the selected data set. Parameters dataset: str, default=\"train\" Data set from which to get the weights. Choose from: \"train\", \"test\" or \"dataset\". Returns dict Classes with the corresponding weights. method get_params (deep=True) [source] Get parameters for this estimator. Parameters deep : bool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns params : dict Parameter names mapped to their values. method log (msg, level=0, severity=\"info\") [source] Print message and save to log file. Parameters msg: int, float or str Message to save to the logger and print to stdout. level: int, default=0 Minimum verbosity level to print the message. severity: str, default=\"info\" Severity level of the message. Choose from: debug, info, warning, error, critical. method merge (other, suffix=\"2\") [source] Merge another instance of the same class into this one. Branches, models, metrics and attributes of the other instance are merged into this one. If there are branches and/or models with the same name, they are merged adding the suffix parameter to their name. The errors and missing attributes are extended with those of the other instance. It's only possible to merge two instances if they are initialized with the same dataset and trained with the same metric. Parameters other: Runner Instance with which to merge. Should be of the same class as self. suffix: str, default=\"2\" Conflicting branches and models are merged adding suffix to the end of their names. method update_layout (dict1=None, overwrite=False, **kwargs) [source] Update the properties of the plot's layout. This recursively updates the structure of the original layout with the values in the input dict / keyword arguments. Parameters dict1: dict or None, default=None Dictionary of properties to be updated. overwrite: bool, default=False If True, overwrite existing properties. If False, apply updates to existing properties recursively, preserving existing properties that are not specified in the update operation. **kwargs Keyword/value pair of properties to be updated. method reset_aesthetics () [source] Reset the plot aesthetics to their default values. method run (*arrays) [source] Train and evaluate the models. Read more in the user guide . Parameters *arrays: sequence of indexables Training set and test set. Allowed formats are: train, test X_train, X_test, y_train, y_test (X_train, y_train), (X_test, y_test) method save (filename=\"auto\", save_data=True) [source] Save the instance to a pickle file. Parameters filename: str, default=\"auto\" Name of the file. Use \"auto\" for automatic naming. save_data: bool, default=True Whether to save the dataset with the instance. This parameter is ignored if the method is not called from atom. If False, remember to add the data to ATOMLoader when loading the file. method set_params (**params) [source] Set the parameters of this estimator. Parameters **params : dict Estimator parameters. Returns self : estimator instance Estimator instance. method stacking (name=\"Stack\", models=None, **kwargs) [source] Add a Stacking model to the pipeline. Parameters name: str, default=\"Stack\" Name of the model. The name is always presided with the model's acronym: stack . models: slice, sequence or None, default=None Models that feed the stacking estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's stacking instance. The model's acronyms can be used for the final_estimator parameter. method voting (name=\"Vote\", models=None, **kwargs) [source] Add a Voting model to the pipeline. Parameters name: str, default=\"Vote\" Name of the model. The name is always presided with the model's acronym: vote . models: slice, sequence or None, default=None Models that feed the voting estimator. If None, it selects all non-ensemble models trained on the current branch. **kwargs Additional keyword arguments for sklearn's voting instance.", "title": "Methods"}, {"location": "changelog/v4.x.x/", "text": "Release history Version 4.14.1 Fixed an installation issue with conda . Version 4.14.0 Refactor of the Cleaner and Vectorizer classes. Refactor of the cross_validate method. The plot_pipeline method now supports drawing multiple pipelines. Renamed the Normalizer class to TextNormalizer . Renamed the Gauss class to Normalizer . Added the inverse_transform method to the Scaler , Normalizer and Cleaner classes. Added the winners property to the trainers (note the extra s ). Added the feature_names_in_ and n_features_in_ attributes to transformers. The default value of the warnings parameter is set to False. Improvements for multicollinearity removal in FeatureSelector . Renamed default feature names to x0 , x1 , etc... for consistency with sklearn's API. Renamed component names in FeatureSelector to pca0 , pca1 , etc... for consistency with sklearn's API. Significant speed up in pipeline transformations. Fixed a bug where mlflow runs could be ended unexpectedly. Version 4.13.1 Fixed an installation issue. Version 4.13.0 Added GPU support. Read more in the user guide . Added advanced feature selection strategies. Added the return_sparse parameter to the Vectorizer class. Added the quantile hyperparameter to the Dummy model. The data attributes now return pandas objects where possible. Fixed a bug where the BO could crash after balancing the data. Fixed a bug where saving the FeatureGenerator class could fail for certain operators. Fixed a bug where the FeatureSelector class displayed the wrong output. Fixed a bug where the mapping attribute was not reordered. Version 4.12.0 Support for Python 3.10 . New Discretizer class to bin numerical features. Refactor of the FeatureGenerator class. The mapping attribute now shows all encoded features. Added the sample_weight parameter to the evaluate method. ATOMClassifier has now a stratify parameter to split the data sets in a stratified fashion . Possibility to exclude hyperparameters from the BO adding ! before the name. Added memory usage to the stats method. Fixed a bug where decision_plot could fail when only one row was plotted. Added versioning to the documentation. Version 4.11.0 Full support for sparse matrices. Read more in the user guide . The shrink method now also handles sparse features. Refactor of the distribution method. Added three new linear models: Lars , Huber and Perc . Dimensions can be shared across models using the key 'all' in ht_params[\"dimensions\"] . Assign hyperparameters to tune using the predefined dimensions. It's now possible to tune a custom number of layers for the MLP model. If multiple BO calls share the best score, the one with the shortest training time is selected as winner (instead of the first). Fixed a bug where the BO could fail when custom dimensions where defined. Fixed a bug where FeatureSelector could fail after repeated calls to fit. Fixed a bug where FeatureGenerator didn't pass the correct data indices to its output. Performance improvements for the custom pipeline. Minor documentation fixes. Version 4.10.0 Added the holdout data set to have an extra way of assessing a model's performance on a completely independent dataset. Read more in the user_guide . Complete rework of the ensemble models. Support for dataframe indexing. Read more in the user guide . New plot_parshap plot to detect overfitting features. The new dashboard method makes analyzing the models even easier using a dashboard app. The plot_feature_importance plot now also accepts estimators with coefficients. Added the transform method for models. Added the threshold parameter to the evaluate method. The reset_predictions method is deprecated in favour of the new clear method. Refactor of the model's full_train method. The merge method is available for all trainers. Improvements in the trainer's pipeline. Training scores are now also saved to the mlflow run. Trying to change the data in a branch after fitting a model with it now raises an exception. Fixed a bug where the columns of array inputs were not ordered correctly. Fixed a bug where branches did not correctly act case-insensitive. Fixed a bug where the export_pipeline method for models would not export the transformers in the correct branch. Version 4.9.1 Changed the default cross-validation for hyperparameter tuning from 5 to 1 to avoid errors with deep learning models . Added clearer exception messages when a model's run failed. Fixed a bug where custom dimensions didn't show during hyperparameter tuning . Documentation improvements. Version 4.9.0 Drop support of Python 3.6 . Added the HistGBM model. Improved print layout for hyperparameter tuning . The new available_models method returns an overview of the available predefined models. The calibrate and cross_validate methods can no longer be accessed from the trainers. The pipeline parameter for the prediction methods is deprecated. Improved visualization of the plot_rfecv , plot_successive_halving and plot_learning_curve methods. Sparse matrices are now accepted as input. Duplicate BO calls are no longer calculated. Improvement in performance of the RNN model. Refactor of the model's bo attribute. Predefined hyperparameters have been updated to be consistent with sklearn's API. Fixed a bug where custom scalers were ignored by the models. Fixed a bug where the BO of certain models would crash with custom hyperparameters. Fixed a bug where duplicate column names could be generated from a custom transformer. Documentation improvements. Version 4.8.0 The Encoder class now directly handles unknown categories encountered during fitting. The Balancer and Encoder classes now accept custom estimators for the strategy parameter. The new merge method enables the user to merge multiple atom instances into one. The dtype shrinking is moved from atom's initializers to the shrink method. ATOM's custom pipeline now handles transformers fitted on a subset of the dataset. The column parameter in the distribution method is renamed to columns for continuity of the API. The mae criterion for the GBM model hyperparameter tuning is deprecated to be consistent with sklearn's API. Branches are now case-insensitive. Renaming a branch using an existing name now raises an exception. Fixed a bug where columns of type category broke the Imputer class. Fixed a bug where predictions of the Stacking ensemble crashed for branches with multiple transformers. The tables in the documentation now adapt to dark mode. Version 4.7.3 Fixed a bug where the conda-forge recipe couldn't install properly. Version 4.7.2 Fixed a bug where the pipeline failed for custom transformers that returned sparse matrices. Package requirements files are added to the installer. Version 4.7.1 Fixed a bug where the pip installer failed. Fixed a bug where categorical columns also selected datetime columns. Version 4.7.0 Launched our new slack channel! The new FeatureExtractor class extracts useful features from datetime columns. The new plot_det method plots a binary classifier's detection error tradeoff curve. The partial dependence plot is able to draw Individual Conditional Expectation (ICE) lines. The full traceback of exceptions encountered during training are now saved to the logger. ATOMClassifier and ATOMRegressor now convert the dtypes of the input data to the minimal allowed type for memory efficiency. The scoring method is renamed to evaluate to clarify its purpose. The column parameter in the apply method is renamed to columns for continuity of the API. Minor documentation improvements. Version 4.6.0 Added the full_train method to retrieve an estimator trained on the complete dataset. The score method is now also able to calculate custom metrics on new data. Refactor of the Imputer class. Refactor of the Encoder class to avoid errors for unknown classes and allow the input of missing values. The clean method no longer automatically encodes the target column for regression tasks. Creating a branch using a models' acronym as name now raises an exception. Fixed a bug where CatBoost failed when early_stopping < 1. Fixed a bug where created pipelines had duplicated names. Version 4.5.0 Support of NLP pipelines. Read more in the user guide . Integration of mlflow to track all models in the pipeline. Read more in the user guide . The new Normalizer class transforms features to a more Gaussian-like distribution. New cross_validate method to evaluate the robustness of a pipeline using cross_validation. New reset method to go back to atom's initial state. Added the Dummy model to compare other models with a simple baseline. New plot_wordcloud and plot_ngrams methods for text visualization. Plots now can return the figure object when display=None . The Pruner class can now able to drop outliers based on the selection of multiple strategies. The new shuffle parameter in atom's initializer determines whether to shuffle the dataset. The trainers no longer require you to specify a model using the models parameter. If left to default, all predefined models for that task are used. The apply method now accepts args and kwargs for the function. Refactor of the evaluate method. Refactor of the export_pipeline method. The parameters in the Cleaner class have been refactored to better describe their function. The train_sizes parameter in train_sizing now accepts integer values to automatically create equally distributed splits in the training set. Refactor of plot_pipeline to show models in the diagram as well. Refactor of the bagging parameter to the (more appropriate) name n_bootstrap . New option to exclude columns from a transformer adding ! before their name. Fixed a bug where the Pruner class failed if there were categorical columns in the dataset. Completely reworked documentation website. Version 4.4.0 The drop method now allows the user to drop columns as part of the pipeline. New apply method to perform data transformations as function to the pipeline Added the status method to save an overview of atom's branches and models to the logger. Improved the output messages for the Imputer class. The dataset's columns can now be called directly from atom. The distribution and plot_distribution methods now ignore missing values. Fixed a bug where transformations could fail when columns were added to the dataset after initializing the pipeline. Fixed a bug where the Cleaner class didn't drop columns consisting entirely of missing values when drop_min_cardinality=True . Fixed a bug where the winning model wasn't displayed correctly. Refactored the way transformers are added or removed from predicting methods. Improved documentation. Version 4.3.0 Possibility to add custom transformers to the pipeline. The export_pipeline utility method exports atom's current pipeline to a sklearn object. Use AutoML to automate the search for an optimized pipeline. New magic methods makes atom behave similarly to sklearn's Pipeline . All training approaches can now be combined in the same atom instance. New plot_relationships , plot_distribution and plot_qq plots for data inspection. Complete rework of all the shap plots to be consistent with their new API. Improvements for the Scaler and Pruner classes. The acronym for custom models now defaults to the capital letters in the class' __name__. Possibility to apply transformations on only a subset of the columns. Plots and methods now accept winner as model name. Fixed a bug where custom metrics didn't show the correct name. Fixed a bug where timers were not displayed correctly. Further compatibility with deep learning datasets. Large refactoring for performance optimization. Cleaner output of messages to the logger. Plots no longer show a default title. Added the AutoML example notebook. Minor bug fixes. Version 4.2.1 Bug fix where there was memory leakage in successive halving and train sizing pipelines. The XGBoost , LightGBM and CatBoost packages can now be installed through the installer's extras_require under the name models , e.g. pip install -U atom-ml[models] . Improved documentation. Version 4.2.0 Possibility to add custom models to the pipeline using ATOMModel . Compatibility with deep learning models. New branch system for different data pipelines. Read more in the user guide . Use the canvas contextmanager to draw multiple plots in one figure. New voting and stacking ensemble techniques. New get_class_weight utility method. New Sequential Feature Selection strategy for the FeatureSelector . Added the sample_weight parameter to the score method. New ways to initialize the data in the training instances. The n_rows parameter in ATOMLoader is deprecated in favour of the new input formats. The test_size parameter now also allows integer values. Renamed categories to classes to be consistent with sklearn's API. The class property now returns a pd.DataFrame of the number of rows per target class in the train, test and complete dataset. Possibility to add custom parameters to an estimator's fit method through est_params . The successive halving and train sizing approaches now both allow subsequent runs from atom without losing the information from previous runs. Bug fix where ATOMLoader wouldn't encode the target column during transformation. Added the Deep learning , Ensembles and Utilities example notebooks. Support for python 3.9 . Version 4.1.0 New est_params parameter to customize the parameters in every model's estimator. Following skopt's API, the n_random_starts parameter to specify the number of random trials is deprecated in favour of n_initial_points . The Balancer class now allows you to use any of the strategies from imblearn . New utility attributes to inspect the dataset. Four new models: CatNB , CNB , ARD and RNN . Added the models section to the documentation. Small changes in log outputs. Bug fixes and performance improvements. Version 4.0.1 Bug fix where the FeatureGenerator was not deterministic for a fixed random state. Bug fix where subsequent runs with the same metric failed. Added the license file to the package's installer. Typo fixes in documentation. Version 4.0.0 Bayesian optimization package changed from GpyOpt to skopt . Complete revision of the model's hyperparameters. Four SHAP plots can now be called directly from an ATOM pipeline. Two new plots for regression tasks. New plot_pipeline and pipeline attribute to access all transformers. Possibility to determine transformer parameters per method. New calibration method and plot . Metrics can now be added as scorers or functions with signature metric(y, y_pred, **kwargs). Implementation of multi-metric runs. Possibility to choose which metric to plot. Early stopping for models that allow in-training validation. Added the ATOMLoader function to load any saved pickle instance. The \"remove\" strategy in the data cleaning parameters is deprecated in favour of \"drop\". Implemented the dfs strategy in FeatureGenerator . All training classes now inherit from BaseEstimator. Added multiple new example notebooks. Tests coverage up to 100%. Completely new documentation page. Bug fixes and performance improvements.", "title": "v4.x.x"}, {"location": "changelog/v4.x.x/#release-history", "text": "", "title": "Release history"}, {"location": "changelog/v4.x.x/#version-4141", "text": "Fixed an installation issue with conda .", "title": "Version 4.14.1"}, {"location": "changelog/v4.x.x/#version-4140", "text": "Refactor of the Cleaner and Vectorizer classes. Refactor of the cross_validate method. The plot_pipeline method now supports drawing multiple pipelines. Renamed the Normalizer class to TextNormalizer . Renamed the Gauss class to Normalizer . Added the inverse_transform method to the Scaler , Normalizer and Cleaner classes. Added the winners property to the trainers (note the extra s ). Added the feature_names_in_ and n_features_in_ attributes to transformers. The default value of the warnings parameter is set to False. Improvements for multicollinearity removal in FeatureSelector . Renamed default feature names to x0 , x1 , etc... for consistency with sklearn's API. Renamed component names in FeatureSelector to pca0 , pca1 , etc... for consistency with sklearn's API. Significant speed up in pipeline transformations. Fixed a bug where mlflow runs could be ended unexpectedly.", "title": "Version 4.14.0"}, {"location": "changelog/v4.x.x/#version-4131", "text": "Fixed an installation issue.", "title": "Version 4.13.1"}, {"location": "changelog/v4.x.x/#version-4130", "text": "Added GPU support. Read more in the user guide . Added advanced feature selection strategies. Added the return_sparse parameter to the Vectorizer class. Added the quantile hyperparameter to the Dummy model. The data attributes now return pandas objects where possible. Fixed a bug where the BO could crash after balancing the data. Fixed a bug where saving the FeatureGenerator class could fail for certain operators. Fixed a bug where the FeatureSelector class displayed the wrong output. Fixed a bug where the mapping attribute was not reordered.", "title": "Version 4.13.0"}, {"location": "changelog/v4.x.x/#version-4120", "text": "Support for Python 3.10 . New Discretizer class to bin numerical features. Refactor of the FeatureGenerator class. The mapping attribute now shows all encoded features. Added the sample_weight parameter to the evaluate method. ATOMClassifier has now a stratify parameter to split the data sets in a stratified fashion . Possibility to exclude hyperparameters from the BO adding ! before the name. Added memory usage to the stats method. Fixed a bug where decision_plot could fail when only one row was plotted. Added versioning to the documentation.", "title": "Version 4.12.0"}, {"location": "changelog/v4.x.x/#version-4110", "text": "Full support for sparse matrices. Read more in the user guide . The shrink method now also handles sparse features. Refactor of the distribution method. Added three new linear models: Lars , Huber and Perc . Dimensions can be shared across models using the key 'all' in ht_params[\"dimensions\"] . Assign hyperparameters to tune using the predefined dimensions. It's now possible to tune a custom number of layers for the MLP model. If multiple BO calls share the best score, the one with the shortest training time is selected as winner (instead of the first). Fixed a bug where the BO could fail when custom dimensions where defined. Fixed a bug where FeatureSelector could fail after repeated calls to fit. Fixed a bug where FeatureGenerator didn't pass the correct data indices to its output. Performance improvements for the custom pipeline. Minor documentation fixes.", "title": "Version 4.11.0"}, {"location": "changelog/v4.x.x/#version-4100", "text": "Added the holdout data set to have an extra way of assessing a model's performance on a completely independent dataset. Read more in the user_guide . Complete rework of the ensemble models. Support for dataframe indexing. Read more in the user guide . New plot_parshap plot to detect overfitting features. The new dashboard method makes analyzing the models even easier using a dashboard app. The plot_feature_importance plot now also accepts estimators with coefficients. Added the transform method for models. Added the threshold parameter to the evaluate method. The reset_predictions method is deprecated in favour of the new clear method. Refactor of the model's full_train method. The merge method is available for all trainers. Improvements in the trainer's pipeline. Training scores are now also saved to the mlflow run. Trying to change the data in a branch after fitting a model with it now raises an exception. Fixed a bug where the columns of array inputs were not ordered correctly. Fixed a bug where branches did not correctly act case-insensitive. Fixed a bug where the export_pipeline method for models would not export the transformers in the correct branch.", "title": "Version 4.10.0"}, {"location": "changelog/v4.x.x/#version-491", "text": "Changed the default cross-validation for hyperparameter tuning from 5 to 1 to avoid errors with deep learning models . Added clearer exception messages when a model's run failed. Fixed a bug where custom dimensions didn't show during hyperparameter tuning . Documentation improvements.", "title": "Version 4.9.1"}, {"location": "changelog/v4.x.x/#version-490", "text": "Drop support of Python 3.6 . Added the HistGBM model. Improved print layout for hyperparameter tuning . The new available_models method returns an overview of the available predefined models. The calibrate and cross_validate methods can no longer be accessed from the trainers. The pipeline parameter for the prediction methods is deprecated. Improved visualization of the plot_rfecv , plot_successive_halving and plot_learning_curve methods. Sparse matrices are now accepted as input. Duplicate BO calls are no longer calculated. Improvement in performance of the RNN model. Refactor of the model's bo attribute. Predefined hyperparameters have been updated to be consistent with sklearn's API. Fixed a bug where custom scalers were ignored by the models. Fixed a bug where the BO of certain models would crash with custom hyperparameters. Fixed a bug where duplicate column names could be generated from a custom transformer. Documentation improvements.", "title": "Version 4.9.0"}, {"location": "changelog/v4.x.x/#version-480", "text": "The Encoder class now directly handles unknown categories encountered during fitting. The Balancer and Encoder classes now accept custom estimators for the strategy parameter. The new merge method enables the user to merge multiple atom instances into one. The dtype shrinking is moved from atom's initializers to the shrink method. ATOM's custom pipeline now handles transformers fitted on a subset of the dataset. The column parameter in the distribution method is renamed to columns for continuity of the API. The mae criterion for the GBM model hyperparameter tuning is deprecated to be consistent with sklearn's API. Branches are now case-insensitive. Renaming a branch using an existing name now raises an exception. Fixed a bug where columns of type category broke the Imputer class. Fixed a bug where predictions of the Stacking ensemble crashed for branches with multiple transformers. The tables in the documentation now adapt to dark mode.", "title": "Version 4.8.0"}, {"location": "changelog/v4.x.x/#version-473", "text": "Fixed a bug where the conda-forge recipe couldn't install properly.", "title": "Version 4.7.3"}, {"location": "changelog/v4.x.x/#version-472", "text": "Fixed a bug where the pipeline failed for custom transformers that returned sparse matrices. Package requirements files are added to the installer.", "title": "Version 4.7.2"}, {"location": "changelog/v4.x.x/#version-471", "text": "Fixed a bug where the pip installer failed. Fixed a bug where categorical columns also selected datetime columns.", "title": "Version 4.7.1"}, {"location": "changelog/v4.x.x/#version-470", "text": "Launched our new slack channel! The new FeatureExtractor class extracts useful features from datetime columns. The new plot_det method plots a binary classifier's detection error tradeoff curve. The partial dependence plot is able to draw Individual Conditional Expectation (ICE) lines. The full traceback of exceptions encountered during training are now saved to the logger. ATOMClassifier and ATOMRegressor now convert the dtypes of the input data to the minimal allowed type for memory efficiency. The scoring method is renamed to evaluate to clarify its purpose. The column parameter in the apply method is renamed to columns for continuity of the API. Minor documentation improvements.", "title": "Version 4.7.0"}, {"location": "changelog/v4.x.x/#version-460", "text": "Added the full_train method to retrieve an estimator trained on the complete dataset. The score method is now also able to calculate custom metrics on new data. Refactor of the Imputer class. Refactor of the Encoder class to avoid errors for unknown classes and allow the input of missing values. The clean method no longer automatically encodes the target column for regression tasks. Creating a branch using a models' acronym as name now raises an exception. Fixed a bug where CatBoost failed when early_stopping < 1. Fixed a bug where created pipelines had duplicated names.", "title": "Version 4.6.0"}, {"location": "changelog/v4.x.x/#version-450", "text": "Support of NLP pipelines. Read more in the user guide . Integration of mlflow to track all models in the pipeline. Read more in the user guide . The new Normalizer class transforms features to a more Gaussian-like distribution. New cross_validate method to evaluate the robustness of a pipeline using cross_validation. New reset method to go back to atom's initial state. Added the Dummy model to compare other models with a simple baseline. New plot_wordcloud and plot_ngrams methods for text visualization. Plots now can return the figure object when display=None . The Pruner class can now able to drop outliers based on the selection of multiple strategies. The new shuffle parameter in atom's initializer determines whether to shuffle the dataset. The trainers no longer require you to specify a model using the models parameter. If left to default, all predefined models for that task are used. The apply method now accepts args and kwargs for the function. Refactor of the evaluate method. Refactor of the export_pipeline method. The parameters in the Cleaner class have been refactored to better describe their function. The train_sizes parameter in train_sizing now accepts integer values to automatically create equally distributed splits in the training set. Refactor of plot_pipeline to show models in the diagram as well. Refactor of the bagging parameter to the (more appropriate) name n_bootstrap . New option to exclude columns from a transformer adding ! before their name. Fixed a bug where the Pruner class failed if there were categorical columns in the dataset. Completely reworked documentation website.", "title": "Version 4.5.0"}, {"location": "changelog/v4.x.x/#version-440", "text": "The drop method now allows the user to drop columns as part of the pipeline. New apply method to perform data transformations as function to the pipeline Added the status method to save an overview of atom's branches and models to the logger. Improved the output messages for the Imputer class. The dataset's columns can now be called directly from atom. The distribution and plot_distribution methods now ignore missing values. Fixed a bug where transformations could fail when columns were added to the dataset after initializing the pipeline. Fixed a bug where the Cleaner class didn't drop columns consisting entirely of missing values when drop_min_cardinality=True . Fixed a bug where the winning model wasn't displayed correctly. Refactored the way transformers are added or removed from predicting methods. Improved documentation.", "title": "Version 4.4.0"}, {"location": "changelog/v4.x.x/#version-430", "text": "Possibility to add custom transformers to the pipeline. The export_pipeline utility method exports atom's current pipeline to a sklearn object. Use AutoML to automate the search for an optimized pipeline. New magic methods makes atom behave similarly to sklearn's Pipeline . All training approaches can now be combined in the same atom instance. New plot_relationships , plot_distribution and plot_qq plots for data inspection. Complete rework of all the shap plots to be consistent with their new API. Improvements for the Scaler and Pruner classes. The acronym for custom models now defaults to the capital letters in the class' __name__. Possibility to apply transformations on only a subset of the columns. Plots and methods now accept winner as model name. Fixed a bug where custom metrics didn't show the correct name. Fixed a bug where timers were not displayed correctly. Further compatibility with deep learning datasets. Large refactoring for performance optimization. Cleaner output of messages to the logger. Plots no longer show a default title. Added the AutoML example notebook. Minor bug fixes.", "title": "Version 4.3.0"}, {"location": "changelog/v4.x.x/#version-421", "text": "Bug fix where there was memory leakage in successive halving and train sizing pipelines. The XGBoost , LightGBM and CatBoost packages can now be installed through the installer's extras_require under the name models , e.g. pip install -U atom-ml[models] . Improved documentation.", "title": "Version 4.2.1"}, {"location": "changelog/v4.x.x/#version-420", "text": "Possibility to add custom models to the pipeline using ATOMModel . Compatibility with deep learning models. New branch system for different data pipelines. Read more in the user guide . Use the canvas contextmanager to draw multiple plots in one figure. New voting and stacking ensemble techniques. New get_class_weight utility method. New Sequential Feature Selection strategy for the FeatureSelector . Added the sample_weight parameter to the score method. New ways to initialize the data in the training instances. The n_rows parameter in ATOMLoader is deprecated in favour of the new input formats. The test_size parameter now also allows integer values. Renamed categories to classes to be consistent with sklearn's API. The class property now returns a pd.DataFrame of the number of rows per target class in the train, test and complete dataset. Possibility to add custom parameters to an estimator's fit method through est_params . The successive halving and train sizing approaches now both allow subsequent runs from atom without losing the information from previous runs. Bug fix where ATOMLoader wouldn't encode the target column during transformation. Added the Deep learning , Ensembles and Utilities example notebooks. Support for python 3.9 .", "title": "Version 4.2.0"}, {"location": "changelog/v4.x.x/#version-410", "text": "New est_params parameter to customize the parameters in every model's estimator. Following skopt's API, the n_random_starts parameter to specify the number of random trials is deprecated in favour of n_initial_points . The Balancer class now allows you to use any of the strategies from imblearn . New utility attributes to inspect the dataset. Four new models: CatNB , CNB , ARD and RNN . Added the models section to the documentation. Small changes in log outputs. Bug fixes and performance improvements.", "title": "Version 4.1.0"}, {"location": "changelog/v4.x.x/#version-401", "text": "Bug fix where the FeatureGenerator was not deterministic for a fixed random state. Bug fix where subsequent runs with the same metric failed. Added the license file to the package's installer. Typo fixes in documentation.", "title": "Version 4.0.1"}, {"location": "changelog/v4.x.x/#version-400", "text": "Bayesian optimization package changed from GpyOpt to skopt . Complete revision of the model's hyperparameters. Four SHAP plots can now be called directly from an ATOM pipeline. Two new plots for regression tasks. New plot_pipeline and pipeline attribute to access all transformers. Possibility to determine transformer parameters per method. New calibration method and plot . Metrics can now be added as scorers or functions with signature metric(y, y_pred, **kwargs). Implementation of multi-metric runs. Possibility to choose which metric to plot. Early stopping for models that allow in-training validation. Added the ATOMLoader function to load any saved pickle instance. The \"remove\" strategy in the data cleaning parameters is deprecated in favour of \"drop\". Implemented the dfs strategy in FeatureGenerator . All training classes now inherit from BaseEstimator. Added multiple new example notebooks. Tests coverage up to 100%. Completely new documentation page. Bug fixes and performance improvements.", "title": "Version 4.0.0"}, {"location": "changelog/v5.x.x/", "text": "Release history Version 5.0.1 Bug fixes Fixed installation issue. Updated package dependencies. Version 5.0.0 New features Completely new hyperparameter tuning process. Completely reworked plotting interface . Accelerate your pipelines with sklearnex . New FeatureGrouper class to extract statistical features from similar groups. New create_app method to create a nice front-end for model predictions. New inverse_transform method for atom and models. New linear model: OrthogonalMatchingPursuit . The plot_results method now accepts time metrics. API changes The gpu parameter is deprecated in favor of device and engine . Refactor of the Cleaner , Discretizer , Encoder and FeatureSelector classes. Refactor of all shap plots . Refactor of the apply method. The plot_scatter_matrix method is renamed to plot_relationships . The kSVM model is renamed to SVM . Multidimensional datasets are no longer supported. Check the deep learning section of the user guide for guidance with such datasets. The greater_is_better , needs_proba and needs_threshold parameters are deprecated. Metric functions are now created using make_scorer 's default parameters. The drop method is removed from atom. Use the reworked apply method instead. The prediction methods can no longer be called from atom. The dashboard method for models is now called create_dashboard . Enhancements New examples for plotting , automated feature scaling , pruning and advanced hyperparameter tuning . The Normalizer class can now be accelerated with GPU . The Scaler class now ignores binary columns (only 0s and 1s). The models parameter in plot and utility methods now accepts model indices. The transform method now also transforms only y when X has a default value. The prediction methods now return pandas objects. Dependency versions are checked with originals after unpickling. Automatic generation of documentation from docstrings. Improvements in documentation display for mobile phones. New feature_importance attribute for models. Added a visualization for automated feature scaling to plot_pipeline . Bug fixes The FeatureExtractor class no longer raises a warning for highly fragmented dataframes. Fixed a bug where models could not call the score function. The Encoder class no longer fails when the user provides ordinal values that are not present during fitting. Fixed a bug with the max_nan_rows parameter in the Imputer class. Fixed a bug where Tokenizer could fail when no ngrams were found.", "title": "v5.x.x"}, {"location": "changelog/v5.x.x/#release-history", "text": "", "title": "Release history"}, {"location": "changelog/v5.x.x/#version-501", "text": "Bug fixes Fixed installation issue. Updated package dependencies.", "title": "Version 5.0.1"}, {"location": "changelog/v5.x.x/#version-500", "text": "New features Completely new hyperparameter tuning process. Completely reworked plotting interface . Accelerate your pipelines with sklearnex . New FeatureGrouper class to extract statistical features from similar groups. New create_app method to create a nice front-end for model predictions. New inverse_transform method for atom and models. New linear model: OrthogonalMatchingPursuit . The plot_results method now accepts time metrics. API changes The gpu parameter is deprecated in favor of device and engine . Refactor of the Cleaner , Discretizer , Encoder and FeatureSelector classes. Refactor of all shap plots . Refactor of the apply method. The plot_scatter_matrix method is renamed to plot_relationships . The kSVM model is renamed to SVM . Multidimensional datasets are no longer supported. Check the deep learning section of the user guide for guidance with such datasets. The greater_is_better , needs_proba and needs_threshold parameters are deprecated. Metric functions are now created using make_scorer 's default parameters. The drop method is removed from atom. Use the reworked apply method instead. The prediction methods can no longer be called from atom. The dashboard method for models is now called create_dashboard . Enhancements New examples for plotting , automated feature scaling , pruning and advanced hyperparameter tuning . The Normalizer class can now be accelerated with GPU . The Scaler class now ignores binary columns (only 0s and 1s). The models parameter in plot and utility methods now accepts model indices. The transform method now also transforms only y when X has a default value. The prediction methods now return pandas objects. Dependency versions are checked with originals after unpickling. Automatic generation of documentation from docstrings. Improvements in documentation display for mobile phones. New feature_importance attribute for models. Added a visualization for automated feature scaling to plot_pipeline . Bug fixes The FeatureExtractor class no longer raises a warning for highly fragmented dataframes. Fixed a bug where models could not call the score function. The Encoder class no longer fails when the user provides ordinal values that are not present during fitting. Fixed a bug with the max_nan_rows parameter in the Imputer class. Fixed a bug where Tokenizer could fail when no ngrams were found.", "title": "Version 5.0.0"}, {"location": "examples/accelerating_cuml/", "text": "Example: Accelerating pipelines on GPU \u00b6 This example shows how to accelerate a pipeline on GPU using cuML . Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. In [1]: Copied! from atom import ATOMClassifier from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier from sklearn.datasets import load_breast_cancer In [2]: Copied! X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) X, y = load_breast_cancer(return_X_y=True, as_frame=True) In [3]: Copied! atom = ATOMClassifier ( X , y , device = \"gpu\" , engine = \"cuml\" , verbose = 2 ) atom = ATOMClassifier(X, y, device=\"gpu\", engine=\"cuml\", verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. GPU training enabled. Backend engine: cuml. Dataset stats ==================== >> Shape: (569, 31) Memory: 141.24 kB Scaled: False Outlier values: 171 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! atom . clean () atom.clean() Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. In [5]: Copied! atom . run ([ \"lr\" , \"rf\" ], n_trials = 10 ) atom.run([\"lr\", \"rf\"], n_trials=10) Training ========================= >> Models: LR, RF Metric: f1 Running hyperparameter tuning for LogisticRegression... | trial | C | max_iter | l1_ratio | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------- | -------- | -------- | ------- | ------- | ---------- | ------- | -------- | | 0 | 76.5012 | 970 | --- | 0.9821 | 0.9821 | 0.932s | 0.932s | COMPLETE | | 1 | 42.1177 | 740 | --- | 0.9739 | 0.9821 | 0.093s | 1.025s | COMPLETE | | 2 | 0.0059 | 690 | --- | 0.9661 | 0.9821 | 0.054s | 1.080s | COMPLETE | | 3 | 3.3535 | 680 | --- | 0.9913 | 0.9913 | 0.069s | 1.149s | COMPLETE | | 4 | 5.1898 | 770 | --- | 0.9739 | 0.9913 | 0.078s | 1.227s | COMPLETE | | 5 | 0.0902 | 840 | --- | 0.9739 | 0.9913 | 0.055s | 1.282s | COMPLETE | | 6 | 0.0225 | 810 | --- | 0.958 | 0.9913 | 0.054s | 1.336s | COMPLETE | | 7 | 0.0557 | 150 | --- | 0.9661 | 0.9913 | 0.058s | 1.395s | COMPLETE | | 8 | 10.9765 | 920 | --- | 0.9735 | 0.9913 | 0.072s | 1.467s | COMPLETE | | 9 | 1.8506 | 170 | --- | 0.9825 | 0.9913 | 0.065s | 1.532s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> C: 3.3535 --> max_iter: 680 Best evaluation --> f1: 0.9913 Time elapsed: 1.532s Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9793 Time elapsed: 0.060s ------------------------------------------------- Total time: 1.592s Running hyperparameter tuning for RandomForest... | trial | n_estimators | split_criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------------ | --------------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | ------- | ------- | ---------- | ------- | -------- | | 0 | 380 | gini | 3 | 14 | 5 | 0.8 | False | --- | 0.9455 | 0.9455 | 0.845s | 0.845s | COMPLETE | | 1 | 170 | gini | 9 | 6 | 13 | 0.9 | False | --- | 0.9558 | 0.9558 | 0.424s | 1.269s | COMPLETE | | 2 | 270 | entropy | 4 | 10 | 12 | 0.8 | False | --- | 0.9739 | 0.9739 | 0.607s | 1.876s | COMPLETE | | 3 | 20 | entropy | 7 | 9 | 17 | 0.9 | False | --- | 0.9636 | 0.9739 | 0.147s | 2.023s | COMPLETE | | 4 | 350 | entropy | 13 | 8 | 16 | 0.9 | False | --- | 0.9009 | 0.9739 | 0.801s | 2.824s | COMPLETE | | 5 | 430 | gini | 13 | 4 | 10 | 0.8 | False | --- | 0.9402 | 0.9739 | 0.837s | 3.662s | COMPLETE | | 6 | 250 | gini | 9 | 9 | 14 | log2 | False | --- | 0.958 | 0.9739 | 0.562s | 4.224s | COMPLETE | | 7 | 410 | entropy | 3 | 8 | 11 | 0.7 | True | 0.6 | 0.9333 | 0.9739 | 0.831s | 5.055s | COMPLETE | | 8 | 100 | gini | 3 | 10 | 18 | 0.8 | False | --- | 0.9381 | 0.9739 | 0.279s | 5.334s | COMPLETE | | 9 | 330 | entropy | 7 | 6 | 17 | 0.7 | False | --- | 0.9558 | 0.9739 | 0.731s | 6.065s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 2 Best parameters: --> n_estimators: 270 --> split_criterion: entropy --> max_depth: 4 --> min_samples_split: 10 --> min_samples_leaf: 12 --> max_features: 0.8 --> bootstrap: False Best evaluation --> f1: 0.9739 Time elapsed: 6.065s Fit --------------------------------------------- Train evaluation --> f1: 0.9809 Test evaluation --> f1: 0.9655 Time elapsed: 0.573s ------------------------------------------------- Total time: 6.638s Final results ==================== >> Total time: 8.389s ------------------------------------- LogisticRegression --> f1: 0.9793 ! RandomForest --> f1: 0.9655 In [6]: Copied! atom . evaluate () atom.evaluate() Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc LR 0.9735 0.9817 0.9643 0.9793 0.9595 0.9439 0.9595 1.0000 0.9762 RF 0.9558 0.9919 0.9453 0.9655 0.9333 0.9054 0.9459 0.9859 0.9866 In [7]: Copied! print ( atom . lr . estimator . __module__ ) print ( atom . rf . estimator . __module__ ) print(atom.lr.estimator.__module__) print(atom.rf.estimator.__module__) cuml.linear_model.logistic_regression cuml.ensemble.randomforestclassifier", "title": "Accelerating cuml"}, {"location": "examples/accelerating_cuml/#example-accelerating-pipelines-on-gpu", "text": "This example shows how to accelerate a pipeline on GPU using cuML . Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. In [1]: Copied! from atom import ATOMClassifier from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier from sklearn.datasets import load_breast_cancer In [2]: Copied! X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) X, y = load_breast_cancer(return_X_y=True, as_frame=True) In [3]: Copied! atom = ATOMClassifier ( X , y , device = \"gpu\" , engine = \"cuml\" , verbose = 2 ) atom = ATOMClassifier(X, y, device=\"gpu\", engine=\"cuml\", verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. GPU training enabled. Backend engine: cuml. Dataset stats ==================== >> Shape: (569, 31) Memory: 141.24 kB Scaled: False Outlier values: 171 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! atom . clean () atom.clean() Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. In [5]: Copied! atom . run ([ \"lr\" , \"rf\" ], n_trials = 10 ) atom.run([\"lr\", \"rf\"], n_trials=10) Training ========================= >> Models: LR, RF Metric: f1 Running hyperparameter tuning for LogisticRegression... | trial | C | max_iter | l1_ratio | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------- | -------- | -------- | ------- | ------- | ---------- | ------- | -------- | | 0 | 76.5012 | 970 | --- | 0.9821 | 0.9821 | 0.932s | 0.932s | COMPLETE | | 1 | 42.1177 | 740 | --- | 0.9739 | 0.9821 | 0.093s | 1.025s | COMPLETE | | 2 | 0.0059 | 690 | --- | 0.9661 | 0.9821 | 0.054s | 1.080s | COMPLETE | | 3 | 3.3535 | 680 | --- | 0.9913 | 0.9913 | 0.069s | 1.149s | COMPLETE | | 4 | 5.1898 | 770 | --- | 0.9739 | 0.9913 | 0.078s | 1.227s | COMPLETE | | 5 | 0.0902 | 840 | --- | 0.9739 | 0.9913 | 0.055s | 1.282s | COMPLETE | | 6 | 0.0225 | 810 | --- | 0.958 | 0.9913 | 0.054s | 1.336s | COMPLETE | | 7 | 0.0557 | 150 | --- | 0.9661 | 0.9913 | 0.058s | 1.395s | COMPLETE | | 8 | 10.9765 | 920 | --- | 0.9735 | 0.9913 | 0.072s | 1.467s | COMPLETE | | 9 | 1.8506 | 170 | --- | 0.9825 | 0.9913 | 0.065s | 1.532s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> C: 3.3535 --> max_iter: 680 Best evaluation --> f1: 0.9913 Time elapsed: 1.532s Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9793 Time elapsed: 0.060s ------------------------------------------------- Total time: 1.592s Running hyperparameter tuning for RandomForest... | trial | n_estimators | split_criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------------ | --------------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | ------- | ------- | ---------- | ------- | -------- | | 0 | 380 | gini | 3 | 14 | 5 | 0.8 | False | --- | 0.9455 | 0.9455 | 0.845s | 0.845s | COMPLETE | | 1 | 170 | gini | 9 | 6 | 13 | 0.9 | False | --- | 0.9558 | 0.9558 | 0.424s | 1.269s | COMPLETE | | 2 | 270 | entropy | 4 | 10 | 12 | 0.8 | False | --- | 0.9739 | 0.9739 | 0.607s | 1.876s | COMPLETE | | 3 | 20 | entropy | 7 | 9 | 17 | 0.9 | False | --- | 0.9636 | 0.9739 | 0.147s | 2.023s | COMPLETE | | 4 | 350 | entropy | 13 | 8 | 16 | 0.9 | False | --- | 0.9009 | 0.9739 | 0.801s | 2.824s | COMPLETE | | 5 | 430 | gini | 13 | 4 | 10 | 0.8 | False | --- | 0.9402 | 0.9739 | 0.837s | 3.662s | COMPLETE | | 6 | 250 | gini | 9 | 9 | 14 | log2 | False | --- | 0.958 | 0.9739 | 0.562s | 4.224s | COMPLETE | | 7 | 410 | entropy | 3 | 8 | 11 | 0.7 | True | 0.6 | 0.9333 | 0.9739 | 0.831s | 5.055s | COMPLETE | | 8 | 100 | gini | 3 | 10 | 18 | 0.8 | False | --- | 0.9381 | 0.9739 | 0.279s | 5.334s | COMPLETE | | 9 | 330 | entropy | 7 | 6 | 17 | 0.7 | False | --- | 0.9558 | 0.9739 | 0.731s | 6.065s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 2 Best parameters: --> n_estimators: 270 --> split_criterion: entropy --> max_depth: 4 --> min_samples_split: 10 --> min_samples_leaf: 12 --> max_features: 0.8 --> bootstrap: False Best evaluation --> f1: 0.9739 Time elapsed: 6.065s Fit --------------------------------------------- Train evaluation --> f1: 0.9809 Test evaluation --> f1: 0.9655 Time elapsed: 0.573s ------------------------------------------------- Total time: 6.638s Final results ==================== >> Total time: 8.389s ------------------------------------- LogisticRegression --> f1: 0.9793 ! RandomForest --> f1: 0.9655 In [6]: Copied! atom . evaluate () atom.evaluate() Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc LR 0.9735 0.9817 0.9643 0.9793 0.9595 0.9439 0.9595 1.0000 0.9762 RF 0.9558 0.9919 0.9453 0.9655 0.9333 0.9054 0.9459 0.9859 0.9866 In [7]: Copied! print ( atom . lr . estimator . __module__ ) print ( atom . rf . estimator . __module__ ) print(atom.lr.estimator.__module__) print(atom.rf.estimator.__module__) cuml.linear_model.logistic_regression cuml.ensemble.randomforestclassifier", "title": "Example: Accelerating pipelines on GPU"}, {"location": "examples/accelerating_sklearnex/", "text": "Example: Accelerating pipelines \u00b6 This example shows how to accelerate your models on cpu using sklearnex . The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , \"RainTomorrow\" , verbose = 2 ) atom = ATOMClassifier(X, \"RainTomorrow\", verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- | | dataset | train | test | | - | -------------- | -------------- | -------------- | | 0 | 110316 (3.5) | 88253 (3.5) | 22063 (3.5) | | 1 | 31877 (1.0) | 25502 (1.0) | 6375 (1.0) | In [4]: Copied! # Impute missing values and encode categorical columns atom . impute () atom . encode () # Impute missing values and encode categorical columns atom.impute() atom.encode() Fitting Imputer... Imputing missing values... --> Dropping 637 samples due to missing values in feature MinTemp. --> Dropping 322 samples due to missing values in feature MaxTemp. --> Dropping 1406 samples due to missing values in feature Rainfall. --> Dropping 60843 samples due to missing values in feature Evaporation. --> Dropping 67816 samples due to missing values in feature Sunshine. --> Dropping 9330 samples due to missing values in feature WindGustDir. --> Dropping 9270 samples due to missing values in feature WindGustSpeed. --> Dropping 10013 samples due to missing values in feature WindDir9am. --> Dropping 3778 samples due to missing values in feature WindDir3pm. --> Dropping 1348 samples due to missing values in feature WindSpeed9am. --> Dropping 2630 samples due to missing values in feature WindSpeed3pm. --> Dropping 1774 samples due to missing values in feature Humidity9am. --> Dropping 3610 samples due to missing values in feature Humidity3pm. --> Dropping 14014 samples due to missing values in feature Pressure9am. --> Dropping 13981 samples due to missing values in feature Pressure3pm. --> Dropping 53657 samples due to missing values in feature Cloud9am. --> Dropping 57094 samples due to missing values in feature Cloud3pm. --> Dropping 904 samples due to missing values in feature Temp9am. --> Dropping 2726 samples due to missing values in feature Temp3pm. --> Dropping 1406 samples due to missing values in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 26 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [5]: Copied! # Train a K-Nearest Neighbors model (using default sklearn) atom . run ( models = \"KNN\" , metric = \"f1\" ) # Train a K-Nearest Neighbors model (using default sklearn) atom.run(models=\"KNN\", metric=\"f1\") Training ========================= >> Models: KNN Metric: f1 Results for KNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 0.7127 Test evaluation --> f1: 0.5994 Time elapsed: 1.697s ------------------------------------------------- Total time: 1.697s Final results ==================== >> Total time: 1.699s ------------------------------------- KNearestNeighbors --> f1: 0.5994 In [6]: Copied! # Now, we train an accelerated KNN using engine=\"sklearnex\" # Note the diffrence in training speed!! atom . run ( models = \"KNN_acc\" , metric = \"f1\" , engine = \"sklearnex\" ) # Now, we train an accelerated KNN using engine=\"sklearnex\" # Note the diffrence in training speed!! atom.run(models=\"KNN_acc\", metric=\"f1\", engine=\"sklearnex\") Training ========================= >> Models: KNN_acc Metric: f1 Results for KNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 0.7127 Test evaluation --> f1: 0.5994 Time elapsed: 1.119s ------------------------------------------------- Total time: 1.119s Final results ==================== >> Total time: 1.120s ------------------------------------- KNearestNeighbors --> f1: 0.5994 Analyze the results \u00b6 In [7]: Copied! atom . results atom.results Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit time KNN 0.7127 0.5994 1.697075 1.697075 KNN_acc 0.7127 0.5994 1.119191 1.119191 In [8]: Copied! # Note how the underlying estimators might look the same... print ( atom . knn . estimator ) print ( atom . knn_acc . estimator ) # ... but are using different implementations print ( atom . knn . estimator . __module__ ) print ( atom . knn_acc . estimator . __module__ ) # Note how the underlying estimators might look the same... print(atom.knn.estimator) print(atom.knn_acc.estimator) # ... but are using different implementations print(atom.knn.estimator.__module__) print(atom.knn_acc.estimator.__module__) KNeighborsClassifier(n_jobs=1) KNeighborsClassifier(n_jobs=1) sklearn.neighbors._classification sklearnex.neighbors.knn_classification In [9]: Copied! with atom . canvas ( 1 , 2 , title = \"Timing engines: sklearn vs sklearnex\" ): atom . plot_results ( metric = \"time_fit\" , title = \"Training\" ) atom . plot_results ( metric = \"time\" , title = \"Total\" ) with atom.canvas(1, 2, title=\"Timing engines: sklearn vs sklearnex\"): atom.plot_results(metric=\"time_fit\", title=\"Training\") atom.plot_results(metric=\"time\", title=\"Total\") ", "title": "Accelerating sklearnex"}, {"location": "examples/accelerating_sklearnex/#example-accelerating-pipelines", "text": "This example shows how to accelerate your models on cpu using sklearnex . The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Accelerating pipelines"}, {"location": "examples/accelerating_sklearnex/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/accelerating_sklearnex/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X , \"RainTomorrow\" , verbose = 2 ) atom = ATOMClassifier(X, \"RainTomorrow\", verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- | | dataset | train | test | | - | -------------- | -------------- | -------------- | | 0 | 110316 (3.5) | 88253 (3.5) | 22063 (3.5) | | 1 | 31877 (1.0) | 25502 (1.0) | 6375 (1.0) | In [4]: Copied! # Impute missing values and encode categorical columns atom . impute () atom . encode () # Impute missing values and encode categorical columns atom.impute() atom.encode() Fitting Imputer... Imputing missing values... --> Dropping 637 samples due to missing values in feature MinTemp. --> Dropping 322 samples due to missing values in feature MaxTemp. --> Dropping 1406 samples due to missing values in feature Rainfall. --> Dropping 60843 samples due to missing values in feature Evaporation. --> Dropping 67816 samples due to missing values in feature Sunshine. --> Dropping 9330 samples due to missing values in feature WindGustDir. --> Dropping 9270 samples due to missing values in feature WindGustSpeed. --> Dropping 10013 samples due to missing values in feature WindDir9am. --> Dropping 3778 samples due to missing values in feature WindDir3pm. --> Dropping 1348 samples due to missing values in feature WindSpeed9am. --> Dropping 2630 samples due to missing values in feature WindSpeed3pm. --> Dropping 1774 samples due to missing values in feature Humidity9am. --> Dropping 3610 samples due to missing values in feature Humidity3pm. --> Dropping 14014 samples due to missing values in feature Pressure9am. --> Dropping 13981 samples due to missing values in feature Pressure3pm. --> Dropping 53657 samples due to missing values in feature Cloud9am. --> Dropping 57094 samples due to missing values in feature Cloud3pm. --> Dropping 904 samples due to missing values in feature Temp9am. --> Dropping 2726 samples due to missing values in feature Temp3pm. --> Dropping 1406 samples due to missing values in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 26 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [5]: Copied! # Train a K-Nearest Neighbors model (using default sklearn) atom . run ( models = \"KNN\" , metric = \"f1\" ) # Train a K-Nearest Neighbors model (using default sklearn) atom.run(models=\"KNN\", metric=\"f1\") Training ========================= >> Models: KNN Metric: f1 Results for KNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 0.7127 Test evaluation --> f1: 0.5994 Time elapsed: 1.697s ------------------------------------------------- Total time: 1.697s Final results ==================== >> Total time: 1.699s ------------------------------------- KNearestNeighbors --> f1: 0.5994 In [6]: Copied! # Now, we train an accelerated KNN using engine=\"sklearnex\" # Note the diffrence in training speed!! atom . run ( models = \"KNN_acc\" , metric = \"f1\" , engine = \"sklearnex\" ) # Now, we train an accelerated KNN using engine=\"sklearnex\" # Note the diffrence in training speed!! atom.run(models=\"KNN_acc\", metric=\"f1\", engine=\"sklearnex\") Training ========================= >> Models: KNN_acc Metric: f1 Results for KNearestNeighbors: Fit --------------------------------------------- Train evaluation --> f1: 0.7127 Test evaluation --> f1: 0.5994 Time elapsed: 1.119s ------------------------------------------------- Total time: 1.119s Final results ==================== >> Total time: 1.120s ------------------------------------- KNearestNeighbors --> f1: 0.5994", "title": "Run the pipeline"}, {"location": "examples/accelerating_sklearnex/#analyze-the-results", "text": "In [7]: Copied! atom . results atom.results Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit time KNN 0.7127 0.5994 1.697075 1.697075 KNN_acc 0.7127 0.5994 1.119191 1.119191 In [8]: Copied! # Note how the underlying estimators might look the same... print ( atom . knn . estimator ) print ( atom . knn_acc . estimator ) # ... but are using different implementations print ( atom . knn . estimator . __module__ ) print ( atom . knn_acc . estimator . __module__ ) # Note how the underlying estimators might look the same... print(atom.knn.estimator) print(atom.knn_acc.estimator) # ... but are using different implementations print(atom.knn.estimator.__module__) print(atom.knn_acc.estimator.__module__) KNeighborsClassifier(n_jobs=1) KNeighborsClassifier(n_jobs=1) sklearn.neighbors._classification sklearnex.neighbors.knn_classification In [9]: Copied! with atom . canvas ( 1 , 2 , title = \"Timing engines: sklearn vs sklearnex\" ): atom . plot_results ( metric = \"time_fit\" , title = \"Training\" ) atom . plot_results ( metric = \"time\" , title = \"Total\" ) with atom.canvas(1, 2, title=\"Timing engines: sklearn vs sklearnex\"): atom.plot_results(metric=\"time_fit\", title=\"Training\") atom.plot_results(metric=\"time\", title=\"Total\") ", "title": "Analyze the results"}, {"location": "examples/advanced_plotting/", "text": "Example: Advanced plotting \u00b6 This example shows how to make the best use of all of atom's plotting options. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , y = \"RainTomorrow\" , verbose = 1 ) atom . impute () atom . encode () atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=1) atom.impute() atom.encode() << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- Fitting Imputer... Imputing missing values... Fitting Encoder... Encoding categorical columns... Customize colors and font size \u00b6 In [4]: Copied! # Let's see how the default aesthetics looks like atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Let's see how the default aesthetics looks like atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  In [5]: Copied! # Change the color palette using color names or their hex codes atom . palette = [ \"red\" , \"#00f\" ] # Change the color palette using color names or their hex codes atom.palette = [\"red\", \"#00f\"] In [6]: Copied! atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  In [7]: Copied! # Change the title and label fontsize atom . title_fontsize = 30 atom . label_fontsize = 24 atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Change the title and label fontsize atom.title_fontsize = 30 atom.label_fontsize = 24 atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  Customize the plot's layout \u00b6 In [8]: Copied! # Use the update_layout method to change layout properties atom . update_layout ( template = \"simple_white\" , barmode = \"group\" , hovermode = \"x\" ) atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Use the update_layout method to change layout properties atom.update_layout(template=\"simple_white\", barmode=\"group\", hovermode=\"x\") atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  Customize the title and legend \u00b6 In [9]: Copied! # Let's go back to the default aesthetics atom . reset_aesthetics () atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Let's go back to the default aesthetics atom.reset_aesthetics() atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  In [10]: Copied! # And update the title with some custom fonts atom . plot_distribution ( columns = [ 1 , 2 ], title = dict ( text = \"Distribution of temperatures\" , font_color = \"teal\" , x = 0 , xanchor = \"left\" , ) ) # And update the title with some custom fonts atom.plot_distribution( columns=[1, 2], title=dict( text=\"Distribution of temperatures\", font_color=\"teal\", x=0, xanchor=\"left\", ) )  In [11]: Copied! # We can update the legend in a similar fashion atom . plot_distribution ( columns = [ 1 , 2 ], title = dict ( text = \"Distribution of temperatures\" , font_color = \"teal\" , x = 0 , xanchor = \"left\" , ), legend = dict ( title = \"Legend's title\" ), ) # We can update the legend in a similar fashion atom.plot_distribution( columns=[1, 2], title=dict( text=\"Distribution of temperatures\", font_color=\"teal\", x=0, xanchor=\"left\", ), legend=dict(title=\"Legend's title\"), )  Using a canvas \u00b6 In [12]: Copied! # Note how the same column over different plots is grouped with atom . canvas ( 2 , 2 ): atom . plot_distribution ( columns = 1 ) atom . plot_distribution ( columns = 2 ) atom . plot_qq ( columns = [ 1 , 2 ], distributions = [ \"norm\" , \"invgauss\" ]) atom . plot_qq ( columns = [ 1 , 2 ]) # Note how the same column over different plots is grouped with atom.canvas(2, 2): atom.plot_distribution(columns=1) atom.plot_distribution(columns=2) atom.plot_qq(columns=[1, 2], distributions=[\"norm\", \"invgauss\"]) atom.plot_qq(columns=[1, 2]) ", "title": "Advanced plotting"}, {"location": "examples/advanced_plotting/#example-advanced-plotting", "text": "This example shows how to make the best use of all of atom's plotting options. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Advanced plotting"}, {"location": "examples/advanced_plotting/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/advanced_plotting/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X , y = \"RainTomorrow\" , verbose = 1 ) atom . impute () atom . encode () atom = ATOMClassifier(X, y=\"RainTomorrow\", verbose=1) atom.impute() atom.encode() << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- Fitting Imputer... Imputing missing values... Fitting Encoder... Encoding categorical columns...", "title": "Run the pipeline"}, {"location": "examples/advanced_plotting/#customize-colors-and-font-size", "text": "In [4]: Copied! # Let's see how the default aesthetics looks like atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Let's see how the default aesthetics looks like atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  In [5]: Copied! # Change the color palette using color names or their hex codes atom . palette = [ \"red\" , \"#00f\" ] # Change the color palette using color names or their hex codes atom.palette = [\"red\", \"#00f\"] In [6]: Copied! atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  In [7]: Copied! # Change the title and label fontsize atom . title_fontsize = 30 atom . label_fontsize = 24 atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Change the title and label fontsize atom.title_fontsize = 30 atom.label_fontsize = 24 atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") ", "title": "Customize colors and font size"}, {"location": "examples/advanced_plotting/#customize-the-plots-layout", "text": "In [8]: Copied! # Use the update_layout method to change layout properties atom . update_layout ( template = \"simple_white\" , barmode = \"group\" , hovermode = \"x\" ) atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Use the update_layout method to change layout properties atom.update_layout(template=\"simple_white\", barmode=\"group\", hovermode=\"x\") atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\") ", "title": "Customize the plot's layout"}, {"location": "examples/advanced_plotting/#customize-the-title-and-legend", "text": "In [9]: Copied! # Let's go back to the default aesthetics atom . reset_aesthetics () atom . plot_distribution ( columns = [ 1 , 2 ], title = \"Distribution of temperatures\" ) # Let's go back to the default aesthetics atom.reset_aesthetics() atom.plot_distribution(columns=[1, 2], title=\"Distribution of temperatures\")  In [10]: Copied! # And update the title with some custom fonts atom . plot_distribution ( columns = [ 1 , 2 ], title = dict ( text = \"Distribution of temperatures\" , font_color = \"teal\" , x = 0 , xanchor = \"left\" , ) ) # And update the title with some custom fonts atom.plot_distribution( columns=[1, 2], title=dict( text=\"Distribution of temperatures\", font_color=\"teal\", x=0, xanchor=\"left\", ) )  In [11]: Copied! # We can update the legend in a similar fashion atom . plot_distribution ( columns = [ 1 , 2 ], title = dict ( text = \"Distribution of temperatures\" , font_color = \"teal\" , x = 0 , xanchor = \"left\" , ), legend = dict ( title = \"Legend's title\" ), ) # We can update the legend in a similar fashion atom.plot_distribution( columns=[1, 2], title=dict( text=\"Distribution of temperatures\", font_color=\"teal\", x=0, xanchor=\"left\", ), legend=dict(title=\"Legend's title\"), ) ", "title": "Customize the title and legend"}, {"location": "examples/advanced_plotting/#using-a-canvas", "text": "In [12]: Copied! # Note how the same column over different plots is grouped with atom . canvas ( 2 , 2 ): atom . plot_distribution ( columns = 1 ) atom . plot_distribution ( columns = 2 ) atom . plot_qq ( columns = [ 1 , 2 ], distributions = [ \"norm\" , \"invgauss\" ]) atom . plot_qq ( columns = [ 1 , 2 ]) # Note how the same column over different plots is grouped with atom.canvas(2, 2): atom.plot_distribution(columns=1) atom.plot_distribution(columns=2) atom.plot_qq(columns=[1, 2], distributions=[\"norm\", \"invgauss\"]) atom.plot_qq(columns=[1, 2]) ", "title": "Using a canvas"}, {"location": "examples/automated_feature_scaling/", "text": "Example: Automated feature scaling \u00b6 This example shows how ATOM handles models that require automated feature scaling. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True) Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Check which models require feature scaling atom . available_models ()[[ \"acronym\" , \"model\" , \"needs_scaling\" ]] # Check which models require feature scaling atom.available_models()[[\"acronym\", \"model\", \"needs_scaling\"]] Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model needs_scaling 0 AdaB AdaBoost False 1 Bag Bagging False 2 BNB BernoulliNB False 3 CatB CatBoost True 4 CatNB CategoricalNB False 5 CNB ComplementNB False 6 Tree DecisionTree False 7 Dummy Dummy False 8 ETree ExtraTree False 9 ET ExtraTrees False 10 GNB GaussianNB False 11 GP GaussianProcess False 12 GBM GradientBoosting False 13 hGBM HistGradientBoosting False 14 KNN KNearestNeighbors True 15 LGB LightGBM True 16 LDA LinearDiscriminantAnalysis False 17 lSVM LinearSVM True 18 LR LogisticRegression True 19 MLP MultiLayerPerceptron True 20 MNB MultinomialNB False 21 PA PassiveAggressive True 22 Perc Perceptron True 23 QDA QuadraticDiscriminantAnalysis False 24 RNN RadiusNearestNeighbors True 25 RF RandomForest False 26 Ridge Ridge True 27 SGD StochasticGradientDescent True 28 SVM SupportVectorMachine True 29 XGB XGBoost True In [5]: Copied! # We fit two models: LR needs scaling and Bag doesn't atom . run ([ \"LR\" , \"Bag\" ]) # We fit two models: LR needs scaling and Bag doesn't atom.run([\"LR\", \"Bag\"]) Training ========================= >> Models: LR, Bag Metric: f1 Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9861 Time elapsed: 0.027s ------------------------------------------------- Total time: 0.027s Fit --------------------------------------------- Train evaluation --> f1: 0.9982 Test evaluation --> f1: 0.9444 Time elapsed: 0.041s ------------------------------------------------- Total time: 0.041s Final results ==================== >> Total time: 0.070s ------------------------------------- LogisticRegression --> f1: 0.9861 ! Bagging --> f1: 0.9444 In [6]: Copied! # Now, we create a new branch and scale the features before fitting the model atom . branch = \"scaling\" # Now, we create a new branch and scale the features before fitting the model atom.branch = \"scaling\" New branch scaling successfully created. In [7]: Copied! atom . scale () atom.scale() Fitting Scaler... Scaling features... In [8]: Copied! atom . run ( \"LR2\" ) atom.run(\"LR2\") Training ========================= >> Models: LR2 Metric: f1 Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9861 Time elapsed: 0.020s ------------------------------------------------- Total time: 0.020s Final results ==================== >> Total time: 0.020s ------------------------------------- LogisticRegression --> f1: 0.9861 Analyze the results \u00b6 In [9]: Copied! # Let's compare the differences between the models print ( atom . lr . scaler ) print ( atom . bag . scaler ) print ( atom . lr2 . scaler ) # Let's compare the differences between the models print(atom.lr.scaler) print(atom.bag.scaler) print(atom.lr2.scaler) Scaler() None None In [10]: Copied! # And the data they use is different print ( atom . lr . X . iloc [: 5 , : 3 ]) print ( \"-----------------------------\" ) print ( atom . bag . X . iloc [: 5 , : 3 ]) print ( \"-----------------------------\" ) print ( atom . lr2 . X_train . equals ( atom . lr . X_train )) # And the data they use is different print(atom.lr.X.iloc[:5, :3]) print(\"-----------------------------\") print(atom.bag.X.iloc[:5, :3]) print(\"-----------------------------\") print(atom.lr2.X_train.equals(atom.lr.X_train)) x0 x1 x2 0 -0.181875 0.356669 -0.147122 1 1.162216 0.300578 1.159704 2 1.056470 1.212060 0.933833 3 0.277287 2.457753 0.188054 4 -1.442482 -0.825921 -1.343434 ----------------------------- x0 x1 x2 0 13.48 20.82 88.40 1 18.31 20.58 120.80 2 17.93 24.48 115.20 3 15.13 29.81 96.71 4 8.95 15.76 58.74 ----------------------------- True In [11]: Copied! # Note that the scaler is included in the model's pipeline print ( atom . lr . pipeline ) print ( \"-----------------------------\" ) print ( atom . bag . pipeline ) print ( \"-----------------------------\" ) print ( atom . lr2 . pipeline ) # Note that the scaler is included in the model's pipeline print(atom.lr.pipeline) print(\"-----------------------------\") print(atom.bag.pipeline) print(\"-----------------------------\") print(atom.lr2.pipeline) 0 Scaler() dtype: object ----------------------------- Series([], Name: master, dtype: object) ----------------------------- 0 Scaler(verbose=2) dtype: object In [12]: Copied! atom . plot_pipeline () atom.plot_pipeline()", "title": "Automated feature scaling"}, {"location": "examples/automated_feature_scaling/#example-automated-feature-scaling", "text": "This example shows how ATOM handles models that require automated feature scaling. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: Automated feature scaling"}, {"location": "examples/automated_feature_scaling/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True)", "title": "Load the data"}, {"location": "examples/automated_feature_scaling/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Check which models require feature scaling atom . available_models ()[[ \"acronym\" , \"model\" , \"needs_scaling\" ]] # Check which models require feature scaling atom.available_models()[[\"acronym\", \"model\", \"needs_scaling\"]] Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model needs_scaling 0 AdaB AdaBoost False 1 Bag Bagging False 2 BNB BernoulliNB False 3 CatB CatBoost True 4 CatNB CategoricalNB False 5 CNB ComplementNB False 6 Tree DecisionTree False 7 Dummy Dummy False 8 ETree ExtraTree False 9 ET ExtraTrees False 10 GNB GaussianNB False 11 GP GaussianProcess False 12 GBM GradientBoosting False 13 hGBM HistGradientBoosting False 14 KNN KNearestNeighbors True 15 LGB LightGBM True 16 LDA LinearDiscriminantAnalysis False 17 lSVM LinearSVM True 18 LR LogisticRegression True 19 MLP MultiLayerPerceptron True 20 MNB MultinomialNB False 21 PA PassiveAggressive True 22 Perc Perceptron True 23 QDA QuadraticDiscriminantAnalysis False 24 RNN RadiusNearestNeighbors True 25 RF RandomForest False 26 Ridge Ridge True 27 SGD StochasticGradientDescent True 28 SVM SupportVectorMachine True 29 XGB XGBoost True In [5]: Copied! # We fit two models: LR needs scaling and Bag doesn't atom . run ([ \"LR\" , \"Bag\" ]) # We fit two models: LR needs scaling and Bag doesn't atom.run([\"LR\", \"Bag\"]) Training ========================= >> Models: LR, Bag Metric: f1 Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9861 Time elapsed: 0.027s ------------------------------------------------- Total time: 0.027s Fit --------------------------------------------- Train evaluation --> f1: 0.9982 Test evaluation --> f1: 0.9444 Time elapsed: 0.041s ------------------------------------------------- Total time: 0.041s Final results ==================== >> Total time: 0.070s ------------------------------------- LogisticRegression --> f1: 0.9861 ! Bagging --> f1: 0.9444 In [6]: Copied! # Now, we create a new branch and scale the features before fitting the model atom . branch = \"scaling\" # Now, we create a new branch and scale the features before fitting the model atom.branch = \"scaling\" New branch scaling successfully created. In [7]: Copied! atom . scale () atom.scale() Fitting Scaler... Scaling features... In [8]: Copied! atom . run ( \"LR2\" ) atom.run(\"LR2\") Training ========================= >> Models: LR2 Metric: f1 Fit --------------------------------------------- Train evaluation --> f1: 0.9913 Test evaluation --> f1: 0.9861 Time elapsed: 0.020s ------------------------------------------------- Total time: 0.020s Final results ==================== >> Total time: 0.020s ------------------------------------- LogisticRegression --> f1: 0.9861", "title": "Run the pipeline"}, {"location": "examples/automated_feature_scaling/#analyze-the-results", "text": "In [9]: Copied! # Let's compare the differences between the models print ( atom . lr . scaler ) print ( atom . bag . scaler ) print ( atom . lr2 . scaler ) # Let's compare the differences between the models print(atom.lr.scaler) print(atom.bag.scaler) print(atom.lr2.scaler) Scaler() None None In [10]: Copied! # And the data they use is different print ( atom . lr . X . iloc [: 5 , : 3 ]) print ( \"-----------------------------\" ) print ( atom . bag . X . iloc [: 5 , : 3 ]) print ( \"-----------------------------\" ) print ( atom . lr2 . X_train . equals ( atom . lr . X_train )) # And the data they use is different print(atom.lr.X.iloc[:5, :3]) print(\"-----------------------------\") print(atom.bag.X.iloc[:5, :3]) print(\"-----------------------------\") print(atom.lr2.X_train.equals(atom.lr.X_train)) x0 x1 x2 0 -0.181875 0.356669 -0.147122 1 1.162216 0.300578 1.159704 2 1.056470 1.212060 0.933833 3 0.277287 2.457753 0.188054 4 -1.442482 -0.825921 -1.343434 ----------------------------- x0 x1 x2 0 13.48 20.82 88.40 1 18.31 20.58 120.80 2 17.93 24.48 115.20 3 15.13 29.81 96.71 4 8.95 15.76 58.74 ----------------------------- True In [11]: Copied! # Note that the scaler is included in the model's pipeline print ( atom . lr . pipeline ) print ( \"-----------------------------\" ) print ( atom . bag . pipeline ) print ( \"-----------------------------\" ) print ( atom . lr2 . pipeline ) # Note that the scaler is included in the model's pipeline print(atom.lr.pipeline) print(\"-----------------------------\") print(atom.bag.pipeline) print(\"-----------------------------\") print(atom.lr2.pipeline) 0 Scaler() dtype: object ----------------------------- Series([], Name: master, dtype: object) ----------------------------- 0 Scaler(verbose=2) dtype: object In [12]: Copied! atom . plot_pipeline () atom.plot_pipeline()", "title": "Analyze the results"}, {"location": "examples/automl/", "text": "Example: AutoML \u00b6 This example shows how to use atom's AutoML implementation to automatically search for an optimized pipeline. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from sklearn.preprocessing import StandardScaler from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from sklearn.preprocessing import StandardScaler from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True) Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , y , n_jobs = 6 , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(X, y, n_jobs=6, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 6 cores. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # It's possible to add custom estimators to the pipeline atom . add ( StandardScaler ()) # It's possible to add custom estimators to the pipeline atom.add(StandardScaler()) Adding StandardScaler to the pipeline... Fitting StandardScaler... In [5]: Copied! # Check that the scaling worked atom . scaled # Check that the scaling worked atom.scaled Out[5]: True In [6]: Copied! # Find an optimized pipeline using AutoML atom . automl ( objective = \"precision\" , max_time = 2 * 60 ) # Find an optimized pipeline using AutoML atom.automl(objective=\"precision\", max_time=2 * 60) Searching for optimal pipeline... AutoMLSearch will use the holdout set to score and rank pipelines. Generating pipelines to search over... 8 pipelines ready for search. ***************************** * Beginning pipeline search * ***************************** Optimizing for Precision. Greater score is better. Using SequentialEngine to train and score pipelines. Will stop searching for new pipelines after 120 seconds. Allowed model families: linear_model, linear_model, xgboost, lightgbm, catboost, random_forest, decision_tree, extra_trees FigureWidget({ 'data': [{'mode': 'lines+markers', 'name': 'Best Score', 'type'\u2026 Evaluating Baseline Pipeline: Mode Baseline Binary Classification Pipeline Mode Baseline Binary Classification Pipeline: Starting cross validation Finished cross validation - mean Precision: 0.000 Starting holdout set scoring Finished holdout set scoring - Precision: 0.000 ***************************** * Evaluating Batch Number 1 * ***************************** Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.992 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.975 Starting holdout set scoring Finished holdout set scoring - Precision: 0.975 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.884 Starting holdout set scoring Finished holdout set scoring - Precision: 0.943 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 2 * ***************************** Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 3 * ***************************** Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 4 * ***************************** XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.988 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.993 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.966 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.992 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 5 * ***************************** CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.988 Starting holdout set scoring Finished holdout set scoring - Precision: 0.970 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.982 Starting holdout set scoring Finished holdout set scoring - Precision: 0.930 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.969 Starting holdout set scoring Finished holdout set scoring - Precision: 0.971 ***************************** * Evaluating Batch Number 6 * ***************************** Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 7 * ***************************** Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.992 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 8 * ***************************** LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.962 Starting holdout set scoring Finished holdout set scoring - Precision: 0.974 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.975 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.922 Starting holdout set scoring Finished holdout set scoring - Precision: 0.919 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.987 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 9 * ***************************** Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.894 Starting holdout set scoring Finished holdout set scoring - Precision: 0.943 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.880 Starting holdout set scoring Finished holdout set scoring - Precision: 0.976 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.911 Starting holdout set scoring Finished holdout set scoring - Precision: 0.895 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.912 Starting holdout set scoring Finished holdout set scoring - Precision: 0.925 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.884 Starting holdout set scoring Finished holdout set scoring - Precision: 0.943 ****************************** * Evaluating Batch Number 10 * ****************************** Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Search finished after 02:01 Best pipeline: Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler Best pipeline Precision: 1.000000 Merging automl results with atom... --> Adding LabelEncoder to the pipeline... --> Adding ReplaceNullableTypes to the pipeline... --> Adding Imputer to the pipeline... --> Adding StandardScaler to the pipeline... --> Adding model LogisticRegression (LR) to the pipeline... Analyze the results \u00b6 In [7]: Copied! # The evalml estimator can be accessed for further analysis atom . evalml # The evalml estimator can be accessed for further analysis atom.evalml Out[7]: <evalml.automl.automl_search.AutoMLSearch at 0x23c82ac8b20> In [8]: Copied! # Check the new transformers in the branch atom . branch . status () # Check the new transformers in the branch atom.branch.status() Branch: master --> Pipeline: --> StandardScaler --> LabelEncoder --> ReplaceNullableTypes --> Imputer --> StandardScaler --> Models: LR In [9]: Copied! # Or draw the pipeline atom . plot_pipeline () # Or draw the pipeline atom.plot_pipeline() In [10]: Copied! # Note that the model is also merged with atom atom . lr # Note that the model is also merged with atom atom.lr Out[10]: LogisticRegression --> Estimator: LogisticRegression --> Evaluation: precision: 0.9726 In [11]: Copied! # The pipeline can be exported to a sklearn-like pipeline atom . export_pipeline ( model = \"lr\" ) # The pipeline can be exported to a sklearn-like pipeline atom.export_pipeline(model=\"lr\") Out[11]: #sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"\u25b8\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"\u25be\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;} Pipeline(memory=Memory(location=None), steps=[('standardscaler', StandardScaler()), ('labelencoder', LabelEncoder(positive_label=None)), ('replacenullabletypes', ReplaceNullableTypes()), ('imputer', Imputer(categorical_impute_strategy='most_frequent', numeric_impute_strategy='most_frequent', boolean_impute_strategy='most_frequent', categorical_fill_value=None, numeric_fill_value=None, boolean_fill_value=None)), ('standardscaler2', StandardScaler()), ('LR', LogisticRegression(C=1.9835334708679646, l1_ratio=0.2896296405458125, n_jobs=6, penalty='elasticnet', random_state=1, solver='saga'))]) In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. Pipeline Pipeline(memory=Memory(location=None), steps=[('standardscaler', StandardScaler()), ('labelencoder', LabelEncoder(positive_label=None)), ('replacenullabletypes', ReplaceNullableTypes()), ('imputer', Imputer(categorical_impute_strategy='most_frequent', numeric_impute_strategy='most_frequent', boolean_impute_strategy='most_frequent', categorical_fill_value=None, numeric_fill_value=None, boolean_fill_value=None)), ('standardscaler2', StandardScaler()), ('LR', LogisticRegression(C=1.9835334708679646, l1_ratio=0.2896296405458125, n_jobs=6, penalty='elasticnet', random_state=1, solver='saga'))]) StandardScaler StandardScaler() LabelEncoder Label Encoder ReplaceNullableTypes Replace Nullable Types Transformer Imputer Imputer StandardScaler Standard Scaler LogisticRegression LogisticRegression(C=1.9835334708679646, l1_ratio=0.2896296405458125, n_jobs=6, penalty='elasticnet', random_state=1, solver='saga')", "title": "AutoML"}, {"location": "examples/automl/#example-automl", "text": "This example shows how to use atom's AutoML implementation to automatically search for an optimized pipeline. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: AutoML"}, {"location": "examples/automl/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from sklearn.preprocessing import StandardScaler from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from sklearn.preprocessing import StandardScaler from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True)", "title": "Load the data"}, {"location": "examples/automl/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X , y , n_jobs = 6 , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(X, y, n_jobs=6, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 6 cores. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # It's possible to add custom estimators to the pipeline atom . add ( StandardScaler ()) # It's possible to add custom estimators to the pipeline atom.add(StandardScaler()) Adding StandardScaler to the pipeline... Fitting StandardScaler... In [5]: Copied! # Check that the scaling worked atom . scaled # Check that the scaling worked atom.scaled Out[5]: True In [6]: Copied! # Find an optimized pipeline using AutoML atom . automl ( objective = \"precision\" , max_time = 2 * 60 ) # Find an optimized pipeline using AutoML atom.automl(objective=\"precision\", max_time=2 * 60) Searching for optimal pipeline... AutoMLSearch will use the holdout set to score and rank pipelines. Generating pipelines to search over... 8 pipelines ready for search. ***************************** * Beginning pipeline search * ***************************** Optimizing for Precision. Greater score is better. Using SequentialEngine to train and score pipelines. Will stop searching for new pipelines after 120 seconds. Allowed model families: linear_model, linear_model, xgboost, lightgbm, catboost, random_forest, decision_tree, extra_trees FigureWidget({ 'data': [{'mode': 'lines+markers', 'name': 'Best Score', 'type'\u2026 Evaluating Baseline Pipeline: Mode Baseline Binary Classification Pipeline Mode Baseline Binary Classification Pipeline: Starting cross validation Finished cross validation - mean Precision: 0.000 Starting holdout set scoring Finished holdout set scoring - Precision: 0.000 ***************************** * Evaluating Batch Number 1 * ***************************** Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.992 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.975 Starting holdout set scoring Finished holdout set scoring - Precision: 0.975 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.884 Starting holdout set scoring Finished holdout set scoring - Precision: 0.943 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 2 * ***************************** Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 3 * ***************************** Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Logistic Regression Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 0.994 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 4 * ***************************** XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.988 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.993 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.966 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.992 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 XGBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 5 * ***************************** CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.988 Starting holdout set scoring Finished holdout set scoring - Precision: 0.970 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.982 Starting holdout set scoring Finished holdout set scoring - Precision: 0.930 CatBoost Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.969 Starting holdout set scoring Finished holdout set scoring - Precision: 0.971 ***************************** * Evaluating Batch Number 6 * ***************************** Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Random Forest Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 7 * ***************************** Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.992 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Extra Trees Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 8 * ***************************** LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.962 Starting holdout set scoring Finished holdout set scoring - Precision: 0.974 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.975 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.922 Starting holdout set scoring Finished holdout set scoring - Precision: 0.919 LightGBM Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.987 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 ***************************** * Evaluating Batch Number 9 * ***************************** Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.894 Starting holdout set scoring Finished holdout set scoring - Precision: 0.943 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.880 Starting holdout set scoring Finished holdout set scoring - Precision: 0.976 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.911 Starting holdout set scoring Finished holdout set scoring - Precision: 0.895 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.912 Starting holdout set scoring Finished holdout set scoring - Precision: 0.925 Decision Tree Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer: Starting cross validation Finished cross validation - mean Precision: 0.884 Starting holdout set scoring Finished holdout set scoring - Precision: 0.943 ****************************** * Evaluating Batch Number 10 * ****************************** Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler: Starting cross validation Finished cross validation - mean Precision: 1.000 Starting holdout set scoring Finished holdout set scoring - Precision: 1.000 Search finished after 02:01 Best pipeline: Elastic Net Classifier w/ Label Encoder + Replace Nullable Types Transformer + Imputer + Standard Scaler Best pipeline Precision: 1.000000 Merging automl results with atom... --> Adding LabelEncoder to the pipeline... --> Adding ReplaceNullableTypes to the pipeline... --> Adding Imputer to the pipeline... --> Adding StandardScaler to the pipeline... --> Adding model LogisticRegression (LR) to the pipeline...", "title": "Run the pipeline"}, {"location": "examples/automl/#analyze-the-results", "text": "In [7]: Copied! # The evalml estimator can be accessed for further analysis atom . evalml # The evalml estimator can be accessed for further analysis atom.evalml Out[7]: <evalml.automl.automl_search.AutoMLSearch at 0x23c82ac8b20> In [8]: Copied! # Check the new transformers in the branch atom . branch . status () # Check the new transformers in the branch atom.branch.status() Branch: master --> Pipeline: --> StandardScaler --> LabelEncoder --> ReplaceNullableTypes --> Imputer --> StandardScaler --> Models: LR In [9]: Copied! # Or draw the pipeline atom . plot_pipeline () # Or draw the pipeline atom.plot_pipeline() In [10]: Copied! # Note that the model is also merged with atom atom . lr # Note that the model is also merged with atom atom.lr Out[10]: LogisticRegression --> Estimator: LogisticRegression --> Evaluation: precision: 0.9726 In [11]: Copied! # The pipeline can be exported to a sklearn-like pipeline atom . export_pipeline ( model = \"lr\" ) # The pipeline can be exported to a sklearn-like pipeline atom.export_pipeline(model=\"lr\") Out[11]: #sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"\u25b8\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"\u25be\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;} Pipeline(memory=Memory(location=None), steps=[('standardscaler', StandardScaler()), ('labelencoder', LabelEncoder(positive_label=None)), ('replacenullabletypes', ReplaceNullableTypes()), ('imputer', Imputer(categorical_impute_strategy='most_frequent', numeric_impute_strategy='most_frequent', boolean_impute_strategy='most_frequent', categorical_fill_value=None, numeric_fill_value=None, boolean_fill_value=None)), ('standardscaler2', StandardScaler()), ('LR', LogisticRegression(C=1.9835334708679646, l1_ratio=0.2896296405458125, n_jobs=6, penalty='elasticnet', random_state=1, solver='saga'))]) In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. Pipeline Pipeline(memory=Memory(location=None), steps=[('standardscaler', StandardScaler()), ('labelencoder', LabelEncoder(positive_label=None)), ('replacenullabletypes', ReplaceNullableTypes()), ('imputer', Imputer(categorical_impute_strategy='most_frequent', numeric_impute_strategy='most_frequent', boolean_impute_strategy='most_frequent', categorical_fill_value=None, numeric_fill_value=None, boolean_fill_value=None)), ('standardscaler2', StandardScaler()), ('LR', LogisticRegression(C=1.9835334708679646, l1_ratio=0.2896296405458125, n_jobs=6, penalty='elasticnet', random_state=1, solver='saga'))]) StandardScaler StandardScaler() LabelEncoder Label Encoder ReplaceNullableTypes Replace Nullable Types Transformer Imputer Imputer StandardScaler Standard Scaler LogisticRegression LogisticRegression(C=1.9835334708679646, l1_ratio=0.2896296405458125, n_jobs=6, penalty='elasticnet', random_state=1, solver='saga')", "title": "Analyze the results"}, {"location": "examples/binary_classification/", "text": "Example: Binary classification \u00b6 This example shows how to use ATOM to solve a binary classification problem. Additonnaly, we'll perform a variety of data cleaning steps to prepare the data for modelling. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! # Call atom using only 5% of the complete dataset (for explanatory purposes) atom = ATOMClassifier ( X , \"RainTomorrow\" , n_rows = 0.05 , n_jobs = 8 , verbose = 2 ) # Call atom using only 5% of the complete dataset (for explanatory purposes) atom = ATOMClassifier(X, \"RainTomorrow\", n_rows=0.05, n_jobs=8, verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 8 cores. Dataset stats ==================== >> Shape: (7109, 22) Memory: 3.08 MB Scaled: False Missing values: 15933 (10.2%) Categorical features: 5 (23.8%) ------------------------------------- Train set size: 5688 Test set size: 1421 ------------------------------------- | | dataset | train | test | | - | ------------ | ------------ | ------------ | | 0 | 5592 (3.7) | 4474 (3.7) | 1118 (3.7) | | 1 | 1517 (1.0) | 1214 (1.0) | 303 (1.0) | In [4]: Copied! # Impute missing values atom . impute ( strat_num = \"median\" , strat_cat = \"drop\" , max_nan_rows = 0.8 ) # Impute missing values atom.impute(strat_num=\"median\", strat_cat=\"drop\", max_nan_rows=0.8) Fitting Imputer... Imputing missing values... --> Dropping 5 samples for containing more than 16 missing values. --> Imputing 17 missing values with median (12.0) in feature MinTemp. --> Imputing 13 missing values with median (22.6) in feature MaxTemp. --> Imputing 73 missing values with median (0.0) in feature Rainfall. --> Imputing 3068 missing values with median (4.8) in feature Evaporation. --> Imputing 3413 missing values with median (8.6) in feature Sunshine. --> Dropping 462 samples due to missing values in feature WindGustDir. --> Imputing 461 missing values with median (37.0) in feature WindGustSpeed. --> Dropping 469 samples due to missing values in feature WindDir9am. --> Dropping 185 samples due to missing values in feature WindDir3pm. --> Imputing 53 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 128 missing values with median (17.0) in feature WindSpeed3pm. --> Imputing 89 missing values with median (70.0) in feature Humidity9am. --> Imputing 175 missing values with median (52.0) in feature Humidity3pm. --> Imputing 707 missing values with median (1017.8) in feature Pressure9am. --> Imputing 704 missing values with median (1015.3) in feature Pressure3pm. --> Imputing 2699 missing values with median (5.0) in feature Cloud9am. --> Imputing 2882 missing values with median (5.0) in feature Cloud3pm. --> Imputing 41 missing values with median (16.6) in feature Temp9am. --> Imputing 132 missing values with median (21.2) in feature Temp3pm. --> Dropping 73 samples due to missing values in feature RainToday. In [5]: Copied! # Encode the categorical features atom . encode ( strategy = \"Target\" , max_onehot = 10 , rare_to_value = 0.04 ) # Encode the categorical features atom.encode(strategy=\"Target\", max_onehot=10, rare_to_value=0.04) Fitting Encoder... Encoding categorical columns... --> Target-encoding feature Location. Contains 47 classes. --> Target-encoding feature WindGustDir. Contains 16 classes. --> Target-encoding feature WindDir9am. Contains 16 classes. --> Target-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [6]: Copied! # Train an Extra-Trees and a Random Forest model atom . run ( models = [ \"ET\" , \"RF\" ], metric = \"f1\" , n_bootstrap = 5 ) # Train an Extra-Trees and a Random Forest model atom.run(models=[\"ET\", \"RF\"], metric=\"f1\", n_bootstrap=5) Training ========================= >> Models: ET, RF Metric: f1 Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.532 Time elapsed: 0.215s Bootstrap --------------------------------------- Evaluation --> f1: 0.4959 \u00b1 0.0125 Time elapsed: 1.003s ------------------------------------------------- Total time: 1.218s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> f1: 0.9995 Test evaluation --> f1: 0.5235 Time elapsed: 0.283s Bootstrap --------------------------------------- Evaluation --> f1: 0.5302 \u00b1 0.0048 Time elapsed: 1.285s ------------------------------------------------- Total time: 1.567s Final results ==================== >> Total time: 2.787s ------------------------------------- ExtraTrees --> f1: 0.4959 \u00b1 0.0125 ~ RandomForest --> f1: 0.5302 \u00b1 0.0048 ~ ! Analyze the results \u00b6 In [7]: Copied! # Let's have a look at the final results atom . results # Let's have a look at the final results atom.results Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit score_bootstrap time_bootstrap time ET 1.0000 0.5320 0.215197 0.495895 1.002652 1.217849 RF 0.9995 0.5235 0.282572 0.530242 1.284799 1.567371 In [8]: Copied! # Visualize the bootstrap results atom . plot_results ( title = \"RF vs ET performance\" ) # Visualize the bootstrap results atom.plot_results(title=\"RF vs ET performance\")  In [9]: Copied! # Print the results of some common metrics atom . evaluate () # Print the results of some common metrics atom.evaluate() Out[9]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc ET 0.8476 0.6559 0.6878 0.5320 0.3624 0.4789 0.7500 0.4122 0.8499 RF 0.8452 0.6729 0.6835 0.5235 0.3545 0.4692 0.7413 0.4046 0.8583 In [10]: Copied! # The winner attribute calls the best model (atom.winner == atom.rf) print ( f \"The winner is the { atom . winner . name } model!!\" ) # The winner attribute calls the best model (atom.winner == atom.rf) print(f\"The winner is the {atom.winner.name} model!!\") The winner is the RF model!! In [11]: Copied! # Visualize the distribution of predicted probabilities atom . winner . plot_probabilities () # Visualize the distribution of predicted probabilities atom.winner.plot_probabilities()  In [12]: Copied! # Compare how different metrics perform for different thresholds atom . winner . plot_threshold ( metric = [ \"f1\" , \"accuracy\" , \"ap\" ], steps = 50 ) # Compare how different metrics perform for different thresholds atom.winner.plot_threshold(metric=[\"f1\", \"accuracy\", \"ap\"], steps=50) ", "title": "Binary classification"}, {"location": "examples/binary_classification/#example-binary-classification", "text": "This example shows how to use ATOM to solve a binary classification problem. Additonnaly, we'll perform a variety of data cleaning steps to prepare the data for modelling. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Binary classification"}, {"location": "examples/binary_classification/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/binary_classification/#run-the-pipeline", "text": "In [3]: Copied! # Call atom using only 5% of the complete dataset (for explanatory purposes) atom = ATOMClassifier ( X , \"RainTomorrow\" , n_rows = 0.05 , n_jobs = 8 , verbose = 2 ) # Call atom using only 5% of the complete dataset (for explanatory purposes) atom = ATOMClassifier(X, \"RainTomorrow\", n_rows=0.05, n_jobs=8, verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 8 cores. Dataset stats ==================== >> Shape: (7109, 22) Memory: 3.08 MB Scaled: False Missing values: 15933 (10.2%) Categorical features: 5 (23.8%) ------------------------------------- Train set size: 5688 Test set size: 1421 ------------------------------------- | | dataset | train | test | | - | ------------ | ------------ | ------------ | | 0 | 5592 (3.7) | 4474 (3.7) | 1118 (3.7) | | 1 | 1517 (1.0) | 1214 (1.0) | 303 (1.0) | In [4]: Copied! # Impute missing values atom . impute ( strat_num = \"median\" , strat_cat = \"drop\" , max_nan_rows = 0.8 ) # Impute missing values atom.impute(strat_num=\"median\", strat_cat=\"drop\", max_nan_rows=0.8) Fitting Imputer... Imputing missing values... --> Dropping 5 samples for containing more than 16 missing values. --> Imputing 17 missing values with median (12.0) in feature MinTemp. --> Imputing 13 missing values with median (22.6) in feature MaxTemp. --> Imputing 73 missing values with median (0.0) in feature Rainfall. --> Imputing 3068 missing values with median (4.8) in feature Evaporation. --> Imputing 3413 missing values with median (8.6) in feature Sunshine. --> Dropping 462 samples due to missing values in feature WindGustDir. --> Imputing 461 missing values with median (37.0) in feature WindGustSpeed. --> Dropping 469 samples due to missing values in feature WindDir9am. --> Dropping 185 samples due to missing values in feature WindDir3pm. --> Imputing 53 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 128 missing values with median (17.0) in feature WindSpeed3pm. --> Imputing 89 missing values with median (70.0) in feature Humidity9am. --> Imputing 175 missing values with median (52.0) in feature Humidity3pm. --> Imputing 707 missing values with median (1017.8) in feature Pressure9am. --> Imputing 704 missing values with median (1015.3) in feature Pressure3pm. --> Imputing 2699 missing values with median (5.0) in feature Cloud9am. --> Imputing 2882 missing values with median (5.0) in feature Cloud3pm. --> Imputing 41 missing values with median (16.6) in feature Temp9am. --> Imputing 132 missing values with median (21.2) in feature Temp3pm. --> Dropping 73 samples due to missing values in feature RainToday. In [5]: Copied! # Encode the categorical features atom . encode ( strategy = \"Target\" , max_onehot = 10 , rare_to_value = 0.04 ) # Encode the categorical features atom.encode(strategy=\"Target\", max_onehot=10, rare_to_value=0.04) Fitting Encoder... Encoding categorical columns... --> Target-encoding feature Location. Contains 47 classes. --> Target-encoding feature WindGustDir. Contains 16 classes. --> Target-encoding feature WindDir9am. Contains 16 classes. --> Target-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [6]: Copied! # Train an Extra-Trees and a Random Forest model atom . run ( models = [ \"ET\" , \"RF\" ], metric = \"f1\" , n_bootstrap = 5 ) # Train an Extra-Trees and a Random Forest model atom.run(models=[\"ET\", \"RF\"], metric=\"f1\", n_bootstrap=5) Training ========================= >> Models: ET, RF Metric: f1 Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.532 Time elapsed: 0.215s Bootstrap --------------------------------------- Evaluation --> f1: 0.4959 \u00b1 0.0125 Time elapsed: 1.003s ------------------------------------------------- Total time: 1.218s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> f1: 0.9995 Test evaluation --> f1: 0.5235 Time elapsed: 0.283s Bootstrap --------------------------------------- Evaluation --> f1: 0.5302 \u00b1 0.0048 Time elapsed: 1.285s ------------------------------------------------- Total time: 1.567s Final results ==================== >> Total time: 2.787s ------------------------------------- ExtraTrees --> f1: 0.4959 \u00b1 0.0125 ~ RandomForest --> f1: 0.5302 \u00b1 0.0048 ~ !", "title": "Run the pipeline"}, {"location": "examples/binary_classification/#analyze-the-results", "text": "In [7]: Copied! # Let's have a look at the final results atom . results # Let's have a look at the final results atom.results Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit score_bootstrap time_bootstrap time ET 1.0000 0.5320 0.215197 0.495895 1.002652 1.217849 RF 0.9995 0.5235 0.282572 0.530242 1.284799 1.567371 In [8]: Copied! # Visualize the bootstrap results atom . plot_results ( title = \"RF vs ET performance\" ) # Visualize the bootstrap results atom.plot_results(title=\"RF vs ET performance\")  In [9]: Copied! # Print the results of some common metrics atom . evaluate () # Print the results of some common metrics atom.evaluate() Out[9]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc ET 0.8476 0.6559 0.6878 0.5320 0.3624 0.4789 0.7500 0.4122 0.8499 RF 0.8452 0.6729 0.6835 0.5235 0.3545 0.4692 0.7413 0.4046 0.8583 In [10]: Copied! # The winner attribute calls the best model (atom.winner == atom.rf) print ( f \"The winner is the { atom . winner . name } model!!\" ) # The winner attribute calls the best model (atom.winner == atom.rf) print(f\"The winner is the {atom.winner.name} model!!\") The winner is the RF model!! In [11]: Copied! # Visualize the distribution of predicted probabilities atom . winner . plot_probabilities () # Visualize the distribution of predicted probabilities atom.winner.plot_probabilities()  In [12]: Copied! # Compare how different metrics perform for different thresholds atom . winner . plot_threshold ( metric = [ \"f1\" , \"accuracy\" , \"ap\" ], steps = 50 ) # Compare how different metrics perform for different thresholds atom.winner.plot_threshold(metric=[\"f1\", \"accuracy\", \"ap\"], steps=50) ", "title": "Analyze the results"}, {"location": "examples/calibration/", "text": "Example: Calibration \u00b6 This example shows how to calibrate a classifier through atom. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load the data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load the data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , \"RainTomorrow\" , n_rows = 1e4 , verbose = 1 , warnings = False ) # Apply data cleaning steps atom . clean () atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" ) atom . encode ( strategy = \"target\" , max_onehot = 5 , rare_to_value = 0.05 ) # Train a linear SVM atom . run ( \"lsvm\" ) atom = ATOMClassifier(X, \"RainTomorrow\", n_rows=1e4, verbose=1, warnings=False) # Apply data cleaning steps atom.clean() atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\") atom.encode(strategy=\"target\", max_onehot=5, rare_to_value=0.05) # Train a linear SVM atom.run(\"lsvm\") << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (10000, 22) Memory: 4.34 MB Scaled: False Missing values: 21954 (10.0%) Categorical features: 5 (23.8%) Duplicate samples: 1 (0.0%) ------------------------------------- Train set size: 8000 Test set size: 2000 ------------------------------------- Fitting Cleaner... Cleaning the data... Fitting Imputer... Imputing missing values... Fitting Encoder... Encoding categorical columns... Training ========================= >> Models: lSVM Metric: f1 Results for LinearSVM: Fit --------------------------------------------- Train evaluation --> f1: 0.5829 Test evaluation --> f1: 0.5787 Time elapsed: 0.431s ------------------------------------------------- Total time: 0.431s Final results ==================== >> Total time: 0.431s ------------------------------------- LinearSVM --> f1: 0.5787 Analyze the results \u00b6 In [4]: Copied! # Check the model's calibration atom . plot_calibration () # Check the model's calibration atom.plot_calibration()  In [5]: Copied! # Let's try to improve it using the calibrate method atom . lsvm . calibrate ( method = \"isotonic\" , cv = 5 ) # Let's try to improve it using the calibrate method atom.lsvm.calibrate(method=\"isotonic\", cv=5) Results for LinearSVM: Fit --------------------------------------------- Train evaluation --> f1: 0.6117 Test evaluation --> f1: 0.609 Time elapsed: 2.180s In [6]: Copied! # And check again... atom . plot_calibration () # And check again... atom.plot_calibration() ", "title": "Calibration"}, {"location": "examples/calibration/#example-calibration", "text": "This example shows how to calibrate a classifier through atom. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Calibration"}, {"location": "examples/calibration/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load the data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load the data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/calibration/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X , \"RainTomorrow\" , n_rows = 1e4 , verbose = 1 , warnings = False ) # Apply data cleaning steps atom . clean () atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" ) atom . encode ( strategy = \"target\" , max_onehot = 5 , rare_to_value = 0.05 ) # Train a linear SVM atom . run ( \"lsvm\" ) atom = ATOMClassifier(X, \"RainTomorrow\", n_rows=1e4, verbose=1, warnings=False) # Apply data cleaning steps atom.clean() atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\") atom.encode(strategy=\"target\", max_onehot=5, rare_to_value=0.05) # Train a linear SVM atom.run(\"lsvm\") << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (10000, 22) Memory: 4.34 MB Scaled: False Missing values: 21954 (10.0%) Categorical features: 5 (23.8%) Duplicate samples: 1 (0.0%) ------------------------------------- Train set size: 8000 Test set size: 2000 ------------------------------------- Fitting Cleaner... Cleaning the data... Fitting Imputer... Imputing missing values... Fitting Encoder... Encoding categorical columns... Training ========================= >> Models: lSVM Metric: f1 Results for LinearSVM: Fit --------------------------------------------- Train evaluation --> f1: 0.5829 Test evaluation --> f1: 0.5787 Time elapsed: 0.431s ------------------------------------------------- Total time: 0.431s Final results ==================== >> Total time: 0.431s ------------------------------------- LinearSVM --> f1: 0.5787", "title": "Run the pipeline"}, {"location": "examples/calibration/#analyze-the-results", "text": "In [4]: Copied! # Check the model's calibration atom . plot_calibration () # Check the model's calibration atom.plot_calibration()  In [5]: Copied! # Let's try to improve it using the calibrate method atom . lsvm . calibrate ( method = \"isotonic\" , cv = 5 ) # Let's try to improve it using the calibrate method atom.lsvm.calibrate(method=\"isotonic\", cv=5) Results for LinearSVM: Fit --------------------------------------------- Train evaluation --> f1: 0.6117 Test evaluation --> f1: 0.609 Time elapsed: 2.180s In [6]: Copied! # And check again... atom . plot_calibration () # And check again... atom.plot_calibration() ", "title": "Analyze the results"}, {"location": "examples/deep_learning/", "text": "Example: Deep learning \u00b6 This example shows how to use ATOM to train and validate a Convolutional Neural Network implemented with Keras using scikeras . Import the MNIST dataset from keras.datasets . This is a well known image dataset whose goal is to classify handwritten digits. Load the data \u00b6 In [1]: Copied! # Disable annoying tf warnings import os os . environ [ \"TF_CPP_MIN_LOG_LEVEL\" ] = \"3\" from tensorflow import get_logger get_logger () . setLevel ( 'ERROR' ) import absl.logging absl . logging . set_verbosity ( absl . logging . ERROR ) from atom import ATOMClassifier , ATOMModel from sklearn.preprocessing import FunctionTransformer from optuna.pruners import PatientPruner from optuna.distributions import CategoricalDistribution , IntDistribution from scikeras.wrappers import KerasClassifier from keras.datasets import mnist from keras.models import Sequential from keras.layers import Dense , Flatten , Conv2D , Dropout # Disable annoying tf warnings import os os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\" from tensorflow import get_logger get_logger().setLevel('ERROR') import absl.logging absl.logging.set_verbosity(absl.logging.ERROR) from atom import ATOMClassifier, ATOMModel from sklearn.preprocessing import FunctionTransformer from optuna.pruners import PatientPruner from optuna.distributions import CategoricalDistribution, IntDistribution from scikeras.wrappers import KerasClassifier from keras.datasets import mnist from keras.models import Sequential from keras.layers import Dense, Flatten, Conv2D, Dropout In [2]: Copied! # Create the convolutional neural network class ConvNN ( KerasClassifier ): \"\"\"Convolutional neural network model.\"\"\" @property def feature_encoder ( self ): \"\"\"Convert the 2d input to the image's format (len(X), 28, 28, 1).\"\"\" return FunctionTransformer ( func = lambda X : X . reshape ( X . shape [ 0 ], 28 , 28 , 1 ), ) @staticmethod def _keras_build_fn (): \"\"\"Create the model's architecture.\"\"\" model = Sequential () model . add ( Conv2D ( filters = 8 , kernel_size = 3 , activation = \"relu\" , input_shape = ( 28 , 28 , 1 ), ) ) # model.add(Conv2D(filters=4, kernel_size=5, activation=\"relu\")) model . add ( Flatten ()) model . add ( Dense ( units = 10 , activation = \"softmax\" )) model . compile ( optimizer = \"adam\" , loss = \"sparse_categorical_crossentropy\" , ) return model # Create the convolutional neural network class ConvNN(KerasClassifier): \"\"\"Convolutional neural network model.\"\"\" @property def feature_encoder(self): \"\"\"Convert the 2d input to the image's format (len(X), 28, 28, 1).\"\"\" return FunctionTransformer( func=lambda X: X.reshape(X.shape[0], 28, 28, 1), ) @staticmethod def _keras_build_fn(): \"\"\"Create the model's architecture.\"\"\" model = Sequential() model.add( Conv2D( filters=8, kernel_size=3, activation=\"relu\", input_shape=(28, 28, 1), ) ) # model.add(Conv2D(filters=4, kernel_size=5, activation=\"relu\")) model.add(Flatten()) model.add(Dense(units=10, activation=\"softmax\")) model.compile( optimizer=\"adam\", loss=\"sparse_categorical_crossentropy\", ) return model In [3]: Copied! # Convert the model to an ATOM model model = ATOMModel ( estimator = ConvNN ( verbose = 0 ), acronym = \"CNN\" , needs_scaling = True , # Applies automated feature scaling before fitting has_validation = \"epochs\" , # Applies in-training validation on parameter epochs ) # Convert the model to an ATOM model model = ATOMModel( estimator=ConvNN(verbose=0), acronym=\"CNN\", needs_scaling=True, # Applies automated feature scaling before fitting has_validation=\"epochs\", # Applies in-training validation on parameter epochs ) In [4]: Copied! # Download the MNIST dataset ( X_train , y_train ), ( X_test , y_test ) = mnist . load_data () # Flatten data to follow sklearn's API (2d input) X_train = X_train . reshape ( len ( X_train ), - 1 ) X_test = X_test . reshape ( len ( X_test ), - 1 ) data = ( X_train , y_train ), ( X_test , y_test ) # Download the MNIST dataset (X_train, y_train), (X_test, y_test) = mnist.load_data() # Flatten data to follow sklearn's API (2d input) X_train = X_train.reshape(len(X_train), -1) X_test = X_test.reshape(len(X_test), -1) data = (X_train, y_train), (X_test, y_test) Run the pipeline \u00b6 In [5]: Copied! atom = ATOMClassifier ( * data , n_rows = 0.1 , n_jobs = 1 , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(*data, n_rows=0.1, n_jobs=1, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: multiclass classification. Dataset stats ==================== >> Shape: (7000, 785) Memory: 5.50 MB Scaled: False Outlier values: 41839 (0.9%) ------------------------------------- Train set size: 6000 Test set size: 1000 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 708 (1.2) | 619 (1.2) | 89 (1.1) | | 1 | 765 (1.3) | 648 (1.3) | 117 (1.4) | | 2 | 648 (1.1) | 548 (1.1) | 100 (1.2) | | 3 | 744 (1.3) | 647 (1.3) | 97 (1.2) | | 4 | 721 (1.2) | 607 (1.2) | 114 (1.4) | | 5 | 592 (1.0) | 508 (1.0) | 84 (1.0) | | 6 | 702 (1.2) | 596 (1.2) | 106 (1.3) | | 7 | 725 (1.2) | 634 (1.2) | 91 (1.1) | | 8 | 674 (1.1) | 572 (1.1) | 102 (1.2) | | 9 | 721 (1.2) | 621 (1.2) | 100 (1.2) | In [6]: Copied! # Like any other model, we can define custom distributions for hyperparameter tuning atom . run ( models = model , metric = \"f1_weighted\" , n_trials = 12 , ht_params = { \"distributions\" : { \"epochs\" : IntDistribution ( 10 , 20 ), \"batch_size\" : CategoricalDistribution ([ 128 , 256 , 512 ]), }, } ) # Like any other model, we can define custom distributions for hyperparameter tuning atom.run( models=model, metric=\"f1_weighted\", n_trials=12, ht_params={ \"distributions\": { \"epochs\": IntDistribution(10, 20), \"batch_size\": CategoricalDistribution([128, 256, 512]), }, } ) Training ========================= >> Models: CNN Metric: f1_weighted Running hyperparameter tuning for ConvNN... | trial | epochs | batch_size | f1_weighted | best_f1_weighted | time_trial | time_ht | state | | ----- | ------- | ---------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | 14 | 128 | 0.9289 | 0.9289 | 8.653s | 8.653s | COMPLETE | | 1 | 11 | 512 | 0.9813 | 0.9813 | 5.419s | 14.072s | COMPLETE | | 2 | 14 | 512 | 0.9895 | 0.9895 | 6.476s | 20.548s | COMPLETE | | 3 | 12 | 128 | 0.9872 | 0.9895 | 7.201s | 27.748s | COMPLETE | | 4 | 14 | 128 | 0.9289 | 0.9895 | 0.501s | 28.250s | COMPLETE | | 5 | 18 | 128 | 0.9918 | 0.9918 | 9.587s | 37.836s | COMPLETE | | 6 | 0/19 | 128 | 0.9896 | 0.9918 | 1.812s | 39.649s | PRUNED | | 7 | 0/11 | 128 | 0.9872 | 0.9918 | 1.785s | 41.433s | PRUNED | | 8 | 0/20 | 256 | 0.9895 | 0.9918 | 1.714s | 43.147s | PRUNED | | 9 | 0/17 | 128 | 0.9942 | 0.9942 | 2.011s | 45.158s | PRUNED | | 10 | 18 | 256 | 1.0 | 1.0 | 8.194s | 53.352s | COMPLETE | | 11 | 18 | 256 | 1.0 | 1.0 | 0.472s | 53.824s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 10 Best parameters: --> epochs: 18 --> batch_size: 256 Best evaluation --> f1_weighted: 1.0 Time elapsed: 53.824s Fit --------------------------------------------- Train evaluation --> f1_weighted: 1.0 Test evaluation --> f1_weighted: 0.956 Time elapsed: 14.035s ------------------------------------------------- Total time: 01m:08s Final results ==================== >> Total time: 01m:10s ------------------------------------- ConvNN --> f1_weighted: 0.956 Analyze the results \u00b6 In [7]: Copied! atom . cnn . trials atom.cnn.trials Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } params estimator score time_trial time_ht state trial 0 {'epochs': 14, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.928914 8.652858 8.652858 COMPLETE 1 {'epochs': 11, 'batch_size': 512} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.981337 5.418926 14.071784 COMPLETE 2 {'epochs': 14, 'batch_size': 512} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.989524 6.475881 20.547665 COMPLETE 3 {'epochs': 12, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.987199 7.20054 27.748205 COMPLETE 4 {'epochs': 14, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.928914 0.501456 28.249661 COMPLETE 5 {'epochs': 18, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.991835 9.586706 37.836367 COMPLETE 6 {'epochs': '0/19', 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.989623 1.812356 39.648723 PRUNED 7 {'epochs': '0/11', 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.987222 1.784515 41.433238 PRUNED 8 {'epochs': '0/20', 'batch_size': 256} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.989524 1.714184 43.147422 PRUNED 9 {'epochs': '0/17', 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.994172 2.010827 45.158249 PRUNED 10 {'epochs': 18, 'batch_size': 256} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 1.0 8.193789 53.352038 COMPLETE 11 {'epochs': 18, 'batch_size': 256} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 1.0 0.47243 53.824468 COMPLETE In [8]: Copied! atom . plot_evals ( dataset = \"test+train\" ) atom.plot_evals(dataset=\"test+train\")  In [9]: Copied! # Use the prediction methods like any other model atom . cnn . predict_proba ( X_train ) # Use the prediction methods like any other model atom.cnn.predict_proba(X_train) Out[9]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 4 5 6 7 8 9 0 2.667587e-11 1.423204e-15 1.897321e-09 4.177241e-03 1.959917e-24 9.958220e-01 5.378779e-17 6.769880e-07 3.797666e-15 7.466505e-08 1 1.000000e+00 1.088900e-21 5.665938e-11 1.283312e-12 5.244474e-19 8.513763e-14 1.282690e-13 6.353681e-13 8.923981e-14 6.010767e-15 2 1.604274e-14 6.149738e-11 9.691398e-09 7.262639e-06 9.290258e-01 3.314378e-15 2.463762e-21 7.028911e-02 1.143039e-16 6.777486e-04 3 4.614237e-10 9.999845e-01 1.029637e-05 3.167258e-07 9.058624e-09 6.250572e-09 4.113872e-13 2.947045e-07 4.647981e-06 3.105437e-10 4 5.340953e-18 4.043613e-15 5.067610e-23 3.933897e-12 1.525269e-06 5.161619e-12 2.803127e-18 3.035959e-07 7.792316e-09 9.999982e-01 ... ... ... ... ... ... ... ... ... ... ... 59995 4.641701e-13 5.263499e-17 3.007880e-13 2.409940e-09 1.768155e-19 3.314675e-09 6.546399e-20 2.068865e-17 1.000000e+00 1.930476e-11 59996 1.147092e-09 2.389565e-19 1.974684e-05 9.999623e-01 1.673667e-19 1.556348e-06 3.198247e-21 1.960399e-18 1.608568e-05 2.387261e-07 59997 2.882433e-17 1.390950e-14 8.691903e-22 3.209542e-11 2.343726e-15 1.000000e+00 7.243893e-17 8.511273e-23 4.616474e-10 5.207763e-11 59998 5.087094e-12 2.245045e-18 4.680251e-12 2.838577e-14 2.635410e-10 5.397062e-10 1.000000e+00 6.982087e-15 8.221984e-15 6.926972e-19 59999 2.945166e-05 1.761085e-11 1.337117e-10 2.293348e-10 6.817801e-12 1.130618e-02 1.809152e-11 3.875938e-13 9.886596e-01 4.672157e-06 60000 rows \u00d7 10 columns In [10]: Copied! # Or make plots... atom . cnn . plot_hyperparameters () # Or make plots... atom.cnn.plot_hyperparameters() ", "title": "Deep learning"}, {"location": "examples/deep_learning/#example-deep-learning", "text": "This example shows how to use ATOM to train and validate a Convolutional Neural Network implemented with Keras using scikeras . Import the MNIST dataset from keras.datasets . This is a well known image dataset whose goal is to classify handwritten digits.", "title": "Example: Deep learning"}, {"location": "examples/deep_learning/#load-the-data", "text": "In [1]: Copied! # Disable annoying tf warnings import os os . environ [ \"TF_CPP_MIN_LOG_LEVEL\" ] = \"3\" from tensorflow import get_logger get_logger () . setLevel ( 'ERROR' ) import absl.logging absl . logging . set_verbosity ( absl . logging . ERROR ) from atom import ATOMClassifier , ATOMModel from sklearn.preprocessing import FunctionTransformer from optuna.pruners import PatientPruner from optuna.distributions import CategoricalDistribution , IntDistribution from scikeras.wrappers import KerasClassifier from keras.datasets import mnist from keras.models import Sequential from keras.layers import Dense , Flatten , Conv2D , Dropout # Disable annoying tf warnings import os os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\" from tensorflow import get_logger get_logger().setLevel('ERROR') import absl.logging absl.logging.set_verbosity(absl.logging.ERROR) from atom import ATOMClassifier, ATOMModel from sklearn.preprocessing import FunctionTransformer from optuna.pruners import PatientPruner from optuna.distributions import CategoricalDistribution, IntDistribution from scikeras.wrappers import KerasClassifier from keras.datasets import mnist from keras.models import Sequential from keras.layers import Dense, Flatten, Conv2D, Dropout In [2]: Copied! # Create the convolutional neural network class ConvNN ( KerasClassifier ): \"\"\"Convolutional neural network model.\"\"\" @property def feature_encoder ( self ): \"\"\"Convert the 2d input to the image's format (len(X), 28, 28, 1).\"\"\" return FunctionTransformer ( func = lambda X : X . reshape ( X . shape [ 0 ], 28 , 28 , 1 ), ) @staticmethod def _keras_build_fn (): \"\"\"Create the model's architecture.\"\"\" model = Sequential () model . add ( Conv2D ( filters = 8 , kernel_size = 3 , activation = \"relu\" , input_shape = ( 28 , 28 , 1 ), ) ) # model.add(Conv2D(filters=4, kernel_size=5, activation=\"relu\")) model . add ( Flatten ()) model . add ( Dense ( units = 10 , activation = \"softmax\" )) model . compile ( optimizer = \"adam\" , loss = \"sparse_categorical_crossentropy\" , ) return model # Create the convolutional neural network class ConvNN(KerasClassifier): \"\"\"Convolutional neural network model.\"\"\" @property def feature_encoder(self): \"\"\"Convert the 2d input to the image's format (len(X), 28, 28, 1).\"\"\" return FunctionTransformer( func=lambda X: X.reshape(X.shape[0], 28, 28, 1), ) @staticmethod def _keras_build_fn(): \"\"\"Create the model's architecture.\"\"\" model = Sequential() model.add( Conv2D( filters=8, kernel_size=3, activation=\"relu\", input_shape=(28, 28, 1), ) ) # model.add(Conv2D(filters=4, kernel_size=5, activation=\"relu\")) model.add(Flatten()) model.add(Dense(units=10, activation=\"softmax\")) model.compile( optimizer=\"adam\", loss=\"sparse_categorical_crossentropy\", ) return model In [3]: Copied! # Convert the model to an ATOM model model = ATOMModel ( estimator = ConvNN ( verbose = 0 ), acronym = \"CNN\" , needs_scaling = True , # Applies automated feature scaling before fitting has_validation = \"epochs\" , # Applies in-training validation on parameter epochs ) # Convert the model to an ATOM model model = ATOMModel( estimator=ConvNN(verbose=0), acronym=\"CNN\", needs_scaling=True, # Applies automated feature scaling before fitting has_validation=\"epochs\", # Applies in-training validation on parameter epochs ) In [4]: Copied! # Download the MNIST dataset ( X_train , y_train ), ( X_test , y_test ) = mnist . load_data () # Flatten data to follow sklearn's API (2d input) X_train = X_train . reshape ( len ( X_train ), - 1 ) X_test = X_test . reshape ( len ( X_test ), - 1 ) data = ( X_train , y_train ), ( X_test , y_test ) # Download the MNIST dataset (X_train, y_train), (X_test, y_test) = mnist.load_data() # Flatten data to follow sklearn's API (2d input) X_train = X_train.reshape(len(X_train), -1) X_test = X_test.reshape(len(X_test), -1) data = (X_train, y_train), (X_test, y_test)", "title": "Load the data"}, {"location": "examples/deep_learning/#run-the-pipeline", "text": "In [5]: Copied! atom = ATOMClassifier ( * data , n_rows = 0.1 , n_jobs = 1 , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(*data, n_rows=0.1, n_jobs=1, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: multiclass classification. Dataset stats ==================== >> Shape: (7000, 785) Memory: 5.50 MB Scaled: False Outlier values: 41839 (0.9%) ------------------------------------- Train set size: 6000 Test set size: 1000 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 708 (1.2) | 619 (1.2) | 89 (1.1) | | 1 | 765 (1.3) | 648 (1.3) | 117 (1.4) | | 2 | 648 (1.1) | 548 (1.1) | 100 (1.2) | | 3 | 744 (1.3) | 647 (1.3) | 97 (1.2) | | 4 | 721 (1.2) | 607 (1.2) | 114 (1.4) | | 5 | 592 (1.0) | 508 (1.0) | 84 (1.0) | | 6 | 702 (1.2) | 596 (1.2) | 106 (1.3) | | 7 | 725 (1.2) | 634 (1.2) | 91 (1.1) | | 8 | 674 (1.1) | 572 (1.1) | 102 (1.2) | | 9 | 721 (1.2) | 621 (1.2) | 100 (1.2) | In [6]: Copied! # Like any other model, we can define custom distributions for hyperparameter tuning atom . run ( models = model , metric = \"f1_weighted\" , n_trials = 12 , ht_params = { \"distributions\" : { \"epochs\" : IntDistribution ( 10 , 20 ), \"batch_size\" : CategoricalDistribution ([ 128 , 256 , 512 ]), }, } ) # Like any other model, we can define custom distributions for hyperparameter tuning atom.run( models=model, metric=\"f1_weighted\", n_trials=12, ht_params={ \"distributions\": { \"epochs\": IntDistribution(10, 20), \"batch_size\": CategoricalDistribution([128, 256, 512]), }, } ) Training ========================= >> Models: CNN Metric: f1_weighted Running hyperparameter tuning for ConvNN... | trial | epochs | batch_size | f1_weighted | best_f1_weighted | time_trial | time_ht | state | | ----- | ------- | ---------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | 14 | 128 | 0.9289 | 0.9289 | 8.653s | 8.653s | COMPLETE | | 1 | 11 | 512 | 0.9813 | 0.9813 | 5.419s | 14.072s | COMPLETE | | 2 | 14 | 512 | 0.9895 | 0.9895 | 6.476s | 20.548s | COMPLETE | | 3 | 12 | 128 | 0.9872 | 0.9895 | 7.201s | 27.748s | COMPLETE | | 4 | 14 | 128 | 0.9289 | 0.9895 | 0.501s | 28.250s | COMPLETE | | 5 | 18 | 128 | 0.9918 | 0.9918 | 9.587s | 37.836s | COMPLETE | | 6 | 0/19 | 128 | 0.9896 | 0.9918 | 1.812s | 39.649s | PRUNED | | 7 | 0/11 | 128 | 0.9872 | 0.9918 | 1.785s | 41.433s | PRUNED | | 8 | 0/20 | 256 | 0.9895 | 0.9918 | 1.714s | 43.147s | PRUNED | | 9 | 0/17 | 128 | 0.9942 | 0.9942 | 2.011s | 45.158s | PRUNED | | 10 | 18 | 256 | 1.0 | 1.0 | 8.194s | 53.352s | COMPLETE | | 11 | 18 | 256 | 1.0 | 1.0 | 0.472s | 53.824s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 10 Best parameters: --> epochs: 18 --> batch_size: 256 Best evaluation --> f1_weighted: 1.0 Time elapsed: 53.824s Fit --------------------------------------------- Train evaluation --> f1_weighted: 1.0 Test evaluation --> f1_weighted: 0.956 Time elapsed: 14.035s ------------------------------------------------- Total time: 01m:08s Final results ==================== >> Total time: 01m:10s ------------------------------------- ConvNN --> f1_weighted: 0.956", "title": "Run the pipeline"}, {"location": "examples/deep_learning/#analyze-the-results", "text": "In [7]: Copied! atom . cnn . trials atom.cnn.trials Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } params estimator score time_trial time_ht state trial 0 {'epochs': 14, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.928914 8.652858 8.652858 COMPLETE 1 {'epochs': 11, 'batch_size': 512} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.981337 5.418926 14.071784 COMPLETE 2 {'epochs': 14, 'batch_size': 512} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.989524 6.475881 20.547665 COMPLETE 3 {'epochs': 12, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.987199 7.20054 27.748205 COMPLETE 4 {'epochs': 14, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.928914 0.501456 28.249661 COMPLETE 5 {'epochs': 18, 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.991835 9.586706 37.836367 COMPLETE 6 {'epochs': '0/19', 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.989623 1.812356 39.648723 PRUNED 7 {'epochs': '0/11', 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.987222 1.784515 41.433238 PRUNED 8 {'epochs': '0/20', 'batch_size': 256} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.989524 1.714184 43.147422 PRUNED 9 {'epochs': '0/17', 'batch_size': 128} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 0.994172 2.010827 45.158249 PRUNED 10 {'epochs': 18, 'batch_size': 256} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 1.0 8.193789 53.352038 COMPLETE 11 {'epochs': 18, 'batch_size': 256} ConvNN(\\n\\tmodel=None\\n\\tbuild_fn=None\\n\\twarm... 1.0 0.47243 53.824468 COMPLETE In [8]: Copied! atom . plot_evals ( dataset = \"test+train\" ) atom.plot_evals(dataset=\"test+train\")  In [9]: Copied! # Use the prediction methods like any other model atom . cnn . predict_proba ( X_train ) # Use the prediction methods like any other model atom.cnn.predict_proba(X_train) Out[9]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 4 5 6 7 8 9 0 2.667587e-11 1.423204e-15 1.897321e-09 4.177241e-03 1.959917e-24 9.958220e-01 5.378779e-17 6.769880e-07 3.797666e-15 7.466505e-08 1 1.000000e+00 1.088900e-21 5.665938e-11 1.283312e-12 5.244474e-19 8.513763e-14 1.282690e-13 6.353681e-13 8.923981e-14 6.010767e-15 2 1.604274e-14 6.149738e-11 9.691398e-09 7.262639e-06 9.290258e-01 3.314378e-15 2.463762e-21 7.028911e-02 1.143039e-16 6.777486e-04 3 4.614237e-10 9.999845e-01 1.029637e-05 3.167258e-07 9.058624e-09 6.250572e-09 4.113872e-13 2.947045e-07 4.647981e-06 3.105437e-10 4 5.340953e-18 4.043613e-15 5.067610e-23 3.933897e-12 1.525269e-06 5.161619e-12 2.803127e-18 3.035959e-07 7.792316e-09 9.999982e-01 ... ... ... ... ... ... ... ... ... ... ... 59995 4.641701e-13 5.263499e-17 3.007880e-13 2.409940e-09 1.768155e-19 3.314675e-09 6.546399e-20 2.068865e-17 1.000000e+00 1.930476e-11 59996 1.147092e-09 2.389565e-19 1.974684e-05 9.999623e-01 1.673667e-19 1.556348e-06 3.198247e-21 1.960399e-18 1.608568e-05 2.387261e-07 59997 2.882433e-17 1.390950e-14 8.691903e-22 3.209542e-11 2.343726e-15 1.000000e+00 7.243893e-17 8.511273e-23 4.616474e-10 5.207763e-11 59998 5.087094e-12 2.245045e-18 4.680251e-12 2.838577e-14 2.635410e-10 5.397062e-10 1.000000e+00 6.982087e-15 8.221984e-15 6.926972e-19 59999 2.945166e-05 1.761085e-11 1.337117e-10 2.293348e-10 6.817801e-12 1.130618e-02 1.809152e-11 3.875938e-13 9.886596e-01 4.672157e-06 60000 rows \u00d7 10 columns In [10]: Copied! # Or make plots... atom . cnn . plot_hyperparameters () # Or make plots... atom.cnn.plot_hyperparameters() ", "title": "Analyze the results"}, {"location": "examples/ensembles/", "text": "Example: Ensembles \u00b6 This example shows how to use atom's ensemble techniques to improve predictions on a dataset combining several models. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) # Load the data X, y = load_breast_cancer(return_X_y=True, as_frame=True) Run the pipeline \u00b6 In [3]: Copied! # Initialize atom and train several models atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) atom . run ( models = [ \"LR\" , \"Tree\" , \"LGB\" ], metric = \"accuracy\" ) # Initialize atom and train several models atom = ATOMClassifier(X, y, verbose=2, random_state=1) atom.run(models=[\"LR\", \"Tree\", \"LGB\"], metric=\"accuracy\") << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | Training ========================= >> Models: LR, Tree, LGB Metric: accuracy Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> accuracy: 0.989 Test evaluation --> accuracy: 0.9823 Time elapsed: 0.081s ------------------------------------------------- Total time: 0.081s Results for DecisionTree: Fit --------------------------------------------- Train evaluation --> accuracy: 1.0 Test evaluation --> accuracy: 0.9469 Time elapsed: 0.023s ------------------------------------------------- Total time: 0.023s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> accuracy: 1.0 Test evaluation --> accuracy: 0.9469 Time elapsed: 0.443s ------------------------------------------------- Total time: 0.443s Final results ==================== >> Total time: 0.551s ------------------------------------- LogisticRegression --> accuracy: 0.9823 ! DecisionTree --> accuracy: 0.9469 LightGBM --> accuracy: 0.9469 Voting \u00b6 In [4]: Copied! # Combine the models into a Voting model atom . voting ( voting = \"soft\" ) # Combine the models into a Voting model atom.voting(voting=\"soft\") Results for Voting: Fit --------------------------------------------- Train evaluation --> accuracy: 1.0 Test evaluation --> accuracy: 0.9469 Time elapsed: 0.041s In [5]: Copied! # Note that we now have an extra model in the pipeline atom . models # Note that we now have an extra model in the pipeline atom.models Out[5]: ['LR', 'Tree', 'LGB', 'Vote'] In [6]: Copied! # The plot_pipeline method helps us visualize the ensemble atom . plot_pipeline () # The plot_pipeline method helps us visualize the ensemble atom.plot_pipeline() In [7]: Copied! # The Vote model averages the scores of the models it contains atom . vote # The Vote model averages the scores of the models it contains atom.vote Out[7]: Voting --> Estimator: VotingClassifier --> Evaluation: accuracy: 0.9469 In [8]: Copied! # We can use it like any other model to make predictions or plots atom . vote . predict_proba_test [: 10 ] # We can use it like any other model to make predictions or plots atom.vote.predict_proba_test[:10] Out[8]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 456 0.060290 0.939710 457 0.999984 0.000016 458 0.000018 0.999982 459 0.000046 0.999954 460 0.999990 0.000010 461 0.028359 0.971641 462 0.000027 0.999973 463 0.000224 0.999776 464 0.999975 0.000025 465 0.000016 0.999984 In [9]: Copied! atom . vote . plot_threshold ( metric = [ \"auc\" , \"recall\" , \"accuracy\" ]) atom.vote.plot_threshold(metric=[\"auc\", \"recall\", \"accuracy\"])  In [10]: Copied! atom . plot_results ( legend = None ) atom.plot_results(legend=None)  In [11]: Copied! atom . vote . delete () atom.vote.delete() Model Vote successfully deleted. Stacking \u00b6 In [12]: Copied! # Just like Voting, we can create a Stacking model atom . stacking ( final_estimator = \"LDA\" ) # Just like Voting, we can create a Stacking model atom.stacking(final_estimator=\"LDA\") Results for Stacking: Fit --------------------------------------------- Train evaluation --> accuracy: 0.9934 Test evaluation --> accuracy: 0.9823 Time elapsed: 1.265s In [13]: Copied! # The final estimator uses the predictions of the underlying models atom . stack . head () # The final estimator uses the predictions of the underlying models atom.stack.head() Out[13]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean radius mean texture mean perimeter mean area mean smoothness mean compactness mean concavity mean concave points mean symmetry mean fractal dimension ... worst texture worst perimeter worst area worst smoothness worst compactness worst concavity worst concave points worst symmetry worst fractal dimension target 0 13.48 20.82 88.40 559.2 0.10160 0.12550 0.10630 0.05439 0.1720 0.06419 ... 26.02 107.30 740.4 0.1610 0.42250 0.5030 0.22580 0.2807 0.10710 0 1 18.31 20.58 120.80 1052.0 0.10680 0.12480 0.15690 0.09451 0.1860 0.05941 ... 26.20 142.20 1493.0 0.1492 0.25360 0.3759 0.15100 0.3074 0.07863 0 2 17.93 24.48 115.20 998.9 0.08855 0.07027 0.05699 0.04744 0.1538 0.05510 ... 34.69 135.10 1320.0 0.1315 0.18060 0.2080 0.11360 0.2504 0.07948 0 3 15.13 29.81 96.71 719.5 0.08320 0.04605 0.04686 0.02739 0.1852 0.05294 ... 36.91 110.10 931.4 0.1148 0.09866 0.1547 0.06575 0.3233 0.06165 0 4 8.95 15.76 58.74 245.2 0.09462 0.12430 0.09263 0.02308 0.1305 0.07163 ... 17.07 63.34 270.0 0.1179 0.18790 0.1544 0.03846 0.1652 0.07722 1 5 rows \u00d7 31 columns In [14]: Copied! # Again, the model can be used for predictions or plots atom . stack . predict ( X ) # Again, the model can be used for predictions or plots atom.stack.predict(X) Out[14]: 0 0 1 0 2 0 3 0 4 0 .. 564 0 565 0 566 0 567 0 568 1 Name: predict, Length: 569, dtype: int32 In [15]: Copied! atom . stack . plot_shap_beeswarm ( show = 10 ) atom.stack.plot_shap_beeswarm(show=10) Permutation explainer: 114it [00:19, 4.28it/s]", "title": "Ensembles"}, {"location": "examples/ensembles/#example-ensembles", "text": "This example shows how to use atom's ensemble techniques to improve predictions on a dataset combining several models. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: Ensembles"}, {"location": "examples/ensembles/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True , as_frame = True ) # Load the data X, y = load_breast_cancer(return_X_y=True, as_frame=True)", "title": "Load the data"}, {"location": "examples/ensembles/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom and train several models atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) atom . run ( models = [ \"LR\" , \"Tree\" , \"LGB\" ], metric = \"accuracy\" ) # Initialize atom and train several models atom = ATOMClassifier(X, y, verbose=2, random_state=1) atom.run(models=[\"LR\", \"Tree\", \"LGB\"], metric=\"accuracy\") << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | Training ========================= >> Models: LR, Tree, LGB Metric: accuracy Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> accuracy: 0.989 Test evaluation --> accuracy: 0.9823 Time elapsed: 0.081s ------------------------------------------------- Total time: 0.081s Results for DecisionTree: Fit --------------------------------------------- Train evaluation --> accuracy: 1.0 Test evaluation --> accuracy: 0.9469 Time elapsed: 0.023s ------------------------------------------------- Total time: 0.023s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> accuracy: 1.0 Test evaluation --> accuracy: 0.9469 Time elapsed: 0.443s ------------------------------------------------- Total time: 0.443s Final results ==================== >> Total time: 0.551s ------------------------------------- LogisticRegression --> accuracy: 0.9823 ! DecisionTree --> accuracy: 0.9469 LightGBM --> accuracy: 0.9469", "title": "Run the pipeline"}, {"location": "examples/ensembles/#voting", "text": "In [4]: Copied! # Combine the models into a Voting model atom . voting ( voting = \"soft\" ) # Combine the models into a Voting model atom.voting(voting=\"soft\") Results for Voting: Fit --------------------------------------------- Train evaluation --> accuracy: 1.0 Test evaluation --> accuracy: 0.9469 Time elapsed: 0.041s In [5]: Copied! # Note that we now have an extra model in the pipeline atom . models # Note that we now have an extra model in the pipeline atom.models Out[5]: ['LR', 'Tree', 'LGB', 'Vote'] In [6]: Copied! # The plot_pipeline method helps us visualize the ensemble atom . plot_pipeline () # The plot_pipeline method helps us visualize the ensemble atom.plot_pipeline() In [7]: Copied! # The Vote model averages the scores of the models it contains atom . vote # The Vote model averages the scores of the models it contains atom.vote Out[7]: Voting --> Estimator: VotingClassifier --> Evaluation: accuracy: 0.9469 In [8]: Copied! # We can use it like any other model to make predictions or plots atom . vote . predict_proba_test [: 10 ] # We can use it like any other model to make predictions or plots atom.vote.predict_proba_test[:10] Out[8]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 456 0.060290 0.939710 457 0.999984 0.000016 458 0.000018 0.999982 459 0.000046 0.999954 460 0.999990 0.000010 461 0.028359 0.971641 462 0.000027 0.999973 463 0.000224 0.999776 464 0.999975 0.000025 465 0.000016 0.999984 In [9]: Copied! atom . vote . plot_threshold ( metric = [ \"auc\" , \"recall\" , \"accuracy\" ]) atom.vote.plot_threshold(metric=[\"auc\", \"recall\", \"accuracy\"])  In [10]: Copied! atom . plot_results ( legend = None ) atom.plot_results(legend=None)  In [11]: Copied! atom . vote . delete () atom.vote.delete() Model Vote successfully deleted.", "title": "Voting"}, {"location": "examples/ensembles/#stacking", "text": "In [12]: Copied! # Just like Voting, we can create a Stacking model atom . stacking ( final_estimator = \"LDA\" ) # Just like Voting, we can create a Stacking model atom.stacking(final_estimator=\"LDA\") Results for Stacking: Fit --------------------------------------------- Train evaluation --> accuracy: 0.9934 Test evaluation --> accuracy: 0.9823 Time elapsed: 1.265s In [13]: Copied! # The final estimator uses the predictions of the underlying models atom . stack . head () # The final estimator uses the predictions of the underlying models atom.stack.head() Out[13]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean radius mean texture mean perimeter mean area mean smoothness mean compactness mean concavity mean concave points mean symmetry mean fractal dimension ... worst texture worst perimeter worst area worst smoothness worst compactness worst concavity worst concave points worst symmetry worst fractal dimension target 0 13.48 20.82 88.40 559.2 0.10160 0.12550 0.10630 0.05439 0.1720 0.06419 ... 26.02 107.30 740.4 0.1610 0.42250 0.5030 0.22580 0.2807 0.10710 0 1 18.31 20.58 120.80 1052.0 0.10680 0.12480 0.15690 0.09451 0.1860 0.05941 ... 26.20 142.20 1493.0 0.1492 0.25360 0.3759 0.15100 0.3074 0.07863 0 2 17.93 24.48 115.20 998.9 0.08855 0.07027 0.05699 0.04744 0.1538 0.05510 ... 34.69 135.10 1320.0 0.1315 0.18060 0.2080 0.11360 0.2504 0.07948 0 3 15.13 29.81 96.71 719.5 0.08320 0.04605 0.04686 0.02739 0.1852 0.05294 ... 36.91 110.10 931.4 0.1148 0.09866 0.1547 0.06575 0.3233 0.06165 0 4 8.95 15.76 58.74 245.2 0.09462 0.12430 0.09263 0.02308 0.1305 0.07163 ... 17.07 63.34 270.0 0.1179 0.18790 0.1544 0.03846 0.1652 0.07722 1 5 rows \u00d7 31 columns In [14]: Copied! # Again, the model can be used for predictions or plots atom . stack . predict ( X ) # Again, the model can be used for predictions or plots atom.stack.predict(X) Out[14]: 0 0 1 0 2 0 3 0 4 0 .. 564 0 565 0 566 0 567 0 568 1 Name: predict, Length: 569, dtype: int32 In [15]: Copied! atom . stack . plot_shap_beeswarm ( show = 10 ) atom.stack.plot_shap_beeswarm(show=10) Permutation explainer: 114it [00:19, 4.28it/s]", "title": "Stacking"}, {"location": "examples/feature_engineering/", "text": "Example: Feature engineering \u00b6 This example shows how to use automated feature generation to improve a model's performance. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! # Initialize atom and apply data cleaning atom = ATOMClassifier ( X , n_rows = 1e4 , test_size = 0.2 , verbose = 0 ) atom . impute ( strat_num = \"knn\" , strat_cat = \"remove\" , max_nan_rows = 0.8 ) atom . encode ( max_onehot = 10 , rare_to_value = 0.04 ) # Initialize atom and apply data cleaning atom = ATOMClassifier(X, n_rows=1e4, test_size=0.2, verbose=0) atom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8) atom.encode(max_onehot=10, rare_to_value=0.04) In [4]: Copied! atom . verbose = 2 # Increase verbosity to see the output # Let's see how a LightGBM model performs atom . run ( 'LGB' , metric = 'auc' ) atom.verbose = 2 # Increase verbosity to see the output # Let's see how a LightGBM model performs atom.run('LGB', metric='auc') Training ========================= >> Models: LGB Metric: roc_auc Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9818 Test evaluation --> roc_auc: 0.8625 Time elapsed: 0.696s ------------------------------------------------- Total time: 0.696s Final results ==================== >> Total time: 0.697s ------------------------------------- LightGBM --> roc_auc: 0.8625 Deep Feature Synthesis \u00b6 In [5]: Copied! # Since we are going to compare different datasets, # we need to create separate branches atom . branch = \"dfs\" # Since we are going to compare different datasets, # we need to create separate branches atom.branch = \"dfs\" New branch dfs successfully created. In [6]: Copied! # Create 50 new features using dfs atom . feature_generation ( \"dfs\" , n_features = 50 , operators = [ \"add\" , \"sub\" , \"log\" ]) # Create 50 new features using dfs atom.feature_generation(\"dfs\", n_features=50, operators=[\"add\", \"sub\", \"log\"]) Fitting FeatureGenerator... Generating new features... --> 50 new features were added. In [7]: Copied! # The warnings warn us that some operators created missing values! # We can see the columns with missing values using the nans attribute atom . nans # The warnings warn us that some operators created missing values! # We can see the columns with missing values using the nans attribute atom.nans Out[7]: NATURAL_LOGARITHM(Cloud3pm) 332 NATURAL_LOGARITHM(Evaporation) 19 NATURAL_LOGARITHM(Rainfall) 6351 dtype: int64 In [8]: Copied! # Turn off warnings in the future atom . warnings = False # Impute the data again to get rid of the missing values atom . impute ( strat_num = \"knn\" , strat_cat = \"remove\" , max_nan_rows = 0.8 ) # Turn off warnings in the future atom.warnings = False # Impute the data again to get rid of the missing values atom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8) Fitting Imputer... Imputing missing values... --> Imputing 332 missing values using the KNN imputer in feature NATURAL_LOGARITHM(Cloud3pm). --> Imputing 19 missing values using the KNN imputer in feature NATURAL_LOGARITHM(Evaporation). --> Imputing 6351 missing values using the KNN imputer in feature NATURAL_LOGARITHM(Rainfall). In [9]: Copied! # 50 new features may be to much... # Let's check for multicollinearity and use rfecv to reduce the number atom . feature_selection ( strategy = \"rfecv\" , solver = \"LGB\" , n_features = 30 , scoring = \"auc\" , max_correlation = 0.98 , ) # 50 new features may be to much... # Let's check for multicollinearity and use rfecv to reduce the number atom.feature_selection( strategy=\"rfecv\", solver=\"LGB\", n_features=30, scoring=\"auc\", max_correlation=0.98, ) Fitting FeatureSelector... Performing feature selection ... --> Feature MinTemp was removed due to collinearity with another feature. --> Feature Location + MaxTemp was removed due to collinearity with another feature. --> Feature Location + Rainfall was removed due to collinearity with another feature. --> Feature Sunshine was removed due to collinearity with another feature. --> Feature Sunshine + WindGustDir was removed due to collinearity with another feature. --> Feature RainToday_No + WindGustSpeed was removed due to collinearity with another feature. --> Feature WindSpeed9am was removed due to collinearity with another feature. --> Feature WindSpeed3pm was removed due to collinearity with another feature. --> Feature Humidity3pm was removed due to collinearity with another feature. --> Feature Humidity3pm + RainToday_rare was removed due to collinearity with another feature. --> Feature Humidity3pm - WindDir9am was removed due to collinearity with another feature. --> Feature NATURAL_LOGARITHM(Pressure9am) was removed due to collinearity with another feature. --> Feature Pressure9am - WindGustDir was removed due to collinearity with another feature. --> Feature Pressure3pm - WindDir3pm was removed due to collinearity with another feature. --> Feature Cloud9am - WindDir3pm was removed due to collinearity with another feature. --> Feature RainToday_No - WindDir9am was removed due to collinearity with another feature. --> Feature RainToday_Yes was removed due to collinearity with another feature. --> Feature Location + RainToday_Yes was removed due to collinearity with another feature. --> Feature RainToday_Yes - WindDir3pm was removed due to collinearity with another feature. --> Feature Humidity3pm - MinTemp was removed due to collinearity with another feature. --> Feature RainToday_rare - WindSpeed3pm was removed due to collinearity with another feature. --> rfecv selected 44 features from the dataset. --> Dropping feature Location (rank 9). --> Dropping feature RainToday_No (rank 8). --> Dropping feature RainToday_rare (rank 6). --> Dropping feature Location - RainToday_rare (rank 3). --> Dropping feature Location - WindGustDir (rank 4). --> Dropping feature NATURAL_LOGARITHM(Cloud3pm) (rank 7). --> Dropping feature NATURAL_LOGARITHM(Evaporation) (rank 5). --> Dropping feature NATURAL_LOGARITHM(Rainfall) (rank 2). In [10]: Copied! # The collinear attribute shows what features were removed due to multicollinearity atom . collinear # The collinear attribute shows what features were removed due to multicollinearity atom.collinear Out[10]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } drop corr_feature corr_value 0 MinTemp MinTemp + RainToday_rare 0.9999 1 Location + MaxTemp MaxTemp 1.0 2 Location + Rainfall Rainfall 1.0 3 Sunshine RainToday_rare + Sunshine, Sunshine + WindGustDir 0.9995, 0.9999 4 Sunshine + WindGustDir Sunshine, RainToday_rare + Sunshine 0.9999, 0.9993 5 RainToday_No + WindGustSpeed WindGustSpeed 0.9995 6 WindSpeed9am RainToday_rare + WindSpeed9am 1.0 7 WindSpeed3pm WindDir9am + WindSpeed3pm 1.0 8 Humidity3pm Cloud3pm + Humidity3pm, Humidity3pm + RainToda... 0.996, 1.0, 1.0 9 Humidity3pm + RainToday_rare Humidity3pm, Cloud3pm + Humidity3pm, Humidity3... 1.0, 0.996, 1.0 10 Humidity3pm - WindDir9am Humidity3pm, Cloud3pm + Humidity3pm, Humidity3... 1.0, 0.996, 1.0 11 NATURAL_LOGARITHM(Pressure9am) Pressure9am, Pressure9am - WindGustDir 1.0, 1.0 12 Pressure9am - WindGustDir Pressure9am, NATURAL_LOGARITHM(Pressure9am) 1.0, 1.0 13 Pressure3pm - WindDir3pm Pressure3pm 1.0 14 Cloud9am - WindDir3pm Cloud9am 0.9998 15 RainToday_No - WindDir9am RainToday_No 0.9906 16 RainToday_Yes Location + RainToday_Yes, RainToday_Yes + Wind... 1.0, 0.9946, 0.9941 17 Location + RainToday_Yes RainToday_Yes, RainToday_Yes + WindGustDir, Ra... 1.0, 0.9946, 0.9941 18 RainToday_Yes - WindDir3pm RainToday_Yes, Location + RainToday_Yes, RainT... 0.9941, 0.9941, 0.9824 19 Humidity3pm - MinTemp Humidity3pm - MaxTemp 0.9877 20 RainToday_rare - WindSpeed3pm RainToday_Yes - WindSpeed3pm 0.9988 In [11]: Copied! # After applying rfecv, we can plot the score per number of features atom . plot_rfecv () # After applying rfecv, we can plot the score per number of features atom.plot_rfecv()  In [12]: Copied! # Let's see how the model performs now # Add a tag to the model's acronym to not overwrite previous LGB atom . run ( \"LGB_dfs\" ) # Let's see how the model performs now # Add a tag to the model's acronym to not overwrite previous LGB atom.run(\"LGB_dfs\") Training ========================= >> Models: LGB_dfs Metric: roc_auc Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9906 Test evaluation --> roc_auc: 0.8616 Time elapsed: 1.485s ------------------------------------------------- Total time: 1.485s Final results ==================== >> Total time: 1.485s ------------------------------------- LightGBM --> roc_auc: 0.8616 Genetic Feature Generation \u00b6 In [13]: Copied! # Create another branch for the genetic features # Split form master to avoid the dfs features atom . branch = \"gfg_from_master\" # Create another branch for the genetic features # Split form master to avoid the dfs features atom.branch = \"gfg_from_master\" New branch gfg successfully created. In [14]: Copied! # Create new features using Genetic Programming atom . feature_generation ( strategy = 'gfg' , n_features = 20 ) # Create new features using Genetic Programming atom.feature_generation(strategy='gfg', n_features=20) Fitting FeatureGenerator... | Population Average | Best Individual | ---- ------------------------- ------------------------------------------ ---------- Gen Length Fitness Length Fitness OOB Fitness Time Left 0 3.08 0.129852 3 0.485297 N/A 21.97s 1 3.06 0.329673 3 0.492484 N/A 26.06s 2 3.27 0.419512 5 0.510269 N/A 22.29s 3 3.90 0.44394 6 0.512441 N/A 22.04s 4 5.31 0.471916 9 0.516333 N/A 20.13s 5 5.36 0.457234 10 0.51887 N/A 22.43s 6 6.05 0.454503 16 0.51986 N/A 18.27s 7 8.56 0.480404 16 0.51986 N/A 13.40s 8 9.73 0.482795 16 0.51986 N/A 12.82s 9 9.79 0.483111 16 0.51986 N/A 11.88s 10 9.95 0.482671 16 0.51986 N/A 11.42s 11 9.96 0.477608 16 0.51986 N/A 12.71s 12 10.10 0.480786 16 0.51986 N/A 10.02s 13 10.03 0.480488 16 0.51986 N/A 7.30s 14 10.03 0.484053 16 0.51986 N/A 6.06s 15 9.95 0.478832 10 0.520691 N/A 5.55s 16 10.10 0.482892 16 0.520868 N/A 3.67s 17 9.99 0.482447 12 0.521197 N/A 2.46s 18 10.02 0.47667 17 0.521669 N/A 1.23s 19 10.05 0.482259 16 0.521743 N/A 0.00s Generating new features... --> 20 new features were added. In [15]: Copied! # We can see the feature's fitness and description through the genetic_features attribute atom . genetic_features # We can see the feature's fitness and description through the genetic_features attribute atom.genetic_features Out[15]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name description fitness 0 x23 log(mul(add(add(WindGustSpeed, sub(Humidity3pm... 0.510691 1 x24 log(mul(add(sub(add(WindGustSpeed, Humidity3pm... 0.510691 2 x25 log(log(mul(add(sub(add(WindGustSpeed, Humidit... 0.510057 3 x26 log(log(mul(add(add(WindGustSpeed, sub(Humidit... 0.510057 4 x27 log(mul(mul(add(add(WindGustSpeed, sub(Humidit... 0.509417 5 x28 log(mul(mul(add(sub(add(WindGustSpeed, Humidit... 0.509417 6 x29 log(log(log(mul(add(add(WindGustSpeed, sub(Hum... 0.509197 7 x30 log(log(mul(mul(add(sub(add(WindGustSpeed, Hum... 0.508659 8 x31 log(log(log(log(mul(add(add(WindGustSpeed, sub... 0.508341 9 x32 log(log(log(mul(mul(add(add(WindGustSpeed, sub... 0.507739 10 x33 log(mul(add(mul(add(add(WindGustSpeed, sub(Hum... 0.507421 11 x34 log(mul(add(mul(add(sub(add(WindGustSpeed, Hum... 0.507421 12 x35 log(log(log(mul(add(mul(add(add(WindGustSpeed,... 0.505743 13 x36 log(log(mul(add(add(WindGustSpeed, add(add(Win... 0.505716 14 x37 log(mul(add(add(WindGustSpeed, mul(add(add(Win... 0.505426 15 x38 log(mul(add(add(WindGustSpeed, mul(add(sub(add... 0.505426 16 x39 log(mul(add(sub(mul(add(add(WindGustSpeed, sub... 0.505410 17 x40 log(mul(add(add(WindGustSpeed, sub(add(add(Win... 0.504868 18 x41 log(mul(add(add(WindGustSpeed, sub(Humidity3pm... 0.504868 19 x42 log(mul(add(add(WindGustSpeed, sub(add(sub(add... 0.504868 In [16]: Copied! # Fit the model again atom . run ( \"LGB_gfg\" , metric = \"auc\" ) # Fit the model again atom.run(\"LGB_gfg\", metric=\"auc\") Training ========================= >> Models: LGB_gfg Metric: roc_auc Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9832 Test evaluation --> roc_auc: 0.8571 Time elapsed: 0.942s ------------------------------------------------- Total time: 0.942s Final results ==================== >> Total time: 0.943s ------------------------------------- LightGBM --> roc_auc: 0.8571 In [17]: Copied! # Visualize the whole pipeline atom . plot_pipeline () # Visualize the whole pipeline atom.plot_pipeline() Analyze the results \u00b6 In [18]: Copied! # Use atom's plots to compare the three models atom . plot_roc ( dataset = \"test+train\" ) # Use atom's plots to compare the three models atom.plot_roc(dataset=\"test+train\")  In [19]: Copied! # To compare other plots it might be useful to use a canvas with atom . canvas ( 1 , 3 , horizontal_spacing = 0.08 , figsize = ( 1800 , 800 )): atom . lgb_dfs . plot_feature_importance ( show = 10 , title = \"LGB + dfs\" ) atom . lgb_gfg . plot_feature_importance ( show = 10 , title = \"LGB + gfg\" ) # To compare other plots it might be useful to use a canvas with atom.canvas(1, 3, horizontal_spacing=0.08, figsize=(1800, 800)): atom.lgb_dfs.plot_feature_importance(show=10, title=\"LGB + dfs\") atom.lgb_gfg.plot_feature_importance(show=10, title=\"LGB + gfg\")  In [20]: Copied! # We can check the feature importance with other plots as well atom . plot_permutation_importance ( models = [ \"LGB_dfs\" , \"LGB_gfg\" ], show = 12 ) # We can check the feature importance with other plots as well atom.plot_permutation_importance(models=[\"LGB_dfs\", \"LGB_gfg\"], show=12)  In [21]: Copied! atom . LGB_gfg . plot_shap_decision ( index = ( 0 , 10 ), show = 15 ) atom.LGB_gfg.plot_shap_decision(index=(0, 10), show=15)", "title": "Feature engineering"}, {"location": "examples/feature_engineering/#example-feature-engineering", "text": "This example shows how to use automated feature generation to improve a model's performance. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Feature engineering"}, {"location": "examples/feature_engineering/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/feature_engineering/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom and apply data cleaning atom = ATOMClassifier ( X , n_rows = 1e4 , test_size = 0.2 , verbose = 0 ) atom . impute ( strat_num = \"knn\" , strat_cat = \"remove\" , max_nan_rows = 0.8 ) atom . encode ( max_onehot = 10 , rare_to_value = 0.04 ) # Initialize atom and apply data cleaning atom = ATOMClassifier(X, n_rows=1e4, test_size=0.2, verbose=0) atom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8) atom.encode(max_onehot=10, rare_to_value=0.04) In [4]: Copied! atom . verbose = 2 # Increase verbosity to see the output # Let's see how a LightGBM model performs atom . run ( 'LGB' , metric = 'auc' ) atom.verbose = 2 # Increase verbosity to see the output # Let's see how a LightGBM model performs atom.run('LGB', metric='auc') Training ========================= >> Models: LGB Metric: roc_auc Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9818 Test evaluation --> roc_auc: 0.8625 Time elapsed: 0.696s ------------------------------------------------- Total time: 0.696s Final results ==================== >> Total time: 0.697s ------------------------------------- LightGBM --> roc_auc: 0.8625", "title": "Run the pipeline"}, {"location": "examples/feature_engineering/#deep-feature-synthesis", "text": "In [5]: Copied! # Since we are going to compare different datasets, # we need to create separate branches atom . branch = \"dfs\" # Since we are going to compare different datasets, # we need to create separate branches atom.branch = \"dfs\" New branch dfs successfully created. In [6]: Copied! # Create 50 new features using dfs atom . feature_generation ( \"dfs\" , n_features = 50 , operators = [ \"add\" , \"sub\" , \"log\" ]) # Create 50 new features using dfs atom.feature_generation(\"dfs\", n_features=50, operators=[\"add\", \"sub\", \"log\"]) Fitting FeatureGenerator... Generating new features... --> 50 new features were added. In [7]: Copied! # The warnings warn us that some operators created missing values! # We can see the columns with missing values using the nans attribute atom . nans # The warnings warn us that some operators created missing values! # We can see the columns with missing values using the nans attribute atom.nans Out[7]: NATURAL_LOGARITHM(Cloud3pm) 332 NATURAL_LOGARITHM(Evaporation) 19 NATURAL_LOGARITHM(Rainfall) 6351 dtype: int64 In [8]: Copied! # Turn off warnings in the future atom . warnings = False # Impute the data again to get rid of the missing values atom . impute ( strat_num = \"knn\" , strat_cat = \"remove\" , max_nan_rows = 0.8 ) # Turn off warnings in the future atom.warnings = False # Impute the data again to get rid of the missing values atom.impute(strat_num=\"knn\", strat_cat=\"remove\", max_nan_rows=0.8) Fitting Imputer... Imputing missing values... --> Imputing 332 missing values using the KNN imputer in feature NATURAL_LOGARITHM(Cloud3pm). --> Imputing 19 missing values using the KNN imputer in feature NATURAL_LOGARITHM(Evaporation). --> Imputing 6351 missing values using the KNN imputer in feature NATURAL_LOGARITHM(Rainfall). In [9]: Copied! # 50 new features may be to much... # Let's check for multicollinearity and use rfecv to reduce the number atom . feature_selection ( strategy = \"rfecv\" , solver = \"LGB\" , n_features = 30 , scoring = \"auc\" , max_correlation = 0.98 , ) # 50 new features may be to much... # Let's check for multicollinearity and use rfecv to reduce the number atom.feature_selection( strategy=\"rfecv\", solver=\"LGB\", n_features=30, scoring=\"auc\", max_correlation=0.98, ) Fitting FeatureSelector... Performing feature selection ... --> Feature MinTemp was removed due to collinearity with another feature. --> Feature Location + MaxTemp was removed due to collinearity with another feature. --> Feature Location + Rainfall was removed due to collinearity with another feature. --> Feature Sunshine was removed due to collinearity with another feature. --> Feature Sunshine + WindGustDir was removed due to collinearity with another feature. --> Feature RainToday_No + WindGustSpeed was removed due to collinearity with another feature. --> Feature WindSpeed9am was removed due to collinearity with another feature. --> Feature WindSpeed3pm was removed due to collinearity with another feature. --> Feature Humidity3pm was removed due to collinearity with another feature. --> Feature Humidity3pm + RainToday_rare was removed due to collinearity with another feature. --> Feature Humidity3pm - WindDir9am was removed due to collinearity with another feature. --> Feature NATURAL_LOGARITHM(Pressure9am) was removed due to collinearity with another feature. --> Feature Pressure9am - WindGustDir was removed due to collinearity with another feature. --> Feature Pressure3pm - WindDir3pm was removed due to collinearity with another feature. --> Feature Cloud9am - WindDir3pm was removed due to collinearity with another feature. --> Feature RainToday_No - WindDir9am was removed due to collinearity with another feature. --> Feature RainToday_Yes was removed due to collinearity with another feature. --> Feature Location + RainToday_Yes was removed due to collinearity with another feature. --> Feature RainToday_Yes - WindDir3pm was removed due to collinearity with another feature. --> Feature Humidity3pm - MinTemp was removed due to collinearity with another feature. --> Feature RainToday_rare - WindSpeed3pm was removed due to collinearity with another feature. --> rfecv selected 44 features from the dataset. --> Dropping feature Location (rank 9). --> Dropping feature RainToday_No (rank 8). --> Dropping feature RainToday_rare (rank 6). --> Dropping feature Location - RainToday_rare (rank 3). --> Dropping feature Location - WindGustDir (rank 4). --> Dropping feature NATURAL_LOGARITHM(Cloud3pm) (rank 7). --> Dropping feature NATURAL_LOGARITHM(Evaporation) (rank 5). --> Dropping feature NATURAL_LOGARITHM(Rainfall) (rank 2). In [10]: Copied! # The collinear attribute shows what features were removed due to multicollinearity atom . collinear # The collinear attribute shows what features were removed due to multicollinearity atom.collinear Out[10]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } drop corr_feature corr_value 0 MinTemp MinTemp + RainToday_rare 0.9999 1 Location + MaxTemp MaxTemp 1.0 2 Location + Rainfall Rainfall 1.0 3 Sunshine RainToday_rare + Sunshine, Sunshine + WindGustDir 0.9995, 0.9999 4 Sunshine + WindGustDir Sunshine, RainToday_rare + Sunshine 0.9999, 0.9993 5 RainToday_No + WindGustSpeed WindGustSpeed 0.9995 6 WindSpeed9am RainToday_rare + WindSpeed9am 1.0 7 WindSpeed3pm WindDir9am + WindSpeed3pm 1.0 8 Humidity3pm Cloud3pm + Humidity3pm, Humidity3pm + RainToda... 0.996, 1.0, 1.0 9 Humidity3pm + RainToday_rare Humidity3pm, Cloud3pm + Humidity3pm, Humidity3... 1.0, 0.996, 1.0 10 Humidity3pm - WindDir9am Humidity3pm, Cloud3pm + Humidity3pm, Humidity3... 1.0, 0.996, 1.0 11 NATURAL_LOGARITHM(Pressure9am) Pressure9am, Pressure9am - WindGustDir 1.0, 1.0 12 Pressure9am - WindGustDir Pressure9am, NATURAL_LOGARITHM(Pressure9am) 1.0, 1.0 13 Pressure3pm - WindDir3pm Pressure3pm 1.0 14 Cloud9am - WindDir3pm Cloud9am 0.9998 15 RainToday_No - WindDir9am RainToday_No 0.9906 16 RainToday_Yes Location + RainToday_Yes, RainToday_Yes + Wind... 1.0, 0.9946, 0.9941 17 Location + RainToday_Yes RainToday_Yes, RainToday_Yes + WindGustDir, Ra... 1.0, 0.9946, 0.9941 18 RainToday_Yes - WindDir3pm RainToday_Yes, Location + RainToday_Yes, RainT... 0.9941, 0.9941, 0.9824 19 Humidity3pm - MinTemp Humidity3pm - MaxTemp 0.9877 20 RainToday_rare - WindSpeed3pm RainToday_Yes - WindSpeed3pm 0.9988 In [11]: Copied! # After applying rfecv, we can plot the score per number of features atom . plot_rfecv () # After applying rfecv, we can plot the score per number of features atom.plot_rfecv()  In [12]: Copied! # Let's see how the model performs now # Add a tag to the model's acronym to not overwrite previous LGB atom . run ( \"LGB_dfs\" ) # Let's see how the model performs now # Add a tag to the model's acronym to not overwrite previous LGB atom.run(\"LGB_dfs\") Training ========================= >> Models: LGB_dfs Metric: roc_auc Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9906 Test evaluation --> roc_auc: 0.8616 Time elapsed: 1.485s ------------------------------------------------- Total time: 1.485s Final results ==================== >> Total time: 1.485s ------------------------------------- LightGBM --> roc_auc: 0.8616", "title": "Deep Feature Synthesis"}, {"location": "examples/feature_engineering/#genetic-feature-generation", "text": "In [13]: Copied! # Create another branch for the genetic features # Split form master to avoid the dfs features atom . branch = \"gfg_from_master\" # Create another branch for the genetic features # Split form master to avoid the dfs features atom.branch = \"gfg_from_master\" New branch gfg successfully created. In [14]: Copied! # Create new features using Genetic Programming atom . feature_generation ( strategy = 'gfg' , n_features = 20 ) # Create new features using Genetic Programming atom.feature_generation(strategy='gfg', n_features=20) Fitting FeatureGenerator... | Population Average | Best Individual | ---- ------------------------- ------------------------------------------ ---------- Gen Length Fitness Length Fitness OOB Fitness Time Left 0 3.08 0.129852 3 0.485297 N/A 21.97s 1 3.06 0.329673 3 0.492484 N/A 26.06s 2 3.27 0.419512 5 0.510269 N/A 22.29s 3 3.90 0.44394 6 0.512441 N/A 22.04s 4 5.31 0.471916 9 0.516333 N/A 20.13s 5 5.36 0.457234 10 0.51887 N/A 22.43s 6 6.05 0.454503 16 0.51986 N/A 18.27s 7 8.56 0.480404 16 0.51986 N/A 13.40s 8 9.73 0.482795 16 0.51986 N/A 12.82s 9 9.79 0.483111 16 0.51986 N/A 11.88s 10 9.95 0.482671 16 0.51986 N/A 11.42s 11 9.96 0.477608 16 0.51986 N/A 12.71s 12 10.10 0.480786 16 0.51986 N/A 10.02s 13 10.03 0.480488 16 0.51986 N/A 7.30s 14 10.03 0.484053 16 0.51986 N/A 6.06s 15 9.95 0.478832 10 0.520691 N/A 5.55s 16 10.10 0.482892 16 0.520868 N/A 3.67s 17 9.99 0.482447 12 0.521197 N/A 2.46s 18 10.02 0.47667 17 0.521669 N/A 1.23s 19 10.05 0.482259 16 0.521743 N/A 0.00s Generating new features... --> 20 new features were added. In [15]: Copied! # We can see the feature's fitness and description through the genetic_features attribute atom . genetic_features # We can see the feature's fitness and description through the genetic_features attribute atom.genetic_features Out[15]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name description fitness 0 x23 log(mul(add(add(WindGustSpeed, sub(Humidity3pm... 0.510691 1 x24 log(mul(add(sub(add(WindGustSpeed, Humidity3pm... 0.510691 2 x25 log(log(mul(add(sub(add(WindGustSpeed, Humidit... 0.510057 3 x26 log(log(mul(add(add(WindGustSpeed, sub(Humidit... 0.510057 4 x27 log(mul(mul(add(add(WindGustSpeed, sub(Humidit... 0.509417 5 x28 log(mul(mul(add(sub(add(WindGustSpeed, Humidit... 0.509417 6 x29 log(log(log(mul(add(add(WindGustSpeed, sub(Hum... 0.509197 7 x30 log(log(mul(mul(add(sub(add(WindGustSpeed, Hum... 0.508659 8 x31 log(log(log(log(mul(add(add(WindGustSpeed, sub... 0.508341 9 x32 log(log(log(mul(mul(add(add(WindGustSpeed, sub... 0.507739 10 x33 log(mul(add(mul(add(add(WindGustSpeed, sub(Hum... 0.507421 11 x34 log(mul(add(mul(add(sub(add(WindGustSpeed, Hum... 0.507421 12 x35 log(log(log(mul(add(mul(add(add(WindGustSpeed,... 0.505743 13 x36 log(log(mul(add(add(WindGustSpeed, add(add(Win... 0.505716 14 x37 log(mul(add(add(WindGustSpeed, mul(add(add(Win... 0.505426 15 x38 log(mul(add(add(WindGustSpeed, mul(add(sub(add... 0.505426 16 x39 log(mul(add(sub(mul(add(add(WindGustSpeed, sub... 0.505410 17 x40 log(mul(add(add(WindGustSpeed, sub(add(add(Win... 0.504868 18 x41 log(mul(add(add(WindGustSpeed, sub(Humidity3pm... 0.504868 19 x42 log(mul(add(add(WindGustSpeed, sub(add(sub(add... 0.504868 In [16]: Copied! # Fit the model again atom . run ( \"LGB_gfg\" , metric = \"auc\" ) # Fit the model again atom.run(\"LGB_gfg\", metric=\"auc\") Training ========================= >> Models: LGB_gfg Metric: roc_auc Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9832 Test evaluation --> roc_auc: 0.8571 Time elapsed: 0.942s ------------------------------------------------- Total time: 0.942s Final results ==================== >> Total time: 0.943s ------------------------------------- LightGBM --> roc_auc: 0.8571 In [17]: Copied! # Visualize the whole pipeline atom . plot_pipeline () # Visualize the whole pipeline atom.plot_pipeline()", "title": "Genetic Feature Generation"}, {"location": "examples/feature_engineering/#analyze-the-results", "text": "In [18]: Copied! # Use atom's plots to compare the three models atom . plot_roc ( dataset = \"test+train\" ) # Use atom's plots to compare the three models atom.plot_roc(dataset=\"test+train\")  In [19]: Copied! # To compare other plots it might be useful to use a canvas with atom . canvas ( 1 , 3 , horizontal_spacing = 0.08 , figsize = ( 1800 , 800 )): atom . lgb_dfs . plot_feature_importance ( show = 10 , title = \"LGB + dfs\" ) atom . lgb_gfg . plot_feature_importance ( show = 10 , title = \"LGB + gfg\" ) # To compare other plots it might be useful to use a canvas with atom.canvas(1, 3, horizontal_spacing=0.08, figsize=(1800, 800)): atom.lgb_dfs.plot_feature_importance(show=10, title=\"LGB + dfs\") atom.lgb_gfg.plot_feature_importance(show=10, title=\"LGB + gfg\")  In [20]: Copied! # We can check the feature importance with other plots as well atom . plot_permutation_importance ( models = [ \"LGB_dfs\" , \"LGB_gfg\" ], show = 12 ) # We can check the feature importance with other plots as well atom.plot_permutation_importance(models=[\"LGB_dfs\", \"LGB_gfg\"], show=12)  In [21]: Copied! atom . LGB_gfg . plot_shap_decision ( index = ( 0 , 10 ), show = 15 ) atom.LGB_gfg.plot_shap_decision(index=(0, 10), show=15)", "title": "Analyze the results"}, {"location": "examples/getting_started/", "text": "Example: Getting started \u00b6 This example shows how to get started with the atom-ml library. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . In [1]: Copied! import pandas as pd from atom import ATOMClassifier # Load the Australian Weather dataset X = pd . read_csv ( \"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\" ) import pandas as pd from atom import ATOMClassifier # Load the Australian Weather dataset X = pd.read_csv(\"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\") In [2]: Copied! atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1000 , verbose = 2 ) atom = ATOMClassifier(X, y=\"RainTomorrow\", n_rows=1000, verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (1000, 22) Memory: 434.20 kB Scaled: False Missing values: 2210 (10.0%) Categorical features: 5 (23.8%) Outlier values: 1 (0.0%) ------------------------------------- Train set size: 800 Test set size: 200 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 777 (3.5) | 622 (3.5) | 155 (3.4) | | 1 | 223 (1.0) | 178 (1.0) | 45 (1.0) | In [3]: Copied! atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" ) atom . encode ( strategy = \"LeaveOneOut\" , max_onehot = 8 ) atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\") atom.encode(strategy=\"LeaveOneOut\", max_onehot=8) Fitting Imputer... Imputing missing values... --> Imputing 1 missing values with median (12.7) in feature MinTemp. --> Imputing 12 missing values with median (0.0) in feature Rainfall. --> Imputing 430 missing values with median (4.6) in feature Evaporation. --> Imputing 476 missing values with median (8.8) in feature Sunshine. --> Imputing 54 missing values with most_frequent (N) in feature WindGustDir. --> Imputing 54 missing values with median (37.0) in feature WindGustSpeed. --> Imputing 70 missing values with most_frequent (N) in feature WindDir9am. --> Imputing 26 missing values with most_frequent (S) in feature WindDir3pm. --> Imputing 5 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 16 missing values with median (17.0) in feature WindSpeed3pm. --> Imputing 9 missing values with median (69.0) in feature Humidity9am. --> Imputing 22 missing values with median (51.0) in feature Humidity3pm. --> Imputing 105 missing values with median (1018.2) in feature Pressure9am. --> Imputing 109 missing values with median (1015.6) in feature Pressure3pm. --> Imputing 393 missing values with median (5.0) in feature Cloud9am. --> Imputing 397 missing values with median (4.0) in feature Cloud3pm. --> Imputing 4 missing values with median (17.0) in feature Temp9am. --> Imputing 15 missing values with median (21.5) in feature Temp3pm. --> Imputing 12 missing values with most_frequent (No) in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 49 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [4]: Copied! atom . run ( models = [ \"LDA\" , \"AdaB\" ], metric = \"auc\" , n_trials = 10 ) atom.run(models=[\"LDA\", \"AdaB\"], metric=\"auc\", n_trials=10) Training ========================= >> Models: LDA, AdaB Metric: roc_auc Running hyperparameter tuning for LinearDiscriminantAnalysis... | trial | solver | shrinkage | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | eigen | 0.8 | 0.8412 | 0.8412 | 0.218s | 0.218s | COMPLETE | | 1 | lsqr | 0.6 | 0.8192 | 0.8412 | 0.253s | 0.471s | COMPLETE | | 2 | lsqr | auto | 0.7988 | 0.8412 | 0.218s | 0.689s | COMPLETE | | 3 | eigen | 0.9 | 0.89 | 0.89 | 0.216s | 0.905s | COMPLETE | | 4 | svd | --- | 0.8542 | 0.89 | 0.249s | 1.154s | COMPLETE | | 5 | lsqr | 0.6 | 0.8192 | 0.89 | 0.004s | 1.158s | COMPLETE | | 6 | lsqr | auto | 0.7988 | 0.89 | 0.003s | 1.161s | COMPLETE | | 7 | lsqr | 0.8 | 0.8129 | 0.89 | 0.244s | 1.405s | COMPLETE | | 8 | lsqr | None | 0.7948 | 0.89 | 0.208s | 1.613s | COMPLETE | | 9 | eigen | 0.8 | 0.8412 | 0.89 | 0.002s | 1.616s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> solver: eigen --> shrinkage: 0.9 Best evaluation --> roc_auc: 0.89 Time elapsed: 1.616s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.8146 Test evaluation --> roc_auc: 0.8305 Time elapsed: 0.040s ------------------------------------------------- Total time: 1.656s Running hyperparameter tuning for AdaBoost... | trial | n_estimators | learning_rate | algorithm | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------------ | ------------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | 190 | 1.6916 | SAMME.R | 0.6808 | 0.6808 | 0.690s | 0.690s | COMPLETE | | 1 | 380 | 0.1227 | SAMME | 0.7919 | 0.7919 | 0.999s | 1.689s | COMPLETE | | 2 | 330 | 4.937 | SAMME | 0.642 | 0.7919 | 0.235s | 1.923s | COMPLETE | | 3 | 80 | 1.0146 | SAMME.R | 0.7708 | 0.7919 | 0.391s | 2.314s | COMPLETE | | 4 | 470 | 3.6762 | SAMME | 0.642 | 0.7919 | 0.215s | 2.529s | COMPLETE | | 5 | 200 | 6.1828 | SAMME | 0.2231 | 0.7919 | 0.209s | 2.737s | COMPLETE | | 6 | 240 | 0.5726 | SAMME.R | 0.7708 | 0.7919 | 0.748s | 3.485s | COMPLETE | | 7 | 390 | 3.0825 | SAMME.R | 0.3262 | 0.7919 | 1.093s | 4.577s | COMPLETE | | 8 | 290 | 0.7957 | SAMME | 0.7699 | 0.7919 | 0.862s | 5.439s | COMPLETE | | 9 | 190 | 0.0256 | SAMME | 0.8011 | 0.8011 | 0.596s | 6.036s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 9 Best parameters: --> n_estimators: 190 --> learning_rate: 0.0256 --> algorithm: SAMME Best evaluation --> roc_auc: 0.8011 Time elapsed: 6.036s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.844 Test evaluation --> roc_auc: 0.8366 Time elapsed: 0.449s ------------------------------------------------- Total time: 6.485s Final results ==================== >> Total time: 8.352s ------------------------------------- LinearDiscriminantAnalysis --> roc_auc: 0.8305 AdaBoost --> roc_auc: 0.8366 ! In [5]: Copied! atom . evaluate () atom.evaluate() Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc LDA 0.805 0.6325 0.7559 0.6061 0.4348 0.4814 0.5556 0.6667 0.8305 AdaB 0.815 0.6505 0.6204 0.3934 0.2449 0.3707 0.7500 0.2667 0.8366", "title": "Getting started"}, {"location": "examples/getting_started/#example-getting-started", "text": "This example shows how to get started with the atom-ml library. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . In [1]: Copied! import pandas as pd from atom import ATOMClassifier # Load the Australian Weather dataset X = pd . read_csv ( \"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\" ) import pandas as pd from atom import ATOMClassifier # Load the Australian Weather dataset X = pd.read_csv(\"https://raw.githubusercontent.com/tvdboom/ATOM/master/examples/datasets/weatherAUS.csv\") In [2]: Copied! atom = ATOMClassifier ( X , y = \"RainTomorrow\" , n_rows = 1000 , verbose = 2 ) atom = ATOMClassifier(X, y=\"RainTomorrow\", n_rows=1000, verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (1000, 22) Memory: 434.20 kB Scaled: False Missing values: 2210 (10.0%) Categorical features: 5 (23.8%) Outlier values: 1 (0.0%) ------------------------------------- Train set size: 800 Test set size: 200 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 777 (3.5) | 622 (3.5) | 155 (3.4) | | 1 | 223 (1.0) | 178 (1.0) | 45 (1.0) | In [3]: Copied! atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" ) atom . encode ( strategy = \"LeaveOneOut\" , max_onehot = 8 ) atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\") atom.encode(strategy=\"LeaveOneOut\", max_onehot=8) Fitting Imputer... Imputing missing values... --> Imputing 1 missing values with median (12.7) in feature MinTemp. --> Imputing 12 missing values with median (0.0) in feature Rainfall. --> Imputing 430 missing values with median (4.6) in feature Evaporation. --> Imputing 476 missing values with median (8.8) in feature Sunshine. --> Imputing 54 missing values with most_frequent (N) in feature WindGustDir. --> Imputing 54 missing values with median (37.0) in feature WindGustSpeed. --> Imputing 70 missing values with most_frequent (N) in feature WindDir9am. --> Imputing 26 missing values with most_frequent (S) in feature WindDir3pm. --> Imputing 5 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 16 missing values with median (17.0) in feature WindSpeed3pm. --> Imputing 9 missing values with median (69.0) in feature Humidity9am. --> Imputing 22 missing values with median (51.0) in feature Humidity3pm. --> Imputing 105 missing values with median (1018.2) in feature Pressure9am. --> Imputing 109 missing values with median (1015.6) in feature Pressure3pm. --> Imputing 393 missing values with median (5.0) in feature Cloud9am. --> Imputing 397 missing values with median (4.0) in feature Cloud3pm. --> Imputing 4 missing values with median (17.0) in feature Temp9am. --> Imputing 15 missing values with median (21.5) in feature Temp3pm. --> Imputing 12 missing values with most_frequent (No) in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 49 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [4]: Copied! atom . run ( models = [ \"LDA\" , \"AdaB\" ], metric = \"auc\" , n_trials = 10 ) atom.run(models=[\"LDA\", \"AdaB\"], metric=\"auc\", n_trials=10) Training ========================= >> Models: LDA, AdaB Metric: roc_auc Running hyperparameter tuning for LinearDiscriminantAnalysis... | trial | solver | shrinkage | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | eigen | 0.8 | 0.8412 | 0.8412 | 0.218s | 0.218s | COMPLETE | | 1 | lsqr | 0.6 | 0.8192 | 0.8412 | 0.253s | 0.471s | COMPLETE | | 2 | lsqr | auto | 0.7988 | 0.8412 | 0.218s | 0.689s | COMPLETE | | 3 | eigen | 0.9 | 0.89 | 0.89 | 0.216s | 0.905s | COMPLETE | | 4 | svd | --- | 0.8542 | 0.89 | 0.249s | 1.154s | COMPLETE | | 5 | lsqr | 0.6 | 0.8192 | 0.89 | 0.004s | 1.158s | COMPLETE | | 6 | lsqr | auto | 0.7988 | 0.89 | 0.003s | 1.161s | COMPLETE | | 7 | lsqr | 0.8 | 0.8129 | 0.89 | 0.244s | 1.405s | COMPLETE | | 8 | lsqr | None | 0.7948 | 0.89 | 0.208s | 1.613s | COMPLETE | | 9 | eigen | 0.8 | 0.8412 | 0.89 | 0.002s | 1.616s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> solver: eigen --> shrinkage: 0.9 Best evaluation --> roc_auc: 0.89 Time elapsed: 1.616s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.8146 Test evaluation --> roc_auc: 0.8305 Time elapsed: 0.040s ------------------------------------------------- Total time: 1.656s Running hyperparameter tuning for AdaBoost... | trial | n_estimators | learning_rate | algorithm | roc_auc | best_roc_auc | time_trial | time_ht | state | | ----- | ------------ | ------------- | --------- | ------- | ------------ | ---------- | ------- | -------- | | 0 | 190 | 1.6916 | SAMME.R | 0.6808 | 0.6808 | 0.690s | 0.690s | COMPLETE | | 1 | 380 | 0.1227 | SAMME | 0.7919 | 0.7919 | 0.999s | 1.689s | COMPLETE | | 2 | 330 | 4.937 | SAMME | 0.642 | 0.7919 | 0.235s | 1.923s | COMPLETE | | 3 | 80 | 1.0146 | SAMME.R | 0.7708 | 0.7919 | 0.391s | 2.314s | COMPLETE | | 4 | 470 | 3.6762 | SAMME | 0.642 | 0.7919 | 0.215s | 2.529s | COMPLETE | | 5 | 200 | 6.1828 | SAMME | 0.2231 | 0.7919 | 0.209s | 2.737s | COMPLETE | | 6 | 240 | 0.5726 | SAMME.R | 0.7708 | 0.7919 | 0.748s | 3.485s | COMPLETE | | 7 | 390 | 3.0825 | SAMME.R | 0.3262 | 0.7919 | 1.093s | 4.577s | COMPLETE | | 8 | 290 | 0.7957 | SAMME | 0.7699 | 0.7919 | 0.862s | 5.439s | COMPLETE | | 9 | 190 | 0.0256 | SAMME | 0.8011 | 0.8011 | 0.596s | 6.036s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 9 Best parameters: --> n_estimators: 190 --> learning_rate: 0.0256 --> algorithm: SAMME Best evaluation --> roc_auc: 0.8011 Time elapsed: 6.036s Fit --------------------------------------------- Train evaluation --> roc_auc: 0.844 Test evaluation --> roc_auc: 0.8366 Time elapsed: 0.449s ------------------------------------------------- Total time: 6.485s Final results ==================== >> Total time: 8.352s ------------------------------------- LinearDiscriminantAnalysis --> roc_auc: 0.8305 AdaBoost --> roc_auc: 0.8366 ! In [5]: Copied! atom . evaluate () atom.evaluate() Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc LDA 0.805 0.6325 0.7559 0.6061 0.4348 0.4814 0.5556 0.6667 0.8305 AdaB 0.815 0.6505 0.6204 0.3934 0.2449 0.3707 0.7500 0.2667 0.8366", "title": "Example: Getting started"}, {"location": "examples/holdout_set/", "text": "Example: Holdout set \u00b6 This example shows when and how to use ATOM's holdout set in an exploration pipeline. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! # Initialize atom specifying a fraction of the dataset for holdout atom = ATOMClassifier ( X , n_rows = 0.5 , holdout_size = 0.2 , verbose = 2 ) # Initialize atom specifying a fraction of the dataset for holdout atom = ATOMClassifier(X, n_rows=0.5, holdout_size=0.2, verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (56877, 22) Memory: 24.67 MB Scaled: False Missing values: 127804 (10.2%) Categorical features: 5 (23.8%) Duplicate samples: 13 (0.0%) ------------------------------------- Train set size: 42658 Test set size: 14219 Holdout set size: 14219 ------------------------------------- | | dataset | train | test | | - | ------------- | ------------- | ------------- | | 0 | 44085 (3.4) | 33064 (3.4) | 11021 (3.4) | | 1 | 12792 (1.0) | 9594 (1.0) | 3198 (1.0) | In [4]: Copied! # The test and holdout fractions are split after subsampling the dataset # Also note that the holdout data set is not a part of atom's dataset print ( \"Length loaded data:\" , len ( X )) print ( \"Length dataset + holdout:\" , len ( atom . dataset ) + len ( atom . holdout )) # The test and holdout fractions are split after subsampling the dataset # Also note that the holdout data set is not a part of atom's dataset print(\"Length loaded data:\", len(X)) print(\"Length dataset + holdout:\", len(atom.dataset) + len(atom.holdout)) Length loaded data: 142193 Length dataset + holdout: 71096 In [5]: Copied! atom . impute () atom . encode () atom.impute() atom.encode() Fitting Imputer... Imputing missing values... --> Dropping 265 samples due to missing values in feature MinTemp. --> Dropping 134 samples due to missing values in feature MaxTemp. --> Dropping 567 samples due to missing values in feature Rainfall. --> Dropping 24603 samples due to missing values in feature Evaporation. --> Dropping 27348 samples due to missing values in feature Sunshine. --> Dropping 3748 samples due to missing values in feature WindGustDir. --> Dropping 3724 samples due to missing values in feature WindGustSpeed. --> Dropping 4044 samples due to missing values in feature WindDir9am. --> Dropping 1518 samples due to missing values in feature WindDir3pm. --> Dropping 550 samples due to missing values in feature WindSpeed9am. --> Dropping 1062 samples due to missing values in feature WindSpeed3pm. --> Dropping 749 samples due to missing values in feature Humidity9am. --> Dropping 1464 samples due to missing values in feature Humidity3pm. --> Dropping 5630 samples due to missing values in feature Pressure9am. --> Dropping 5643 samples due to missing values in feature Pressure3pm. --> Dropping 21665 samples due to missing values in feature Cloud9am. --> Dropping 23040 samples due to missing values in feature Cloud3pm. --> Dropping 381 samples due to missing values in feature Temp9am. --> Dropping 1102 samples due to missing values in feature Temp3pm. --> Dropping 567 samples due to missing values in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 26 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [6]: Copied! # Unlike train and test, the holdout data set is not transformed until used for predictions atom . holdout # Unlike train and test, the holdout data set is not transformed until used for predictions atom.holdout Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 SalmonGums 7.4 13.5 1.6 NaN NaN NW 22.0 SE W ... 92.0 93.0 NaN NaN NaN NaN 12.0 11.2 Yes 1 1 MountGinini -0.5 1.8 0.0 NaN NaN NE 37.0 ENE ENE ... 97.0 88.0 NaN NaN NaN NaN 0.5 0.9 No 0 2 Watsonia 8.2 24.5 0.0 5.2 11.1 SSW 30.0 NaN SSW ... 92.0 40.0 1024.5 1023.1 1.0 3.0 11.3 24.2 No 0 3 Williamtown 16.1 22.6 1.8 1.8 0.3 E 41.0 E ENE ... 65.0 76.0 1029.2 1028.3 7.0 8.0 21.1 20.2 Yes 1 4 PearceRAAF 13.9 24.6 0.6 NaN 11.9 WSW 44.0 SW SW ... 66.0 47.0 1006.7 1006.7 7.0 4.0 18.8 23.0 No 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 14214 CoffsHarbour 5.4 20.8 0.0 2.2 10.3 NE 39.0 SW NE ... 78.0 61.0 1023.6 1020.6 0.0 1.0 14.5 20.2 No 1 14215 BadgerysCreek 3.2 17.6 0.0 NaN NaN SW 28.0 WSW S ... 80.0 47.0 1019.3 1017.9 NaN NaN 9.9 16.6 No 0 14216 Albany 15.5 23.6 0.0 7.4 9.2 NaN NaN E ESE ... 71.0 70.0 1020.5 1016.1 2.0 3.0 17.5 21.5 No 0 14217 SydneyAirport 15.3 33.5 0.0 8.0 10.6 NW 41.0 N NW ... 26.0 14.0 1014.2 1010.7 2.0 0.0 25.1 32.1 No 0 14218 WaggaWagga 23.7 34.8 0.0 14.8 NaN WSW 43.0 WSW WSW ... 45.0 35.0 1009.4 1008.9 1.0 2.0 28.9 32.8 No 0 14219 rows \u00d7 22 columns In [7]: Copied! atom . run ( models = [ \"GNB\" , \"LR\" , \"RF\" ]) atom.run(models=[\"GNB\", \"LR\", \"RF\"]) Training ========================= >> Models: GNB, LR, RF Metric: f1 Results for GaussianNB: Fit --------------------------------------------- Train evaluation --> f1: 0.5989 Test evaluation --> f1: 0.6007 Time elapsed: 0.041s ------------------------------------------------- Total time: 0.041s Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> f1: 0.6062 Test evaluation --> f1: 0.6133 Time elapsed: 0.148s ------------------------------------------------- Total time: 0.148s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.6229 Time elapsed: 2.744s ------------------------------------------------- Total time: 2.744s Final results ==================== >> Total time: 2.936s ------------------------------------- GaussianNB --> f1: 0.6007 LogisticRegression --> f1: 0.6133 RandomForest --> f1: 0.6229 ~ ! In [8]: Copied! atom . plot_prc () atom.plot_prc()  In [10]: Copied! # Based on the results on the test set, we select the best model for further tuning atom . run ( \"lr_tuned\" , n_trials = 10 ) # Based on the results on the test set, we select the best model for further tuning atom.run(\"lr_tuned\", n_trials=10) Training ========================= >> Models: LR_tuned Metric: f1 Running hyperparameter tuning for LogisticRegression... | trial | penalty | C | solver | max_iter | l1_ratio | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------- | ------- | ------- | -------- | -------- | ------- | ------- | ---------- | ------- | -------- | | 0 | l1 | 4.2668 | saga | 920 | --- | 0.6033 | 0.6033 | 0.692s | 0.692s | COMPLETE | | 1 | none | --- | saga | 1000 | --- | 0.6102 | 0.6102 | 0.901s | 1.592s | COMPLETE | | 2 | l2 | 0.0295 | newto.. | 230 | --- | 0.5737 | 0.6102 | 0.593s | 2.185s | COMPLETE | | 3 | l2 | 0.038 | newto.. | 360 | --- | 0.6161 | 0.6161 | 0.571s | 2.756s | COMPLETE | | 4 | l2 | 7.0752 | sag | 260 | --- | 0.5997 | 0.6161 | 0.697s | 3.452s | COMPLETE | | 5 | l2 | 0.0011 | sag | 910 | --- | 0.54 | 0.6161 | 0.550s | 4.003s | COMPLETE | | 6 | none | --- | newto.. | 810 | --- | 0.5923 | 0.6161 | 0.557s | 4.559s | COMPLETE | | 7 | l1 | 0.9715 | libli.. | 350 | --- | 0.5865 | 0.6161 | 0.715s | 5.274s | COMPLETE | | 8 | l2 | 0.0013 | newto.. | 900 | --- | 0.5466 | 0.6161 | 0.540s | 5.814s | COMPLETE | | 9 | l1 | 0.0021 | saga | 260 | --- | 0.5022 | 0.6161 | 0.556s | 6.370s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> penalty: l2 --> C: 0.038 --> solver: newton-cg --> max_iter: 360 Best evaluation --> f1: 0.6161 Time elapsed: 6.370s Fit --------------------------------------------- Train evaluation --> f1: 0.6042 Test evaluation --> f1: 0.6099 Time elapsed: 0.169s ------------------------------------------------- Total time: 6.539s Final results ==================== >> Total time: 6.566s ------------------------------------- LogisticRegression --> f1: 0.6099 Analyze the results \u00b6 We already used the test set to choose the best model for futher tuning, so this set is no longer truly independent. Although it may not be directly visible in the results, using the test set now to evaluate the tuned LR model would be a mistake, since it carries a bias. For this reason, we have set apart an extra, indepedent set to validate the final model: the holdout set. If we are not going to use the test set for validation, we might as well use it to train the model and so optimize the use of the available data. Use the full_train method for this. In [11]: Copied! # Re-train the model on the full dataset (train + test) atom . lr_tuned . full_train () # Re-train the model on the full dataset (train + test) atom.lr_tuned.full_train() Fit --------------------------------------------- Train evaluation --> f1: 0.6062 Test evaluation --> f1: 0.6123 Time elapsed: 0.356s In [12]: Copied! # Evaluate on the holdout set atom . lr_tuned . evaluate ( dataset = \"holdout\" ) # Evaluate on the holdout set atom.lr_tuned.evaluate(dataset=\"holdout\") Out[12]: accuracy 0.8555 average_precision 0.7229 balanced_accuracy 0.7436 f1 0.6255 jaccard 0.4550 matthews_corrcoef 0.5485 precision 0.7396 recall 0.5418 roc_auc 0.8828 Name: LR_tuned, dtype: float64 In [14]: Copied! atom . lr_tuned . plot_prc ( dataset = \"holdout\" , legend = \"upper right\" ) atom.lr_tuned.plot_prc(dataset=\"holdout\", legend=\"upper right\") ", "title": "Holdout set"}, {"location": "examples/holdout_set/#example-holdout-set", "text": "This example shows when and how to use ATOM's holdout set in an exploration pipeline. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Holdout set"}, {"location": "examples/holdout_set/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/holdout_set/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom specifying a fraction of the dataset for holdout atom = ATOMClassifier ( X , n_rows = 0.5 , holdout_size = 0.2 , verbose = 2 ) # Initialize atom specifying a fraction of the dataset for holdout atom = ATOMClassifier(X, n_rows=0.5, holdout_size=0.2, verbose=2) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (56877, 22) Memory: 24.67 MB Scaled: False Missing values: 127804 (10.2%) Categorical features: 5 (23.8%) Duplicate samples: 13 (0.0%) ------------------------------------- Train set size: 42658 Test set size: 14219 Holdout set size: 14219 ------------------------------------- | | dataset | train | test | | - | ------------- | ------------- | ------------- | | 0 | 44085 (3.4) | 33064 (3.4) | 11021 (3.4) | | 1 | 12792 (1.0) | 9594 (1.0) | 3198 (1.0) | In [4]: Copied! # The test and holdout fractions are split after subsampling the dataset # Also note that the holdout data set is not a part of atom's dataset print ( \"Length loaded data:\" , len ( X )) print ( \"Length dataset + holdout:\" , len ( atom . dataset ) + len ( atom . holdout )) # The test and holdout fractions are split after subsampling the dataset # Also note that the holdout data set is not a part of atom's dataset print(\"Length loaded data:\", len(X)) print(\"Length dataset + holdout:\", len(atom.dataset) + len(atom.holdout)) Length loaded data: 142193 Length dataset + holdout: 71096 In [5]: Copied! atom . impute () atom . encode () atom.impute() atom.encode() Fitting Imputer... Imputing missing values... --> Dropping 265 samples due to missing values in feature MinTemp. --> Dropping 134 samples due to missing values in feature MaxTemp. --> Dropping 567 samples due to missing values in feature Rainfall. --> Dropping 24603 samples due to missing values in feature Evaporation. --> Dropping 27348 samples due to missing values in feature Sunshine. --> Dropping 3748 samples due to missing values in feature WindGustDir. --> Dropping 3724 samples due to missing values in feature WindGustSpeed. --> Dropping 4044 samples due to missing values in feature WindDir9am. --> Dropping 1518 samples due to missing values in feature WindDir3pm. --> Dropping 550 samples due to missing values in feature WindSpeed9am. --> Dropping 1062 samples due to missing values in feature WindSpeed3pm. --> Dropping 749 samples due to missing values in feature Humidity9am. --> Dropping 1464 samples due to missing values in feature Humidity3pm. --> Dropping 5630 samples due to missing values in feature Pressure9am. --> Dropping 5643 samples due to missing values in feature Pressure3pm. --> Dropping 21665 samples due to missing values in feature Cloud9am. --> Dropping 23040 samples due to missing values in feature Cloud3pm. --> Dropping 381 samples due to missing values in feature Temp9am. --> Dropping 1102 samples due to missing values in feature Temp3pm. --> Dropping 567 samples due to missing values in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 26 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [6]: Copied! # Unlike train and test, the holdout data set is not transformed until used for predictions atom . holdout # Unlike train and test, the holdout data set is not transformed until used for predictions atom.holdout Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 SalmonGums 7.4 13.5 1.6 NaN NaN NW 22.0 SE W ... 92.0 93.0 NaN NaN NaN NaN 12.0 11.2 Yes 1 1 MountGinini -0.5 1.8 0.0 NaN NaN NE 37.0 ENE ENE ... 97.0 88.0 NaN NaN NaN NaN 0.5 0.9 No 0 2 Watsonia 8.2 24.5 0.0 5.2 11.1 SSW 30.0 NaN SSW ... 92.0 40.0 1024.5 1023.1 1.0 3.0 11.3 24.2 No 0 3 Williamtown 16.1 22.6 1.8 1.8 0.3 E 41.0 E ENE ... 65.0 76.0 1029.2 1028.3 7.0 8.0 21.1 20.2 Yes 1 4 PearceRAAF 13.9 24.6 0.6 NaN 11.9 WSW 44.0 SW SW ... 66.0 47.0 1006.7 1006.7 7.0 4.0 18.8 23.0 No 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 14214 CoffsHarbour 5.4 20.8 0.0 2.2 10.3 NE 39.0 SW NE ... 78.0 61.0 1023.6 1020.6 0.0 1.0 14.5 20.2 No 1 14215 BadgerysCreek 3.2 17.6 0.0 NaN NaN SW 28.0 WSW S ... 80.0 47.0 1019.3 1017.9 NaN NaN 9.9 16.6 No 0 14216 Albany 15.5 23.6 0.0 7.4 9.2 NaN NaN E ESE ... 71.0 70.0 1020.5 1016.1 2.0 3.0 17.5 21.5 No 0 14217 SydneyAirport 15.3 33.5 0.0 8.0 10.6 NW 41.0 N NW ... 26.0 14.0 1014.2 1010.7 2.0 0.0 25.1 32.1 No 0 14218 WaggaWagga 23.7 34.8 0.0 14.8 NaN WSW 43.0 WSW WSW ... 45.0 35.0 1009.4 1008.9 1.0 2.0 28.9 32.8 No 0 14219 rows \u00d7 22 columns In [7]: Copied! atom . run ( models = [ \"GNB\" , \"LR\" , \"RF\" ]) atom.run(models=[\"GNB\", \"LR\", \"RF\"]) Training ========================= >> Models: GNB, LR, RF Metric: f1 Results for GaussianNB: Fit --------------------------------------------- Train evaluation --> f1: 0.5989 Test evaluation --> f1: 0.6007 Time elapsed: 0.041s ------------------------------------------------- Total time: 0.041s Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> f1: 0.6062 Test evaluation --> f1: 0.6133 Time elapsed: 0.148s ------------------------------------------------- Total time: 0.148s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> f1: 1.0 Test evaluation --> f1: 0.6229 Time elapsed: 2.744s ------------------------------------------------- Total time: 2.744s Final results ==================== >> Total time: 2.936s ------------------------------------- GaussianNB --> f1: 0.6007 LogisticRegression --> f1: 0.6133 RandomForest --> f1: 0.6229 ~ ! In [8]: Copied! atom . plot_prc () atom.plot_prc()  In [10]: Copied! # Based on the results on the test set, we select the best model for further tuning atom . run ( \"lr_tuned\" , n_trials = 10 ) # Based on the results on the test set, we select the best model for further tuning atom.run(\"lr_tuned\", n_trials=10) Training ========================= >> Models: LR_tuned Metric: f1 Running hyperparameter tuning for LogisticRegression... | trial | penalty | C | solver | max_iter | l1_ratio | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------- | ------- | ------- | -------- | -------- | ------- | ------- | ---------- | ------- | -------- | | 0 | l1 | 4.2668 | saga | 920 | --- | 0.6033 | 0.6033 | 0.692s | 0.692s | COMPLETE | | 1 | none | --- | saga | 1000 | --- | 0.6102 | 0.6102 | 0.901s | 1.592s | COMPLETE | | 2 | l2 | 0.0295 | newto.. | 230 | --- | 0.5737 | 0.6102 | 0.593s | 2.185s | COMPLETE | | 3 | l2 | 0.038 | newto.. | 360 | --- | 0.6161 | 0.6161 | 0.571s | 2.756s | COMPLETE | | 4 | l2 | 7.0752 | sag | 260 | --- | 0.5997 | 0.6161 | 0.697s | 3.452s | COMPLETE | | 5 | l2 | 0.0011 | sag | 910 | --- | 0.54 | 0.6161 | 0.550s | 4.003s | COMPLETE | | 6 | none | --- | newto.. | 810 | --- | 0.5923 | 0.6161 | 0.557s | 4.559s | COMPLETE | | 7 | l1 | 0.9715 | libli.. | 350 | --- | 0.5865 | 0.6161 | 0.715s | 5.274s | COMPLETE | | 8 | l2 | 0.0013 | newto.. | 900 | --- | 0.5466 | 0.6161 | 0.540s | 5.814s | COMPLETE | | 9 | l1 | 0.0021 | saga | 260 | --- | 0.5022 | 0.6161 | 0.556s | 6.370s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 3 Best parameters: --> penalty: l2 --> C: 0.038 --> solver: newton-cg --> max_iter: 360 Best evaluation --> f1: 0.6161 Time elapsed: 6.370s Fit --------------------------------------------- Train evaluation --> f1: 0.6042 Test evaluation --> f1: 0.6099 Time elapsed: 0.169s ------------------------------------------------- Total time: 6.539s Final results ==================== >> Total time: 6.566s ------------------------------------- LogisticRegression --> f1: 0.6099", "title": "Run the pipeline"}, {"location": "examples/holdout_set/#analyze-the-results", "text": "We already used the test set to choose the best model for futher tuning, so this set is no longer truly independent. Although it may not be directly visible in the results, using the test set now to evaluate the tuned LR model would be a mistake, since it carries a bias. For this reason, we have set apart an extra, indepedent set to validate the final model: the holdout set. If we are not going to use the test set for validation, we might as well use it to train the model and so optimize the use of the available data. Use the full_train method for this. In [11]: Copied! # Re-train the model on the full dataset (train + test) atom . lr_tuned . full_train () # Re-train the model on the full dataset (train + test) atom.lr_tuned.full_train() Fit --------------------------------------------- Train evaluation --> f1: 0.6062 Test evaluation --> f1: 0.6123 Time elapsed: 0.356s In [12]: Copied! # Evaluate on the holdout set atom . lr_tuned . evaluate ( dataset = \"holdout\" ) # Evaluate on the holdout set atom.lr_tuned.evaluate(dataset=\"holdout\") Out[12]: accuracy 0.8555 average_precision 0.7229 balanced_accuracy 0.7436 f1 0.6255 jaccard 0.4550 matthews_corrcoef 0.5485 precision 0.7396 recall 0.5418 roc_auc 0.8828 Name: LR_tuned, dtype: float64 In [14]: Copied! atom . lr_tuned . plot_prc ( dataset = \"holdout\" , legend = \"upper right\" ) atom.lr_tuned.plot_prc(dataset=\"holdout\", legend=\"upper right\") ", "title": "Analyze the results"}, {"location": "examples/hyperparameter_tuning/", "text": "Example: Hyperparameter tuning \u00b6 This example shows an advanced example on how to optimize your model's hyperparameters for multi-metric runs. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from optuna.distributions import IntDistribution from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from optuna.distributions import IntDistribution from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True) Run the pipeline \u00b6 In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , n_jobs = 4 , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, n_jobs=4, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 4 cores. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Train a MultiLayerPerceptron model on two metrics # using a custom number of hidden layers atom . run ( models = \"MLP\" , metric = [ \"f1\" , \"ap\" ], n_trials = 10 , est_params = { \"activation\" : \"relu\" }, ht_params = { \"distributions\" : { \"hidden_layer_1\" : IntDistribution ( 2 , 4 ), \"hidden_layer_2\" : IntDistribution ( 10 , 20 ), \"hidden_layer_3\" : IntDistribution ( 10 , 20 ), \"hidden_layer_4\" : IntDistribution ( 2 , 4 ), } } ) # Train a MultiLayerPerceptron model on two metrics # using a custom number of hidden layers atom.run( models=\"MLP\", metric=[\"f1\", \"ap\"], n_trials=10, est_params={\"activation\": \"relu\"}, ht_params={ \"distributions\": { \"hidden_layer_1\": IntDistribution(2, 4), \"hidden_layer_2\": IntDistribution(10, 20), \"hidden_layer_3\": IntDistribution(10, 20), \"hidden_layer_4\": IntDistribution(2, 4), } } ) Training ========================= >> Models: MLP Metric: f1, average_precision Running hyperparameter tuning for MultiLayerPerceptron... | trial | hidden_layer_1 | hidden_layer_2 | hidden_layer_3 | hidden_layer_4 | f1 | best_f1 | average_precision | best_average_precision | time_trial | time_ht | state | | ----- | -------------- | -------------- | -------------- | -------------- | ------- | ------- | ----------------- | ---------------------- | ---------- | ------- | -------- | | 0 | 3 | 17 | 10 | 2 | 0.9455 | 0.9455 | 0.9837 | 0.9837 | 0.943s | 0.943s | COMPLETE | | 1 | 2 | 11 | 12 | 3 | 0.9739 | 0.9739 | 0.9988 | 0.9988 | 0.929s | 1.872s | COMPLETE | | 2 | 3 | 15 | 14 | 4 | 0.9913 | 0.9913 | 1.0 | 1.0 | 0.935s | 2.807s | COMPLETE | | 3 | 2 | 19 | 10 | 4 | 0.9649 | 0.9913 | 0.9867 | 1.0 | 0.926s | 3.732s | COMPLETE | | 4 | 3 | 16 | 11 | 2 | 0.9655 | 0.9913 | 0.998 | 1.0 | 0.925s | 4.657s | COMPLETE | | 5 | 4 | 20 | 13 | 4 | 0.9821 | 0.9913 | 0.9994 | 1.0 | 0.940s | 5.597s | COMPLETE | | 6 | 4 | 19 | 10 | 2 | 0.9825 | 0.9913 | 0.9901 | 1.0 | 0.943s | 6.540s | COMPLETE | | 7 | 2 | 19 | 11 | 3 | 0.7703 | 0.9913 | 0.9991 | 1.0 | 0.943s | 7.483s | COMPLETE | | 8 | 4 | 15 | 17 | 2 | 0.9913 | 0.9913 | 0.9997 | 1.0 | 0.930s | 8.413s | COMPLETE | | 9 | 4 | 19 | 10 | 4 | 0.9739 | 0.9913 | 0.9813 | 1.0 | 0.915s | 9.327s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 2 Best parameters: --> hidden_layer_sizes: (3, 15, 14, 4) Best evaluation --> f1: 0.9913 average_precision: 1.0 Time elapsed: 9.327s Fit --------------------------------------------- Train evaluation --> f1: 0.993 average_precision: 0.998 Test evaluation --> f1: 0.9861 average_precision: 0.995 Time elapsed: 1.305s ------------------------------------------------- Total time: 10.633s Final results ==================== >> Total time: 10.675s ------------------------------------- MultiLayerPerceptron --> f1: 0.9861 average_precision: 0.995 In [5]: Copied! # For multi-metric runs, the selected best trial is the first in the Pareto front atom . mlp . best_trial # For multi-metric runs, the selected best trial is the first in the Pareto front atom.mlp.best_trial Out[5]: FrozenTrial(number=2, state=TrialState.COMPLETE, values=[0.9913043478260869, 1.0000000000000002], datetime_start=datetime.datetime(2022, 11, 23, 17, 35, 3, 837565), datetime_complete=datetime.datetime(2022, 11, 23, 17, 35, 4, 771413), params={'hidden_layer_1': 3, 'hidden_layer_2': 15, 'hidden_layer_3': 14, 'hidden_layer_4': 4}, user_attrs={'params': {'hidden_layer_1': 3, 'hidden_layer_2': 15, 'hidden_layer_3': 14, 'hidden_layer_4': 4}, 'estimator': MLPClassifier(hidden_layer_sizes=(3, 15, 14, 4), random_state=1)}, system_attrs={'nsga2:generation': 0}, intermediate_values={}, distributions={'hidden_layer_1': IntDistribution(high=4, log=False, low=2, step=1), 'hidden_layer_2': IntDistribution(high=20, log=False, low=10, step=1), 'hidden_layer_3': IntDistribution(high=20, log=False, low=10, step=1), 'hidden_layer_4': IntDistribution(high=4, log=False, low=2, step=1)}, trial_id=2, value=None) In [6]: Copied! atom . plot_pareto_front () atom.plot_pareto_front()  In [7]: Copied! # If you are unhappy with the results, it's possible to conitnue the study atom . mlp . hyperparameter_tuning ( n_trials = 5 ) # If you are unhappy with the results, it's possible to conitnue the study atom.mlp.hyperparameter_tuning(n_trials=5) Running hyperparameter tuning for MultiLayerPerceptron... | trial | hidden_layer_1 | hidden_layer_2 | hidden_layer_3 | hidden_layer_4 | f1 | best_f1 | average_precision | best_average_precision | time_trial | time_ht | state | | ----- | -------------- | -------------- | -------------- | -------------- | ------- | ------- | ----------------- | ---------------------- | ---------- | ------- | -------- | | 10 | 4 | 18 | 13 | 4 | 1.0 | 1.0 | 1.0 | 1.0 | 0.977s | 10.304s | COMPLETE | | 11 | 2 | 14 | 19 | 2 | 0.9492 | 1.0 | 0.9899 | 1.0 | 0.924s | 11.228s | COMPLETE | | 12 | 2 | 11 | 10 | 4 | 0.7703 | 1.0 | 0.99 | 1.0 | 0.919s | 12.147s | COMPLETE | | 13 | 2 | 12 | 15 | 2 | 0.9643 | 1.0 | 0.9813 | 1.0 | 0.914s | 13.061s | COMPLETE | | 14 | 3 | 11 | 16 | 4 | 0.7703 | 1.0 | 0.9724 | 1.0 | 0.926s | 13.987s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 10 Best parameters: --> hidden_layer_sizes: (4, 18, 13, 4) Best evaluation --> f1: 1.0 average_precision: 1.0 Time elapsed: 13.987s In [8]: Copied! # The trials attribute gives an overview of the trial results atom . mlp . trials # The trials attribute gives an overview of the trial results atom.mlp.trials Out[8]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } params estimator score time_trial time_ht state trial 0 {'hidden_layer_sizes': (3, 17, 10, 2)} MLPClassifier(hidden_layer_sizes=(3, 17, 10, 2... [0.9454545454545454, 0.9837236558914353] 0.942854 0.942854 COMPLETE 1 {'hidden_layer_sizes': (2, 11, 12, 3)} MLPClassifier(hidden_layer_sizes=(2, 11, 12, 3... [0.9739130434782608, 0.9988003322156944] 0.928844 1.871698 COMPLETE 2 {'hidden_layer_sizes': (3, 15, 14, 4)} MLPClassifier(hidden_layer_sizes=(3, 15, 14, 4... [0.9913043478260869, 1.0000000000000002] 0.934848 2.806546 COMPLETE 3 {'hidden_layer_sizes': (2, 19, 10, 4)} MLPClassifier(hidden_layer_sizes=(2, 19, 10, 4... [0.9649122807017544, 0.9867431480369178] 0.925841 3.732387 COMPLETE 4 {'hidden_layer_sizes': (3, 16, 11, 2)} MLPClassifier(hidden_layer_sizes=(3, 16, 11, 2... [0.9655172413793103, 0.9980213692125051] 0.92484 4.657227 COMPLETE 5 {'hidden_layer_sizes': (4, 20, 13, 4)} MLPClassifier(hidden_layer_sizes=(4, 20, 13, 4... [0.9821428571428572, 0.999389732649834] 0.939853 5.59708 COMPLETE 6 {'hidden_layer_sizes': (4, 19, 10, 2)} MLPClassifier(hidden_layer_sizes=(4, 19, 10, 2... [0.9824561403508771, 0.990093407959159] 0.942856 6.539936 COMPLETE 7 {'hidden_layer_sizes': (2, 19, 11, 3)} MLPClassifier(hidden_layer_sizes=(2, 19, 11, 3... [0.7702702702702703, 0.9990764494418141] 0.942856 7.482792 COMPLETE 8 {'hidden_layer_sizes': (4, 15, 17, 2)} MLPClassifier(hidden_layer_sizes=(4, 15, 17, 2... [0.9913043478260869, 0.9996975196612221] 0.929844 8.412636 COMPLETE 9 {'hidden_layer_sizes': (4, 19, 10, 4)} MLPClassifier(hidden_layer_sizes=(4, 19, 10, 4... [0.9739130434782608, 0.9813127743443262] 0.914831 9.327467 COMPLETE 10 {'hidden_layer_sizes': (4, 18, 13, 4)} MLPClassifier(hidden_layer_sizes=(4, 18, 13, 4... [1.0, 1.0000000000000002] 0.976887 10.304354 COMPLETE 11 {'hidden_layer_sizes': (2, 14, 19, 2)} MLPClassifier(hidden_layer_sizes=(2, 14, 19, 2... [0.9491525423728813, 0.9899476963066745] 0.923839 11.228193 COMPLETE 12 {'hidden_layer_sizes': (2, 11, 10, 4)} MLPClassifier(hidden_layer_sizes=(2, 11, 10, 4... [0.7702702702702703, 0.9900232191286547] 0.918835 12.147028 COMPLETE 13 {'hidden_layer_sizes': (2, 12, 15, 2)} MLPClassifier(hidden_layer_sizes=(2, 12, 15, 2... [0.9642857142857142, 0.9812621686248989] 0.91383 13.060858 COMPLETE 14 {'hidden_layer_sizes': (3, 11, 16, 4)} MLPClassifier(hidden_layer_sizes=(3, 11, 16, 4... [0.7702702702702703, 0.9723670235061694] 0.92584 13.986698 COMPLETE In [9]: Copied! # Select a custom best trial... atom . mlp . best_trial = 2 # ...and check that the best parameters are now those in the selected trial atom . mlp . best_params # Select a custom best trial... atom.mlp.best_trial = 2 # ...and check that the best parameters are now those in the selected trial atom.mlp.best_params Out[9]: {'hidden_layer_sizes': (3, 15, 14, 4)} In [10]: Copied! # Lastly, fit the model on the complete training set # using the new combination of hyperparameters atom . mlp . fit () # Lastly, fit the model on the complete training set # using the new combination of hyperparameters atom.mlp.fit() Fit --------------------------------------------- Train evaluation --> f1: 0.9948 average_precision: 0.9994 Test evaluation --> f1: 0.9861 average_precision: 0.997 Time elapsed: 2.648s Analyze the results \u00b6 In [11]: Copied! atom . plot_trials () atom.plot_trials()  In [12]: Copied! atom . plot_parallel_coordinate () atom.plot_parallel_coordinate() ", "title": "Hyperparameter tuning"}, {"location": "examples/hyperparameter_tuning/#example-hyperparameter-tuning", "text": "This example shows an advanced example on how to optimize your model's hyperparameters for multi-metric runs. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: Hyperparameter tuning"}, {"location": "examples/hyperparameter_tuning/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from optuna.distributions import IntDistribution from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from optuna.distributions import IntDistribution from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True)", "title": "Load the data"}, {"location": "examples/hyperparameter_tuning/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , n_jobs = 4 , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, n_jobs=4, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Parallel processing with 4 cores. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Train a MultiLayerPerceptron model on two metrics # using a custom number of hidden layers atom . run ( models = \"MLP\" , metric = [ \"f1\" , \"ap\" ], n_trials = 10 , est_params = { \"activation\" : \"relu\" }, ht_params = { \"distributions\" : { \"hidden_layer_1\" : IntDistribution ( 2 , 4 ), \"hidden_layer_2\" : IntDistribution ( 10 , 20 ), \"hidden_layer_3\" : IntDistribution ( 10 , 20 ), \"hidden_layer_4\" : IntDistribution ( 2 , 4 ), } } ) # Train a MultiLayerPerceptron model on two metrics # using a custom number of hidden layers atom.run( models=\"MLP\", metric=[\"f1\", \"ap\"], n_trials=10, est_params={\"activation\": \"relu\"}, ht_params={ \"distributions\": { \"hidden_layer_1\": IntDistribution(2, 4), \"hidden_layer_2\": IntDistribution(10, 20), \"hidden_layer_3\": IntDistribution(10, 20), \"hidden_layer_4\": IntDistribution(2, 4), } } ) Training ========================= >> Models: MLP Metric: f1, average_precision Running hyperparameter tuning for MultiLayerPerceptron... | trial | hidden_layer_1 | hidden_layer_2 | hidden_layer_3 | hidden_layer_4 | f1 | best_f1 | average_precision | best_average_precision | time_trial | time_ht | state | | ----- | -------------- | -------------- | -------------- | -------------- | ------- | ------- | ----------------- | ---------------------- | ---------- | ------- | -------- | | 0 | 3 | 17 | 10 | 2 | 0.9455 | 0.9455 | 0.9837 | 0.9837 | 0.943s | 0.943s | COMPLETE | | 1 | 2 | 11 | 12 | 3 | 0.9739 | 0.9739 | 0.9988 | 0.9988 | 0.929s | 1.872s | COMPLETE | | 2 | 3 | 15 | 14 | 4 | 0.9913 | 0.9913 | 1.0 | 1.0 | 0.935s | 2.807s | COMPLETE | | 3 | 2 | 19 | 10 | 4 | 0.9649 | 0.9913 | 0.9867 | 1.0 | 0.926s | 3.732s | COMPLETE | | 4 | 3 | 16 | 11 | 2 | 0.9655 | 0.9913 | 0.998 | 1.0 | 0.925s | 4.657s | COMPLETE | | 5 | 4 | 20 | 13 | 4 | 0.9821 | 0.9913 | 0.9994 | 1.0 | 0.940s | 5.597s | COMPLETE | | 6 | 4 | 19 | 10 | 2 | 0.9825 | 0.9913 | 0.9901 | 1.0 | 0.943s | 6.540s | COMPLETE | | 7 | 2 | 19 | 11 | 3 | 0.7703 | 0.9913 | 0.9991 | 1.0 | 0.943s | 7.483s | COMPLETE | | 8 | 4 | 15 | 17 | 2 | 0.9913 | 0.9913 | 0.9997 | 1.0 | 0.930s | 8.413s | COMPLETE | | 9 | 4 | 19 | 10 | 4 | 0.9739 | 0.9913 | 0.9813 | 1.0 | 0.915s | 9.327s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 2 Best parameters: --> hidden_layer_sizes: (3, 15, 14, 4) Best evaluation --> f1: 0.9913 average_precision: 1.0 Time elapsed: 9.327s Fit --------------------------------------------- Train evaluation --> f1: 0.993 average_precision: 0.998 Test evaluation --> f1: 0.9861 average_precision: 0.995 Time elapsed: 1.305s ------------------------------------------------- Total time: 10.633s Final results ==================== >> Total time: 10.675s ------------------------------------- MultiLayerPerceptron --> f1: 0.9861 average_precision: 0.995 In [5]: Copied! # For multi-metric runs, the selected best trial is the first in the Pareto front atom . mlp . best_trial # For multi-metric runs, the selected best trial is the first in the Pareto front atom.mlp.best_trial Out[5]: FrozenTrial(number=2, state=TrialState.COMPLETE, values=[0.9913043478260869, 1.0000000000000002], datetime_start=datetime.datetime(2022, 11, 23, 17, 35, 3, 837565), datetime_complete=datetime.datetime(2022, 11, 23, 17, 35, 4, 771413), params={'hidden_layer_1': 3, 'hidden_layer_2': 15, 'hidden_layer_3': 14, 'hidden_layer_4': 4}, user_attrs={'params': {'hidden_layer_1': 3, 'hidden_layer_2': 15, 'hidden_layer_3': 14, 'hidden_layer_4': 4}, 'estimator': MLPClassifier(hidden_layer_sizes=(3, 15, 14, 4), random_state=1)}, system_attrs={'nsga2:generation': 0}, intermediate_values={}, distributions={'hidden_layer_1': IntDistribution(high=4, log=False, low=2, step=1), 'hidden_layer_2': IntDistribution(high=20, log=False, low=10, step=1), 'hidden_layer_3': IntDistribution(high=20, log=False, low=10, step=1), 'hidden_layer_4': IntDistribution(high=4, log=False, low=2, step=1)}, trial_id=2, value=None) In [6]: Copied! atom . plot_pareto_front () atom.plot_pareto_front()  In [7]: Copied! # If you are unhappy with the results, it's possible to conitnue the study atom . mlp . hyperparameter_tuning ( n_trials = 5 ) # If you are unhappy with the results, it's possible to conitnue the study atom.mlp.hyperparameter_tuning(n_trials=5) Running hyperparameter tuning for MultiLayerPerceptron... | trial | hidden_layer_1 | hidden_layer_2 | hidden_layer_3 | hidden_layer_4 | f1 | best_f1 | average_precision | best_average_precision | time_trial | time_ht | state | | ----- | -------------- | -------------- | -------------- | -------------- | ------- | ------- | ----------------- | ---------------------- | ---------- | ------- | -------- | | 10 | 4 | 18 | 13 | 4 | 1.0 | 1.0 | 1.0 | 1.0 | 0.977s | 10.304s | COMPLETE | | 11 | 2 | 14 | 19 | 2 | 0.9492 | 1.0 | 0.9899 | 1.0 | 0.924s | 11.228s | COMPLETE | | 12 | 2 | 11 | 10 | 4 | 0.7703 | 1.0 | 0.99 | 1.0 | 0.919s | 12.147s | COMPLETE | | 13 | 2 | 12 | 15 | 2 | 0.9643 | 1.0 | 0.9813 | 1.0 | 0.914s | 13.061s | COMPLETE | | 14 | 3 | 11 | 16 | 4 | 0.7703 | 1.0 | 0.9724 | 1.0 | 0.926s | 13.987s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 10 Best parameters: --> hidden_layer_sizes: (4, 18, 13, 4) Best evaluation --> f1: 1.0 average_precision: 1.0 Time elapsed: 13.987s In [8]: Copied! # The trials attribute gives an overview of the trial results atom . mlp . trials # The trials attribute gives an overview of the trial results atom.mlp.trials Out[8]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } params estimator score time_trial time_ht state trial 0 {'hidden_layer_sizes': (3, 17, 10, 2)} MLPClassifier(hidden_layer_sizes=(3, 17, 10, 2... [0.9454545454545454, 0.9837236558914353] 0.942854 0.942854 COMPLETE 1 {'hidden_layer_sizes': (2, 11, 12, 3)} MLPClassifier(hidden_layer_sizes=(2, 11, 12, 3... [0.9739130434782608, 0.9988003322156944] 0.928844 1.871698 COMPLETE 2 {'hidden_layer_sizes': (3, 15, 14, 4)} MLPClassifier(hidden_layer_sizes=(3, 15, 14, 4... [0.9913043478260869, 1.0000000000000002] 0.934848 2.806546 COMPLETE 3 {'hidden_layer_sizes': (2, 19, 10, 4)} MLPClassifier(hidden_layer_sizes=(2, 19, 10, 4... [0.9649122807017544, 0.9867431480369178] 0.925841 3.732387 COMPLETE 4 {'hidden_layer_sizes': (3, 16, 11, 2)} MLPClassifier(hidden_layer_sizes=(3, 16, 11, 2... [0.9655172413793103, 0.9980213692125051] 0.92484 4.657227 COMPLETE 5 {'hidden_layer_sizes': (4, 20, 13, 4)} MLPClassifier(hidden_layer_sizes=(4, 20, 13, 4... [0.9821428571428572, 0.999389732649834] 0.939853 5.59708 COMPLETE 6 {'hidden_layer_sizes': (4, 19, 10, 2)} MLPClassifier(hidden_layer_sizes=(4, 19, 10, 2... [0.9824561403508771, 0.990093407959159] 0.942856 6.539936 COMPLETE 7 {'hidden_layer_sizes': (2, 19, 11, 3)} MLPClassifier(hidden_layer_sizes=(2, 19, 11, 3... [0.7702702702702703, 0.9990764494418141] 0.942856 7.482792 COMPLETE 8 {'hidden_layer_sizes': (4, 15, 17, 2)} MLPClassifier(hidden_layer_sizes=(4, 15, 17, 2... [0.9913043478260869, 0.9996975196612221] 0.929844 8.412636 COMPLETE 9 {'hidden_layer_sizes': (4, 19, 10, 4)} MLPClassifier(hidden_layer_sizes=(4, 19, 10, 4... [0.9739130434782608, 0.9813127743443262] 0.914831 9.327467 COMPLETE 10 {'hidden_layer_sizes': (4, 18, 13, 4)} MLPClassifier(hidden_layer_sizes=(4, 18, 13, 4... [1.0, 1.0000000000000002] 0.976887 10.304354 COMPLETE 11 {'hidden_layer_sizes': (2, 14, 19, 2)} MLPClassifier(hidden_layer_sizes=(2, 14, 19, 2... [0.9491525423728813, 0.9899476963066745] 0.923839 11.228193 COMPLETE 12 {'hidden_layer_sizes': (2, 11, 10, 4)} MLPClassifier(hidden_layer_sizes=(2, 11, 10, 4... [0.7702702702702703, 0.9900232191286547] 0.918835 12.147028 COMPLETE 13 {'hidden_layer_sizes': (2, 12, 15, 2)} MLPClassifier(hidden_layer_sizes=(2, 12, 15, 2... [0.9642857142857142, 0.9812621686248989] 0.91383 13.060858 COMPLETE 14 {'hidden_layer_sizes': (3, 11, 16, 4)} MLPClassifier(hidden_layer_sizes=(3, 11, 16, 4... [0.7702702702702703, 0.9723670235061694] 0.92584 13.986698 COMPLETE In [9]: Copied! # Select a custom best trial... atom . mlp . best_trial = 2 # ...and check that the best parameters are now those in the selected trial atom . mlp . best_params # Select a custom best trial... atom.mlp.best_trial = 2 # ...and check that the best parameters are now those in the selected trial atom.mlp.best_params Out[9]: {'hidden_layer_sizes': (3, 15, 14, 4)} In [10]: Copied! # Lastly, fit the model on the complete training set # using the new combination of hyperparameters atom . mlp . fit () # Lastly, fit the model on the complete training set # using the new combination of hyperparameters atom.mlp.fit() Fit --------------------------------------------- Train evaluation --> f1: 0.9948 average_precision: 0.9994 Test evaluation --> f1: 0.9861 average_precision: 0.997 Time elapsed: 2.648s", "title": "Run the pipeline"}, {"location": "examples/hyperparameter_tuning/#analyze-the-results", "text": "In [11]: Copied! atom . plot_trials () atom.plot_trials()  In [12]: Copied! atom . plot_parallel_coordinate () atom.plot_parallel_coordinate() ", "title": "Analyze the results"}, {"location": "examples/imbalanced_datasets/", "text": "Example: Imbalanced datasets \u00b6 This example shows how ATOM can help you handle imbalanced datasets. We will evaluate the performance of three different Random Forest models: one trained directly on the imbalanced dataset, one trained on an oversampled dataset and the last one trained on an undersampled dataset. Load the data \u00b6 In [1]: Copied! # Import packages from atom import ATOMClassifier from sklearn.datasets import make_classification # Import packages from atom import ATOMClassifier from sklearn.datasets import make_classification In [2]: Copied! # Create a mock imbalanced dataset X , y = make_classification ( n_samples = 5000 , n_features = 30 , n_informative = 20 , weights = ( 0.95 ,), random_state = 1 , ) # Create a mock imbalanced dataset X, y = make_classification( n_samples=5000, n_features=30, n_informative=20, weights=(0.95,), random_state=1, ) Run the pipeline \u00b6 In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , test_size = 0.2 , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, test_size=0.2, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (5000, 31) Memory: 1.22 MB Scaled: False Outlier values: 570 (0.5%) ------------------------------------- Train set size: 4000 Test set size: 1000 ------------------------------------- | | dataset | train | test | | - | ------------ | ------------ | ------------ | | 0 | 4731 (17.6) | 3785 (17.6) | 946 (17.5) | | 1 | 269 (1.0) | 215 (1.0) | 54 (1.0) | In [4]: Copied! # Let's have a look at the data. Note that, since the input wasn't # a dataframe, atom has given default names to the columns. atom . head () # Let's have a look at the data. Note that, since the input wasn't # a dataframe, atom has given default names to the columns. atom.head() Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 ... x21 x22 x23 x24 x25 x26 x27 x28 x29 target 0 -0.535760 -2.426045 1.256836 0.374501 -3.241958 -1.239468 -0.208750 -6.015995 3.698669 0.112512 ... 0.044302 -1.935727 10.870353 0.286755 -2.416507 0.556990 -1.522635 3.719201 1.449135 0 1 -3.311935 -3.149920 -0.801252 -2.644414 -0.704889 -3.312256 0.714515 2.992345 5.056910 3.036775 ... 2.224359 0.451273 -1.822108 -1.435801 0.036132 -1.364583 1.215663 5.232161 1.408798 0 2 3.821199 1.328129 -1.000720 -13.151697 0.254253 1.263636 -1.088451 4.924264 -1.225646 -6.974824 ... 3.541222 1.686667 -13.763703 -1.321256 1.677687 0.774966 -5.067689 4.663386 -1.714186 0 3 5.931126 3.338830 0.545906 2.296355 -3.941088 3.527252 -0.158770 3.138381 -0.927460 -1.642079 ... -3.634442 7.853176 -8.457598 0.000490 -2.612756 -1.138206 0.497150 4.351289 -0.321748 0 4 -2.829472 -1.227185 -0.751892 3.056106 -1.988920 -2.219184 -0.075882 5.790102 -2.786671 2.023458 ... 4.057954 1.178564 -15.028187 1.627140 -1.093587 -0.422655 1.777011 6.660638 -2.553723 0 5 rows \u00d7 31 columns In [5]: Copied! # Let's start reducing the number of features atom . feature_selection ( \"RFE\" , solver = \"RF\" , n_features = 12 ) # Let's start reducing the number of features atom.feature_selection(\"RFE\", solver=\"RF\", n_features=12) Fitting FeatureSelector... Performing feature selection ... --> rfe selected 12 features from the dataset. --> Dropping feature x1 (rank 8). --> Dropping feature x2 (rank 11). --> Dropping feature x4 (rank 3). --> Dropping feature x6 (rank 16). --> Dropping feature x7 (rank 14). --> Dropping feature x10 (rank 19). --> Dropping feature x12 (rank 13). --> Dropping feature x13 (rank 12). --> Dropping feature x14 (rank 9). --> Dropping feature x16 (rank 10). --> Dropping feature x18 (rank 17). --> Dropping feature x19 (rank 2). --> Dropping feature x20 (rank 4). --> Dropping feature x22 (rank 7). --> Dropping feature x23 (rank 5). --> Dropping feature x24 (rank 18). --> Dropping feature x25 (rank 6). --> Dropping feature x26 (rank 15). In [6]: Copied! # Fit a model directly on the imbalanced data atom . run ( \"RF\" , metric = \"ba\" ) # Fit a model directly on the imbalanced data atom.run(\"RF\", metric=\"ba\") Training ========================= >> Models: RF Metric: balanced_accuracy Results for RandomForest: Fit --------------------------------------------- Train evaluation --> balanced_accuracy: 1.0 Test evaluation --> balanced_accuracy: 0.5556 Time elapsed: 0.893s ------------------------------------------------- Total time: 0.893s Final results ==================== >> Total time: 0.895s ------------------------------------- RandomForest --> balanced_accuracy: 0.5556 ~ In [7]: Copied! # The transformer and the models have been added to the branch atom . branch # The transformer and the models have been added to the branch atom.branch Out[7]: Branch: master --> Pipeline: --> FeatureSelector --> Models: RF Oversampling \u00b6 In [8]: Copied! # Create a new branch for oversampling atom . branch = \"oversample\" # Create a new branch for oversampling atom.branch = \"oversample\" New branch oversample successfully created. In [9]: Copied! # Perform oversampling of the minority class atom . balance ( strategy = \"smote\" ) # Perform oversampling of the minority class atom.balance(strategy=\"smote\") Oversampling with SMOTE... --> Adding 3570 samples to class 1. In [10]: Copied! atom . classes # Check the balanced training set! atom.classes # Check the balanced training set! Out[10]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } dataset train test 0 4731 3785 946 1 3839 3785 54 In [11]: Copied! # Train another model on the new branch. Add a tag after # the model's acronym to distinguish it from the first model atom . run ( \"rf_os\" ) # os for oversample # Train another model on the new branch. Add a tag after # the model's acronym to distinguish it from the first model atom.run(\"rf_os\") # os for oversample Training ========================= >> Models: RF_os Metric: balanced_accuracy Results for RandomForest: Fit --------------------------------------------- Train evaluation --> balanced_accuracy: 1.0 Test evaluation --> balanced_accuracy: 0.7672 Time elapsed: 1.619s ------------------------------------------------- Total time: 1.619s Final results ==================== >> Total time: 1.619s ------------------------------------- RandomForest --> balanced_accuracy: 0.7672 ~ Undersampling \u00b6 In [12]: Copied! # Create the undersampling branch # Split from master to not adopt the oversmapling transformer atom . branch = \"undersample_from_master\" # Create the undersampling branch # Split from master to not adopt the oversmapling transformer atom.branch = \"undersample_from_master\" New branch undersample successfully created. In [13]: Copied! atom . classes # In this branch, the data is still imbalanced atom.classes # In this branch, the data is still imbalanced Out[13]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } dataset train test 0 4731 3785 946 1 269 215 54 In [14]: Copied! # Perform undersampling of the majority class atom . balance ( strategy = \"NearMiss\" ) # Perform undersampling of the majority class atom.balance(strategy=\"NearMiss\") Undersampling with NearMiss... --> Removing 3570 samples from class 0. In [15]: Copied! atom . run ( \"rf_us\" ) atom.run(\"rf_us\") Training ========================= >> Models: RF_us Metric: balanced_accuracy Results for RandomForest: Fit --------------------------------------------- Train evaluation --> balanced_accuracy: 1.0 Test evaluation --> balanced_accuracy: 0.6706 Time elapsed: 0.238s ------------------------------------------------- Total time: 0.238s Final results ==================== >> Total time: 0.238s ------------------------------------- RandomForest --> balanced_accuracy: 0.6706 ~ In [16]: Copied! # Check that the branch only contains the desired transformers atom . branch # Check that the branch only contains the desired transformers atom.branch Out[16]: Branch: undersample --> Pipeline: --> FeatureSelector --> Balancer --> Models: RF_us In [17]: Copied! # Visualize the complete pipeline atom . plot_pipeline () # Visualize the complete pipeline atom.plot_pipeline() Analyze the results \u00b6 In [18]: Copied! atom . evaluate () atom.evaluate() Out[18]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc RF 0.952 0.6562 0.5556 0.2000 0.1111 0.3252 1.000 0.1111 0.9107 RF_os 0.956 0.6215 0.7672 0.5769 0.4054 0.5542 0.600 0.5556 0.9251 RF_us 0.509 0.3687 0.6706 0.1578 0.0857 0.1545 0.087 0.8519 0.8258 In [19]: Copied! atom . plot_prc () atom.plot_prc()  In [20]: Copied! atom . plot_roc () atom.plot_roc() ", "title": "Imbalanced datasets"}, {"location": "examples/imbalanced_datasets/#example-imbalanced-datasets", "text": "This example shows how ATOM can help you handle imbalanced datasets. We will evaluate the performance of three different Random Forest models: one trained directly on the imbalanced dataset, one trained on an oversampled dataset and the last one trained on an undersampled dataset.", "title": "Example: Imbalanced datasets"}, {"location": "examples/imbalanced_datasets/#load-the-data", "text": "In [1]: Copied! # Import packages from atom import ATOMClassifier from sklearn.datasets import make_classification # Import packages from atom import ATOMClassifier from sklearn.datasets import make_classification In [2]: Copied! # Create a mock imbalanced dataset X , y = make_classification ( n_samples = 5000 , n_features = 30 , n_informative = 20 , weights = ( 0.95 ,), random_state = 1 , ) # Create a mock imbalanced dataset X, y = make_classification( n_samples=5000, n_features=30, n_informative=20, weights=(0.95,), random_state=1, )", "title": "Load the data"}, {"location": "examples/imbalanced_datasets/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , test_size = 0.2 , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, test_size=0.2, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (5000, 31) Memory: 1.22 MB Scaled: False Outlier values: 570 (0.5%) ------------------------------------- Train set size: 4000 Test set size: 1000 ------------------------------------- | | dataset | train | test | | - | ------------ | ------------ | ------------ | | 0 | 4731 (17.6) | 3785 (17.6) | 946 (17.5) | | 1 | 269 (1.0) | 215 (1.0) | 54 (1.0) | In [4]: Copied! # Let's have a look at the data. Note that, since the input wasn't # a dataframe, atom has given default names to the columns. atom . head () # Let's have a look at the data. Note that, since the input wasn't # a dataframe, atom has given default names to the columns. atom.head() Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 ... x21 x22 x23 x24 x25 x26 x27 x28 x29 target 0 -0.535760 -2.426045 1.256836 0.374501 -3.241958 -1.239468 -0.208750 -6.015995 3.698669 0.112512 ... 0.044302 -1.935727 10.870353 0.286755 -2.416507 0.556990 -1.522635 3.719201 1.449135 0 1 -3.311935 -3.149920 -0.801252 -2.644414 -0.704889 -3.312256 0.714515 2.992345 5.056910 3.036775 ... 2.224359 0.451273 -1.822108 -1.435801 0.036132 -1.364583 1.215663 5.232161 1.408798 0 2 3.821199 1.328129 -1.000720 -13.151697 0.254253 1.263636 -1.088451 4.924264 -1.225646 -6.974824 ... 3.541222 1.686667 -13.763703 -1.321256 1.677687 0.774966 -5.067689 4.663386 -1.714186 0 3 5.931126 3.338830 0.545906 2.296355 -3.941088 3.527252 -0.158770 3.138381 -0.927460 -1.642079 ... -3.634442 7.853176 -8.457598 0.000490 -2.612756 -1.138206 0.497150 4.351289 -0.321748 0 4 -2.829472 -1.227185 -0.751892 3.056106 -1.988920 -2.219184 -0.075882 5.790102 -2.786671 2.023458 ... 4.057954 1.178564 -15.028187 1.627140 -1.093587 -0.422655 1.777011 6.660638 -2.553723 0 5 rows \u00d7 31 columns In [5]: Copied! # Let's start reducing the number of features atom . feature_selection ( \"RFE\" , solver = \"RF\" , n_features = 12 ) # Let's start reducing the number of features atom.feature_selection(\"RFE\", solver=\"RF\", n_features=12) Fitting FeatureSelector... Performing feature selection ... --> rfe selected 12 features from the dataset. --> Dropping feature x1 (rank 8). --> Dropping feature x2 (rank 11). --> Dropping feature x4 (rank 3). --> Dropping feature x6 (rank 16). --> Dropping feature x7 (rank 14). --> Dropping feature x10 (rank 19). --> Dropping feature x12 (rank 13). --> Dropping feature x13 (rank 12). --> Dropping feature x14 (rank 9). --> Dropping feature x16 (rank 10). --> Dropping feature x18 (rank 17). --> Dropping feature x19 (rank 2). --> Dropping feature x20 (rank 4). --> Dropping feature x22 (rank 7). --> Dropping feature x23 (rank 5). --> Dropping feature x24 (rank 18). --> Dropping feature x25 (rank 6). --> Dropping feature x26 (rank 15). In [6]: Copied! # Fit a model directly on the imbalanced data atom . run ( \"RF\" , metric = \"ba\" ) # Fit a model directly on the imbalanced data atom.run(\"RF\", metric=\"ba\") Training ========================= >> Models: RF Metric: balanced_accuracy Results for RandomForest: Fit --------------------------------------------- Train evaluation --> balanced_accuracy: 1.0 Test evaluation --> balanced_accuracy: 0.5556 Time elapsed: 0.893s ------------------------------------------------- Total time: 0.893s Final results ==================== >> Total time: 0.895s ------------------------------------- RandomForest --> balanced_accuracy: 0.5556 ~ In [7]: Copied! # The transformer and the models have been added to the branch atom . branch # The transformer and the models have been added to the branch atom.branch Out[7]: Branch: master --> Pipeline: --> FeatureSelector --> Models: RF", "title": "Run the pipeline"}, {"location": "examples/imbalanced_datasets/#oversampling", "text": "In [8]: Copied! # Create a new branch for oversampling atom . branch = \"oversample\" # Create a new branch for oversampling atom.branch = \"oversample\" New branch oversample successfully created. In [9]: Copied! # Perform oversampling of the minority class atom . balance ( strategy = \"smote\" ) # Perform oversampling of the minority class atom.balance(strategy=\"smote\") Oversampling with SMOTE... --> Adding 3570 samples to class 1. In [10]: Copied! atom . classes # Check the balanced training set! atom.classes # Check the balanced training set! Out[10]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } dataset train test 0 4731 3785 946 1 3839 3785 54 In [11]: Copied! # Train another model on the new branch. Add a tag after # the model's acronym to distinguish it from the first model atom . run ( \"rf_os\" ) # os for oversample # Train another model on the new branch. Add a tag after # the model's acronym to distinguish it from the first model atom.run(\"rf_os\") # os for oversample Training ========================= >> Models: RF_os Metric: balanced_accuracy Results for RandomForest: Fit --------------------------------------------- Train evaluation --> balanced_accuracy: 1.0 Test evaluation --> balanced_accuracy: 0.7672 Time elapsed: 1.619s ------------------------------------------------- Total time: 1.619s Final results ==================== >> Total time: 1.619s ------------------------------------- RandomForest --> balanced_accuracy: 0.7672 ~", "title": "Oversampling"}, {"location": "examples/imbalanced_datasets/#undersampling", "text": "In [12]: Copied! # Create the undersampling branch # Split from master to not adopt the oversmapling transformer atom . branch = \"undersample_from_master\" # Create the undersampling branch # Split from master to not adopt the oversmapling transformer atom.branch = \"undersample_from_master\" New branch undersample successfully created. In [13]: Copied! atom . classes # In this branch, the data is still imbalanced atom.classes # In this branch, the data is still imbalanced Out[13]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } dataset train test 0 4731 3785 946 1 269 215 54 In [14]: Copied! # Perform undersampling of the majority class atom . balance ( strategy = \"NearMiss\" ) # Perform undersampling of the majority class atom.balance(strategy=\"NearMiss\") Undersampling with NearMiss... --> Removing 3570 samples from class 0. In [15]: Copied! atom . run ( \"rf_us\" ) atom.run(\"rf_us\") Training ========================= >> Models: RF_us Metric: balanced_accuracy Results for RandomForest: Fit --------------------------------------------- Train evaluation --> balanced_accuracy: 1.0 Test evaluation --> balanced_accuracy: 0.6706 Time elapsed: 0.238s ------------------------------------------------- Total time: 0.238s Final results ==================== >> Total time: 0.238s ------------------------------------- RandomForest --> balanced_accuracy: 0.6706 ~ In [16]: Copied! # Check that the branch only contains the desired transformers atom . branch # Check that the branch only contains the desired transformers atom.branch Out[16]: Branch: undersample --> Pipeline: --> FeatureSelector --> Balancer --> Models: RF_us In [17]: Copied! # Visualize the complete pipeline atom . plot_pipeline () # Visualize the complete pipeline atom.plot_pipeline()", "title": "Undersampling"}, {"location": "examples/imbalanced_datasets/#analyze-the-results", "text": "In [18]: Copied! atom . evaluate () atom.evaluate() Out[18]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } accuracy average_precision balanced_accuracy f1 jaccard matthews_corrcoef precision recall roc_auc RF 0.952 0.6562 0.5556 0.2000 0.1111 0.3252 1.000 0.1111 0.9107 RF_os 0.956 0.6215 0.7672 0.5769 0.4054 0.5542 0.600 0.5556 0.9251 RF_us 0.509 0.3687 0.6706 0.1578 0.0857 0.1545 0.087 0.8519 0.8258 In [19]: Copied! atom . plot_prc () atom.plot_prc()  In [20]: Copied! atom . plot_roc () atom.plot_roc() ", "title": "Analyze the results"}, {"location": "examples/in_training_validation/", "text": "Example: In-training validation \u00b6 This example shows how to keep track of the model's performance during training. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True) Run the pipeline \u00b6 In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Not all models support in-training validation # You can chek which ones do using the available_models method df = atom . available_models ()[[ \"acronym\" , \"model\" , \"has_validation\" ]] df [ df [ \"has_validation\" ]] # Not all models support in-training validation # You can chek which ones do using the available_models method df = atom.available_models()[[\"acronym\", \"model\", \"has_validation\"]] df[df[\"has_validation\"]] Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model has_validation 3 CatB CatBoost True 15 LGB LightGBM True 19 MLP MultiLayerPerceptron True 21 PA PassiveAggressive True 22 Perc Perceptron True 27 SGD StochasticGradientDescent True 29 XGB XGBoost True In [5]: Copied! # Run the models normally atom . run ( models = [ \"MLP\" , \"LGB\" ], metric = \"auc\" ) # Run the models normally atom.run(models=[\"MLP\", \"LGB\"], metric=\"auc\") Training ========================= >> Models: MLP, LGB Metric: roc_auc Results for MultiLayerPerceptron: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9997 Test evaluation --> roc_auc: 0.9936 Time elapsed: 1.673s ------------------------------------------------- Total time: 1.673s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9775 Time elapsed: 0.309s ------------------------------------------------- Total time: 0.309s Final results ==================== >> Total time: 1.982s ------------------------------------- MultiLayerPerceptron --> roc_auc: 0.9936 ! LightGBM --> roc_auc: 0.9775 Analyze the results \u00b6 In [6]: Copied! atom . plot_evals ( title = \"In-training validation scores\" ) atom.plot_evals(title=\"In-training validation scores\")  In [8]: Copied! # Plot the validation on the train and test set atom . lgb . plot_evals ( dataset = \"train+test\" , title = \"LightGBM's in-training validation\" ) # Plot the validation on the train and test set atom.lgb.plot_evals(dataset=\"train+test\", title=\"LightGBM's in-training validation\") ", "title": "In-training validation"}, {"location": "examples/in_training_validation/#example-in-training-validation", "text": "This example shows how to keep track of the model's performance during training. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: In-training validation"}, {"location": "examples/in_training_validation/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True)", "title": "Load the data"}, {"location": "examples/in_training_validation/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Not all models support in-training validation # You can chek which ones do using the available_models method df = atom . available_models ()[[ \"acronym\" , \"model\" , \"has_validation\" ]] df [ df [ \"has_validation\" ]] # Not all models support in-training validation # You can chek which ones do using the available_models method df = atom.available_models()[[\"acronym\", \"model\", \"has_validation\"]] df[df[\"has_validation\"]] Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model has_validation 3 CatB CatBoost True 15 LGB LightGBM True 19 MLP MultiLayerPerceptron True 21 PA PassiveAggressive True 22 Perc Perceptron True 27 SGD StochasticGradientDescent True 29 XGB XGBoost True In [5]: Copied! # Run the models normally atom . run ( models = [ \"MLP\" , \"LGB\" ], metric = \"auc\" ) # Run the models normally atom.run(models=[\"MLP\", \"LGB\"], metric=\"auc\") Training ========================= >> Models: MLP, LGB Metric: roc_auc Results for MultiLayerPerceptron: Fit --------------------------------------------- Train evaluation --> roc_auc: 0.9997 Test evaluation --> roc_auc: 0.9936 Time elapsed: 1.673s ------------------------------------------------- Total time: 1.673s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> roc_auc: 1.0 Test evaluation --> roc_auc: 0.9775 Time elapsed: 0.309s ------------------------------------------------- Total time: 0.309s Final results ==================== >> Total time: 1.982s ------------------------------------- MultiLayerPerceptron --> roc_auc: 0.9936 ! LightGBM --> roc_auc: 0.9775", "title": "Run the pipeline"}, {"location": "examples/in_training_validation/#analyze-the-results", "text": "In [6]: Copied! atom . plot_evals ( title = \"In-training validation scores\" ) atom.plot_evals(title=\"In-training validation scores\")  In [8]: Copied! # Plot the validation on the train and test set atom . lgb . plot_evals ( dataset = \"train+test\" , title = \"LightGBM's in-training validation\" ) # Plot the validation on the train and test set atom.lgb.plot_evals(dataset=\"train+test\", title=\"LightGBM's in-training validation\") ", "title": "Analyze the results"}, {"location": "examples/multi_metric/", "text": "Example: Multi-metric runs \u00b6 This example shows how to evaluate an atom's pipeline on multiple metrics. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMRegressor # Import packages import pandas as pd from atom import ATOMRegressor In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/abalone.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/abalone.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Sex Length Diameter Height Whole weight Shucked weight Viscera weight Shell weight Rings 0 M 0.455 0.365 0.095 0.5140 0.2245 0.1010 0.150 15 1 M 0.350 0.265 0.090 0.2255 0.0995 0.0485 0.070 7 2 F 0.530 0.420 0.135 0.6770 0.2565 0.1415 0.210 9 3 M 0.440 0.365 0.125 0.5160 0.2155 0.1140 0.155 10 4 I 0.330 0.255 0.080 0.2050 0.0895 0.0395 0.055 7 Run the pipeline \u00b6 In [3]: Copied! atom = ATOMRegressor ( X , n_jobs = 1 , verbose = 2 , random_state = 1 ) atom = ATOMRegressor(X, n_jobs=1, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: regression. Dataset stats ==================== >> Shape: (4177, 9) Memory: 509.72 kB Scaled: False Categorical features: 1 (12.5%) Outlier values: 189 (0.6%) ------------------------------------- Train set size: 3342 Test set size: 835 In [4]: Copied! atom . encode () atom.encode() Fitting Encoder... Encoding categorical columns... --> OneHot-encoding feature Sex. Contains 3 classes. In [5]: Copied! # For every step of the BO, both metrics are calculated, # but only the first is used for optimization! atom . run ( models = [ \"lsvm\" , \"hGBM\" ], metric = ( \"r2\" , \"rmse\" ), n_trials = 10 , n_bootstrap = 6 , ) # For every step of the BO, both metrics are calculated, # but only the first is used for optimization! atom.run( models=[\"lsvm\", \"hGBM\"], metric=(\"r2\", \"rmse\"), n_trials=10, n_bootstrap=6, ) Training ========================= >> Models: lSVM, hGBM Metric: r2, neg_root_mean_squared_error Running hyperparameter tuning for LinearSVM... | trial | loss | C | dual | r2 | best_r2 | neg_root_mean_squared_error | best_neg_root_mean_squared_error | time_trial | time_ht | state | | ----- | ----------------------- | ------- | ------- | ------- | ------- | --------------------------- | -------------------------------- | ---------- | ------- | -------- | | 0 | squared_epsilon_insen.. | 0.001 | True | 0.2887 | 0.2887 | -2.6528 | -2.6528 | 0.043s | 0.043s | COMPLETE | | 1 | squared_epsilon_insen.. | 0.0534 | False | 0.3862 | 0.3862 | -2.5926 | -2.5926 | 0.057s | 0.100s | COMPLETE | | 2 | squared_epsilon_insen.. | 0.0105 | True | 0.433 | 0.433 | -2.4084 | -2.4084 | 0.048s | 0.148s | COMPLETE | | 3 | epsilon_insensitive | 0.6215 | True | 0.4022 | 0.433 | -2.5251 | -2.4084 | 0.046s | 0.194s | COMPLETE | | 4 | squared_epsilon_insen.. | 0.0369 | False | 0.4057 | 0.433 | -2.5477 | -2.4084 | 0.039s | 0.233s | COMPLETE | | 5 | epsilon_insensitive | 0.0016 | True | -1.5344 | 0.433 | -5.0102 | -2.4084 | 0.039s | 0.272s | COMPLETE | | 6 | squared_epsilon_insen.. | 61.5811 | False | 0.4354 | 0.4354 | -2.3845 | -2.3845 | 0.040s | 0.312s | COMPLETE | | 7 | squared_epsilon_insen.. | 14.898 | False | 0.4925 | 0.4925 | -2.2628 | -2.2628 | 0.044s | 0.356s | COMPLETE | | 8 | epsilon_insensitive | 0.0252 | True | 0.3695 | 0.4925 | -2.6178 | -2.2628 | 0.039s | 0.395s | COMPLETE | | 9 | squared_epsilon_insen.. | 0.0294 | True | 0.4767 | 0.4925 | -2.3896 | -2.2628 | 0.050s | 0.445s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 7 Best parameters: --> loss: squared_epsilon_insensitive --> C: 14.898 --> dual: False Best evaluation --> r2: 0.4925 neg_root_mean_squared_error: -2.2628 Time elapsed: 0.445s Fit --------------------------------------------- Train evaluation --> r2: 0.4592 neg_root_mean_squared_error: -2.3795 Test evaluation --> r2: 0.4584 neg_root_mean_squared_error: -2.3369 Time elapsed: 0.027s Bootstrap --------------------------------------- Evaluation --> r2: 0.4577 \u00b1 0.002 neg_root_mean_squared_error: -2.3384 \u00b1 0.0043 Time elapsed: 0.107s ------------------------------------------------- Total time: 0.580s Running hyperparameter tuning for HistGradientBoosting... | trial | loss | learning_rate | max_iter | max_leaf_nodes | max_depth | min_samples_leaf | l2_regularization | r2 | best_r2 | neg_root_mean_squared_error | best_neg_root_mean_squared_error | time_trial | time_ht | state | | ----- | ----------- | ------------- | -------- | -------------- | --------- | ---------------- | ----------------- | ------- | ------- | --------------------------- | -------------------------------- | ---------- | ------- | -------- | | 0 | absolute_.. | 0.0402 | 80 | 13 | 15 | 24 | 0.9 | 0.5248 | 0.5248 | -2.1683 | -2.1683 | 0.277s | 0.277s | COMPLETE | | 1 | squared_e.. | 0.0219 | 440 | 14 | 9 | 16 | 0.1 | 0.5673 | 0.5673 | -2.1767 | -2.1683 | 1.106s | 1.383s | COMPLETE | | 2 | absolute_.. | 0.034 | 250 | 12 | 12 | 26 | 0.4 | 0.5174 | 0.5673 | -2.2218 | -2.1683 | 0.864s | 2.247s | COMPLETE | | 3 | absolute_.. | 0.3174 | 370 | 46 | 6 | 10 | 0.6 | 0.5566 | 0.5673 | -2.1746 | -2.1683 | 1.385s | 3.632s | COMPLETE | | 4 | poisson | 0.0518 | 460 | 35 | 3 | 15 | 0.9 | 0.5691 | 0.5691 | -2.1695 | -2.1683 | 0.593s | 4.225s | COMPLETE | | 5 | poisson | 0.0177 | 140 | 34 | None | 21 | 0.0 | 0.5546 | 0.5691 | -2.1003 | -2.1003 | 0.818s | 5.043s | COMPLETE | | 6 | absolute_.. | 0.0255 | 130 | 40 | 15 | 17 | 0.6 | 0.483 | 0.5691 | -2.2817 | -2.1003 | 1.093s | 6.136s | COMPLETE | | 7 | squared_e.. | 0.0136 | 190 | 35 | 14 | 22 | 1.0 | 0.5699 | 0.5699 | -2.083 | -2.083 | 1.003s | 7.138s | COMPLETE | | 8 | squared_e.. | 0.1919 | 200 | 29 | 5 | 26 | 0.3 | 0.5105 | 0.5699 | -2.3066 | -2.083 | 0.388s | 7.527s | COMPLETE | | 9 | squared_e.. | 0.4892 | 460 | 28 | 10 | 24 | 1.0 | 0.4298 | 0.5699 | -2.4942 | -2.083 | 1.438s | 8.965s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 7 Best parameters: --> loss: squared_error --> learning_rate: 0.0136 --> max_iter: 190 --> max_leaf_nodes: 35 --> max_depth: 14 --> min_samples_leaf: 22 --> l2_regularization: 1.0 Best evaluation --> r2: 0.5699 neg_root_mean_squared_error: -2.083 Time elapsed: 8.965s Fit --------------------------------------------- Train evaluation --> r2: 0.6668 neg_root_mean_squared_error: -1.8677 Test evaluation --> r2: 0.5583 neg_root_mean_squared_error: -2.1105 Time elapsed: 1.059s Bootstrap --------------------------------------- Evaluation --> r2: 0.5388 \u00b1 0.0083 neg_root_mean_squared_error: -2.1565 \u00b1 0.0192 Time elapsed: 5.925s ------------------------------------------------- Total time: 15.949s Final results ==================== >> Total time: 16.714s ------------------------------------- LinearSVM --> r2: 0.4577 \u00b1 0.002 neg_root_mean_squared_error: -2.3384 \u00b1 0.0043 HistGradientBoosting --> r2: 0.5388 \u00b1 0.0083 neg_root_mean_squared_error: -2.1565 \u00b1 0.0192 ! In [6]: Copied! # Check the robustness of the pipeline using cross-validation atom . winner . cross_validate () # Check the robustness of the pipeline using cross-validation atom.winner.cross_validate() Applying cross-validation... Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } train_r2 test_r2 train_neg_root_mean_squared_error test_neg_root_mean_squared_error time (s) 0 0.672482 0.534480 -1.841417 -2.214880 1.074976 1 0.669693 0.541603 -1.850140 -2.193359 1.078980 2 0.674650 0.525120 -1.860947 -2.111204 1.142037 3 0.661519 0.579041 -1.851866 -2.194239 1.110008 4 0.666829 0.558253 -1.867706 -2.110524 1.085987 mean 0.669035 0.547699 -1.854415 -2.164841 1.098398 std 0.004587 0.019055 0.009089 0.044741 0.024975 Analyze the results \u00b6 In [7]: Copied! # The columns in the results dataframe contain a list of # scores, one for each metric (in the same order as called) atom . results [[ \"score_ht\" , \"score_train\" , \"score_test\" ]] # The columns in the results dataframe contain a list of # scores, one for each metric (in the same order as called) atom.results[[\"score_ht\", \"score_train\", \"score_test\"]] Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_ht score_train score_test lSVM [0.4925303455788521, -2.262753922393612] [0.4592, -2.3795] [0.4584, -2.3369] hGBM [0.5699377046439738, -2.08304173753828] [0.6668, -1.8677] [0.5583, -2.1105] In [8]: Copied! # Some plots allow us to choose the metric we want to show with atom . canvas (): atom . plot_trials ( metric = \"r2\" , title = \"Hyperparameter tuning performance for R2\" ) atom . plot_trials ( metric = \"rmse\" , title = \"Hyperparameter tuning performance for RMSE\" ) # Some plots allow us to choose the metric we want to show with atom.canvas(): atom.plot_trials(metric=\"r2\", title=\"Hyperparameter tuning performance for R2\") atom.plot_trials(metric=\"rmse\", title=\"Hyperparameter tuning performance for RMSE\")  In [9]: Copied! atom . plot_results ( metric = \"r2\" ) atom.plot_results(metric=\"r2\") ", "title": "Multi-metric runs"}, {"location": "examples/multi_metric/#example-multi-metric-runs", "text": "This example shows how to evaluate an atom's pipeline on multiple metrics. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: Multi-metric runs"}, {"location": "examples/multi_metric/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMRegressor # Import packages import pandas as pd from atom import ATOMRegressor In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/abalone.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/abalone.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Sex Length Diameter Height Whole weight Shucked weight Viscera weight Shell weight Rings 0 M 0.455 0.365 0.095 0.5140 0.2245 0.1010 0.150 15 1 M 0.350 0.265 0.090 0.2255 0.0995 0.0485 0.070 7 2 F 0.530 0.420 0.135 0.6770 0.2565 0.1415 0.210 9 3 M 0.440 0.365 0.125 0.5160 0.2155 0.1140 0.155 10 4 I 0.330 0.255 0.080 0.2050 0.0895 0.0395 0.055 7", "title": "Load the data"}, {"location": "examples/multi_metric/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMRegressor ( X , n_jobs = 1 , verbose = 2 , random_state = 1 ) atom = ATOMRegressor(X, n_jobs=1, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: regression. Dataset stats ==================== >> Shape: (4177, 9) Memory: 509.72 kB Scaled: False Categorical features: 1 (12.5%) Outlier values: 189 (0.6%) ------------------------------------- Train set size: 3342 Test set size: 835 In [4]: Copied! atom . encode () atom.encode() Fitting Encoder... Encoding categorical columns... --> OneHot-encoding feature Sex. Contains 3 classes. In [5]: Copied! # For every step of the BO, both metrics are calculated, # but only the first is used for optimization! atom . run ( models = [ \"lsvm\" , \"hGBM\" ], metric = ( \"r2\" , \"rmse\" ), n_trials = 10 , n_bootstrap = 6 , ) # For every step of the BO, both metrics are calculated, # but only the first is used for optimization! atom.run( models=[\"lsvm\", \"hGBM\"], metric=(\"r2\", \"rmse\"), n_trials=10, n_bootstrap=6, ) Training ========================= >> Models: lSVM, hGBM Metric: r2, neg_root_mean_squared_error Running hyperparameter tuning for LinearSVM... | trial | loss | C | dual | r2 | best_r2 | neg_root_mean_squared_error | best_neg_root_mean_squared_error | time_trial | time_ht | state | | ----- | ----------------------- | ------- | ------- | ------- | ------- | --------------------------- | -------------------------------- | ---------- | ------- | -------- | | 0 | squared_epsilon_insen.. | 0.001 | True | 0.2887 | 0.2887 | -2.6528 | -2.6528 | 0.043s | 0.043s | COMPLETE | | 1 | squared_epsilon_insen.. | 0.0534 | False | 0.3862 | 0.3862 | -2.5926 | -2.5926 | 0.057s | 0.100s | COMPLETE | | 2 | squared_epsilon_insen.. | 0.0105 | True | 0.433 | 0.433 | -2.4084 | -2.4084 | 0.048s | 0.148s | COMPLETE | | 3 | epsilon_insensitive | 0.6215 | True | 0.4022 | 0.433 | -2.5251 | -2.4084 | 0.046s | 0.194s | COMPLETE | | 4 | squared_epsilon_insen.. | 0.0369 | False | 0.4057 | 0.433 | -2.5477 | -2.4084 | 0.039s | 0.233s | COMPLETE | | 5 | epsilon_insensitive | 0.0016 | True | -1.5344 | 0.433 | -5.0102 | -2.4084 | 0.039s | 0.272s | COMPLETE | | 6 | squared_epsilon_insen.. | 61.5811 | False | 0.4354 | 0.4354 | -2.3845 | -2.3845 | 0.040s | 0.312s | COMPLETE | | 7 | squared_epsilon_insen.. | 14.898 | False | 0.4925 | 0.4925 | -2.2628 | -2.2628 | 0.044s | 0.356s | COMPLETE | | 8 | epsilon_insensitive | 0.0252 | True | 0.3695 | 0.4925 | -2.6178 | -2.2628 | 0.039s | 0.395s | COMPLETE | | 9 | squared_epsilon_insen.. | 0.0294 | True | 0.4767 | 0.4925 | -2.3896 | -2.2628 | 0.050s | 0.445s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 7 Best parameters: --> loss: squared_epsilon_insensitive --> C: 14.898 --> dual: False Best evaluation --> r2: 0.4925 neg_root_mean_squared_error: -2.2628 Time elapsed: 0.445s Fit --------------------------------------------- Train evaluation --> r2: 0.4592 neg_root_mean_squared_error: -2.3795 Test evaluation --> r2: 0.4584 neg_root_mean_squared_error: -2.3369 Time elapsed: 0.027s Bootstrap --------------------------------------- Evaluation --> r2: 0.4577 \u00b1 0.002 neg_root_mean_squared_error: -2.3384 \u00b1 0.0043 Time elapsed: 0.107s ------------------------------------------------- Total time: 0.580s Running hyperparameter tuning for HistGradientBoosting... | trial | loss | learning_rate | max_iter | max_leaf_nodes | max_depth | min_samples_leaf | l2_regularization | r2 | best_r2 | neg_root_mean_squared_error | best_neg_root_mean_squared_error | time_trial | time_ht | state | | ----- | ----------- | ------------- | -------- | -------------- | --------- | ---------------- | ----------------- | ------- | ------- | --------------------------- | -------------------------------- | ---------- | ------- | -------- | | 0 | absolute_.. | 0.0402 | 80 | 13 | 15 | 24 | 0.9 | 0.5248 | 0.5248 | -2.1683 | -2.1683 | 0.277s | 0.277s | COMPLETE | | 1 | squared_e.. | 0.0219 | 440 | 14 | 9 | 16 | 0.1 | 0.5673 | 0.5673 | -2.1767 | -2.1683 | 1.106s | 1.383s | COMPLETE | | 2 | absolute_.. | 0.034 | 250 | 12 | 12 | 26 | 0.4 | 0.5174 | 0.5673 | -2.2218 | -2.1683 | 0.864s | 2.247s | COMPLETE | | 3 | absolute_.. | 0.3174 | 370 | 46 | 6 | 10 | 0.6 | 0.5566 | 0.5673 | -2.1746 | -2.1683 | 1.385s | 3.632s | COMPLETE | | 4 | poisson | 0.0518 | 460 | 35 | 3 | 15 | 0.9 | 0.5691 | 0.5691 | -2.1695 | -2.1683 | 0.593s | 4.225s | COMPLETE | | 5 | poisson | 0.0177 | 140 | 34 | None | 21 | 0.0 | 0.5546 | 0.5691 | -2.1003 | -2.1003 | 0.818s | 5.043s | COMPLETE | | 6 | absolute_.. | 0.0255 | 130 | 40 | 15 | 17 | 0.6 | 0.483 | 0.5691 | -2.2817 | -2.1003 | 1.093s | 6.136s | COMPLETE | | 7 | squared_e.. | 0.0136 | 190 | 35 | 14 | 22 | 1.0 | 0.5699 | 0.5699 | -2.083 | -2.083 | 1.003s | 7.138s | COMPLETE | | 8 | squared_e.. | 0.1919 | 200 | 29 | 5 | 26 | 0.3 | 0.5105 | 0.5699 | -2.3066 | -2.083 | 0.388s | 7.527s | COMPLETE | | 9 | squared_e.. | 0.4892 | 460 | 28 | 10 | 24 | 1.0 | 0.4298 | 0.5699 | -2.4942 | -2.083 | 1.438s | 8.965s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 7 Best parameters: --> loss: squared_error --> learning_rate: 0.0136 --> max_iter: 190 --> max_leaf_nodes: 35 --> max_depth: 14 --> min_samples_leaf: 22 --> l2_regularization: 1.0 Best evaluation --> r2: 0.5699 neg_root_mean_squared_error: -2.083 Time elapsed: 8.965s Fit --------------------------------------------- Train evaluation --> r2: 0.6668 neg_root_mean_squared_error: -1.8677 Test evaluation --> r2: 0.5583 neg_root_mean_squared_error: -2.1105 Time elapsed: 1.059s Bootstrap --------------------------------------- Evaluation --> r2: 0.5388 \u00b1 0.0083 neg_root_mean_squared_error: -2.1565 \u00b1 0.0192 Time elapsed: 5.925s ------------------------------------------------- Total time: 15.949s Final results ==================== >> Total time: 16.714s ------------------------------------- LinearSVM --> r2: 0.4577 \u00b1 0.002 neg_root_mean_squared_error: -2.3384 \u00b1 0.0043 HistGradientBoosting --> r2: 0.5388 \u00b1 0.0083 neg_root_mean_squared_error: -2.1565 \u00b1 0.0192 ! In [6]: Copied! # Check the robustness of the pipeline using cross-validation atom . winner . cross_validate () # Check the robustness of the pipeline using cross-validation atom.winner.cross_validate() Applying cross-validation... Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } train_r2 test_r2 train_neg_root_mean_squared_error test_neg_root_mean_squared_error time (s) 0 0.672482 0.534480 -1.841417 -2.214880 1.074976 1 0.669693 0.541603 -1.850140 -2.193359 1.078980 2 0.674650 0.525120 -1.860947 -2.111204 1.142037 3 0.661519 0.579041 -1.851866 -2.194239 1.110008 4 0.666829 0.558253 -1.867706 -2.110524 1.085987 mean 0.669035 0.547699 -1.854415 -2.164841 1.098398 std 0.004587 0.019055 0.009089 0.044741 0.024975", "title": "Run the pipeline"}, {"location": "examples/multi_metric/#analyze-the-results", "text": "In [7]: Copied! # The columns in the results dataframe contain a list of # scores, one for each metric (in the same order as called) atom . results [[ \"score_ht\" , \"score_train\" , \"score_test\" ]] # The columns in the results dataframe contain a list of # scores, one for each metric (in the same order as called) atom.results[[\"score_ht\", \"score_train\", \"score_test\"]] Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_ht score_train score_test lSVM [0.4925303455788521, -2.262753922393612] [0.4592, -2.3795] [0.4584, -2.3369] hGBM [0.5699377046439738, -2.08304173753828] [0.6668, -1.8677] [0.5583, -2.1105] In [8]: Copied! # Some plots allow us to choose the metric we want to show with atom . canvas (): atom . plot_trials ( metric = \"r2\" , title = \"Hyperparameter tuning performance for R2\" ) atom . plot_trials ( metric = \"rmse\" , title = \"Hyperparameter tuning performance for RMSE\" ) # Some plots allow us to choose the metric we want to show with atom.canvas(): atom.plot_trials(metric=\"r2\", title=\"Hyperparameter tuning performance for R2\") atom.plot_trials(metric=\"rmse\", title=\"Hyperparameter tuning performance for RMSE\")  In [9]: Copied! atom . plot_results ( metric = \"r2\" ) atom.plot_results(metric=\"r2\") ", "title": "Analyze the results"}, {"location": "examples/multiclass_classification/", "text": "Example: Multiclass classification \u00b6 This example shows how to compare the performance of three models on a multiclass classification task. Import the wine dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict wines into three groups (which cultivator it's from) using features based on the results of chemical analysis. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_wine from atom import ATOMClassifier # Import packages from sklearn.datasets import load_wine from atom import ATOMClassifier In [2]: Copied! # Load data X , y = load_wine ( return_X_y = True , as_frame = True ) # Let's have a look X . head () # Load data X, y = load_wine(return_X_y=True, as_frame=True) # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue od280/od315_of_diluted_wines proline 0 14.23 1.71 2.43 15.6 127.0 2.80 3.06 0.28 2.29 5.64 1.04 3.92 1065.0 1 13.20 1.78 2.14 11.2 100.0 2.65 2.76 0.26 1.28 4.38 1.05 3.40 1050.0 2 13.16 2.36 2.67 18.6 101.0 2.80 3.24 0.30 2.81 5.68 1.03 3.17 1185.0 3 14.37 1.95 2.50 16.8 113.0 3.85 3.49 0.24 2.18 7.80 0.86 3.45 1480.0 4 13.24 2.59 2.87 21.0 118.0 2.80 2.69 0.39 1.82 4.32 1.04 2.93 735.0 Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , y , n_jobs =- 1 , verbose = 2 , random_state = 1 ) # Fit the pipeline with the selected models atom . run ( models = [ \"LR\" , \"LDA\" , \"RF\" ], metric = \"roc_auc_ovr\" , n_trials = 14 , n_bootstrap = 5 , ) atom = ATOMClassifier(X, y, n_jobs=-1, verbose=2, random_state=1) # Fit the pipeline with the selected models atom.run( models=[\"LR\",\"LDA\", \"RF\"], metric=\"roc_auc_ovr\", n_trials=14, n_bootstrap=5, ) << ================== ATOM ================== >> Algorithm task: multiclass classification. Parallel processing with 16 cores. Dataset stats ==================== >> Shape: (178, 14) Memory: 19.35 kB Scaled: False Outlier values: 12 (0.6%) ------------------------------------- Train set size: 143 Test set size: 35 ------------------------------------- | | dataset | train | test | | - | ---------- | ---------- | ---------- | | 0 | 59 (1.2) | 47 (1.2) | 12 (1.3) | | 1 | 71 (1.5) | 57 (1.5) | 14 (1.6) | | 2 | 48 (1.0) | 39 (1.0) | 9 (1.0) | Training ========================= >> Models: LR, LDA, RF Metric: roc_auc_ovr Running hyperparameter tuning for LogisticRegression... | trial | penalty | C | solver | max_iter | l1_ratio | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht | state | | ----- | ------- | ------- | ------- | -------- | -------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | l2 | 0.0054 | saga | 480 | --- | 1.0 | 1.0 | 0.023s | 0.023s | COMPLETE | | 1 | l2 | 0.122 | saga | 380 | --- | 1.0 | 1.0 | 0.022s | 0.045s | COMPLETE | | 2 | l2 | 0.0071 | sag | 720 | --- | 1.0 | 1.0 | 0.019s | 0.064s | COMPLETE | | 3 | l2 | 87.9641 | libli.. | 920 | --- | 0.9984 | 1.0 | 0.014s | 0.078s | COMPLETE | | 4 | none | --- | sag | 630 | --- | 1.0 | 1.0 | 0.038s | 0.116s | COMPLETE | | 5 | l2 | 0.0018 | sag | 920 | --- | 1.0 | 1.0 | 0.023s | 0.139s | COMPLETE | | 6 | l2 | 43.4053 | sag | 780 | --- | 1.0 | 1.0 | 0.040s | 0.179s | COMPLETE | | 7 | l2 | 2.0759 | libli.. | 470 | --- | 1.0 | 1.0 | 0.015s | 0.194s | COMPLETE | | 8 | l2 | 0.043 | sag | 110 | --- | 1.0 | 1.0 | 0.021s | 0.215s | COMPLETE | | 9 | l2 | 46.0233 | saga | 740 | --- | 1.0 | 1.0 | 0.035s | 0.250s | COMPLETE | | 10 | l2 | 1.2173 | lbfgs | 280 | --- | 1.0 | 1.0 | 0.815s | 1.065s | COMPLETE | | 11 | l2 | 0.0983 | saga | 450 | --- | 1.0 | 1.0 | 0.030s | 1.095s | COMPLETE | | 12 | elast.. | 0.001 | saga | 330 | 0.6 | 0.5 | 1.0 | 0.027s | 1.122s | COMPLETE | | 13 | l2 | 0.4352 | newto.. | 300 | --- | 1.0 | 1.0 | 0.365s | 1.487s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 0 Best parameters: --> penalty: l2 --> C: 0.0054 --> solver: saga --> max_iter: 480 Best evaluation --> roc_auc_ovr: 1.0 Time elapsed: 1.487s Fit --------------------------------------------- Train evaluation --> roc_auc_ovr: 0.999 Test evaluation --> roc_auc_ovr: 0.9977 Time elapsed: 0.029s Bootstrap --------------------------------------- Evaluation --> roc_auc_ovr: 0.9982 \u00b1 0.0006 Time elapsed: 0.081s ------------------------------------------------- Total time: 1.597s Running hyperparameter tuning for LinearDiscriminantAnalysis... | trial | solver | shrinkage | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht | state | | ----- | ------- | --------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | lsqr | 0.9 | 0.9221 | 0.9221 | 0.010s | 0.010s | COMPLETE | | 1 | eigen | 1.0 | 0.9121 | 0.9221 | 0.006s | 0.016s | COMPLETE | | 2 | eigen | 1.0 | 0.9121 | 0.9221 | 0.001s | 0.017s | COMPLETE | | 3 | lsqr | 0.7 | 0.8638 | 0.9221 | 0.006s | 0.023s | COMPLETE | | 4 | eigen | 0.7 | 0.9019 | 0.9221 | 0.009s | 0.032s | COMPLETE | | 5 | lsqr | auto | 1.0 | 1.0 | 0.008s | 0.040s | COMPLETE | | 6 | eigen | 1.0 | 0.9121 | 1.0 | 0.001s | 0.041s | COMPLETE | | 7 | lsqr | 1.0 | 0.9445 | 1.0 | 0.006s | 0.047s | COMPLETE | | 8 | svd | --- | 1.0 | 1.0 | 0.007s | 0.054s | COMPLETE | | 9 | svd | --- | 1.0 | 1.0 | 0.001s | 0.055s | COMPLETE | | 10 | lsqr | auto | 1.0 | 1.0 | 0.002s | 0.057s | COMPLETE | | 11 | svd | --- | 1.0 | 1.0 | 0.002s | 0.059s | COMPLETE | | 12 | svd | --- | 1.0 | 1.0 | 0.002s | 0.061s | COMPLETE | | 13 | svd | --- | 1.0 | 1.0 | 0.002s | 0.063s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 5 Best parameters: --> solver: lsqr --> shrinkage: auto Best evaluation --> roc_auc_ovr: 1.0 Time elapsed: 0.063s Fit --------------------------------------------- Train evaluation --> roc_auc_ovr: 1.0 Test evaluation --> roc_auc_ovr: 1.0 Time elapsed: 0.015s Bootstrap --------------------------------------- Evaluation --> roc_auc_ovr: 0.9998 \u00b1 0.0005 Time elapsed: 0.037s ------------------------------------------------- Total time: 0.115s Running hyperparameter tuning for RandomForest... | trial | n_estimators | criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | ccp_alpha | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht | state | | ----- | ------------ | --------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | --------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | 210 | gini | 10 | 17 | 20 | 0.5 | False | --- | 0.0 | 0.9803 | 0.9803 | 0.214s | 0.214s | COMPLETE | | 1 | 380 | gini | 4 | 15 | 3 | 0.9 | False | --- | 0.01 | 0.9816 | 0.9816 | 0.390s | 0.605s | COMPLETE | | 2 | 380 | entropy | 6 | 2 | 13 | 0.9 | False | --- | 0.03 | 0.9944 | 0.9944 | 0.388s | 0.993s | COMPLETE | | 3 | 470 | gini | 11 | 9 | 18 | None | True | 0.6 | 0.025 | 0.9569 | 0.9944 | 0.583s | 1.575s | COMPLETE | | 4 | 100 | entropy | 12 | 14 | 6 | 0.9 | False | --- | 0.035 | 1.0 | 1.0 | 0.116s | 1.692s | COMPLETE | | 5 | 470 | entropy | 13 | 11 | 1 | None | True | 0.6 | 0.01 | 1.0 | 1.0 | 0.594s | 2.285s | COMPLETE | | 6 | 250 | gini | 14 | 13 | 17 | 0.7 | True | None | 0.02 | 1.0 | 1.0 | 0.325s | 2.610s | COMPLETE | | 7 | 220 | gini | 5 | 10 | 7 | 0.5 | True | 0.9 | 0.035 | 0.9981 | 1.0 | 0.295s | 2.906s | COMPLETE | | 8 | 130 | entropy | 4 | 6 | 11 | 0.9 | False | --- | 0.03 | 1.0 | 1.0 | 0.148s | 3.054s | COMPLETE | | 9 | 370 | gini | 12 | 2 | 4 | 0.5 | False | --- | 0.02 | 0.9916 | 1.0 | 0.377s | 3.431s | COMPLETE | | 10 | 10 | entropy | None | 20 | 7 | log2 | False | --- | 0.035 | 1.0 | 1.0 | 0.037s | 3.468s | COMPLETE | | 11 | 70 | entropy | 13 | 12 | 1 | None | True | 0.5 | 0.01 | 0.9928 | 1.0 | 0.116s | 3.584s | COMPLETE | | 12 | 500 | entropy | 9 | 7 | 7 | 0.6 | True | 0.6 | 0.01 | 1.0 | 1.0 | 0.642s | 4.226s | COMPLETE | | 13 | 140 | entropy | 16 | 16 | 1 | 0.8 | True | 0.5 | 0.0 | 1.0 | 1.0 | 0.190s | 4.416s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 4 Best parameters: --> n_estimators: 100 --> criterion: entropy --> max_depth: 12 --> min_samples_split: 14 --> min_samples_leaf: 6 --> max_features: 0.9 --> bootstrap: False --> ccp_alpha: 0.035 Best evaluation --> roc_auc_ovr: 1.0 Time elapsed: 4.416s Fit --------------------------------------------- Train evaluation --> roc_auc_ovr: 0.9993 Test evaluation --> roc_auc_ovr: 1.0 Time elapsed: 0.132s Bootstrap --------------------------------------- Evaluation --> roc_auc_ovr: 0.9936 \u00b1 0.0067 Time elapsed: 0.555s ------------------------------------------------- Total time: 5.103s Final results ==================== >> Total time: 7.139s ------------------------------------- LogisticRegression --> roc_auc_ovr: 0.9982 \u00b1 0.0006 LinearDiscriminantAnalysis --> roc_auc_ovr: 0.9998 \u00b1 0.0005 ! RandomForest --> roc_auc_ovr: 0.9936 \u00b1 0.0067 Analyze the results \u00b6 In [4]: Copied! atom . results atom.results Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_ht time_ht score_train score_test time_fit score_bootstrap time_bootstrap time LR 1.0 1.487354 0.9990 0.9977 0.029027 0.998186 0.081073 1.597454 LDA 1.0 0.063054 1.0000 1.0000 0.015013 0.999773 0.037034 0.115101 RF 1.0 4.416013 0.9993 1.0000 0.132121 0.993613 0.554504 5.102638 In [5]: Copied! # Show the score for some different metrics atom . evaluate ([ \"precision_macro\" , \"recall_macro\" , \"jaccard_weighted\" ]) # Show the score for some different metrics atom.evaluate([\"precision_macro\", \"recall_macro\", \"jaccard_weighted\"]) Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } precision_macro recall_macro jaccard_weighted LR 0.9429 0.9484 0.8924 LDA 0.9667 0.9762 0.9457 RF 0.8799 0.8915 0.7968 In [6]: Copied! # Some plots allow you to choose the target class to look at atom . rf . plot_probabilities ( dataset = \"train\" , target = 2 ) # Some plots allow you to choose the target class to look at atom.rf.plot_probabilities(dataset=\"train\", target=2)  In [9]: Copied! atom . lda . plot_shap_heatmap ( target = 2 , show = 7 ) atom.lda.plot_shap_heatmap(target=2, show=7)", "title": "Multiclass classification"}, {"location": "examples/multiclass_classification/#example-multiclass-classification", "text": "This example shows how to compare the performance of three models on a multiclass classification task. Import the wine dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict wines into three groups (which cultivator it's from) using features based on the results of chemical analysis.", "title": "Example: Multiclass classification"}, {"location": "examples/multiclass_classification/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_wine from atom import ATOMClassifier # Import packages from sklearn.datasets import load_wine from atom import ATOMClassifier In [2]: Copied! # Load data X , y = load_wine ( return_X_y = True , as_frame = True ) # Let's have a look X . head () # Load data X, y = load_wine(return_X_y=True, as_frame=True) # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue od280/od315_of_diluted_wines proline 0 14.23 1.71 2.43 15.6 127.0 2.80 3.06 0.28 2.29 5.64 1.04 3.92 1065.0 1 13.20 1.78 2.14 11.2 100.0 2.65 2.76 0.26 1.28 4.38 1.05 3.40 1050.0 2 13.16 2.36 2.67 18.6 101.0 2.80 3.24 0.30 2.81 5.68 1.03 3.17 1185.0 3 14.37 1.95 2.50 16.8 113.0 3.85 3.49 0.24 2.18 7.80 0.86 3.45 1480.0 4 13.24 2.59 2.87 21.0 118.0 2.80 2.69 0.39 1.82 4.32 1.04 2.93 735.0", "title": "Load the data"}, {"location": "examples/multiclass_classification/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X , y , n_jobs =- 1 , verbose = 2 , random_state = 1 ) # Fit the pipeline with the selected models atom . run ( models = [ \"LR\" , \"LDA\" , \"RF\" ], metric = \"roc_auc_ovr\" , n_trials = 14 , n_bootstrap = 5 , ) atom = ATOMClassifier(X, y, n_jobs=-1, verbose=2, random_state=1) # Fit the pipeline with the selected models atom.run( models=[\"LR\",\"LDA\", \"RF\"], metric=\"roc_auc_ovr\", n_trials=14, n_bootstrap=5, ) << ================== ATOM ================== >> Algorithm task: multiclass classification. Parallel processing with 16 cores. Dataset stats ==================== >> Shape: (178, 14) Memory: 19.35 kB Scaled: False Outlier values: 12 (0.6%) ------------------------------------- Train set size: 143 Test set size: 35 ------------------------------------- | | dataset | train | test | | - | ---------- | ---------- | ---------- | | 0 | 59 (1.2) | 47 (1.2) | 12 (1.3) | | 1 | 71 (1.5) | 57 (1.5) | 14 (1.6) | | 2 | 48 (1.0) | 39 (1.0) | 9 (1.0) | Training ========================= >> Models: LR, LDA, RF Metric: roc_auc_ovr Running hyperparameter tuning for LogisticRegression... | trial | penalty | C | solver | max_iter | l1_ratio | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht | state | | ----- | ------- | ------- | ------- | -------- | -------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | l2 | 0.0054 | saga | 480 | --- | 1.0 | 1.0 | 0.023s | 0.023s | COMPLETE | | 1 | l2 | 0.122 | saga | 380 | --- | 1.0 | 1.0 | 0.022s | 0.045s | COMPLETE | | 2 | l2 | 0.0071 | sag | 720 | --- | 1.0 | 1.0 | 0.019s | 0.064s | COMPLETE | | 3 | l2 | 87.9641 | libli.. | 920 | --- | 0.9984 | 1.0 | 0.014s | 0.078s | COMPLETE | | 4 | none | --- | sag | 630 | --- | 1.0 | 1.0 | 0.038s | 0.116s | COMPLETE | | 5 | l2 | 0.0018 | sag | 920 | --- | 1.0 | 1.0 | 0.023s | 0.139s | COMPLETE | | 6 | l2 | 43.4053 | sag | 780 | --- | 1.0 | 1.0 | 0.040s | 0.179s | COMPLETE | | 7 | l2 | 2.0759 | libli.. | 470 | --- | 1.0 | 1.0 | 0.015s | 0.194s | COMPLETE | | 8 | l2 | 0.043 | sag | 110 | --- | 1.0 | 1.0 | 0.021s | 0.215s | COMPLETE | | 9 | l2 | 46.0233 | saga | 740 | --- | 1.0 | 1.0 | 0.035s | 0.250s | COMPLETE | | 10 | l2 | 1.2173 | lbfgs | 280 | --- | 1.0 | 1.0 | 0.815s | 1.065s | COMPLETE | | 11 | l2 | 0.0983 | saga | 450 | --- | 1.0 | 1.0 | 0.030s | 1.095s | COMPLETE | | 12 | elast.. | 0.001 | saga | 330 | 0.6 | 0.5 | 1.0 | 0.027s | 1.122s | COMPLETE | | 13 | l2 | 0.4352 | newto.. | 300 | --- | 1.0 | 1.0 | 0.365s | 1.487s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 0 Best parameters: --> penalty: l2 --> C: 0.0054 --> solver: saga --> max_iter: 480 Best evaluation --> roc_auc_ovr: 1.0 Time elapsed: 1.487s Fit --------------------------------------------- Train evaluation --> roc_auc_ovr: 0.999 Test evaluation --> roc_auc_ovr: 0.9977 Time elapsed: 0.029s Bootstrap --------------------------------------- Evaluation --> roc_auc_ovr: 0.9982 \u00b1 0.0006 Time elapsed: 0.081s ------------------------------------------------- Total time: 1.597s Running hyperparameter tuning for LinearDiscriminantAnalysis... | trial | solver | shrinkage | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht | state | | ----- | ------- | --------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | lsqr | 0.9 | 0.9221 | 0.9221 | 0.010s | 0.010s | COMPLETE | | 1 | eigen | 1.0 | 0.9121 | 0.9221 | 0.006s | 0.016s | COMPLETE | | 2 | eigen | 1.0 | 0.9121 | 0.9221 | 0.001s | 0.017s | COMPLETE | | 3 | lsqr | 0.7 | 0.8638 | 0.9221 | 0.006s | 0.023s | COMPLETE | | 4 | eigen | 0.7 | 0.9019 | 0.9221 | 0.009s | 0.032s | COMPLETE | | 5 | lsqr | auto | 1.0 | 1.0 | 0.008s | 0.040s | COMPLETE | | 6 | eigen | 1.0 | 0.9121 | 1.0 | 0.001s | 0.041s | COMPLETE | | 7 | lsqr | 1.0 | 0.9445 | 1.0 | 0.006s | 0.047s | COMPLETE | | 8 | svd | --- | 1.0 | 1.0 | 0.007s | 0.054s | COMPLETE | | 9 | svd | --- | 1.0 | 1.0 | 0.001s | 0.055s | COMPLETE | | 10 | lsqr | auto | 1.0 | 1.0 | 0.002s | 0.057s | COMPLETE | | 11 | svd | --- | 1.0 | 1.0 | 0.002s | 0.059s | COMPLETE | | 12 | svd | --- | 1.0 | 1.0 | 0.002s | 0.061s | COMPLETE | | 13 | svd | --- | 1.0 | 1.0 | 0.002s | 0.063s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 5 Best parameters: --> solver: lsqr --> shrinkage: auto Best evaluation --> roc_auc_ovr: 1.0 Time elapsed: 0.063s Fit --------------------------------------------- Train evaluation --> roc_auc_ovr: 1.0 Test evaluation --> roc_auc_ovr: 1.0 Time elapsed: 0.015s Bootstrap --------------------------------------- Evaluation --> roc_auc_ovr: 0.9998 \u00b1 0.0005 Time elapsed: 0.037s ------------------------------------------------- Total time: 0.115s Running hyperparameter tuning for RandomForest... | trial | n_estimators | criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | ccp_alpha | roc_auc_ovr | best_roc_auc_ovr | time_trial | time_ht | state | | ----- | ------------ | --------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | --------- | ----------- | ---------------- | ---------- | ------- | -------- | | 0 | 210 | gini | 10 | 17 | 20 | 0.5 | False | --- | 0.0 | 0.9803 | 0.9803 | 0.214s | 0.214s | COMPLETE | | 1 | 380 | gini | 4 | 15 | 3 | 0.9 | False | --- | 0.01 | 0.9816 | 0.9816 | 0.390s | 0.605s | COMPLETE | | 2 | 380 | entropy | 6 | 2 | 13 | 0.9 | False | --- | 0.03 | 0.9944 | 0.9944 | 0.388s | 0.993s | COMPLETE | | 3 | 470 | gini | 11 | 9 | 18 | None | True | 0.6 | 0.025 | 0.9569 | 0.9944 | 0.583s | 1.575s | COMPLETE | | 4 | 100 | entropy | 12 | 14 | 6 | 0.9 | False | --- | 0.035 | 1.0 | 1.0 | 0.116s | 1.692s | COMPLETE | | 5 | 470 | entropy | 13 | 11 | 1 | None | True | 0.6 | 0.01 | 1.0 | 1.0 | 0.594s | 2.285s | COMPLETE | | 6 | 250 | gini | 14 | 13 | 17 | 0.7 | True | None | 0.02 | 1.0 | 1.0 | 0.325s | 2.610s | COMPLETE | | 7 | 220 | gini | 5 | 10 | 7 | 0.5 | True | 0.9 | 0.035 | 0.9981 | 1.0 | 0.295s | 2.906s | COMPLETE | | 8 | 130 | entropy | 4 | 6 | 11 | 0.9 | False | --- | 0.03 | 1.0 | 1.0 | 0.148s | 3.054s | COMPLETE | | 9 | 370 | gini | 12 | 2 | 4 | 0.5 | False | --- | 0.02 | 0.9916 | 1.0 | 0.377s | 3.431s | COMPLETE | | 10 | 10 | entropy | None | 20 | 7 | log2 | False | --- | 0.035 | 1.0 | 1.0 | 0.037s | 3.468s | COMPLETE | | 11 | 70 | entropy | 13 | 12 | 1 | None | True | 0.5 | 0.01 | 0.9928 | 1.0 | 0.116s | 3.584s | COMPLETE | | 12 | 500 | entropy | 9 | 7 | 7 | 0.6 | True | 0.6 | 0.01 | 1.0 | 1.0 | 0.642s | 4.226s | COMPLETE | | 13 | 140 | entropy | 16 | 16 | 1 | 0.8 | True | 0.5 | 0.0 | 1.0 | 1.0 | 0.190s | 4.416s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 4 Best parameters: --> n_estimators: 100 --> criterion: entropy --> max_depth: 12 --> min_samples_split: 14 --> min_samples_leaf: 6 --> max_features: 0.9 --> bootstrap: False --> ccp_alpha: 0.035 Best evaluation --> roc_auc_ovr: 1.0 Time elapsed: 4.416s Fit --------------------------------------------- Train evaluation --> roc_auc_ovr: 0.9993 Test evaluation --> roc_auc_ovr: 1.0 Time elapsed: 0.132s Bootstrap --------------------------------------- Evaluation --> roc_auc_ovr: 0.9936 \u00b1 0.0067 Time elapsed: 0.555s ------------------------------------------------- Total time: 5.103s Final results ==================== >> Total time: 7.139s ------------------------------------- LogisticRegression --> roc_auc_ovr: 0.9982 \u00b1 0.0006 LinearDiscriminantAnalysis --> roc_auc_ovr: 0.9998 \u00b1 0.0005 ! RandomForest --> roc_auc_ovr: 0.9936 \u00b1 0.0067", "title": "Run the pipeline"}, {"location": "examples/multiclass_classification/#analyze-the-results", "text": "In [4]: Copied! atom . results atom.results Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_ht time_ht score_train score_test time_fit score_bootstrap time_bootstrap time LR 1.0 1.487354 0.9990 0.9977 0.029027 0.998186 0.081073 1.597454 LDA 1.0 0.063054 1.0000 1.0000 0.015013 0.999773 0.037034 0.115101 RF 1.0 4.416013 0.9993 1.0000 0.132121 0.993613 0.554504 5.102638 In [5]: Copied! # Show the score for some different metrics atom . evaluate ([ \"precision_macro\" , \"recall_macro\" , \"jaccard_weighted\" ]) # Show the score for some different metrics atom.evaluate([\"precision_macro\", \"recall_macro\", \"jaccard_weighted\"]) Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } precision_macro recall_macro jaccard_weighted LR 0.9429 0.9484 0.8924 LDA 0.9667 0.9762 0.9457 RF 0.8799 0.8915 0.7968 In [6]: Copied! # Some plots allow you to choose the target class to look at atom . rf . plot_probabilities ( dataset = \"train\" , target = 2 ) # Some plots allow you to choose the target class to look at atom.rf.plot_probabilities(dataset=\"train\", target=2)  In [9]: Copied! atom . lda . plot_shap_heatmap ( target = 2 , show = 7 ) atom.lda.plot_shap_heatmap(target=2, show=7)", "title": "Analyze the results"}, {"location": "examples/nlp/", "text": "Example: NLP \u00b6 This example shows how to use ATOM to quickly go from raw text data to model predictions. Import the 20 newsgroups text dataset from sklearn.datasets . The dataset comprises around 18000 articles on 20 topics. The goal is to predict the topic of every article. Load the data \u00b6 In [1]: Copied! import numpy as np from atom import ATOMClassifier from sklearn.datasets import fetch_20newsgroups import numpy as np from atom import ATOMClassifier from sklearn.datasets import fetch_20newsgroups In [2]: Copied! # Use only a subset of the available topics for faster processing X_text , y_text = fetch_20newsgroups ( return_X_y = True , categories = [ 'sci.med' , 'comp.windows.x' , 'misc.forsale' , 'rec.autos' , ], shuffle = True , random_state = 1 , ) X_text = np . array ( X_text ) . reshape ( - 1 , 1 ) # Use only a subset of the available topics for faster processing X_text, y_text = fetch_20newsgroups( return_X_y=True, categories=[ 'sci.med', 'comp.windows.x', 'misc.forsale', 'rec.autos', ], shuffle=True, random_state=1, ) X_text = np.array(X_text).reshape(-1, 1) Run the pipeline \u00b6 In [3]: Copied! atom = ATOMClassifier ( X_text , y_text , index = True , test_size = 0.3 , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(X_text, y_text, index=True, test_size=0.3, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: multiclass classification. Dataset stats ==================== >> Shape: (2366, 2) Memory: 4.07 MB Scaled: False Categorical features: 1 (100.0%) ------------------------------------- Train set size: 1657 Test set size: 709 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 593 (1.0) | 415 (1.0) | 178 (1.0) | | 1 | 585 (1.0) | 410 (1.0) | 175 (1.0) | | 2 | 594 (1.0) | 416 (1.0) | 178 (1.0) | | 3 | 594 (1.0) | 416 (1.0) | 178 (1.0) | In [4]: Copied! atom . dataset # Note that the feature is automatically named 'corpus' atom.dataset # Note that the feature is automatically named 'corpus' Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } corpus target 1731 From: rlm@helen.surfcty.com (Robert L. McMilli... 0 1496 From: carl@SOL1.GPS.CALTECH.EDU (Carl J Lydick... 3 1290 From: thssjxy@iitmax.iit.edu (Smile)\\nSubject:... 1 2021 From: c23st@kocrsv01.delcoelect.com (Spiros Tr... 2 142 From: ginkgo@ecsvax.uncecs.edu (J. Geary Morto... 1 ... ... ... 510 From: mary@uicsl.csl.uiuc.edu (Mary E. Allison... 3 1948 From: ndd@sunbar.mc.duke.edu (Ned Danieley)\\nS... 0 798 From: kk@unisql.UUCP (Kerry Kimbrough)\\nSubjec... 0 2222 From: hamachi@adobe.com (Gordon Hamachi)\\nSubj... 2 2215 From: mobasser@vu-vlsi.ee.vill.edu (Bijan Moba... 2 2366 rows \u00d7 2 columns In [5]: Copied! # Let's have a look at the first document atom . corpus [ 0 ] # Let's have a look at the first document atom.corpus[0] Out[5]: 'From: caf@omen.UUCP (Chuck Forsberg WA7KGX)\\nSubject: Re: My New Diet --> IT WORKS GREAT !!!!\\nOrganization: Omen Technology INC, Portland Rain Forest\\nLines: 32\\n\\nIn article <1qk6v3INNrm6@lynx.unm.edu> bhjelle@carina.unm.edu () writes:\\n>\\n>Gordon Banks:\\n>\\n>>a lot to keep from going back to morbid obesity. I think all\\n>>of us cycle. One\\'s success depends on how large the fluctuations\\n>>in the cycle are. Some people can cycle only 5 pounds. Unfortunately,\\n>>I\\'m not one of them.\\n>>\\n>>\\n>This certainly describes my situation perfectly. For me there is\\n>a constant dynamic between my tendency to eat, which appears to\\n>be totally limitless, and the purely conscious desire to not\\n>put on too much weight. When I get too fat, I just diet/exercise\\n>more (with varying degrees of success) to take off the\\n>extra weight. Usually I cycle within a 15 lb range, but\\n>smaller and larger cycles occur as well. I\\'m always afraid\\n>that this method will stop working someday, but usually\\n>I seem to be able to hold the weight gain in check.\\n>This is one reason I have a hard time accepting the notion\\n>of some metabolic derangement associated with cycle dieting\\n>(that results in long-term weight gain). I have been cycle-\\n>dieting for at least 20 years without seeing such a change.\\n\\nAs mentioned in Adiposity 101, only some experience weight\\nrebound. The fact that you don\\'t doesn\\'t prove it doesn\\'t\\nhappen to others.\\n-- \\nChuck Forsberg WA7KGX ...!tektronix!reed!omen!caf \\nAuthor of YMODEM, ZMODEM, Professional-YAM, ZCOMM, and DSZ\\n Omen Technology Inc \"The High Reliability Software\"\\n17505-V NW Sauvie IS RD Portland OR 97231 503-621-3406\\n' In [6]: Copied! # Clean the documents from noise (emails, numbers, etc...) atom . textclean () # Clean the documents from noise (emails, numbers, etc...) atom.textclean() Fitting TextCleaner... Cleaning the corpus... --> Decoding unicode characters to ascii. --> Converting text to lower case. --> Dropping 8115 emails from 2352 documents. --> Dropping 0 URL links from 0 documents. --> Dropping 1619 HTML tags from 964 documents. --> Dropping 2 emojis from 1 documents. --> Dropping 29292 numbers from 2363 documents. --> Dropping punctuation from the text. In [7]: Copied! # Have a look at the removed items atom . drops # Have a look at the removed items atom.drops Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } email url html emoji number 1731 [rlm@helen.surfcty.com, rlm@helen.surfcty.com] NaN [<std.disclaimer.h>] NaN [8] 1496 [carl@sol1.gps.caltech.edu, carl@sol1.gps.calt... NaN [<>] NaN [28] 1290 [thssjxy@iitmax.iit.edu, thssjxy@iitmax.acc.ii... NaN NaN NaN [223158, 15645, 14, 80, 150] 2021 [c23st@kocrsv01.delcoelect.com, c4wjgq.a40@con... NaN [<>] NaN [10, 21, 6, 317, 451, 0815, 46904] 142 [ginkgo@ecsvax.uncecs.edu, ginkgo@uncecs.edu] NaN [<>] NaN [95, 17, 95, 95, 95, 100, 00, 919, 851, 6565, ... ... ... ... ... ... ... 403 NaN NaN NaN NaN [223, 250, 10, 8, 8, 2002, 1600] 1634 NaN NaN NaN NaN [15, 1, 1] 1262 NaN NaN NaN NaN [38, 84] 1360 NaN NaN NaN NaN [27, 15, 27, 225, 250, 412, 624, 6115, 371, 0154] 211 NaN NaN NaN NaN [13, 93, 212, 274, 0646, 1097, 08836, 908, 563... 2366 rows \u00d7 5 columns In [8]: Copied! # Check how the first document changed atom . corpus [ 0 ] # Check how the first document changed atom.corpus[0] Out[8]: 'from chuck forsberg wa7kgx\\nsubject re my new diet it works great \\norganization omen technology inc portland rain forest\\nlines \\n\\nin article writes\\n\\ngordon banks\\n\\na lot to keep from going back to morbid obesity i think all\\nof us cycle ones success depends on how large the fluctuations\\nin the cycle are some people can cycle only pounds unfortunately\\nim not one of them\\n\\n\\nthis certainly describes my situation perfectly for me there is\\na constant dynamic between my tendency to eat which appears to\\nbe totally limitless and the purely conscious desire to not\\nput on too much weight when i get too fat i just dietexercise\\nmore with varying degrees of success to take off the\\nextra weight usually i cycle within a lb range but\\nsmaller and larger cycles occur as well im always afraid\\nthat this method will stop working someday but usually\\ni seem to be able to hold the weight gain in check\\nthis is one reason i have a hard time accepting the notion\\nof some metabolic derangement associated with cycle dieting\\nthat results in longterm weight gain i have been cycle\\ndieting for at least years without seeing such a change\\n\\nas mentioned in adiposity only some experience weight\\nrebound the fact that you dont doesnt prove it doesnt\\nhappen to others\\n \\nchuck forsberg wa7kgx tektronixreedomencaf \\nauthor of ymodem zmodem professionalyam zcomm and dsz\\n omen technology inc the high reliability software\\nv nw sauvie is rd portland or \\n' In [9]: Copied! # Convert the strings to a sequence of words atom . tokenize () # Convert the strings to a sequence of words atom.tokenize() Fitting Tokenizer... Tokenizing the corpus... In [10]: Copied! # Print the first few words of the first document atom . corpus [ 0 ][: 7 ] # Print the first few words of the first document atom.corpus[0][:7] Out[10]: ['from', 'chuck', 'forsberg', 'wa7kgx', 'subject', 're', 'my'] In [11]: Copied! # Normalize the text to a predefined standard atom . textnormalize ( stopwords = \"english\" , lemmatize = True ) # Normalize the text to a predefined standard atom.textnormalize(stopwords=\"english\", lemmatize=True) Fitting TextNormalizer... Normalizing the corpus... --> Dropping stopwords. --> Applying lemmatization. In [12]: Copied! atom . corpus [ 0 ][: 7 ] # Check changes... atom.corpus[0][:7] # Check changes... Out[12]: ['chuck', 'forsberg', 'wa7kgx', 'subject', 'new', 'diet', 'work'] In [13]: Copied! # Visualize the most common words with a wordcloud atom . plot_wordcloud ( figsize = ( 700 , 500 )) # Visualize the most common words with a wordcloud atom.plot_wordcloud(figsize=(700, 500))  In [14]: Copied! # Have a look at the most frequent bigrams atom . plot_ngrams ( 2 ) # Have a look at the most frequent bigrams atom.plot_ngrams(2)  In [15]: Copied! # Create the bigrams using the tokenizer atom . tokenize ( bigram_freq = 215 ) # Create the bigrams using the tokenizer atom.tokenize(bigram_freq=215) Fitting Tokenizer... Tokenizing the corpus... --> Creating 7 bigrams on 3125 locations. In [16]: Copied! atom . bigrams atom.bigrams Out[16]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } bigram frequency 0 x_x 1169 1 line_article 531 2 line_nntppostinghost 386 3 organization_university 331 4 gordon_bank 266 5 distribution_usa 227 6 line_distribution 215 In [17]: Copied! # As a last step before modelling, convert the words to vectors atom . vectorize ( strategy = \"tfidf\" ) # As a last step before modelling, convert the words to vectors atom.vectorize(strategy=\"tfidf\") Fitting Vectorizer... Vectorizing the corpus... In [18]: Copied! # The dimensionality of the dataset has increased a lot! atom . shape # The dimensionality of the dataset has increased a lot! atom.shape Out[18]: (2366, 24344) In [19]: Copied! # Note that the data is sparse and the columns are named # after the words they are embedding atom . dtypes # Note that the data is sparse and the columns are named # after the words they are embedding atom.dtypes Out[19]: corpus_00 Sparse[float64, 0] corpus_000 Sparse[float64, 0] corpus_000000e5 Sparse[float64, 0] corpus_00000ee5 Sparse[float64, 0] corpus_000010af Sparse[float64, 0] ... corpus_zurich Sparse[float64, 0] corpus_zvi Sparse[float64, 0] corpus_zx Sparse[float64, 0] corpus_zz Sparse[float64, 0] target int64 Length: 24344, dtype: object In [20]: Copied! # When the dataset is sparse, stats() shows the density atom . stats () # When the dataset is sparse, stats() shows the density atom.stats() Dataset stats ==================== >> Shape: (2366, 24344) Memory: 2.54 MB Sparse: True Density: 0.35% ------------------------------------- Train set size: 1657 Test set size: 709 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 593 (1.0) | 415 (1.0) | 178 (1.0) | | 1 | 585 (1.0) | 410 (1.0) | 175 (1.0) | | 2 | 594 (1.0) | 416 (1.0) | 178 (1.0) | | 3 | 594 (1.0) | 416 (1.0) | 178 (1.0) | In [21]: Copied! # Check which models have support for sparse matrices atom . available_models ()[[ \"acronym\" , \"model\" , \"accepts_sparse\" ]] # Check which models have support for sparse matrices atom.available_models()[[\"acronym\", \"model\", \"accepts_sparse\"]] Out[21]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model accepts_sparse 0 AdaB AdaBoost True 1 Bag Bagging True 2 BNB BernoulliNB True 3 CatB CatBoost True 4 CatNB CategoricalNB True 5 CNB ComplementNB True 6 Tree DecisionTree True 7 Dummy Dummy False 8 ETree ExtraTree True 9 ET ExtraTrees True 10 GNB GaussianNB False 11 GP GaussianProcess False 12 GBM GradientBoosting True 13 hGBM HistGradientBoosting False 14 KNN KNearestNeighbors True 15 LGB LightGBM True 16 LDA LinearDiscriminantAnalysis False 17 lSVM LinearSVM True 18 LR LogisticRegression True 19 MLP MultiLayerPerceptron True 20 MNB MultinomialNB True 21 PA PassiveAggressive True 22 Perc Perceptron False 23 QDA QuadraticDiscriminantAnalysis False 24 RNN RadiusNearestNeighbors True 25 RF RandomForest True 26 Ridge Ridge True 27 SGD StochasticGradientDescent True 28 SVM SupportVectorMachine True 29 XGB XGBoost True In [22]: Copied! # Train the model atom . run ( models = \"RF\" , metric = \"f1_weighted\" ) # Train the model atom.run(models=\"RF\", metric=\"f1_weighted\") Training ========================= >> Models: RF Metric: f1_weighted Results for RandomForest: Fit --------------------------------------------- Train evaluation --> f1_weighted: 1.0 Test evaluation --> f1_weighted: 0.9237 Time elapsed: 30.365s ------------------------------------------------- Total time: 30.365s Final results ==================== >> Total time: 30.365s ------------------------------------- RandomForest --> f1_weighted: 0.9237 Analyze the results \u00b6 In [23]: Copied! atom . evaluate () atom.evaluate() Out[23]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } balanced_accuracy f1_weighted jaccard_weighted matthews_corrcoef precision_weighted recall_weighted RF 0.9239 0.9237 0.8583 0.8994 0.9266 0.9238 In [24]: Copied! atom . plot_confusion_matrix ( figsize = ( 700 , 600 )) atom.plot_confusion_matrix(figsize=(700, 600))  In [25]: Copied! atom . plot_shap_decision ( index = 0 , show = 15 ) atom.plot_shap_decision(index=0, show=15) In [26]: Copied! atom . plot_shap_beeswarm ( target = 0 , show = 15 ) atom.plot_shap_beeswarm(target=0, show=15) 100%|===================| 2822/2836 [02:39<00:00]", "title": "NLP"}, {"location": "examples/nlp/#example-nlp", "text": "This example shows how to use ATOM to quickly go from raw text data to model predictions. Import the 20 newsgroups text dataset from sklearn.datasets . The dataset comprises around 18000 articles on 20 topics. The goal is to predict the topic of every article.", "title": "Example: NLP"}, {"location": "examples/nlp/#load-the-data", "text": "In [1]: Copied! import numpy as np from atom import ATOMClassifier from sklearn.datasets import fetch_20newsgroups import numpy as np from atom import ATOMClassifier from sklearn.datasets import fetch_20newsgroups In [2]: Copied! # Use only a subset of the available topics for faster processing X_text , y_text = fetch_20newsgroups ( return_X_y = True , categories = [ 'sci.med' , 'comp.windows.x' , 'misc.forsale' , 'rec.autos' , ], shuffle = True , random_state = 1 , ) X_text = np . array ( X_text ) . reshape ( - 1 , 1 ) # Use only a subset of the available topics for faster processing X_text, y_text = fetch_20newsgroups( return_X_y=True, categories=[ 'sci.med', 'comp.windows.x', 'misc.forsale', 'rec.autos', ], shuffle=True, random_state=1, ) X_text = np.array(X_text).reshape(-1, 1)", "title": "Load the data"}, {"location": "examples/nlp/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMClassifier ( X_text , y_text , index = True , test_size = 0.3 , verbose = 2 , random_state = 1 ) atom = ATOMClassifier(X_text, y_text, index=True, test_size=0.3, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: multiclass classification. Dataset stats ==================== >> Shape: (2366, 2) Memory: 4.07 MB Scaled: False Categorical features: 1 (100.0%) ------------------------------------- Train set size: 1657 Test set size: 709 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 593 (1.0) | 415 (1.0) | 178 (1.0) | | 1 | 585 (1.0) | 410 (1.0) | 175 (1.0) | | 2 | 594 (1.0) | 416 (1.0) | 178 (1.0) | | 3 | 594 (1.0) | 416 (1.0) | 178 (1.0) | In [4]: Copied! atom . dataset # Note that the feature is automatically named 'corpus' atom.dataset # Note that the feature is automatically named 'corpus' Out[4]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } corpus target 1731 From: rlm@helen.surfcty.com (Robert L. McMilli... 0 1496 From: carl@SOL1.GPS.CALTECH.EDU (Carl J Lydick... 3 1290 From: thssjxy@iitmax.iit.edu (Smile)\\nSubject:... 1 2021 From: c23st@kocrsv01.delcoelect.com (Spiros Tr... 2 142 From: ginkgo@ecsvax.uncecs.edu (J. Geary Morto... 1 ... ... ... 510 From: mary@uicsl.csl.uiuc.edu (Mary E. Allison... 3 1948 From: ndd@sunbar.mc.duke.edu (Ned Danieley)\\nS... 0 798 From: kk@unisql.UUCP (Kerry Kimbrough)\\nSubjec... 0 2222 From: hamachi@adobe.com (Gordon Hamachi)\\nSubj... 2 2215 From: mobasser@vu-vlsi.ee.vill.edu (Bijan Moba... 2 2366 rows \u00d7 2 columns In [5]: Copied! # Let's have a look at the first document atom . corpus [ 0 ] # Let's have a look at the first document atom.corpus[0] Out[5]: 'From: caf@omen.UUCP (Chuck Forsberg WA7KGX)\\nSubject: Re: My New Diet --> IT WORKS GREAT !!!!\\nOrganization: Omen Technology INC, Portland Rain Forest\\nLines: 32\\n\\nIn article <1qk6v3INNrm6@lynx.unm.edu> bhjelle@carina.unm.edu () writes:\\n>\\n>Gordon Banks:\\n>\\n>>a lot to keep from going back to morbid obesity. I think all\\n>>of us cycle. One\\'s success depends on how large the fluctuations\\n>>in the cycle are. Some people can cycle only 5 pounds. Unfortunately,\\n>>I\\'m not one of them.\\n>>\\n>>\\n>This certainly describes my situation perfectly. For me there is\\n>a constant dynamic between my tendency to eat, which appears to\\n>be totally limitless, and the purely conscious desire to not\\n>put on too much weight. When I get too fat, I just diet/exercise\\n>more (with varying degrees of success) to take off the\\n>extra weight. Usually I cycle within a 15 lb range, but\\n>smaller and larger cycles occur as well. I\\'m always afraid\\n>that this method will stop working someday, but usually\\n>I seem to be able to hold the weight gain in check.\\n>This is one reason I have a hard time accepting the notion\\n>of some metabolic derangement associated with cycle dieting\\n>(that results in long-term weight gain). I have been cycle-\\n>dieting for at least 20 years without seeing such a change.\\n\\nAs mentioned in Adiposity 101, only some experience weight\\nrebound. The fact that you don\\'t doesn\\'t prove it doesn\\'t\\nhappen to others.\\n-- \\nChuck Forsberg WA7KGX ...!tektronix!reed!omen!caf \\nAuthor of YMODEM, ZMODEM, Professional-YAM, ZCOMM, and DSZ\\n Omen Technology Inc \"The High Reliability Software\"\\n17505-V NW Sauvie IS RD Portland OR 97231 503-621-3406\\n' In [6]: Copied! # Clean the documents from noise (emails, numbers, etc...) atom . textclean () # Clean the documents from noise (emails, numbers, etc...) atom.textclean() Fitting TextCleaner... Cleaning the corpus... --> Decoding unicode characters to ascii. --> Converting text to lower case. --> Dropping 8115 emails from 2352 documents. --> Dropping 0 URL links from 0 documents. --> Dropping 1619 HTML tags from 964 documents. --> Dropping 2 emojis from 1 documents. --> Dropping 29292 numbers from 2363 documents. --> Dropping punctuation from the text. In [7]: Copied! # Have a look at the removed items atom . drops # Have a look at the removed items atom.drops Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } email url html emoji number 1731 [rlm@helen.surfcty.com, rlm@helen.surfcty.com] NaN [<std.disclaimer.h>] NaN [8] 1496 [carl@sol1.gps.caltech.edu, carl@sol1.gps.calt... NaN [<>] NaN [28] 1290 [thssjxy@iitmax.iit.edu, thssjxy@iitmax.acc.ii... NaN NaN NaN [223158, 15645, 14, 80, 150] 2021 [c23st@kocrsv01.delcoelect.com, c4wjgq.a40@con... NaN [<>] NaN [10, 21, 6, 317, 451, 0815, 46904] 142 [ginkgo@ecsvax.uncecs.edu, ginkgo@uncecs.edu] NaN [<>] NaN [95, 17, 95, 95, 95, 100, 00, 919, 851, 6565, ... ... ... ... ... ... ... 403 NaN NaN NaN NaN [223, 250, 10, 8, 8, 2002, 1600] 1634 NaN NaN NaN NaN [15, 1, 1] 1262 NaN NaN NaN NaN [38, 84] 1360 NaN NaN NaN NaN [27, 15, 27, 225, 250, 412, 624, 6115, 371, 0154] 211 NaN NaN NaN NaN [13, 93, 212, 274, 0646, 1097, 08836, 908, 563... 2366 rows \u00d7 5 columns In [8]: Copied! # Check how the first document changed atom . corpus [ 0 ] # Check how the first document changed atom.corpus[0] Out[8]: 'from chuck forsberg wa7kgx\\nsubject re my new diet it works great \\norganization omen technology inc portland rain forest\\nlines \\n\\nin article writes\\n\\ngordon banks\\n\\na lot to keep from going back to morbid obesity i think all\\nof us cycle ones success depends on how large the fluctuations\\nin the cycle are some people can cycle only pounds unfortunately\\nim not one of them\\n\\n\\nthis certainly describes my situation perfectly for me there is\\na constant dynamic between my tendency to eat which appears to\\nbe totally limitless and the purely conscious desire to not\\nput on too much weight when i get too fat i just dietexercise\\nmore with varying degrees of success to take off the\\nextra weight usually i cycle within a lb range but\\nsmaller and larger cycles occur as well im always afraid\\nthat this method will stop working someday but usually\\ni seem to be able to hold the weight gain in check\\nthis is one reason i have a hard time accepting the notion\\nof some metabolic derangement associated with cycle dieting\\nthat results in longterm weight gain i have been cycle\\ndieting for at least years without seeing such a change\\n\\nas mentioned in adiposity only some experience weight\\nrebound the fact that you dont doesnt prove it doesnt\\nhappen to others\\n \\nchuck forsberg wa7kgx tektronixreedomencaf \\nauthor of ymodem zmodem professionalyam zcomm and dsz\\n omen technology inc the high reliability software\\nv nw sauvie is rd portland or \\n' In [9]: Copied! # Convert the strings to a sequence of words atom . tokenize () # Convert the strings to a sequence of words atom.tokenize() Fitting Tokenizer... Tokenizing the corpus... In [10]: Copied! # Print the first few words of the first document atom . corpus [ 0 ][: 7 ] # Print the first few words of the first document atom.corpus[0][:7] Out[10]: ['from', 'chuck', 'forsberg', 'wa7kgx', 'subject', 're', 'my'] In [11]: Copied! # Normalize the text to a predefined standard atom . textnormalize ( stopwords = \"english\" , lemmatize = True ) # Normalize the text to a predefined standard atom.textnormalize(stopwords=\"english\", lemmatize=True) Fitting TextNormalizer... Normalizing the corpus... --> Dropping stopwords. --> Applying lemmatization. In [12]: Copied! atom . corpus [ 0 ][: 7 ] # Check changes... atom.corpus[0][:7] # Check changes... Out[12]: ['chuck', 'forsberg', 'wa7kgx', 'subject', 'new', 'diet', 'work'] In [13]: Copied! # Visualize the most common words with a wordcloud atom . plot_wordcloud ( figsize = ( 700 , 500 )) # Visualize the most common words with a wordcloud atom.plot_wordcloud(figsize=(700, 500))  In [14]: Copied! # Have a look at the most frequent bigrams atom . plot_ngrams ( 2 ) # Have a look at the most frequent bigrams atom.plot_ngrams(2)  In [15]: Copied! # Create the bigrams using the tokenizer atom . tokenize ( bigram_freq = 215 ) # Create the bigrams using the tokenizer atom.tokenize(bigram_freq=215) Fitting Tokenizer... Tokenizing the corpus... --> Creating 7 bigrams on 3125 locations. In [16]: Copied! atom . bigrams atom.bigrams Out[16]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } bigram frequency 0 x_x 1169 1 line_article 531 2 line_nntppostinghost 386 3 organization_university 331 4 gordon_bank 266 5 distribution_usa 227 6 line_distribution 215 In [17]: Copied! # As a last step before modelling, convert the words to vectors atom . vectorize ( strategy = \"tfidf\" ) # As a last step before modelling, convert the words to vectors atom.vectorize(strategy=\"tfidf\") Fitting Vectorizer... Vectorizing the corpus... In [18]: Copied! # The dimensionality of the dataset has increased a lot! atom . shape # The dimensionality of the dataset has increased a lot! atom.shape Out[18]: (2366, 24344) In [19]: Copied! # Note that the data is sparse and the columns are named # after the words they are embedding atom . dtypes # Note that the data is sparse and the columns are named # after the words they are embedding atom.dtypes Out[19]: corpus_00 Sparse[float64, 0] corpus_000 Sparse[float64, 0] corpus_000000e5 Sparse[float64, 0] corpus_00000ee5 Sparse[float64, 0] corpus_000010af Sparse[float64, 0] ... corpus_zurich Sparse[float64, 0] corpus_zvi Sparse[float64, 0] corpus_zx Sparse[float64, 0] corpus_zz Sparse[float64, 0] target int64 Length: 24344, dtype: object In [20]: Copied! # When the dataset is sparse, stats() shows the density atom . stats () # When the dataset is sparse, stats() shows the density atom.stats() Dataset stats ==================== >> Shape: (2366, 24344) Memory: 2.54 MB Sparse: True Density: 0.35% ------------------------------------- Train set size: 1657 Test set size: 709 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 593 (1.0) | 415 (1.0) | 178 (1.0) | | 1 | 585 (1.0) | 410 (1.0) | 175 (1.0) | | 2 | 594 (1.0) | 416 (1.0) | 178 (1.0) | | 3 | 594 (1.0) | 416 (1.0) | 178 (1.0) | In [21]: Copied! # Check which models have support for sparse matrices atom . available_models ()[[ \"acronym\" , \"model\" , \"accepts_sparse\" ]] # Check which models have support for sparse matrices atom.available_models()[[\"acronym\", \"model\", \"accepts_sparse\"]] Out[21]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model accepts_sparse 0 AdaB AdaBoost True 1 Bag Bagging True 2 BNB BernoulliNB True 3 CatB CatBoost True 4 CatNB CategoricalNB True 5 CNB ComplementNB True 6 Tree DecisionTree True 7 Dummy Dummy False 8 ETree ExtraTree True 9 ET ExtraTrees True 10 GNB GaussianNB False 11 GP GaussianProcess False 12 GBM GradientBoosting True 13 hGBM HistGradientBoosting False 14 KNN KNearestNeighbors True 15 LGB LightGBM True 16 LDA LinearDiscriminantAnalysis False 17 lSVM LinearSVM True 18 LR LogisticRegression True 19 MLP MultiLayerPerceptron True 20 MNB MultinomialNB True 21 PA PassiveAggressive True 22 Perc Perceptron False 23 QDA QuadraticDiscriminantAnalysis False 24 RNN RadiusNearestNeighbors True 25 RF RandomForest True 26 Ridge Ridge True 27 SGD StochasticGradientDescent True 28 SVM SupportVectorMachine True 29 XGB XGBoost True In [22]: Copied! # Train the model atom . run ( models = \"RF\" , metric = \"f1_weighted\" ) # Train the model atom.run(models=\"RF\", metric=\"f1_weighted\") Training ========================= >> Models: RF Metric: f1_weighted Results for RandomForest: Fit --------------------------------------------- Train evaluation --> f1_weighted: 1.0 Test evaluation --> f1_weighted: 0.9237 Time elapsed: 30.365s ------------------------------------------------- Total time: 30.365s Final results ==================== >> Total time: 30.365s ------------------------------------- RandomForest --> f1_weighted: 0.9237", "title": "Run the pipeline"}, {"location": "examples/nlp/#analyze-the-results", "text": "In [23]: Copied! atom . evaluate () atom.evaluate() Out[23]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } balanced_accuracy f1_weighted jaccard_weighted matthews_corrcoef precision_weighted recall_weighted RF 0.9239 0.9237 0.8583 0.8994 0.9266 0.9238 In [24]: Copied! atom . plot_confusion_matrix ( figsize = ( 700 , 600 )) atom.plot_confusion_matrix(figsize=(700, 600))  In [25]: Copied! atom . plot_shap_decision ( index = 0 , show = 15 ) atom.plot_shap_decision(index=0, show=15) In [26]: Copied! atom . plot_shap_beeswarm ( target = 0 , show = 15 ) atom.plot_shap_beeswarm(target=0, show=15) 100%|===================| 2822/2836 [02:39<00:00]", "title": "Analyze the results"}, {"location": "examples/pruning/", "text": "Example: Pruning \u00b6 This example shows an advanced example on how to use hyperparameter tuning with pruning. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not. Load the data \u00b6 In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from optuna.pruners import HyperbandPruner from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from optuna.pruners import HyperbandPruner from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True) Run the pipeline \u00b6 In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Use ht_params to specify a custom pruner # Note that pruned trials show the number of iterations it completed atom . run ( models = \"SGD\" , metric = \"f1\" , n_trials = 25 , ht_params = { \"distributions\" : [ \"penalty\" , \"max_iter\" ], \"pruner\" : HyperbandPruner (), } ) # Use ht_params to specify a custom pruner # Note that pruned trials show the number of iterations it completed atom.run( models=\"SGD\", metric=\"f1\", n_trials=25, ht_params={ \"distributions\": [\"penalty\", \"max_iter\"], \"pruner\": HyperbandPruner(), } ) Training ========================= >> Models: SGD Metric: f1 Running hyperparameter tuning for StochasticGradientDescent... | trial | penalty | max_iter | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------- | -------- | ------- | ------- | ---------- | ------- | -------- | | 0 | l1 | 650 | 0.9735 | 0.9735 | 2.288s | 2.288s | COMPLETE | | 1 | elast.. | 1050 | 0.9739 | 0.9739 | 3.783s | 6.072s | COMPLETE | | 2 | elast.. | 500 | 0.9558 | 0.9739 | 1.788s | 7.859s | COMPLETE | | 3 | none | 700 | 0.9825 | 0.9825 | 2.370s | 10.229s | COMPLETE | | 4 | l1 | 3/1400 | 0.9821 | 0.9825 | 0.032s | 10.261s | PRUNED | | 5 | none | 9/1400 | 0.9821 | 0.9825 | 0.046s | 10.307s | PRUNED | | 6 | l2 | 3/1200 | 0.9825 | 0.9825 | 0.025s | 10.332s | PRUNED | | 7 | l2 | 1/1250 | 0.9358 | 0.9825 | 0.019s | 10.351s | PRUNED | | 8 | none | 1/600 | 0.9912 | 0.9912 | 0.023s | 10.374s | PRUNED | | 9 | l1 | 9/600 | 0.9381 | 0.9912 | 0.048s | 10.422s | PRUNED | | 10 | l1 | 3/1000 | 0.9828 | 0.9912 | 0.029s | 10.451s | PRUNED | | 11 | elast.. | 1/1200 | 0.955 | 0.9912 | 0.021s | 10.473s | PRUNED | | 12 | l2 | 1/550 | 0.9541 | 0.9912 | 0.021s | 10.494s | PRUNED | | 13 | elast.. | 1/1100 | 0.9636 | 0.9912 | 0.020s | 10.514s | PRUNED | | 14 | none | 9/900 | 0.9565 | 0.9912 | 0.047s | 10.561s | PRUNED | | 15 | l1 | 1/850 | 0.9735 | 0.9912 | 0.023s | 10.584s | PRUNED | | 16 | elast.. | 1/750 | 0.9298 | 0.9912 | 0.022s | 10.606s | PRUNED | | 17 | l1 | 1250 | 0.9912 | 0.9912 | 4.543s | 15.149s | COMPLETE | | 18 | none | 700 | 0.9825 | 0.9912 | 0.004s | 15.153s | COMPLETE | | 19 | none | 3/750 | 0.9739 | 0.9912 | 0.025s | 15.178s | PRUNED | | 20 | none | 1/750 | 0.9492 | 0.9912 | 0.024s | 15.202s | PRUNED | | 21 | l2 | 1150 | 0.9828 | 0.9912 | 4.169s | 19.371s | COMPLETE | | 22 | none | 1/850 | 0.9643 | 0.9912 | 0.024s | 19.395s | PRUNED | | 23 | l1 | 3/900 | 0.9649 | 0.9912 | 0.029s | 19.424s | PRUNED | | 24 | l1 | 650 | 0.9735 | 0.9912 | 0.005s | 19.429s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 17 Best parameters: --> penalty: l1 --> max_iter: 1250 Best evaluation --> f1: 0.9912 Time elapsed: 19.429s Fit --------------------------------------------- Train evaluation --> f1: 0.9983 Test evaluation --> f1: 0.9353 Time elapsed: 6.245s ------------------------------------------------- Total time: 25.673s Final results ==================== >> Total time: 25.733s ------------------------------------- StochasticGradientDescent --> f1: 0.9353 Analyze the results \u00b6 In [5]: Copied! atom . plot_trials () atom.plot_trials()  In [6]: Copied! atom . plot_hyperparameter_importance () atom.plot_hyperparameter_importance() ", "title": "Pruning"}, {"location": "examples/pruning/#example-pruning", "text": "This example shows an advanced example on how to use hyperparameter tuning with pruning. Import the breast cancer dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict whether a patient has breast cancer or not.", "title": "Example: Pruning"}, {"location": "examples/pruning/#load-the-data", "text": "In [1]: Copied! # Import packages from sklearn.datasets import load_breast_cancer from optuna.pruners import HyperbandPruner from atom import ATOMClassifier # Import packages from sklearn.datasets import load_breast_cancer from optuna.pruners import HyperbandPruner from atom import ATOMClassifier In [2]: Copied! # Load the data X , y = load_breast_cancer ( return_X_y = True ) # Load the data X, y = load_breast_cancer(return_X_y=True)", "title": "Load the data"}, {"location": "examples/pruning/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom atom = ATOMClassifier ( X , y , verbose = 2 , random_state = 1 ) # Initialize atom atom = ATOMClassifier(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (569, 31) Memory: 138.96 kB Scaled: False Outlier values: 167 (1.2%) ------------------------------------- Train set size: 456 Test set size: 113 ------------------------------------- | | dataset | train | test | | - | ----------- | ----------- | ----------- | | 0 | 212 (1.0) | 170 (1.0) | 42 (1.0) | | 1 | 357 (1.7) | 286 (1.7) | 71 (1.7) | In [4]: Copied! # Use ht_params to specify a custom pruner # Note that pruned trials show the number of iterations it completed atom . run ( models = \"SGD\" , metric = \"f1\" , n_trials = 25 , ht_params = { \"distributions\" : [ \"penalty\" , \"max_iter\" ], \"pruner\" : HyperbandPruner (), } ) # Use ht_params to specify a custom pruner # Note that pruned trials show the number of iterations it completed atom.run( models=\"SGD\", metric=\"f1\", n_trials=25, ht_params={ \"distributions\": [\"penalty\", \"max_iter\"], \"pruner\": HyperbandPruner(), } ) Training ========================= >> Models: SGD Metric: f1 Running hyperparameter tuning for StochasticGradientDescent... | trial | penalty | max_iter | f1 | best_f1 | time_trial | time_ht | state | | ----- | ------- | -------- | ------- | ------- | ---------- | ------- | -------- | | 0 | l1 | 650 | 0.9735 | 0.9735 | 2.288s | 2.288s | COMPLETE | | 1 | elast.. | 1050 | 0.9739 | 0.9739 | 3.783s | 6.072s | COMPLETE | | 2 | elast.. | 500 | 0.9558 | 0.9739 | 1.788s | 7.859s | COMPLETE | | 3 | none | 700 | 0.9825 | 0.9825 | 2.370s | 10.229s | COMPLETE | | 4 | l1 | 3/1400 | 0.9821 | 0.9825 | 0.032s | 10.261s | PRUNED | | 5 | none | 9/1400 | 0.9821 | 0.9825 | 0.046s | 10.307s | PRUNED | | 6 | l2 | 3/1200 | 0.9825 | 0.9825 | 0.025s | 10.332s | PRUNED | | 7 | l2 | 1/1250 | 0.9358 | 0.9825 | 0.019s | 10.351s | PRUNED | | 8 | none | 1/600 | 0.9912 | 0.9912 | 0.023s | 10.374s | PRUNED | | 9 | l1 | 9/600 | 0.9381 | 0.9912 | 0.048s | 10.422s | PRUNED | | 10 | l1 | 3/1000 | 0.9828 | 0.9912 | 0.029s | 10.451s | PRUNED | | 11 | elast.. | 1/1200 | 0.955 | 0.9912 | 0.021s | 10.473s | PRUNED | | 12 | l2 | 1/550 | 0.9541 | 0.9912 | 0.021s | 10.494s | PRUNED | | 13 | elast.. | 1/1100 | 0.9636 | 0.9912 | 0.020s | 10.514s | PRUNED | | 14 | none | 9/900 | 0.9565 | 0.9912 | 0.047s | 10.561s | PRUNED | | 15 | l1 | 1/850 | 0.9735 | 0.9912 | 0.023s | 10.584s | PRUNED | | 16 | elast.. | 1/750 | 0.9298 | 0.9912 | 0.022s | 10.606s | PRUNED | | 17 | l1 | 1250 | 0.9912 | 0.9912 | 4.543s | 15.149s | COMPLETE | | 18 | none | 700 | 0.9825 | 0.9912 | 0.004s | 15.153s | COMPLETE | | 19 | none | 3/750 | 0.9739 | 0.9912 | 0.025s | 15.178s | PRUNED | | 20 | none | 1/750 | 0.9492 | 0.9912 | 0.024s | 15.202s | PRUNED | | 21 | l2 | 1150 | 0.9828 | 0.9912 | 4.169s | 19.371s | COMPLETE | | 22 | none | 1/850 | 0.9643 | 0.9912 | 0.024s | 19.395s | PRUNED | | 23 | l1 | 3/900 | 0.9649 | 0.9912 | 0.029s | 19.424s | PRUNED | | 24 | l1 | 650 | 0.9735 | 0.9912 | 0.005s | 19.429s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 17 Best parameters: --> penalty: l1 --> max_iter: 1250 Best evaluation --> f1: 0.9912 Time elapsed: 19.429s Fit --------------------------------------------- Train evaluation --> f1: 0.9983 Test evaluation --> f1: 0.9353 Time elapsed: 6.245s ------------------------------------------------- Total time: 25.673s Final results ==================== >> Total time: 25.733s ------------------------------------- StochasticGradientDescent --> f1: 0.9353", "title": "Run the pipeline"}, {"location": "examples/pruning/#analyze-the-results", "text": "In [5]: Copied! atom . plot_trials () atom.plot_trials()  In [6]: Copied! atom . plot_hyperparameter_importance () atom.plot_hyperparameter_importance() ", "title": "Analyze the results"}, {"location": "examples/regression/", "text": "Example: Regression \u00b6 This example shows how to use ATOM to apply pca on the data and run a regression pipeline. Download the abalone dataset from https://archive.ics.uci.edu/ml/datasets/Abalone . The goal of this dataset is to predict the rings (age) of abalone shells from physical measurements. Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMRegressor # Import packages import pandas as pd from atom import ATOMRegressor In [2]: Copied! # Load the data X = pd . read_csv ( \"./datasets/abalone.csv\" ) # Let's have a look X . head () # Load the data X = pd.read_csv(\"./datasets/abalone.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Sex Length Diameter Height Whole weight Shucked weight Viscera weight Shell weight Rings 0 M 0.455 0.365 0.095 0.5140 0.2245 0.1010 0.150 15 1 M 0.350 0.265 0.090 0.2255 0.0995 0.0485 0.070 7 2 F 0.530 0.420 0.135 0.6770 0.2565 0.1415 0.210 9 3 M 0.440 0.365 0.125 0.5160 0.2155 0.1140 0.155 10 4 I 0.330 0.255 0.080 0.2050 0.0895 0.0395 0.055 7 In [3]: Copied! # Initialize atom for regression tasks atom = ATOMRegressor ( X , \"Rings\" , verbose = 2 , random_state = 42 ) # Initialize atom for regression tasks atom = ATOMRegressor(X, \"Rings\", verbose=2, random_state=42) << ================== ATOM ================== >> Algorithm task: regression. Dataset stats ==================== >> Shape: (4177, 9) Memory: 509.72 kB Scaled: False Categorical features: 1 (12.5%) Outlier values: 195 (0.6%) ------------------------------------- Train set size: 3342 Test set size: 835 In [4]: Copied! # Encode the categorical features atom . encode () # Encode the categorical features atom.encode() Fitting Encoder... Encoding categorical columns... --> OneHot-encoding feature Sex. Contains 3 classes. In [5]: Copied! # Plot the dataset's correlation matrix atom . plot_correlation () # Plot the dataset's correlation matrix atom.plot_correlation()  In [6]: Copied! # Apply pca for dimensionality reduction atom . feature_selection ( strategy = \"pca\" , n_features = 6 ) # Apply pca for dimensionality reduction atom.feature_selection(strategy=\"pca\", n_features=6) Fitting FeatureSelector... Performing feature selection ... --> Applying Principal Component Analysis... --> Scaling features... --> Keeping 6 components. --> Explained variance ratio: 0.97 In [7]: Copied! # Note that the fetaures are automatically renamed to pca0, pca1, etc... atom . columns # Note that the fetaures are automatically renamed to pca0, pca1, etc... atom.columns Out[7]: Index(['pca0', 'pca1', 'pca2', 'pca3', 'pca4', 'pca5', 'Rings'], dtype='object') In [8]: Copied! # Use the plotting methods to see the retained variance ratio atom . plot_pca () # Use the plotting methods to see the retained variance ratio atom.plot_pca()  In [9]: Copied! atom . plot_components () atom.plot_components()  Run the pipeline \u00b6 In [10]: Copied! atom . run ( models = [ \"Tree\" , \"Bag\" , \"ET\" ], metric = \"mse\" , n_trials = 5 , n_bootstrap = 5 , ) atom.run( models=[\"Tree\", \"Bag\", \"ET\"], metric=\"mse\", n_trials=5, n_bootstrap=5, ) Training ========================= >> Models: Tree, Bag, ET Metric: neg_mean_squared_error Running hyperparameter tuning for DecisionTree... | trial | criterion | splitter | max_depth | min_samples_split | min_samples_leaf | max_features | ccp_alpha | neg_mean_squared_error | best_neg_mean_squared_error | time_trial | time_ht | state | | ----- | ----------- | -------- | --------- | ----------------- | ---------------- | ------------ | --------- | ---------------------- | --------------------------- | ---------- | ------- | -------- | | 0 | absolute_.. | best | 5 | 8 | 10 | None | 0.035 | -6.5456 | -6.5456 | 0.244s | 0.244s | COMPLETE | | 1 | squared_e.. | best | 10 | 5 | 1 | 0.5 | 0.03 | -7.1959 | -6.5456 | 0.060s | 0.304s | COMPLETE | | 2 | absolute_.. | random | 14 | 15 | 16 | sqrt | 0.025 | -8.5859 | -6.5456 | 0.075s | 0.379s | COMPLETE | | 3 | friedman_.. | random | 4 | 10 | 17 | 0.9 | 0.01 | -7.4933 | -6.5456 | 0.058s | 0.437s | COMPLETE | | 4 | poisson | best | 12 | 15 | 8 | 0.6 | 0.02 | -5.8126 | -5.8126 | 0.060s | 0.497s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 4 Best parameters: --> criterion: poisson --> splitter: best --> max_depth: 12 --> min_samples_split: 15 --> min_samples_leaf: 8 --> max_features: 0.6 --> ccp_alpha: 0.02 Best evaluation --> neg_mean_squared_error: -5.8126 Time elapsed: 0.497s Fit --------------------------------------------- Train evaluation --> neg_mean_squared_error: -6.2977 Test evaluation --> neg_mean_squared_error: -7.1923 Time elapsed: 0.019s Bootstrap --------------------------------------- Evaluation --> neg_mean_squared_error: -7.6026 \u00b1 0.3783 Time elapsed: 0.076s ------------------------------------------------- Total time: 0.593s Running hyperparameter tuning for Bagging... | trial | n_estimators | max_samples | max_features | bootstrap | bootstrap_features | neg_mean_squared_error | best_neg_mean_squared_error | time_trial | time_ht | state | | ----- | ------------ | ----------- | ------------ | --------- | ------------------ | ---------------------- | --------------------------- | ---------- | ------- | -------- | | 0 | 190 | 1.0 | 0.9 | True | True | -4.5751 | -4.5751 | 1.593s | 1.593s | COMPLETE | | 1 | 440 | 0.8 | 0.9 | False | True | -6.7839 | -4.5751 | 4.784s | 6.378s | COMPLETE | | 2 | 100 | 0.6 | 0.6 | True | False | -5.0065 | -4.5751 | 0.551s | 6.928s | COMPLETE | | 3 | 70 | 0.6 | 0.7 | False | False | -5.4027 | -4.5751 | 0.564s | 7.492s | COMPLETE | | 4 | 300 | 0.5 | 0.8 | True | False | -5.0964 | -4.5751 | 1.593s | 9.085s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 0 Best parameters: --> n_estimators: 190 --> max_samples: 1.0 --> max_features: 0.9 --> bootstrap: True --> bootstrap_features: True Best evaluation --> neg_mean_squared_error: -4.5751 Time elapsed: 9.085s Fit --------------------------------------------- Train evaluation --> neg_mean_squared_error: -0.7581 Test evaluation --> neg_mean_squared_error: -5.7896 Time elapsed: 2.108s Bootstrap --------------------------------------- Evaluation --> neg_mean_squared_error: -5.9893 \u00b1 0.1646 Time elapsed: 9.210s ------------------------------------------------- Total time: 20.403s Running hyperparameter tuning for ExtraTrees... | trial | n_estimators | criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | ccp_alpha | neg_mean_squared_error | best_neg_mean_squared_error | time_trial | time_ht | state | | ----- | ------------ | ------------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | --------- | ---------------------- | --------------------------- | ---------- | ------- | -------- | | 0 | 190 | squared_error | 8 | 13 | 3 | 0.5 | True | 0.6 | 0.025 | -5.1462 | -5.1462 | 0.293s | 0.293s | COMPLETE | | 1 | 230 | absolute_er.. | 8 | 8 | 8 | sqrt | True | 0.6 | 0.0 | -9.3444 | -5.1462 | 1.334s | 1.627s | COMPLETE | | 2 | 180 | absolute_er.. | 7 | 2 | 3 | 0.6 | True | 0.6 | 0.03 | -5.7371 | -5.1462 | 1.745s | 3.372s | COMPLETE | | 3 | 100 | squared_error | 14 | 15 | 8 | None | True | 0.9 | 0.005 | -5.1938 | -5.1462 | 0.225s | 3.597s | COMPLETE | | 4 | 340 | squared_error | 6 | 15 | 8 | None | True | 0.8 | 0.01 | -4.8716 | -4.8716 | 0.486s | 4.084s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 4 Best parameters: --> n_estimators: 340 --> criterion: squared_error --> max_depth: 6 --> min_samples_split: 15 --> min_samples_leaf: 8 --> max_features: None --> bootstrap: True --> max_samples: 0.8 --> ccp_alpha: 0.01 Best evaluation --> neg_mean_squared_error: -4.8716 Time elapsed: 4.084s Fit --------------------------------------------- Train evaluation --> neg_mean_squared_error: -5.4808 Test evaluation --> neg_mean_squared_error: -6.3445 Time elapsed: 0.522s Bootstrap --------------------------------------- Evaluation --> neg_mean_squared_error: -6.3694 \u00b1 0.0737 Time elapsed: 2.282s ------------------------------------------------- Total time: 6.888s Final results ==================== >> Total time: 28.341s ------------------------------------- DecisionTree --> neg_mean_squared_error: -7.6026 \u00b1 0.3783 ~ Bagging --> neg_mean_squared_error: -5.9893 \u00b1 0.1646 ~ ! ExtraTrees --> neg_mean_squared_error: -6.3694 \u00b1 0.0737 ~ Analyze the results \u00b6 In [11]: Copied! # Use the errors or residuals plots to check the model performances atom . plot_residuals () # Use the errors or residuals plots to check the model performances atom.plot_residuals()  In [12]: Copied! atom . plot_errors () atom.plot_errors()  In [13]: Copied! # Analyze the relation between the target response and the features atom . n_jobs = 8 # The method can be slow... atom . plot_partial_dependence ( columns = ( 0 , 1 , 2 , 3 )) atom . ET . plot_partial_dependence ( columns = ( 0 , 2 ), pair = 4 ) # Analyze the relation between the target response and the features atom.n_jobs = 8 # The method can be slow... atom.plot_partial_dependence(columns=(0, 1, 2, 3)) atom.ET.plot_partial_dependence(columns=(0, 2), pair=4)  ", "title": "Regression"}, {"location": "examples/regression/#example-regression", "text": "This example shows how to use ATOM to apply pca on the data and run a regression pipeline. Download the abalone dataset from https://archive.ics.uci.edu/ml/datasets/Abalone . The goal of this dataset is to predict the rings (age) of abalone shells from physical measurements.", "title": "Example: Regression"}, {"location": "examples/regression/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMRegressor # Import packages import pandas as pd from atom import ATOMRegressor In [2]: Copied! # Load the data X = pd . read_csv ( \"./datasets/abalone.csv\" ) # Let's have a look X . head () # Load the data X = pd.read_csv(\"./datasets/abalone.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Sex Length Diameter Height Whole weight Shucked weight Viscera weight Shell weight Rings 0 M 0.455 0.365 0.095 0.5140 0.2245 0.1010 0.150 15 1 M 0.350 0.265 0.090 0.2255 0.0995 0.0485 0.070 7 2 F 0.530 0.420 0.135 0.6770 0.2565 0.1415 0.210 9 3 M 0.440 0.365 0.125 0.5160 0.2155 0.1140 0.155 10 4 I 0.330 0.255 0.080 0.2050 0.0895 0.0395 0.055 7 In [3]: Copied! # Initialize atom for regression tasks atom = ATOMRegressor ( X , \"Rings\" , verbose = 2 , random_state = 42 ) # Initialize atom for regression tasks atom = ATOMRegressor(X, \"Rings\", verbose=2, random_state=42) << ================== ATOM ================== >> Algorithm task: regression. Dataset stats ==================== >> Shape: (4177, 9) Memory: 509.72 kB Scaled: False Categorical features: 1 (12.5%) Outlier values: 195 (0.6%) ------------------------------------- Train set size: 3342 Test set size: 835 In [4]: Copied! # Encode the categorical features atom . encode () # Encode the categorical features atom.encode() Fitting Encoder... Encoding categorical columns... --> OneHot-encoding feature Sex. Contains 3 classes. In [5]: Copied! # Plot the dataset's correlation matrix atom . plot_correlation () # Plot the dataset's correlation matrix atom.plot_correlation()  In [6]: Copied! # Apply pca for dimensionality reduction atom . feature_selection ( strategy = \"pca\" , n_features = 6 ) # Apply pca for dimensionality reduction atom.feature_selection(strategy=\"pca\", n_features=6) Fitting FeatureSelector... Performing feature selection ... --> Applying Principal Component Analysis... --> Scaling features... --> Keeping 6 components. --> Explained variance ratio: 0.97 In [7]: Copied! # Note that the fetaures are automatically renamed to pca0, pca1, etc... atom . columns # Note that the fetaures are automatically renamed to pca0, pca1, etc... atom.columns Out[7]: Index(['pca0', 'pca1', 'pca2', 'pca3', 'pca4', 'pca5', 'Rings'], dtype='object') In [8]: Copied! # Use the plotting methods to see the retained variance ratio atom . plot_pca () # Use the plotting methods to see the retained variance ratio atom.plot_pca()  In [9]: Copied! atom . plot_components () atom.plot_components() ", "title": "Load the data"}, {"location": "examples/regression/#run-the-pipeline", "text": "In [10]: Copied! atom . run ( models = [ \"Tree\" , \"Bag\" , \"ET\" ], metric = \"mse\" , n_trials = 5 , n_bootstrap = 5 , ) atom.run( models=[\"Tree\", \"Bag\", \"ET\"], metric=\"mse\", n_trials=5, n_bootstrap=5, ) Training ========================= >> Models: Tree, Bag, ET Metric: neg_mean_squared_error Running hyperparameter tuning for DecisionTree... | trial | criterion | splitter | max_depth | min_samples_split | min_samples_leaf | max_features | ccp_alpha | neg_mean_squared_error | best_neg_mean_squared_error | time_trial | time_ht | state | | ----- | ----------- | -------- | --------- | ----------------- | ---------------- | ------------ | --------- | ---------------------- | --------------------------- | ---------- | ------- | -------- | | 0 | absolute_.. | best | 5 | 8 | 10 | None | 0.035 | -6.5456 | -6.5456 | 0.244s | 0.244s | COMPLETE | | 1 | squared_e.. | best | 10 | 5 | 1 | 0.5 | 0.03 | -7.1959 | -6.5456 | 0.060s | 0.304s | COMPLETE | | 2 | absolute_.. | random | 14 | 15 | 16 | sqrt | 0.025 | -8.5859 | -6.5456 | 0.075s | 0.379s | COMPLETE | | 3 | friedman_.. | random | 4 | 10 | 17 | 0.9 | 0.01 | -7.4933 | -6.5456 | 0.058s | 0.437s | COMPLETE | | 4 | poisson | best | 12 | 15 | 8 | 0.6 | 0.02 | -5.8126 | -5.8126 | 0.060s | 0.497s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 4 Best parameters: --> criterion: poisson --> splitter: best --> max_depth: 12 --> min_samples_split: 15 --> min_samples_leaf: 8 --> max_features: 0.6 --> ccp_alpha: 0.02 Best evaluation --> neg_mean_squared_error: -5.8126 Time elapsed: 0.497s Fit --------------------------------------------- Train evaluation --> neg_mean_squared_error: -6.2977 Test evaluation --> neg_mean_squared_error: -7.1923 Time elapsed: 0.019s Bootstrap --------------------------------------- Evaluation --> neg_mean_squared_error: -7.6026 \u00b1 0.3783 Time elapsed: 0.076s ------------------------------------------------- Total time: 0.593s Running hyperparameter tuning for Bagging... | trial | n_estimators | max_samples | max_features | bootstrap | bootstrap_features | neg_mean_squared_error | best_neg_mean_squared_error | time_trial | time_ht | state | | ----- | ------------ | ----------- | ------------ | --------- | ------------------ | ---------------------- | --------------------------- | ---------- | ------- | -------- | | 0 | 190 | 1.0 | 0.9 | True | True | -4.5751 | -4.5751 | 1.593s | 1.593s | COMPLETE | | 1 | 440 | 0.8 | 0.9 | False | True | -6.7839 | -4.5751 | 4.784s | 6.378s | COMPLETE | | 2 | 100 | 0.6 | 0.6 | True | False | -5.0065 | -4.5751 | 0.551s | 6.928s | COMPLETE | | 3 | 70 | 0.6 | 0.7 | False | False | -5.4027 | -4.5751 | 0.564s | 7.492s | COMPLETE | | 4 | 300 | 0.5 | 0.8 | True | False | -5.0964 | -4.5751 | 1.593s | 9.085s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 0 Best parameters: --> n_estimators: 190 --> max_samples: 1.0 --> max_features: 0.9 --> bootstrap: True --> bootstrap_features: True Best evaluation --> neg_mean_squared_error: -4.5751 Time elapsed: 9.085s Fit --------------------------------------------- Train evaluation --> neg_mean_squared_error: -0.7581 Test evaluation --> neg_mean_squared_error: -5.7896 Time elapsed: 2.108s Bootstrap --------------------------------------- Evaluation --> neg_mean_squared_error: -5.9893 \u00b1 0.1646 Time elapsed: 9.210s ------------------------------------------------- Total time: 20.403s Running hyperparameter tuning for ExtraTrees... | trial | n_estimators | criterion | max_depth | min_samples_split | min_samples_leaf | max_features | bootstrap | max_samples | ccp_alpha | neg_mean_squared_error | best_neg_mean_squared_error | time_trial | time_ht | state | | ----- | ------------ | ------------- | --------- | ----------------- | ---------------- | ------------ | --------- | ----------- | --------- | ---------------------- | --------------------------- | ---------- | ------- | -------- | | 0 | 190 | squared_error | 8 | 13 | 3 | 0.5 | True | 0.6 | 0.025 | -5.1462 | -5.1462 | 0.293s | 0.293s | COMPLETE | | 1 | 230 | absolute_er.. | 8 | 8 | 8 | sqrt | True | 0.6 | 0.0 | -9.3444 | -5.1462 | 1.334s | 1.627s | COMPLETE | | 2 | 180 | absolute_er.. | 7 | 2 | 3 | 0.6 | True | 0.6 | 0.03 | -5.7371 | -5.1462 | 1.745s | 3.372s | COMPLETE | | 3 | 100 | squared_error | 14 | 15 | 8 | None | True | 0.9 | 0.005 | -5.1938 | -5.1462 | 0.225s | 3.597s | COMPLETE | | 4 | 340 | squared_error | 6 | 15 | 8 | None | True | 0.8 | 0.01 | -4.8716 | -4.8716 | 0.486s | 4.084s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 4 Best parameters: --> n_estimators: 340 --> criterion: squared_error --> max_depth: 6 --> min_samples_split: 15 --> min_samples_leaf: 8 --> max_features: None --> bootstrap: True --> max_samples: 0.8 --> ccp_alpha: 0.01 Best evaluation --> neg_mean_squared_error: -4.8716 Time elapsed: 4.084s Fit --------------------------------------------- Train evaluation --> neg_mean_squared_error: -5.4808 Test evaluation --> neg_mean_squared_error: -6.3445 Time elapsed: 0.522s Bootstrap --------------------------------------- Evaluation --> neg_mean_squared_error: -6.3694 \u00b1 0.0737 Time elapsed: 2.282s ------------------------------------------------- Total time: 6.888s Final results ==================== >> Total time: 28.341s ------------------------------------- DecisionTree --> neg_mean_squared_error: -7.6026 \u00b1 0.3783 ~ Bagging --> neg_mean_squared_error: -5.9893 \u00b1 0.1646 ~ ! ExtraTrees --> neg_mean_squared_error: -6.3694 \u00b1 0.0737 ~", "title": "Run the pipeline"}, {"location": "examples/regression/#analyze-the-results", "text": "In [11]: Copied! # Use the errors or residuals plots to check the model performances atom . plot_residuals () # Use the errors or residuals plots to check the model performances atom.plot_residuals()  In [12]: Copied! atom . plot_errors () atom.plot_errors()  In [13]: Copied! # Analyze the relation between the target response and the features atom . n_jobs = 8 # The method can be slow... atom . plot_partial_dependence ( columns = ( 0 , 1 , 2 , 3 )) atom . ET . plot_partial_dependence ( columns = ( 0 , 2 ), pair = 4 ) # Analyze the relation between the target response and the features atom.n_jobs = 8 # The method can be slow... atom.plot_partial_dependence(columns=(0, 1, 2, 3)) atom.ET.plot_partial_dependence(columns=(0, 2), pair=4)  ", "title": "Analyze the results"}, {"location": "examples/successive_halving/", "text": "Example: Successive halving \u00b6 This example shows how to compare multiple tree-based models using successive halving. Import the california housing dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict house prices. Load the data \u00b6 In [1]: Copied! from sklearn.datasets import fetch_california_housing from atom import ATOMRegressor from sklearn.datasets import fetch_california_housing from atom import ATOMRegressor In [2]: Copied! # Load the data X , y = fetch_california_housing ( return_X_y = True ) # Load the data X, y = fetch_california_housing(return_X_y=True) Run the pipeline \u00b6 In [3]: Copied! atom = ATOMRegressor ( X , y , verbose = 2 , random_state = 1 ) atom = ATOMRegressor(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: regression. Dataset stats ==================== >> Shape: (20640, 9) Memory: 1.49 MB Scaled: False Outlier values: 786 (0.5%) ------------------------------------- Train set size: 16512 Test set size: 4128 In [4]: Copied! # Compare tree-based models via successive halving atom . successive_halving ( models = [ \"Tree\" , \"Bag\" , \"ET\" , \"RF\" , \"LGB\" , \"CatB\" ], metric = \"mae\" , n_bootstrap = 5 , ) # Compare tree-based models via successive halving atom.successive_halving( models=[\"Tree\", \"Bag\", \"ET\", \"RF\", \"LGB\", \"CatB\"], metric=\"mae\", n_bootstrap=5, ) Training ========================= >> Metric: neg_mean_absolute_error Run: 0 =========================== >> Models: Tree6, Bag6, ET6, RF6, LGB6, CatB6 Size of training set: 16512 (17%) Size of test set: 4128 Results for DecisionTree: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.0 Test evaluation --> neg_mean_absolute_error: -0.5538 Time elapsed: 0.036s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.5542 \u00b1 0.0284 Time elapsed: 0.321s ------------------------------------------------- Total time: 0.357s Results for Bagging: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.1648 Test evaluation --> neg_mean_absolute_error: -0.42 Time elapsed: 0.146s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.4289 \u00b1 0.0055 Time elapsed: 0.831s ------------------------------------------------- Total time: 0.977s Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.0 Test evaluation --> neg_mean_absolute_error: -0.3958 Time elapsed: 0.787s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.4015 \u00b1 0.0029 Time elapsed: 3.544s ------------------------------------------------- Total time: 4.331s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.145 Test evaluation --> neg_mean_absolute_error: -0.4003 Time elapsed: 1.320s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.4052 \u00b1 0.005 Time elapsed: 6.386s ------------------------------------------------- Total time: 7.707s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.2022 Test evaluation --> neg_mean_absolute_error: -0.3599 Time elapsed: 0.361s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3607 \u00b1 0.0018 Time elapsed: 0.848s ------------------------------------------------- Total time: 1.209s Results for CatBoost: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.1591 Test evaluation --> neg_mean_absolute_error: -0.3433 Time elapsed: 4.811s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3486 \u00b1 0.0017 Time elapsed: 21.200s ------------------------------------------------- Total time: 26.010s Final results ==================== >> Total time: 40.595s ------------------------------------- DecisionTree --> neg_mean_absolute_error: -0.5542 \u00b1 0.0284 ~ Bagging --> neg_mean_absolute_error: -0.4289 \u00b1 0.0055 ~ ExtraTrees --> neg_mean_absolute_error: -0.4015 \u00b1 0.0029 ~ RandomForest --> neg_mean_absolute_error: -0.4052 \u00b1 0.005 ~ LightGBM --> neg_mean_absolute_error: -0.3607 \u00b1 0.0018 ~ CatBoost --> neg_mean_absolute_error: -0.3486 \u00b1 0.0017 ~ ! Run: 1 =========================== >> Models: ET3, LGB3, CatB3 Size of training set: 16512 (33%) Size of test set: 4128 Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.0 Test evaluation --> neg_mean_absolute_error: -0.3691 Time elapsed: 1.399s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3828 \u00b1 0.0053 Time elapsed: 5.967s ------------------------------------------------- Total time: 7.367s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.2367 Test evaluation --> neg_mean_absolute_error: -0.3342 Time elapsed: 0.366s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3451 \u00b1 0.0056 Time elapsed: 0.969s ------------------------------------------------- Total time: 1.336s Results for CatBoost: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.1876 Test evaluation --> neg_mean_absolute_error: -0.3176 Time elapsed: 4.778s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3296 \u00b1 0.0024 Time elapsed: 23.359s ------------------------------------------------- Total time: 28.137s Final results ==================== >> Total time: 36.844s ------------------------------------- ExtraTrees --> neg_mean_absolute_error: -0.3828 \u00b1 0.0053 ~ LightGBM --> neg_mean_absolute_error: -0.3451 \u00b1 0.0056 ~ CatBoost --> neg_mean_absolute_error: -0.3296 \u00b1 0.0024 ~ ! Run: 2 =========================== >> Models: CatB1 Size of training set: 16512 (100%) Size of test set: 4128 Results for CatBoost: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.2229 Test evaluation --> neg_mean_absolute_error: -0.2986 Time elapsed: 7.226s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3091 \u00b1 0.0026 Time elapsed: 35.044s ------------------------------------------------- Total time: 42.269s Final results ==================== >> Total time: 42.270s ------------------------------------- CatBoost --> neg_mean_absolute_error: -0.3091 \u00b1 0.0026 ~ Analyze the results \u00b6 In [5]: Copied! # The results is now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the number of models fitted during that run atom . results # The results is now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the number of models fitted during that run atom.results Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit score_bootstrap time_bootstrap time frac model 0.17 Bag6 -0.1648 -0.4200 0.146132 -0.428947 0.830754 0.976886 CatB6 -0.1591 -0.3433 4.810551 -0.348576 21.199617 26.010168 ET6 -0.0000 -0.3958 0.786993 -0.401530 3.544431 4.331424 LGB6 -0.2022 -0.3599 0.361332 -0.360678 0.847782 1.209114 RF6 -0.1450 -0.4003 1.320198 -0.405193 6.386311 7.706509 Tree6 -0.0000 -0.5538 0.036031 -0.554181 0.321293 0.357324 0.33 CatB3 -0.1876 -0.3176 4.777847 -0.329575 23.359312 28.137159 ET3 -0.0000 -0.3691 1.399291 -0.382764 5.967419 7.366710 LGB3 -0.2367 -0.3342 0.366333 -0.345083 0.969394 1.335727 1.00 CatB1 -0.2229 -0.2986 7.225810 -0.309112 35.043598 42.269408 In [6]: Copied! # Plot the successive halving's results atom . plot_successive_halving () # Plot the successive halving's results atom.plot_successive_halving()  In [9]: Copied! # Use regex to call all the models with the same estimator... atom . plot_errors ( models = [ \"CatB.*\" ]) # Use regex to call all the models with the same estimator... atom.plot_errors(models=[\"CatB.*\"])  In [10]: Copied! # ...or to call the models from the same run atom . plot_errors ( models = \".*3\" ) # ...or to call the models from the same run atom.plot_errors(models=\".*3\") ", "title": "Successive halving"}, {"location": "examples/successive_halving/#example-successive-halving", "text": "This example shows how to compare multiple tree-based models using successive halving. Import the california housing dataset from sklearn.datasets . This is a small and easy to train dataset whose goal is to predict house prices.", "title": "Example: Successive halving"}, {"location": "examples/successive_halving/#load-the-data", "text": "In [1]: Copied! from sklearn.datasets import fetch_california_housing from atom import ATOMRegressor from sklearn.datasets import fetch_california_housing from atom import ATOMRegressor In [2]: Copied! # Load the data X , y = fetch_california_housing ( return_X_y = True ) # Load the data X, y = fetch_california_housing(return_X_y=True)", "title": "Load the data"}, {"location": "examples/successive_halving/#run-the-pipeline", "text": "In [3]: Copied! atom = ATOMRegressor ( X , y , verbose = 2 , random_state = 1 ) atom = ATOMRegressor(X, y, verbose=2, random_state=1) << ================== ATOM ================== >> Algorithm task: regression. Dataset stats ==================== >> Shape: (20640, 9) Memory: 1.49 MB Scaled: False Outlier values: 786 (0.5%) ------------------------------------- Train set size: 16512 Test set size: 4128 In [4]: Copied! # Compare tree-based models via successive halving atom . successive_halving ( models = [ \"Tree\" , \"Bag\" , \"ET\" , \"RF\" , \"LGB\" , \"CatB\" ], metric = \"mae\" , n_bootstrap = 5 , ) # Compare tree-based models via successive halving atom.successive_halving( models=[\"Tree\", \"Bag\", \"ET\", \"RF\", \"LGB\", \"CatB\"], metric=\"mae\", n_bootstrap=5, ) Training ========================= >> Metric: neg_mean_absolute_error Run: 0 =========================== >> Models: Tree6, Bag6, ET6, RF6, LGB6, CatB6 Size of training set: 16512 (17%) Size of test set: 4128 Results for DecisionTree: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.0 Test evaluation --> neg_mean_absolute_error: -0.5538 Time elapsed: 0.036s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.5542 \u00b1 0.0284 Time elapsed: 0.321s ------------------------------------------------- Total time: 0.357s Results for Bagging: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.1648 Test evaluation --> neg_mean_absolute_error: -0.42 Time elapsed: 0.146s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.4289 \u00b1 0.0055 Time elapsed: 0.831s ------------------------------------------------- Total time: 0.977s Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.0 Test evaluation --> neg_mean_absolute_error: -0.3958 Time elapsed: 0.787s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.4015 \u00b1 0.0029 Time elapsed: 3.544s ------------------------------------------------- Total time: 4.331s Results for RandomForest: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.145 Test evaluation --> neg_mean_absolute_error: -0.4003 Time elapsed: 1.320s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.4052 \u00b1 0.005 Time elapsed: 6.386s ------------------------------------------------- Total time: 7.707s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.2022 Test evaluation --> neg_mean_absolute_error: -0.3599 Time elapsed: 0.361s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3607 \u00b1 0.0018 Time elapsed: 0.848s ------------------------------------------------- Total time: 1.209s Results for CatBoost: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.1591 Test evaluation --> neg_mean_absolute_error: -0.3433 Time elapsed: 4.811s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3486 \u00b1 0.0017 Time elapsed: 21.200s ------------------------------------------------- Total time: 26.010s Final results ==================== >> Total time: 40.595s ------------------------------------- DecisionTree --> neg_mean_absolute_error: -0.5542 \u00b1 0.0284 ~ Bagging --> neg_mean_absolute_error: -0.4289 \u00b1 0.0055 ~ ExtraTrees --> neg_mean_absolute_error: -0.4015 \u00b1 0.0029 ~ RandomForest --> neg_mean_absolute_error: -0.4052 \u00b1 0.005 ~ LightGBM --> neg_mean_absolute_error: -0.3607 \u00b1 0.0018 ~ CatBoost --> neg_mean_absolute_error: -0.3486 \u00b1 0.0017 ~ ! Run: 1 =========================== >> Models: ET3, LGB3, CatB3 Size of training set: 16512 (33%) Size of test set: 4128 Results for ExtraTrees: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.0 Test evaluation --> neg_mean_absolute_error: -0.3691 Time elapsed: 1.399s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3828 \u00b1 0.0053 Time elapsed: 5.967s ------------------------------------------------- Total time: 7.367s Results for LightGBM: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.2367 Test evaluation --> neg_mean_absolute_error: -0.3342 Time elapsed: 0.366s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3451 \u00b1 0.0056 Time elapsed: 0.969s ------------------------------------------------- Total time: 1.336s Results for CatBoost: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.1876 Test evaluation --> neg_mean_absolute_error: -0.3176 Time elapsed: 4.778s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3296 \u00b1 0.0024 Time elapsed: 23.359s ------------------------------------------------- Total time: 28.137s Final results ==================== >> Total time: 36.844s ------------------------------------- ExtraTrees --> neg_mean_absolute_error: -0.3828 \u00b1 0.0053 ~ LightGBM --> neg_mean_absolute_error: -0.3451 \u00b1 0.0056 ~ CatBoost --> neg_mean_absolute_error: -0.3296 \u00b1 0.0024 ~ ! Run: 2 =========================== >> Models: CatB1 Size of training set: 16512 (100%) Size of test set: 4128 Results for CatBoost: Fit --------------------------------------------- Train evaluation --> neg_mean_absolute_error: -0.2229 Test evaluation --> neg_mean_absolute_error: -0.2986 Time elapsed: 7.226s Bootstrap --------------------------------------- Evaluation --> neg_mean_absolute_error: -0.3091 \u00b1 0.0026 Time elapsed: 35.044s ------------------------------------------------- Total time: 42.269s Final results ==================== >> Total time: 42.270s ------------------------------------- CatBoost --> neg_mean_absolute_error: -0.3091 \u00b1 0.0026 ~", "title": "Run the pipeline"}, {"location": "examples/successive_halving/#analyze-the-results", "text": "In [5]: Copied! # The results is now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the number of models fitted during that run atom . results # The results is now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the number of models fitted during that run atom.results Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit score_bootstrap time_bootstrap time frac model 0.17 Bag6 -0.1648 -0.4200 0.146132 -0.428947 0.830754 0.976886 CatB6 -0.1591 -0.3433 4.810551 -0.348576 21.199617 26.010168 ET6 -0.0000 -0.3958 0.786993 -0.401530 3.544431 4.331424 LGB6 -0.2022 -0.3599 0.361332 -0.360678 0.847782 1.209114 RF6 -0.1450 -0.4003 1.320198 -0.405193 6.386311 7.706509 Tree6 -0.0000 -0.5538 0.036031 -0.554181 0.321293 0.357324 0.33 CatB3 -0.1876 -0.3176 4.777847 -0.329575 23.359312 28.137159 ET3 -0.0000 -0.3691 1.399291 -0.382764 5.967419 7.366710 LGB3 -0.2367 -0.3342 0.366333 -0.345083 0.969394 1.335727 1.00 CatB1 -0.2229 -0.2986 7.225810 -0.309112 35.043598 42.269408 In [6]: Copied! # Plot the successive halving's results atom . plot_successive_halving () # Plot the successive halving's results atom.plot_successive_halving()  In [9]: Copied! # Use regex to call all the models with the same estimator... atom . plot_errors ( models = [ \"CatB.*\" ]) # Use regex to call all the models with the same estimator... atom.plot_errors(models=[\"CatB.*\"])  In [10]: Copied! # ...or to call the models from the same run atom . plot_errors ( models = \".*3\" ) # ...or to call the models from the same run atom.plot_errors(models=\".*3\") ", "title": "Analyze the results"}, {"location": "examples/train_sizing/", "text": "Example: Train sizing \u00b6 This example shows how to asses a model's performance based on the size of the training set. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load the data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load the data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Run the pipeline \u00b6 In [3]: Copied! # Initialize atom and prepare the data atom = ATOMClassifier ( X , verbose = 2 , random_state = 1 ) atom . clean () atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" , max_nan_rows = 0.8 ) atom . encode () # Initialize atom and prepare the data atom = ATOMClassifier(X, verbose=2, random_state=1) atom.clean() atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\", max_nan_rows=0.8) atom.encode() << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- | | dataset | train | test | | - | -------------- | -------------- | -------------- | | 0 | 110316 (3.5) | 88253 (3.5) | 22063 (3.5) | | 1 | 31877 (1.0) | 25502 (1.0) | 6375 (1.0) | Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. Fitting Imputer... Imputing missing values... --> Dropping 161 samples for containing more than 16 missing values. --> Imputing 481 missing values with median (12.0) in feature MinTemp. --> Imputing 265 missing values with median (22.6) in feature MaxTemp. --> Imputing 1354 missing values with median (0.0) in feature Rainfall. --> Imputing 60682 missing values with median (4.8) in feature Evaporation. --> Imputing 67659 missing values with median (8.4) in feature Sunshine. --> Imputing 9187 missing values with most_frequent (W) in feature WindGustDir. --> Imputing 9127 missing values with median (39.0) in feature WindGustSpeed. --> Imputing 9852 missing values with most_frequent (N) in feature WindDir9am. --> Imputing 3617 missing values with most_frequent (SE) in feature WindDir3pm. --> Imputing 1187 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 2469 missing values with median (19.0) in feature WindSpeed3pm. --> Imputing 1613 missing values with median (70.0) in feature Humidity9am. --> Imputing 3449 missing values with median (52.0) in feature Humidity3pm. --> Imputing 13863 missing values with median (1017.6) in feature Pressure9am. --> Imputing 13830 missing values with median (1015.2) in feature Pressure3pm. --> Imputing 53496 missing values with median (5.0) in feature Cloud9am. --> Imputing 56933 missing values with median (5.0) in feature Cloud3pm. --> Imputing 743 missing values with median (16.7) in feature Temp9am. --> Imputing 2565 missing values with median (21.1) in feature Temp3pm. --> Imputing 1354 missing values with most_frequent (No) in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 49 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [4]: Copied! # Analyze the impact of the training set's size on a LightGBM model atom . train_sizing ( \"LGB\" , train_sizes = 10 , n_bootstrap = 5 ) # Analyze the impact of the training set's size on a LightGBM model atom.train_sizing(\"LGB\", train_sizes=10, n_bootstrap=5) Training ========================= >> Metric: f1 Run: 0 =========================== >> Models: LGB01 Size of training set: 11362 (10%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.795 Test evaluation --> f1: 0.6169 Time elapsed: 2.726s Bootstrap --------------------------------------- Evaluation --> f1: 0.6025 \u00b1 0.0021 Time elapsed: 2.361s ------------------------------------------------- Total time: 5.088s Final results ==================== >> Total time: 5.089s ------------------------------------- LightGBM --> f1: 0.6025 \u00b1 0.0021 ~ Run: 1 =========================== >> Models: LGB02 Size of training set: 22724 (20%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.711 Test evaluation --> f1: 0.6172 Time elapsed: 3.588s Bootstrap --------------------------------------- Evaluation --> f1: 0.606 \u00b1 0.0021 Time elapsed: 3.214s ------------------------------------------------- Total time: 6.802s Final results ==================== >> Total time: 6.803s ------------------------------------- LightGBM --> f1: 0.606 \u00b1 0.0021 Run: 2 =========================== >> Models: LGB03 Size of training set: 34087 (30%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6844 Test evaluation --> f1: 0.6205 Time elapsed: 4.145s Bootstrap --------------------------------------- Evaluation --> f1: 0.6136 \u00b1 0.0021 Time elapsed: 3.725s ------------------------------------------------- Total time: 7.870s Final results ==================== >> Total time: 7.872s ------------------------------------- LightGBM --> f1: 0.6136 \u00b1 0.0021 Run: 3 =========================== >> Models: LGB04 Size of training set: 45449 (40%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6788 Test evaluation --> f1: 0.6246 Time elapsed: 4.740s Bootstrap --------------------------------------- Evaluation --> f1: 0.6209 \u00b1 0.0012 Time elapsed: 4.361s ------------------------------------------------- Total time: 9.101s Final results ==================== >> Total time: 9.105s ------------------------------------- LightGBM --> f1: 0.6209 \u00b1 0.0012 Run: 4 =========================== >> Models: LGB05 Size of training set: 56812 (50%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6694 Test evaluation --> f1: 0.6256 Time elapsed: 5.560s Bootstrap --------------------------------------- Evaluation --> f1: 0.6231 \u00b1 0.0025 Time elapsed: 5.129s ------------------------------------------------- Total time: 10.689s Final results ==================== >> Total time: 10.693s ------------------------------------- LightGBM --> f1: 0.6231 \u00b1 0.0025 Run: 5 =========================== >> Models: LGB06 Size of training set: 68174 (60%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6623 Test evaluation --> f1: 0.627 Time elapsed: 6.235s Bootstrap --------------------------------------- Evaluation --> f1: 0.6223 \u00b1 0.0043 Time elapsed: 5.758s ------------------------------------------------- Total time: 11.993s Final results ==================== >> Total time: 11.998s ------------------------------------- LightGBM --> f1: 0.6223 \u00b1 0.0043 Run: 6 =========================== >> Models: LGB07 Size of training set: 79536 (70%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6609 Test evaluation --> f1: 0.6307 Time elapsed: 6.979s Bootstrap --------------------------------------- Evaluation --> f1: 0.6254 \u00b1 0.0029 Time elapsed: 6.485s ------------------------------------------------- Total time: 13.465s Final results ==================== >> Total time: 13.469s ------------------------------------- LightGBM --> f1: 0.6254 \u00b1 0.0029 Run: 7 =========================== >> Models: LGB08 Size of training set: 90899 (80%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6588 Test evaluation --> f1: 0.6316 Time elapsed: 7.869s Bootstrap --------------------------------------- Evaluation --> f1: 0.6255 \u00b1 0.002 Time elapsed: 7.227s ------------------------------------------------- Total time: 15.095s Final results ==================== >> Total time: 15.101s ------------------------------------- LightGBM --> f1: 0.6255 \u00b1 0.002 Run: 8 =========================== >> Models: LGB09 Size of training set: 102261 (90%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6601 Test evaluation --> f1: 0.6318 Time elapsed: 8.578s Bootstrap --------------------------------------- Evaluation --> f1: 0.6253 \u00b1 0.0022 Time elapsed: 8.169s ------------------------------------------------- Total time: 16.747s Final results ==================== >> Total time: 16.752s ------------------------------------- LightGBM --> f1: 0.6253 \u00b1 0.0022 Run: 9 =========================== >> Models: LGB10 Size of training set: 113624 (100%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6558 Test evaluation --> f1: 0.631 Time elapsed: 9.401s Bootstrap --------------------------------------- Evaluation --> f1: 0.6258 \u00b1 0.0034 Time elapsed: 8.782s ------------------------------------------------- Total time: 18.183s Final results ==================== >> Total time: 18.190s ------------------------------------- LightGBM --> f1: 0.6258 \u00b1 0.0034 Analyze the results \u00b6 In [5]: Copied! # The results are now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the fraction as well (without the dot) atom . results # The results are now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the fraction as well (without the dot) atom.results Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit score_bootstrap time_bootstrap time frac model 0.1 LGB01 0.7950 0.6169 2.726477 0.602473 2.361145 5.087622 0.2 LGB02 0.7110 0.6172 3.587786 0.605984 3.214102 6.801888 0.3 LGB03 0.6844 0.6205 4.144765 0.613633 3.724748 7.869513 0.4 LGB04 0.6788 0.6246 4.740403 0.620894 4.360960 9.101363 0.5 LGB05 0.6694 0.6256 5.559976 0.623075 5.128658 10.688634 0.6 LGB06 0.6623 0.6270 6.234684 0.622287 5.758230 11.992914 0.7 LGB07 0.6609 0.6307 6.979477 0.625412 6.485406 13.464883 0.8 LGB08 0.6588 0.6316 7.868586 0.625519 7.226822 15.095408 0.9 LGB09 0.6601 0.6318 8.578300 0.625334 8.168814 16.747114 1.0 LGB10 0.6558 0.6310 9.401000 0.625840 8.782370 18.183370 In [7]: Copied! # Every model can be accessed through its name atom . lgb05 . plot_shap_waterfall ( show = 6 ) # Every model can be accessed through its name atom.lgb05.plot_shap_waterfall(show=6) In [8]: Copied! # Plot the train sizing's results atom . plot_learning_curve () # Plot the train sizing's results atom.plot_learning_curve() ", "title": "Train sizing"}, {"location": "examples/train_sizing/#example-train-sizing", "text": "This example shows how to asses a model's performance based on the size of the training set. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Train sizing"}, {"location": "examples/train_sizing/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from atom import ATOMClassifier # Import packages import pandas as pd from atom import ATOMClassifier In [2]: Copied! # Load the data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load the data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/train_sizing/#run-the-pipeline", "text": "In [3]: Copied! # Initialize atom and prepare the data atom = ATOMClassifier ( X , verbose = 2 , random_state = 1 ) atom . clean () atom . impute ( strat_num = \"median\" , strat_cat = \"most_frequent\" , max_nan_rows = 0.8 ) atom . encode () # Initialize atom and prepare the data atom = ATOMClassifier(X, verbose=2, random_state=1) atom.clean() atom.impute(strat_num=\"median\", strat_cat=\"most_frequent\", max_nan_rows=0.8) atom.encode() << ================== ATOM ================== >> Algorithm task: binary classification. Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- | | dataset | train | test | | - | -------------- | -------------- | -------------- | | 0 | 110316 (3.5) | 88253 (3.5) | 22063 (3.5) | | 1 | 31877 (1.0) | 25502 (1.0) | 6375 (1.0) | Fitting Cleaner... Cleaning the data... --> Label-encoding the target column. Fitting Imputer... Imputing missing values... --> Dropping 161 samples for containing more than 16 missing values. --> Imputing 481 missing values with median (12.0) in feature MinTemp. --> Imputing 265 missing values with median (22.6) in feature MaxTemp. --> Imputing 1354 missing values with median (0.0) in feature Rainfall. --> Imputing 60682 missing values with median (4.8) in feature Evaporation. --> Imputing 67659 missing values with median (8.4) in feature Sunshine. --> Imputing 9187 missing values with most_frequent (W) in feature WindGustDir. --> Imputing 9127 missing values with median (39.0) in feature WindGustSpeed. --> Imputing 9852 missing values with most_frequent (N) in feature WindDir9am. --> Imputing 3617 missing values with most_frequent (SE) in feature WindDir3pm. --> Imputing 1187 missing values with median (13.0) in feature WindSpeed9am. --> Imputing 2469 missing values with median (19.0) in feature WindSpeed3pm. --> Imputing 1613 missing values with median (70.0) in feature Humidity9am. --> Imputing 3449 missing values with median (52.0) in feature Humidity3pm. --> Imputing 13863 missing values with median (1017.6) in feature Pressure9am. --> Imputing 13830 missing values with median (1015.2) in feature Pressure3pm. --> Imputing 53496 missing values with median (5.0) in feature Cloud9am. --> Imputing 56933 missing values with median (5.0) in feature Cloud3pm. --> Imputing 743 missing values with median (16.7) in feature Temp9am. --> Imputing 2565 missing values with median (21.1) in feature Temp3pm. --> Imputing 1354 missing values with most_frequent (No) in feature RainToday. Fitting Encoder... Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 49 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. In [4]: Copied! # Analyze the impact of the training set's size on a LightGBM model atom . train_sizing ( \"LGB\" , train_sizes = 10 , n_bootstrap = 5 ) # Analyze the impact of the training set's size on a LightGBM model atom.train_sizing(\"LGB\", train_sizes=10, n_bootstrap=5) Training ========================= >> Metric: f1 Run: 0 =========================== >> Models: LGB01 Size of training set: 11362 (10%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.795 Test evaluation --> f1: 0.6169 Time elapsed: 2.726s Bootstrap --------------------------------------- Evaluation --> f1: 0.6025 \u00b1 0.0021 Time elapsed: 2.361s ------------------------------------------------- Total time: 5.088s Final results ==================== >> Total time: 5.089s ------------------------------------- LightGBM --> f1: 0.6025 \u00b1 0.0021 ~ Run: 1 =========================== >> Models: LGB02 Size of training set: 22724 (20%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.711 Test evaluation --> f1: 0.6172 Time elapsed: 3.588s Bootstrap --------------------------------------- Evaluation --> f1: 0.606 \u00b1 0.0021 Time elapsed: 3.214s ------------------------------------------------- Total time: 6.802s Final results ==================== >> Total time: 6.803s ------------------------------------- LightGBM --> f1: 0.606 \u00b1 0.0021 Run: 2 =========================== >> Models: LGB03 Size of training set: 34087 (30%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6844 Test evaluation --> f1: 0.6205 Time elapsed: 4.145s Bootstrap --------------------------------------- Evaluation --> f1: 0.6136 \u00b1 0.0021 Time elapsed: 3.725s ------------------------------------------------- Total time: 7.870s Final results ==================== >> Total time: 7.872s ------------------------------------- LightGBM --> f1: 0.6136 \u00b1 0.0021 Run: 3 =========================== >> Models: LGB04 Size of training set: 45449 (40%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6788 Test evaluation --> f1: 0.6246 Time elapsed: 4.740s Bootstrap --------------------------------------- Evaluation --> f1: 0.6209 \u00b1 0.0012 Time elapsed: 4.361s ------------------------------------------------- Total time: 9.101s Final results ==================== >> Total time: 9.105s ------------------------------------- LightGBM --> f1: 0.6209 \u00b1 0.0012 Run: 4 =========================== >> Models: LGB05 Size of training set: 56812 (50%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6694 Test evaluation --> f1: 0.6256 Time elapsed: 5.560s Bootstrap --------------------------------------- Evaluation --> f1: 0.6231 \u00b1 0.0025 Time elapsed: 5.129s ------------------------------------------------- Total time: 10.689s Final results ==================== >> Total time: 10.693s ------------------------------------- LightGBM --> f1: 0.6231 \u00b1 0.0025 Run: 5 =========================== >> Models: LGB06 Size of training set: 68174 (60%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6623 Test evaluation --> f1: 0.627 Time elapsed: 6.235s Bootstrap --------------------------------------- Evaluation --> f1: 0.6223 \u00b1 0.0043 Time elapsed: 5.758s ------------------------------------------------- Total time: 11.993s Final results ==================== >> Total time: 11.998s ------------------------------------- LightGBM --> f1: 0.6223 \u00b1 0.0043 Run: 6 =========================== >> Models: LGB07 Size of training set: 79536 (70%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6609 Test evaluation --> f1: 0.6307 Time elapsed: 6.979s Bootstrap --------------------------------------- Evaluation --> f1: 0.6254 \u00b1 0.0029 Time elapsed: 6.485s ------------------------------------------------- Total time: 13.465s Final results ==================== >> Total time: 13.469s ------------------------------------- LightGBM --> f1: 0.6254 \u00b1 0.0029 Run: 7 =========================== >> Models: LGB08 Size of training set: 90899 (80%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6588 Test evaluation --> f1: 0.6316 Time elapsed: 7.869s Bootstrap --------------------------------------- Evaluation --> f1: 0.6255 \u00b1 0.002 Time elapsed: 7.227s ------------------------------------------------- Total time: 15.095s Final results ==================== >> Total time: 15.101s ------------------------------------- LightGBM --> f1: 0.6255 \u00b1 0.002 Run: 8 =========================== >> Models: LGB09 Size of training set: 102261 (90%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6601 Test evaluation --> f1: 0.6318 Time elapsed: 8.578s Bootstrap --------------------------------------- Evaluation --> f1: 0.6253 \u00b1 0.0022 Time elapsed: 8.169s ------------------------------------------------- Total time: 16.747s Final results ==================== >> Total time: 16.752s ------------------------------------- LightGBM --> f1: 0.6253 \u00b1 0.0022 Run: 9 =========================== >> Models: LGB10 Size of training set: 113624 (100%) Size of test set: 28408 Results for LightGBM: Fit --------------------------------------------- Train evaluation --> f1: 0.6558 Test evaluation --> f1: 0.631 Time elapsed: 9.401s Bootstrap --------------------------------------- Evaluation --> f1: 0.6258 \u00b1 0.0034 Time elapsed: 8.782s ------------------------------------------------- Total time: 18.183s Final results ==================== >> Total time: 18.190s ------------------------------------- LightGBM --> f1: 0.6258 \u00b1 0.0034", "title": "Run the pipeline"}, {"location": "examples/train_sizing/#analyze-the-results", "text": "In [5]: Copied! # The results are now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the fraction as well (without the dot) atom . results # The results are now multi-index, where frac is the fraction # of the training set used to fit the model. The model names # end with the fraction as well (without the dot) atom.results Out[5]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_train score_test time_fit score_bootstrap time_bootstrap time frac model 0.1 LGB01 0.7950 0.6169 2.726477 0.602473 2.361145 5.087622 0.2 LGB02 0.7110 0.6172 3.587786 0.605984 3.214102 6.801888 0.3 LGB03 0.6844 0.6205 4.144765 0.613633 3.724748 7.869513 0.4 LGB04 0.6788 0.6246 4.740403 0.620894 4.360960 9.101363 0.5 LGB05 0.6694 0.6256 5.559976 0.623075 5.128658 10.688634 0.6 LGB06 0.6623 0.6270 6.234684 0.622287 5.758230 11.992914 0.7 LGB07 0.6609 0.6307 6.979477 0.625412 6.485406 13.464883 0.8 LGB08 0.6588 0.6316 7.868586 0.625519 7.226822 15.095408 0.9 LGB09 0.6601 0.6318 8.578300 0.625334 8.168814 16.747114 1.0 LGB10 0.6558 0.6310 9.401000 0.625840 8.782370 18.183370 In [7]: Copied! # Every model can be accessed through its name atom . lgb05 . plot_shap_waterfall ( show = 6 ) # Every model can be accessed through its name atom.lgb05.plot_shap_waterfall(show=6) In [8]: Copied! # Plot the train sizing's results atom . plot_learning_curve () # Plot the train sizing's results atom.plot_learning_curve() ", "title": "Analyze the results"}, {"location": "examples/utilities/", "text": "Example: Utilities \u00b6 This example shows various useful utilities that can be used to improve atom's pipelines. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow . Load the data \u00b6 In [1]: Copied! # Import packages import pandas as pd from sklearn.metrics import fbeta_score from atom import ATOMClassifier , ATOMLoader # Import packages import pandas as pd from sklearn.metrics import fbeta_score from atom import ATOMClassifier, ATOMLoader In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns Use the utility attributes \u00b6 In [3]: Copied! atom = ATOMClassifier ( X , random_state = 1 ) atom . clean () # Quickly check what columns have missing values print ( f \"Columns with missing values: \\n { atom . nans } \" ) # Or what columns are categorical print ( f \" \\n Categorical columns: { atom . categorical } \" ) # Or if the dataset is scaled print ( f \" \\n Is the dataset scaled? { atom . scaled } \" ) atom = ATOMClassifier(X, random_state=1) atom.clean() # Quickly check what columns have missing values print(f\"Columns with missing values:\\n{atom.nans}\") # Or what columns are categorical print(f\"\\nCategorical columns: {atom.categorical}\") # Or if the dataset is scaled print(f\"\\nIs the dataset scaled? {atom.scaled}\") Columns with missing values: MinTemp 637 MaxTemp 322 Rainfall 1406 Evaporation 60843 Sunshine 67816 WindGustDir 9330 WindGustSpeed 9270 WindDir9am 10013 WindDir3pm 3778 WindSpeed9am 1348 WindSpeed3pm 2630 Humidity9am 1774 Humidity3pm 3610 Pressure9am 14014 Pressure3pm 13981 Cloud9am 53657 Cloud3pm 57094 Temp9am 904 Temp3pm 2726 RainToday 1406 dtype: int64 Categorical columns: Index(['Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainToday'], dtype='object') Is the dataset scaled? False Use the stats method to assess changes in the dataset \u00b6 In [4]: Copied! # Note the number of missing values and categorical columns atom . stats () # Note the number of missing values and categorical columns atom.stats() Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- | | dataset | train | test | | - | --------- | --------- | --------- | | 0 | 0 (0.0) | 0 (0.0) | 0 (0.0) | | 1 | 0 (0.0) | 0 (0.0) | 0 (0.0) | In [5]: Copied! # Now, let's impute and encode the dataset... atom . impute () atom . encode () # ... and the values are gone atom . stats () # Now, let's impute and encode the dataset... atom.impute() atom.encode() # ... and the values are gone atom.stats() Dataset stats ==================== >> Shape: (56420, 22) Memory: 9.93 MB Scaled: False Outlier values: 3203 (0.3%) ------------------------------------- Train set size: 45075 Test set size: 11345 ------------------------------------- | | dataset | train | test | | - | --------- | --------- | --------- | | 0 | 0 (0.0) | 0 (0.0) | 0 (0.0) | | 1 | 0 (0.0) | 0 (0.0) | 0 (0.0) | Inspect feature distributions \u00b6 In [6]: Copied! # Compare the relationship of multiple columns with a scatter maxtrix atom . plot_relationships ( columns = slice ( 0 , 5 )) # Compare the relationship of multiple columns with a scatter maxtrix atom.plot_relationships(columns=slice(0, 5))  In [7]: Copied! # Check which distribution fits a column best atom . distribution ( columns = \"Rainfall\" ) # Check which distribution fits a column best atom.distribution(columns=\"Rainfall\") Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Rainfall dist stat beta score 0.6506 p_value 0.0 expon score 0.6506 p_value 0.0 gamma score 0.6465 p_value 0.0 invgauss score 0.6257 p_value 0.0 lognorm score 0.6485 p_value 0.0 norm score 0.3807 p_value 0.0 pearson3 score 0.6506 p_value 0.0 triang score 0.7191 p_value 0.0 uniform score 0.8914 p_value 0.0 weibull_min score 0.6506 p_value 0.0 weibull_max score 0.8896 p_value 0.0 In [8]: Copied! # Investigate a column's distribution atom . plot_distribution ( columns = \"MinTemp\" , distributions = \"beta\" ) atom . plot_qq ( columns = \"MinTemp\" , distributions = \"beta\" ) # Investigate a column's distribution atom.plot_distribution(columns=\"MinTemp\", distributions=\"beta\") atom.plot_qq(columns=\"MinTemp\", distributions=\"beta\")   Change the data mid-pipeline \u00b6 There are two ways to quickly transform the dataset mid-pipeline. The first way is through the property's @setter . The downside for this approach is that the transformation is not stored in atom's pipeline, so the transformation is not applied on new data. Therefore, we recommend using the second approach, through the add method. In [9]: Copied! # Note that we can only replace a dataframe with a new dataframe! atom . X = atom . X . assign ( AvgTemp = ( atom . X [ \"MaxTemp\" ] + atom . X [ \"MinTemp\" ]) / 2 ) # This will automatically update all other data attributes assert \"AvgTemp\" in atom # But it's not saved to atom's pipeline atom . pipeline # Note that we can only replace a dataframe with a new dataframe! atom.X = atom.X.assign(AvgTemp=(atom.X[\"MaxTemp\"] + atom.X[\"MinTemp\"])/2) # This will automatically update all other data attributes assert \"AvgTemp\" in atom # But it's not saved to atom's pipeline atom.pipeline Out[9]: 0 Cleaner() 1 Imputer() 2 Encoder() dtype: object In [12]: Copied! # Same transformation, different approach (AvgTemp is overwritten) def transform ( df ): df [ \"AvgTemp\" ] = ( df . MaxTemp + df . MinTemp ) / 2 return df atom . apply ( transform ) assert \"AvgTemp\" in atom # Same transformation, different approach (AvgTemp is overwritten) def transform(df): df[\"AvgTemp\"] = (df.MaxTemp + df.MinTemp) / 2 return df atom.apply(transform) assert \"AvgTemp\" in atom In [13]: Copied! # Now the function appears in the pipeline atom . pipeline # Now the function appears in the pipeline atom.pipeline Out[13]: 0 Cleaner() 1 Imputer() 2 Encoder() 3 FunctionTransformer(func=<function transform a... dtype: object Get an overview of the available models \u00b6 In [14]: Copied! atom . available_models () atom.available_models() Out[14]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model estimator module needs_scaling accepts_sparse has_validation supports_engines 0 AdaB AdaBoost AdaBoostClassifier sklearnensemble False True False sklearn 1 Bag Bagging BaggingClassifier sklearnensemble False True False sklearn 2 BNB BernoulliNB BernoulliNB sklearnnaive_bayes False True False sklearn, cuml 3 CatB CatBoost CatBoostClassifier catboostcatboost True True True catboost 4 CatNB CategoricalNB CategoricalNB sklearnnaive_bayes False True False sklearn, cuml 5 CNB ComplementNB ComplementNB sklearnnaive_bayes False True False sklearn, cuml 6 Tree DecisionTree DecisionTreeClassifier sklearntree False True False sklearn 7 Dummy Dummy DummyClassifier sklearndummy False False False sklearn 8 ETree ExtraTree ExtraTreeClassifier sklearntree False True False sklearn 9 ET ExtraTrees ExtraTreesClassifier sklearnensemble False True False sklearn 10 GNB GaussianNB GaussianNB sklearnnaive_bayes False False False sklearn, cuml 11 GP GaussianProcess GaussianProcessClassifier sklearngaussian_process False False False sklearn 12 GBM GradientBoosting GradientBoostingClassifier sklearnensemble False True False sklearn 13 hGBM HistGradientBoosting HistGradientBoostingClassifier sklearnensemble False False False sklearn 14 KNN KNearestNeighbors KNeighborsClassifier sklearnneighbors True True False sklearn, sklearnex, cuml 15 LGB LightGBM LGBMClassifier lightgbmlightgbm.sklearn True True True lightgbm 16 LDA LinearDiscriminantAnalysis LinearDiscriminantAnalysis sklearndiscriminant_analysis False False False sklearn 17 lSVM LinearSVM LinearSVC sklearnsvm True True False sklearn, cuml 18 LR LogisticRegression LogisticRegression sklearnlinear_model True True False sklearn, sklearnex, cuml 19 MLP MultiLayerPerceptron MLPClassifier sklearnneural_network True True True sklearn 20 MNB MultinomialNB MultinomialNB sklearnnaive_bayes False True False sklearn, cuml 21 PA PassiveAggressive PassiveAggressiveClassifier sklearnlinear_model True True True sklearn 22 Perc Perceptron Perceptron sklearnlinear_model True False True sklearn 23 QDA QuadraticDiscriminantAnalysis QuadraticDiscriminantAnalysis sklearndiscriminant_analysis False False False sklearn 24 RNN RadiusNearestNeighbors RadiusNeighborsClassifier sklearnneighbors True True False sklearn 25 RF RandomForest RandomForestClassifier sklearnensemble False True False sklearn, sklearnex, cuml 26 Ridge Ridge RidgeClassifier sklearnlinear_model True True False sklearn, sklearnex, cuml 27 SGD StochasticGradientDescent SGDClassifier sklearnlinear_model True True True sklearn 28 SVM SupportVectorMachine SVC sklearnsvm True True False sklearn, sklearnex, cuml 29 XGB XGBoost XGBClassifier xgboostxgboost True True True xgboost Use a custom metric \u00b6 In [15]: Copied! atom . verbose = 1 # Define a custom metric def f2 ( y_true , y_pred ): return fbeta_score ( y_true , y_pred , beta = 2 ) # Use the greater_is_better, needs_proba and needs_threshold parameters if necessary atom . run ( models = \"LR\" , metric = f2 ) atom.verbose = 1 # Define a custom metric def f2(y_true, y_pred): return fbeta_score(y_true, y_pred, beta=2) # Use the greater_is_better, needs_proba and needs_threshold parameters if necessary atom.run(models=\"LR\", metric=f2) Training ========================= >> Models: LR Metric: f2 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> f2: 0.5693 Test evaluation --> f2: 0.5709 Time elapsed: 0.299s ------------------------------------------------- Total time: 0.299s Final results ==================== >> Total time: 0.301s ------------------------------------- LogisticRegression --> f2: 0.5709 Customize the estimator's parameters \u00b6 In [16]: Copied! # You can use the est_params parameter to customize the estimator # Let's run AdaBoost using LR instead of a decision tree as base estimator atom . run ( \"AdaB\" , est_params = { \"base_estimator\" : atom . lr . estimator }) # You can use the est_params parameter to customize the estimator # Let's run AdaBoost using LR instead of a decision tree as base estimator atom.run(\"AdaB\", est_params={\"base_estimator\": atom.lr.estimator}) Training ========================= >> Models: AdaB Metric: f2 Results for AdaBoost: Fit --------------------------------------------- Train evaluation --> f2: 0.5579 Test evaluation --> f2: 0.5639 Time elapsed: 2.248s ------------------------------------------------- Total time: 2.248s Final results ==================== >> Total time: 2.250s ------------------------------------- AdaBoost --> f2: 0.5639 In [17]: Copied! atom . adab . estimator atom.adab.estimator Out[17]: #sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"\u25b8\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"\u25be\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;} AdaBoostClassifier(base_estimator=LogisticRegression(n_jobs=1, random_state=1), random_state=1) In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. AdaBoostClassifier AdaBoostClassifier(base_estimator=LogisticRegression(n_jobs=1, random_state=1), random_state=1) base_estimator: LogisticRegression LogisticRegression(n_jobs=1, random_state=1) LogisticRegression LogisticRegression(n_jobs=1, random_state=1) In [19]: Copied! # Note that parameters specified by est_params are not optimized in the BO atom . run ( models = \"Tree\" , n_trials = 10 , est_params = { \"criterion\" : \"gini\" , \"splitter\" : \"best\" , \"min_samples_leaf\" : 1 , \"ccp_alpha\" : 0.035 , }, verbose = 2 , ) # Note that parameters specified by est_params are not optimized in the BO atom.run( models=\"Tree\", n_trials=10, est_params={ \"criterion\": \"gini\", \"splitter\": \"best\", \"min_samples_leaf\": 1, \"ccp_alpha\": 0.035, }, verbose=2, ) Training ========================= >> Models: Tree Metric: f2 Running hyperparameter tuning for DecisionTree... | trial | max_depth | min_samples_split | max_features | f2 | best_f2 | time_trial | time_ht | state | | ----- | --------- | ----------------- | ------------ | ------- | ------- | ---------- | ------- | -------- | | 0 | 13 | 12 | 0.5 | 0.4362 | 0.4362 | 1.791s | 1.791s | COMPLETE | | 1 | 14 | 16 | log2 | 0.4729 | 0.4729 | 1.375s | 3.166s | COMPLETE | | 2 | 16 | 13 | 0.8 | 0.4626 | 0.4729 | 1.631s | 4.798s | COMPLETE | | 3 | 9 | 6 | None | 0.4903 | 0.4903 | 1.588s | 6.386s | COMPLETE | | 4 | 5 | 2 | log2 | 0.4889 | 0.4903 | 1.497s | 7.883s | COMPLETE | | 5 | 1 | 15 | 0.5 | 0.4953 | 0.4953 | 1.567s | 9.450s | COMPLETE | | 6 | 15 | 9 | sqrt | 0.5004 | 0.5004 | 1.640s | 11.091s | COMPLETE | | 7 | 13 | 20 | None | 0.5004 | 0.5004 | 1.833s | 12.924s | COMPLETE | | 8 | 3 | 19 | 0.5 | 0.4936 | 0.5004 | 1.506s | 14.430s | COMPLETE | | 9 | 15 | 20 | sqrt | 0.4762 | 0.5004 | 1.575s | 16.005s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 6 Best parameters: --> max_depth: 15 --> min_samples_split: 9 --> max_features: sqrt Best evaluation --> f2: 0.5004 Time elapsed: 16.005s Fit --------------------------------------------- Train evaluation --> f2: 0.4925 Test evaluation --> f2: 0.4925 Time elapsed: 0.167s ------------------------------------------------- Total time: 16.172s Final results ==================== >> Total time: 16.199s ------------------------------------- DecisionTree --> f2: 0.4925 Save & load \u00b6 Note that both instances need to be initialized with the same data and use the same metric for model training to be able to merge. In [20]: Copied! # Save the atom instance as a pickle # Use save_data=False to save the instance without the data atom . save ( \"atom\" , save_data = False ) # Save the atom instance as a pickle # Use save_data=False to save the instance without the data atom.save(\"atom\", save_data=False) ATOMClassifier successfully saved. In [21]: Copied! # Load the instance again with ATOMLoader # No need to store the transformed data, providing the original dataset to # the loader automatically transforms it through all the steps in the pipeline atom_2 = ATOMLoader ( \"atom\" , data = ( X ,), verbose = 2 ) # Load the instance again with ATOMLoader # No need to store the transformed data, providing the original dataset to # the loader automatically transforms it through all the steps in the pipeline atom_2 = ATOMLoader(\"atom\", data=(X,), verbose=2) Cleaning the data... --> Label-encoding the target column. Imputing missing values... --> Dropping 637 samples due to missing values in feature MinTemp. --> Dropping 322 samples due to missing values in feature MaxTemp. --> Dropping 1406 samples due to missing values in feature Rainfall. --> Dropping 60843 samples due to missing values in feature Evaporation. --> Dropping 67816 samples due to missing values in feature Sunshine. --> Dropping 9330 samples due to missing values in feature WindGustDir. --> Dropping 9270 samples due to missing values in feature WindGustSpeed. --> Dropping 10013 samples due to missing values in feature WindDir9am. --> Dropping 3778 samples due to missing values in feature WindDir3pm. --> Dropping 1348 samples due to missing values in feature WindSpeed9am. --> Dropping 2630 samples due to missing values in feature WindSpeed3pm. --> Dropping 1774 samples due to missing values in feature Humidity9am. --> Dropping 3610 samples due to missing values in feature Humidity3pm. --> Dropping 14014 samples due to missing values in feature Pressure9am. --> Dropping 13981 samples due to missing values in feature Pressure3pm. --> Dropping 53657 samples due to missing values in feature Cloud9am. --> Dropping 57094 samples due to missing values in feature Cloud3pm. --> Dropping 904 samples due to missing values in feature Temp9am. --> Dropping 2726 samples due to missing values in feature Temp3pm. --> Dropping 1406 samples due to missing values in feature RainToday. Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 26 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. ATOMClassifier successfully loaded. In [24]: Copied! # Create a separate instance with its own branch and model atom_3 = ATOMClassifier ( X , verbose = 0 , random_state = 1 ) atom_3 . branch . name = \"lightgbm\" atom_3 . impute () atom_3 . encode () atom_3 . run ( \"LGB\" , metric = f2 ) # Create a separate instance with its own branch and model atom_3 = ATOMClassifier(X, verbose=0, random_state=1) atom_3.branch.name = \"lightgbm\" atom_3.impute() atom_3.encode() atom_3.run(\"LGB\", metric=f2) In [25]: Copied! # Merge the instances atom_2 . merge ( atom_3 ) # Merge the instances atom_2.merge(atom_3) Merging instances... --> Merging branch lightgbm. --> Merging model LGB. --> Merging attributes. In [26]: Copied! # Note that it now contains both branches and all models atom_2 # Note that it now contains both branches and all models atom_2 Out[26]: ATOMClassifier --> Branches: --> master ! --> lightgbm --> Models: LR, AdaB, Tree, LGB --> Metric: f2 --> Errors: 0 In [27]: Copied! atom_2 . results atom_2.results Out[27]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_ht time_ht score_train score_test time_fit time LR NaN NaN 0.5693 0.5709 0.299272 0.299272 AdaB NaN NaN 0.5579 0.5639 2.247532 2.247532 Tree 0.500381 16.00508 0.4925 0.4925 0.167152 16.172232 LGB NaN NaN 0.6578 0.5909 3.562652 3.562652", "title": "Utilities"}, {"location": "examples/utilities/#example-utilities", "text": "This example shows various useful utilities that can be used to improve atom's pipelines. The data used is a variation on the Australian weather dataset from Kaggle. You can download it from here . The goal of this dataset is to predict whether or not it will rain tomorrow training a binary classifier on target RainTomorrow .", "title": "Example: Utilities"}, {"location": "examples/utilities/#load-the-data", "text": "In [1]: Copied! # Import packages import pandas as pd from sklearn.metrics import fbeta_score from atom import ATOMClassifier , ATOMLoader # Import packages import pandas as pd from sklearn.metrics import fbeta_score from atom import ATOMClassifier, ATOMLoader In [2]: Copied! # Load data X = pd . read_csv ( \"./datasets/weatherAUS.csv\" ) # Let's have a look X . head () # Load data X = pd.read_csv(\"./datasets/weatherAUS.csv\") # Let's have a look X.head() Out[2]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am WindDir3pm ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 MelbourneAirport 18.0 26.9 21.4 7.0 8.9 SSE 41.0 W SSE ... 95.0 54.0 1019.5 1017.0 8.0 5.0 18.5 26.0 Yes 0 1 Adelaide 17.2 23.4 0.0 NaN NaN S 41.0 S WSW ... 59.0 36.0 1015.7 1015.7 NaN NaN 17.7 21.9 No 0 2 Cairns 18.6 24.6 7.4 3.0 6.1 SSE 54.0 SSE SE ... 78.0 57.0 1018.7 1016.6 3.0 3.0 20.8 24.1 Yes 0 3 Portland 13.6 16.8 4.2 1.2 0.0 ESE 39.0 ESE ESE ... 76.0 74.0 1021.4 1020.5 7.0 8.0 15.6 16.0 Yes 1 4 Walpole 16.4 19.9 0.0 NaN NaN SE 44.0 SE SE ... 78.0 70.0 1019.4 1018.9 NaN NaN 17.4 18.1 No 0 5 rows \u00d7 22 columns", "title": "Load the data"}, {"location": "examples/utilities/#use-the-utility-attributes", "text": "In [3]: Copied! atom = ATOMClassifier ( X , random_state = 1 ) atom . clean () # Quickly check what columns have missing values print ( f \"Columns with missing values: \\n { atom . nans } \" ) # Or what columns are categorical print ( f \" \\n Categorical columns: { atom . categorical } \" ) # Or if the dataset is scaled print ( f \" \\n Is the dataset scaled? { atom . scaled } \" ) atom = ATOMClassifier(X, random_state=1) atom.clean() # Quickly check what columns have missing values print(f\"Columns with missing values:\\n{atom.nans}\") # Or what columns are categorical print(f\"\\nCategorical columns: {atom.categorical}\") # Or if the dataset is scaled print(f\"\\nIs the dataset scaled? {atom.scaled}\") Columns with missing values: MinTemp 637 MaxTemp 322 Rainfall 1406 Evaporation 60843 Sunshine 67816 WindGustDir 9330 WindGustSpeed 9270 WindDir9am 10013 WindDir3pm 3778 WindSpeed9am 1348 WindSpeed3pm 2630 Humidity9am 1774 Humidity3pm 3610 Pressure9am 14014 Pressure3pm 13981 Cloud9am 53657 Cloud3pm 57094 Temp9am 904 Temp3pm 2726 RainToday 1406 dtype: int64 Categorical columns: Index(['Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainToday'], dtype='object') Is the dataset scaled? False", "title": "Use the utility attributes"}, {"location": "examples/utilities/#use-the-stats-method-to-assess-changes-in-the-dataset", "text": "In [4]: Copied! # Note the number of missing values and categorical columns atom . stats () # Note the number of missing values and categorical columns atom.stats() Dataset stats ==================== >> Shape: (142193, 22) Memory: 61.69 MB Scaled: False Missing values: 316559 (10.1%) Categorical features: 5 (23.8%) Duplicate samples: 45 (0.0%) ------------------------------------- Train set size: 113755 Test set size: 28438 ------------------------------------- | | dataset | train | test | | - | --------- | --------- | --------- | | 0 | 0 (0.0) | 0 (0.0) | 0 (0.0) | | 1 | 0 (0.0) | 0 (0.0) | 0 (0.0) | In [5]: Copied! # Now, let's impute and encode the dataset... atom . impute () atom . encode () # ... and the values are gone atom . stats () # Now, let's impute and encode the dataset... atom.impute() atom.encode() # ... and the values are gone atom.stats() Dataset stats ==================== >> Shape: (56420, 22) Memory: 9.93 MB Scaled: False Outlier values: 3203 (0.3%) ------------------------------------- Train set size: 45075 Test set size: 11345 ------------------------------------- | | dataset | train | test | | - | --------- | --------- | --------- | | 0 | 0 (0.0) | 0 (0.0) | 0 (0.0) | | 1 | 0 (0.0) | 0 (0.0) | 0 (0.0) |", "title": "Use the stats method to assess changes in the dataset"}, {"location": "examples/utilities/#inspect-feature-distributions", "text": "In [6]: Copied! # Compare the relationship of multiple columns with a scatter maxtrix atom . plot_relationships ( columns = slice ( 0 , 5 )) # Compare the relationship of multiple columns with a scatter maxtrix atom.plot_relationships(columns=slice(0, 5))  In [7]: Copied! # Check which distribution fits a column best atom . distribution ( columns = \"Rainfall\" ) # Check which distribution fits a column best atom.distribution(columns=\"Rainfall\") Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Rainfall dist stat beta score 0.6506 p_value 0.0 expon score 0.6506 p_value 0.0 gamma score 0.6465 p_value 0.0 invgauss score 0.6257 p_value 0.0 lognorm score 0.6485 p_value 0.0 norm score 0.3807 p_value 0.0 pearson3 score 0.6506 p_value 0.0 triang score 0.7191 p_value 0.0 uniform score 0.8914 p_value 0.0 weibull_min score 0.6506 p_value 0.0 weibull_max score 0.8896 p_value 0.0 In [8]: Copied! # Investigate a column's distribution atom . plot_distribution ( columns = \"MinTemp\" , distributions = \"beta\" ) atom . plot_qq ( columns = \"MinTemp\" , distributions = \"beta\" ) # Investigate a column's distribution atom.plot_distribution(columns=\"MinTemp\", distributions=\"beta\") atom.plot_qq(columns=\"MinTemp\", distributions=\"beta\")  ", "title": "Inspect feature distributions"}, {"location": "examples/utilities/#change-the-data-mid-pipeline", "text": "There are two ways to quickly transform the dataset mid-pipeline. The first way is through the property's @setter . The downside for this approach is that the transformation is not stored in atom's pipeline, so the transformation is not applied on new data. Therefore, we recommend using the second approach, through the add method. In [9]: Copied! # Note that we can only replace a dataframe with a new dataframe! atom . X = atom . X . assign ( AvgTemp = ( atom . X [ \"MaxTemp\" ] + atom . X [ \"MinTemp\" ]) / 2 ) # This will automatically update all other data attributes assert \"AvgTemp\" in atom # But it's not saved to atom's pipeline atom . pipeline # Note that we can only replace a dataframe with a new dataframe! atom.X = atom.X.assign(AvgTemp=(atom.X[\"MaxTemp\"] + atom.X[\"MinTemp\"])/2) # This will automatically update all other data attributes assert \"AvgTemp\" in atom # But it's not saved to atom's pipeline atom.pipeline Out[9]: 0 Cleaner() 1 Imputer() 2 Encoder() dtype: object In [12]: Copied! # Same transformation, different approach (AvgTemp is overwritten) def transform ( df ): df [ \"AvgTemp\" ] = ( df . MaxTemp + df . MinTemp ) / 2 return df atom . apply ( transform ) assert \"AvgTemp\" in atom # Same transformation, different approach (AvgTemp is overwritten) def transform(df): df[\"AvgTemp\"] = (df.MaxTemp + df.MinTemp) / 2 return df atom.apply(transform) assert \"AvgTemp\" in atom In [13]: Copied! # Now the function appears in the pipeline atom . pipeline # Now the function appears in the pipeline atom.pipeline Out[13]: 0 Cleaner() 1 Imputer() 2 Encoder() 3 FunctionTransformer(func=<function transform a... dtype: object", "title": "Change the data mid-pipeline"}, {"location": "examples/utilities/#get-an-overview-of-the-available-models", "text": "In [14]: Copied! atom . available_models () atom.available_models() Out[14]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } acronym model estimator module needs_scaling accepts_sparse has_validation supports_engines 0 AdaB AdaBoost AdaBoostClassifier sklearnensemble False True False sklearn 1 Bag Bagging BaggingClassifier sklearnensemble False True False sklearn 2 BNB BernoulliNB BernoulliNB sklearnnaive_bayes False True False sklearn, cuml 3 CatB CatBoost CatBoostClassifier catboostcatboost True True True catboost 4 CatNB CategoricalNB CategoricalNB sklearnnaive_bayes False True False sklearn, cuml 5 CNB ComplementNB ComplementNB sklearnnaive_bayes False True False sklearn, cuml 6 Tree DecisionTree DecisionTreeClassifier sklearntree False True False sklearn 7 Dummy Dummy DummyClassifier sklearndummy False False False sklearn 8 ETree ExtraTree ExtraTreeClassifier sklearntree False True False sklearn 9 ET ExtraTrees ExtraTreesClassifier sklearnensemble False True False sklearn 10 GNB GaussianNB GaussianNB sklearnnaive_bayes False False False sklearn, cuml 11 GP GaussianProcess GaussianProcessClassifier sklearngaussian_process False False False sklearn 12 GBM GradientBoosting GradientBoostingClassifier sklearnensemble False True False sklearn 13 hGBM HistGradientBoosting HistGradientBoostingClassifier sklearnensemble False False False sklearn 14 KNN KNearestNeighbors KNeighborsClassifier sklearnneighbors True True False sklearn, sklearnex, cuml 15 LGB LightGBM LGBMClassifier lightgbmlightgbm.sklearn True True True lightgbm 16 LDA LinearDiscriminantAnalysis LinearDiscriminantAnalysis sklearndiscriminant_analysis False False False sklearn 17 lSVM LinearSVM LinearSVC sklearnsvm True True False sklearn, cuml 18 LR LogisticRegression LogisticRegression sklearnlinear_model True True False sklearn, sklearnex, cuml 19 MLP MultiLayerPerceptron MLPClassifier sklearnneural_network True True True sklearn 20 MNB MultinomialNB MultinomialNB sklearnnaive_bayes False True False sklearn, cuml 21 PA PassiveAggressive PassiveAggressiveClassifier sklearnlinear_model True True True sklearn 22 Perc Perceptron Perceptron sklearnlinear_model True False True sklearn 23 QDA QuadraticDiscriminantAnalysis QuadraticDiscriminantAnalysis sklearndiscriminant_analysis False False False sklearn 24 RNN RadiusNearestNeighbors RadiusNeighborsClassifier sklearnneighbors True True False sklearn 25 RF RandomForest RandomForestClassifier sklearnensemble False True False sklearn, sklearnex, cuml 26 Ridge Ridge RidgeClassifier sklearnlinear_model True True False sklearn, sklearnex, cuml 27 SGD StochasticGradientDescent SGDClassifier sklearnlinear_model True True True sklearn 28 SVM SupportVectorMachine SVC sklearnsvm True True False sklearn, sklearnex, cuml 29 XGB XGBoost XGBClassifier xgboostxgboost True True True xgboost", "title": "Get an overview of the available models"}, {"location": "examples/utilities/#use-a-custom-metric", "text": "In [15]: Copied! atom . verbose = 1 # Define a custom metric def f2 ( y_true , y_pred ): return fbeta_score ( y_true , y_pred , beta = 2 ) # Use the greater_is_better, needs_proba and needs_threshold parameters if necessary atom . run ( models = \"LR\" , metric = f2 ) atom.verbose = 1 # Define a custom metric def f2(y_true, y_pred): return fbeta_score(y_true, y_pred, beta=2) # Use the greater_is_better, needs_proba and needs_threshold parameters if necessary atom.run(models=\"LR\", metric=f2) Training ========================= >> Models: LR Metric: f2 Results for LogisticRegression: Fit --------------------------------------------- Train evaluation --> f2: 0.5693 Test evaluation --> f2: 0.5709 Time elapsed: 0.299s ------------------------------------------------- Total time: 0.299s Final results ==================== >> Total time: 0.301s ------------------------------------- LogisticRegression --> f2: 0.5709", "title": "Use a custom metric"}, {"location": "examples/utilities/#customize-the-estimators-parameters", "text": "In [16]: Copied! # You can use the est_params parameter to customize the estimator # Let's run AdaBoost using LR instead of a decision tree as base estimator atom . run ( \"AdaB\" , est_params = { \"base_estimator\" : atom . lr . estimator }) # You can use the est_params parameter to customize the estimator # Let's run AdaBoost using LR instead of a decision tree as base estimator atom.run(\"AdaB\", est_params={\"base_estimator\": atom.lr.estimator}) Training ========================= >> Models: AdaB Metric: f2 Results for AdaBoost: Fit --------------------------------------------- Train evaluation --> f2: 0.5579 Test evaluation --> f2: 0.5639 Time elapsed: 2.248s ------------------------------------------------- Total time: 2.248s Final results ==================== >> Total time: 2.250s ------------------------------------- AdaBoost --> f2: 0.5639 In [17]: Copied! atom . adab . estimator atom.adab.estimator Out[17]: #sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"\u25b8\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"\u25be\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;} AdaBoostClassifier(base_estimator=LogisticRegression(n_jobs=1, random_state=1), random_state=1) In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. AdaBoostClassifier AdaBoostClassifier(base_estimator=LogisticRegression(n_jobs=1, random_state=1), random_state=1) base_estimator: LogisticRegression LogisticRegression(n_jobs=1, random_state=1) LogisticRegression LogisticRegression(n_jobs=1, random_state=1) In [19]: Copied! # Note that parameters specified by est_params are not optimized in the BO atom . run ( models = \"Tree\" , n_trials = 10 , est_params = { \"criterion\" : \"gini\" , \"splitter\" : \"best\" , \"min_samples_leaf\" : 1 , \"ccp_alpha\" : 0.035 , }, verbose = 2 , ) # Note that parameters specified by est_params are not optimized in the BO atom.run( models=\"Tree\", n_trials=10, est_params={ \"criterion\": \"gini\", \"splitter\": \"best\", \"min_samples_leaf\": 1, \"ccp_alpha\": 0.035, }, verbose=2, ) Training ========================= >> Models: Tree Metric: f2 Running hyperparameter tuning for DecisionTree... | trial | max_depth | min_samples_split | max_features | f2 | best_f2 | time_trial | time_ht | state | | ----- | --------- | ----------------- | ------------ | ------- | ------- | ---------- | ------- | -------- | | 0 | 13 | 12 | 0.5 | 0.4362 | 0.4362 | 1.791s | 1.791s | COMPLETE | | 1 | 14 | 16 | log2 | 0.4729 | 0.4729 | 1.375s | 3.166s | COMPLETE | | 2 | 16 | 13 | 0.8 | 0.4626 | 0.4729 | 1.631s | 4.798s | COMPLETE | | 3 | 9 | 6 | None | 0.4903 | 0.4903 | 1.588s | 6.386s | COMPLETE | | 4 | 5 | 2 | log2 | 0.4889 | 0.4903 | 1.497s | 7.883s | COMPLETE | | 5 | 1 | 15 | 0.5 | 0.4953 | 0.4953 | 1.567s | 9.450s | COMPLETE | | 6 | 15 | 9 | sqrt | 0.5004 | 0.5004 | 1.640s | 11.091s | COMPLETE | | 7 | 13 | 20 | None | 0.5004 | 0.5004 | 1.833s | 12.924s | COMPLETE | | 8 | 3 | 19 | 0.5 | 0.4936 | 0.5004 | 1.506s | 14.430s | COMPLETE | | 9 | 15 | 20 | sqrt | 0.4762 | 0.5004 | 1.575s | 16.005s | COMPLETE | Hyperparameter tuning --------------------------- Best trial --> 6 Best parameters: --> max_depth: 15 --> min_samples_split: 9 --> max_features: sqrt Best evaluation --> f2: 0.5004 Time elapsed: 16.005s Fit --------------------------------------------- Train evaluation --> f2: 0.4925 Test evaluation --> f2: 0.4925 Time elapsed: 0.167s ------------------------------------------------- Total time: 16.172s Final results ==================== >> Total time: 16.199s ------------------------------------- DecisionTree --> f2: 0.4925", "title": "Customize the estimator's parameters"}, {"location": "examples/utilities/#save-load", "text": "Note that both instances need to be initialized with the same data and use the same metric for model training to be able to merge. In [20]: Copied! # Save the atom instance as a pickle # Use save_data=False to save the instance without the data atom . save ( \"atom\" , save_data = False ) # Save the atom instance as a pickle # Use save_data=False to save the instance without the data atom.save(\"atom\", save_data=False) ATOMClassifier successfully saved. In [21]: Copied! # Load the instance again with ATOMLoader # No need to store the transformed data, providing the original dataset to # the loader automatically transforms it through all the steps in the pipeline atom_2 = ATOMLoader ( \"atom\" , data = ( X ,), verbose = 2 ) # Load the instance again with ATOMLoader # No need to store the transformed data, providing the original dataset to # the loader automatically transforms it through all the steps in the pipeline atom_2 = ATOMLoader(\"atom\", data=(X,), verbose=2) Cleaning the data... --> Label-encoding the target column. Imputing missing values... --> Dropping 637 samples due to missing values in feature MinTemp. --> Dropping 322 samples due to missing values in feature MaxTemp. --> Dropping 1406 samples due to missing values in feature Rainfall. --> Dropping 60843 samples due to missing values in feature Evaporation. --> Dropping 67816 samples due to missing values in feature Sunshine. --> Dropping 9330 samples due to missing values in feature WindGustDir. --> Dropping 9270 samples due to missing values in feature WindGustSpeed. --> Dropping 10013 samples due to missing values in feature WindDir9am. --> Dropping 3778 samples due to missing values in feature WindDir3pm. --> Dropping 1348 samples due to missing values in feature WindSpeed9am. --> Dropping 2630 samples due to missing values in feature WindSpeed3pm. --> Dropping 1774 samples due to missing values in feature Humidity9am. --> Dropping 3610 samples due to missing values in feature Humidity3pm. --> Dropping 14014 samples due to missing values in feature Pressure9am. --> Dropping 13981 samples due to missing values in feature Pressure3pm. --> Dropping 53657 samples due to missing values in feature Cloud9am. --> Dropping 57094 samples due to missing values in feature Cloud3pm. --> Dropping 904 samples due to missing values in feature Temp9am. --> Dropping 2726 samples due to missing values in feature Temp3pm. --> Dropping 1406 samples due to missing values in feature RainToday. Encoding categorical columns... --> LeaveOneOut-encoding feature Location. Contains 26 classes. --> LeaveOneOut-encoding feature WindGustDir. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir9am. Contains 16 classes. --> LeaveOneOut-encoding feature WindDir3pm. Contains 16 classes. --> Ordinal-encoding feature RainToday. Contains 2 classes. ATOMClassifier successfully loaded. In [24]: Copied! # Create a separate instance with its own branch and model atom_3 = ATOMClassifier ( X , verbose = 0 , random_state = 1 ) atom_3 . branch . name = \"lightgbm\" atom_3 . impute () atom_3 . encode () atom_3 . run ( \"LGB\" , metric = f2 ) # Create a separate instance with its own branch and model atom_3 = ATOMClassifier(X, verbose=0, random_state=1) atom_3.branch.name = \"lightgbm\" atom_3.impute() atom_3.encode() atom_3.run(\"LGB\", metric=f2) In [25]: Copied! # Merge the instances atom_2 . merge ( atom_3 ) # Merge the instances atom_2.merge(atom_3) Merging instances... --> Merging branch lightgbm. --> Merging model LGB. --> Merging attributes. In [26]: Copied! # Note that it now contains both branches and all models atom_2 # Note that it now contains both branches and all models atom_2 Out[26]: ATOMClassifier --> Branches: --> master ! --> lightgbm --> Models: LR, AdaB, Tree, LGB --> Metric: f2 --> Errors: 0 In [27]: Copied! atom_2 . results atom_2.results Out[27]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } score_ht time_ht score_train score_test time_fit time LR NaN NaN 0.5693 0.5709 0.299272 0.299272 AdaB NaN NaN 0.5579 0.5639 2.247532 2.247532 Tree 0.500381 16.00508 0.4925 0.4925 0.167152 16.172232 LGB NaN NaN 0.6578 0.5909 3.562652 3.562652", "title": "Save &amp; load"}, {"location": "user_guide/accelerating/", "text": "Accelerating pipelines CPU acceleration ATOM uses sklearnex to accelerate sklearn applications and still have full conformance with its API. This tool can bring over 10-100X acceleration across a variety of transformers and models. See here an example. Prerequisites Operating System: Linux (Ubuntu, Fedora, etc...) Windows 8.1+ macOS CPU: Processor must have x86 architecture. Processor must support at least one of SSE2, AVX, AVX2, AVX512 instruction sets. ARM* architecture is not supported. Libraries: sklearnex >=2021.6.3 (automatically installed with atom) Note Intel\u00ae processors provide better performance than other CPUs. Supported estimators Transformers Pruner (only for strategy=\"dbscan\") FeatureSelector (only for strategy=\"pca\" and dense datasets) Models ElasticNet KNearestNeighbors Lasso LogisticRegression OrdinaryLeastSquares RandomForest Ridge (only for regression tasks) SupportVectorMachine GPU acceleration Graphics Processing Units (GPUs) can significantly accelerate calculations for preprocessing step or training machine learning models. Training models involves compute-intensive matrix multiplications and other operations that can take advantage of a GPU's massively parallel architecture. Training on large datasets can take hours to run on a single processor. However, if you offload those tasks to a GPU, you can reduce training time to minutes instead. Training transformers and models in atom using a GPU is as easy as initializing the instance with parameter device = \"gpu\" . The device parameter accepts any string that follows the SYCL_DEVICE_FILTER filter selector. Examples are: device=\"cpu\" (use CPU) device=\"gpu\" (use default GPU) device=\"gpu:1\" (use second GPU) Use the engine parameter to choose between the cuML and sklearnex execution engines. The XGBoost , LightGBM and CatBoost models come with their own GPU engine. Setting device=\"gpu\" is sufficient to accelerate them with GPU, regardless of the engine parameter. Warning GPU accelerated estimators almost never support sparse datasets . Refer to their respective documentation to check which ones do. GPU accelerated estimators often use slightly different hyperparameters than their CPU counterparts. ATOM does not support multi-GPU training. If there is more than one GPU on the machine and the device parameter does not specify which one to use, the first one is used by default. Example Train a model on a GPU yourself using SageMaker Studio Lab. Just click on the badge above and run the notebook! Make sure to choose the GPU compute type. Prerequisites Operating System: Ubuntu 18.04/20.04 or CentOS 7/8 with gcc/++ 9.0+ Windows 10+ with WSL2 (see here a tutorial) GPU: For sklearnex: All Intel\u00ae integrated and discrete GPUs. For cuML: NVIDIA Pascal\u2122 or better with compute capability 6.0+ Drivers: For cuML: CUDA & NVIDIA Drivers of versions 11.0, 11.2, 11.4 or 11.5 For sklearnex: Intel\u00ae GPU drivers. Libraries: sklearnex >=2021.6.3 (automatically installed with ATOM) cuML >=22.10 Supported estimators Transformers Cleaner (only for cuML with encode_target=True) Discretizer (only for cuML with strategy!=\"custom\") Imputer (only for cuML with strat_num=\"knn\") Normalizer (only for cuML) Pruner (only for strategy=\"dbscan\") Scaler (only for cuML) Vectorizer (only for cuML) FeatureSelector (only for strategy=\"pca\" and dense datasets) Models BernoulliNB (only for cuML) CatBoost CategoricalNB (only for cuML) ElasticNet (only for cuML) GaussianNB (only for cuML) KNearestNeighbors Lasso (only for cuML) LightGBM (requires extra installations ) LinearSVM (only for cuML) LogisticRegression MultinomialNB (only for cuML) OrdinaryLeastSquares RandomForest Ridge (only for regression tasks) SupportVectorMachine XGBoost", "title": "Accelerating pipelines"}, {"location": "user_guide/accelerating/#accelerating-pipelines", "text": "", "title": "Accelerating pipelines"}, {"location": "user_guide/accelerating/#cpu-acceleration", "text": "ATOM uses sklearnex to accelerate sklearn applications and still have full conformance with its API. This tool can bring over 10-100X acceleration across a variety of transformers and models. See here an example.", "title": "CPU acceleration"}, {"location": "user_guide/accelerating/#prerequisites", "text": "Operating System: Linux (Ubuntu, Fedora, etc...) Windows 8.1+ macOS CPU: Processor must have x86 architecture. Processor must support at least one of SSE2, AVX, AVX2, AVX512 instruction sets. ARM* architecture is not supported. Libraries: sklearnex >=2021.6.3 (automatically installed with atom) Note Intel\u00ae processors provide better performance than other CPUs.", "title": "Prerequisites"}, {"location": "user_guide/accelerating/#supported-estimators", "text": "Transformers Pruner (only for strategy=\"dbscan\") FeatureSelector (only for strategy=\"pca\" and dense datasets) Models ElasticNet KNearestNeighbors Lasso LogisticRegression OrdinaryLeastSquares RandomForest Ridge (only for regression tasks) SupportVectorMachine", "title": "Supported estimators"}, {"location": "user_guide/accelerating/#gpu-acceleration", "text": "Graphics Processing Units (GPUs) can significantly accelerate calculations for preprocessing step or training machine learning models. Training models involves compute-intensive matrix multiplications and other operations that can take advantage of a GPU's massively parallel architecture. Training on large datasets can take hours to run on a single processor. However, if you offload those tasks to a GPU, you can reduce training time to minutes instead. Training transformers and models in atom using a GPU is as easy as initializing the instance with parameter device = \"gpu\" . The device parameter accepts any string that follows the SYCL_DEVICE_FILTER filter selector. Examples are: device=\"cpu\" (use CPU) device=\"gpu\" (use default GPU) device=\"gpu:1\" (use second GPU) Use the engine parameter to choose between the cuML and sklearnex execution engines. The XGBoost , LightGBM and CatBoost models come with their own GPU engine. Setting device=\"gpu\" is sufficient to accelerate them with GPU, regardless of the engine parameter. Warning GPU accelerated estimators almost never support sparse datasets . Refer to their respective documentation to check which ones do. GPU accelerated estimators often use slightly different hyperparameters than their CPU counterparts. ATOM does not support multi-GPU training. If there is more than one GPU on the machine and the device parameter does not specify which one to use, the first one is used by default. Example Train a model on a GPU yourself using SageMaker Studio Lab. Just click on the badge above and run the notebook! Make sure to choose the GPU compute type.", "title": "GPU acceleration"}, {"location": "user_guide/accelerating/#prerequisites_1", "text": "Operating System: Ubuntu 18.04/20.04 or CentOS 7/8 with gcc/++ 9.0+ Windows 10+ with WSL2 (see here a tutorial) GPU: For sklearnex: All Intel\u00ae integrated and discrete GPUs. For cuML: NVIDIA Pascal\u2122 or better with compute capability 6.0+ Drivers: For cuML: CUDA & NVIDIA Drivers of versions 11.0, 11.2, 11.4 or 11.5 For sklearnex: Intel\u00ae GPU drivers. Libraries: sklearnex >=2021.6.3 (automatically installed with ATOM) cuML >=22.10", "title": "Prerequisites"}, {"location": "user_guide/accelerating/#supported-estimators_1", "text": "Transformers Cleaner (only for cuML with encode_target=True) Discretizer (only for cuML with strategy!=\"custom\") Imputer (only for cuML with strat_num=\"knn\") Normalizer (only for cuML) Pruner (only for strategy=\"dbscan\") Scaler (only for cuML) Vectorizer (only for cuML) FeatureSelector (only for strategy=\"pca\" and dense datasets) Models BernoulliNB (only for cuML) CatBoost CategoricalNB (only for cuML) ElasticNet (only for cuML) GaussianNB (only for cuML) KNearestNeighbors Lasso (only for cuML) LightGBM (requires extra installations ) LinearSVM (only for cuML) LogisticRegression MultinomialNB (only for cuML) OrdinaryLeastSquares RandomForest Ridge (only for regression tasks) SupportVectorMachine XGBoost", "title": "Supported estimators"}, {"location": "user_guide/data_cleaning/", "text": "Data cleaning More often than not, you'll need to do some data cleaning before fitting your dataset to a model. Usually, this involves importing different libraries and writing many lines of code. Since ATOM is all about fast exploration and experimentation, it provides various data cleaning classes to apply the most common transformations fast and easy. Note All of atom's data cleaning methods automatically adopt the relevant transformer attributes ( n_jobs , verbose , logger , random_state ) from atom. A different choice can be added as parameter to the method call, e.g. atom . scale ( verbose = 2 ) . Note Like the add method, the data cleaning methods accept the columns parameter to only transform a subset of the dataset's features, e.g. atom . scale ( columns = [ 0 , 1 ]) . Balancing the data One of the common issues found in datasets that are used for classification is imbalanced classes. Data imbalance usually reflects an unequal distribution of classes within a dataset. For example, in a credit card fraud detection dataset, most of the transactions are non-fraud, and a very few cases are fraud. This leaves us with a very unbalanced ratio of fraud vs non-fraud cases. The Balancer class can oversample the minority class or undersample the majority class using any of the transformers implemented in the imblearn package. It can be accessed from atom through the balance method. Standard data cleaning There are many data cleaning steps that are useful to perform on any dataset before modelling. These are general rules that apply almost on every use-case and every task. The Cleaner class is a convenient tool to apply such steps. It can be accessed from atom through the clean method. Use the class' parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column. Binning numerical features Discretization (otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes. Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins. The Discretizer class can be used to bin continuous data into intervals. It can be accessed from atom through the discretize method. Encoding categorical features Many datasets contain categorical features. Their variables are typically stored as text values which represent various classes. Some examples include color (\u201cRed\u201d, \u201cYellow\u201d, \u201cBlue\u201d), size (\u201cSmall\u201d, \u201cMedium\u201d, \u201cLarge\u201d) or geographic designations (city or country). Regardless of what the value is used for, the challenge is determining how to use this data in the analysis. The majority of sklearn's models don't support direct manipulation of this kind of data. Use the Encoder class to encode categorical features to numerical values. It can be accessed from atom through the encode method. There are many strategies to encode categorical columns. The Encoder class applies one strategy or another depending on the number of classes in the column to be encoded. When there are only two, the values are encoded with 0 or 1. When there are more than two, the columns can be encoded using one-hot encoding or any other strategy of the category-encoders package, depending on the value of the max_onehot parameter. One-hot encodes the column making a dummy feature for every class. This approach preserves all the information but increases the size of the dataset considerably, making it often an undesirable strategy for high cardinality features. Other strategies like LeaveOneOut transform the column in place. Imputing missing values For various reasons, many real world datasets contain missing values, often encoded as blanks, NaNs or other placeholders. Such datasets however are incompatible with ATOM's models which assume that all values in an array are numerical, and that all have and hold meaning. The Imputer class handles missing values in the dataset by either dropping or imputing the value. It can be accessed from atom through the impute method. Normalizing the feature set Use the Normalizer class to transform the feature set to follow a Normal (Gaussian)-like distribution. In general, data must be transformed when using models that assume normality in the residuals. Examples of such models are LogisticRegression , LinearDiscriminantAnalysis and GaussianNB . The class can be accessed from atom through the normalize method. Handling outliers When modelling, it is important to clean the data sample to ensure that the observations best represent the problem. Sometimes a dataset can contain extreme values that are outside the range of what is expected and unlike the other data. These are called outliers. Often, machine learning modelling and model skill in general can be improved by understanding and even removing these outlier samples. The Pruner class offers 7 different strategies to detect outliers (described hereunder). It can be accessed from atom through the prune method. z-score The z-score of a value in the dataset is defined as the number of standard deviations by which the value is above or below the mean of the column. Values above or below a certain threshold (specified with the parameter max_sigma ) are considered outliers. Note that, contrary to the rest of the strategies, this approach selects outlier values, not outlier samples! Because of this, it is possible to replace the outlier value instead of dropping the entire sample. Isolation Forest Uses a tree-based anomaly detection algorithm. It is based on modeling the normal data in such a way as to isolate anomalies that are both few and different in the feature space. Read more in sklearn's documentation . Elliptic Envelope If the input variables have a Gaussian distribution, then simple statistical methods can be used to detect outliers. For example, if the dataset has two input variables and both are Gaussian, the feature space forms a multidimensional Gaussian, and knowledge of this distribution can be used to identify values far from the distribution. This approach can be generalized by defining a hypersphere (ellipsoid) that covers the normal data, and data that falls outside this shape is considered an outlier. Read more in sklearn's documentation . Local Outlier Factor A simple approach to identifying outliers is to locate those examples that are far from the other examples in the feature space. This can work well for feature spaces with low dimensionality (few features) but becomes less reliable as the number of features is increased. The local outlier factor is a technique that attempts to harness the idea of nearest neighbors for outlier detection. Each example is assigned a score of how isolated or how likely it is to be outliers based on the size of its local neighborhood. Those examples with the largest score are more likely to be outliers. Read more in sklearn's documentation . One-class SVM The support vector machine algorithm, initially developed for binary classification tasks, can also be used for one-class classification. When modeling one class, the algorithm captures the density of the majority class and classifies examples on the extremes of the density function as outliers. This modification of SVM is referred to as One-Class SVM. Read more in sklearn's documentation . DBSCAN The DBSCAN algorithm views clusters as areas of high density separated by areas of low density. Due to this rather generic view, clusters found by DBSCAN can be any shape, as opposed to k-means which assumes that clusters are convex shaped. Samples that lie outside any cluster are considered outliers. Read more in sklearn's documentation . OPTICS The OPTICS algorithm shares many similarities with the DBSCAN algorithm, and can be considered a generalization of DBSCAN that relaxes the eps requirement from a single value to a value range. The key difference between DBSCAN and OPTICS is that the OPTICS algorithm builds a reachability graph, and a spot within the cluster ordering. These two attributes are assigned when the model is fitted, and are used to determine cluster membership. Read more in sklearn's documentation . Scaling the feature set Standardization of a dataset is a common requirement for many machine learning estimators; they might behave badly if the individual features do not more or less look like standard normally distributed data (e.g. Gaussian with zero mean and unit variance). The Scaler class let you quickly scale atom's dataset using one of sklearn's scalers. It can be accessed from atom through the scale method. Info All strategies can utilize GPU speed-up. Click here for further information about GPU implementation.", "title": "Data cleaning"}, {"location": "user_guide/data_cleaning/#data-cleaning", "text": "More often than not, you'll need to do some data cleaning before fitting your dataset to a model. Usually, this involves importing different libraries and writing many lines of code. Since ATOM is all about fast exploration and experimentation, it provides various data cleaning classes to apply the most common transformations fast and easy. Note All of atom's data cleaning methods automatically adopt the relevant transformer attributes ( n_jobs , verbose , logger , random_state ) from atom. A different choice can be added as parameter to the method call, e.g. atom . scale ( verbose = 2 ) . Note Like the add method, the data cleaning methods accept the columns parameter to only transform a subset of the dataset's features, e.g. atom . scale ( columns = [ 0 , 1 ]) .", "title": "Data cleaning"}, {"location": "user_guide/data_cleaning/#balancing-the-data", "text": "One of the common issues found in datasets that are used for classification is imbalanced classes. Data imbalance usually reflects an unequal distribution of classes within a dataset. For example, in a credit card fraud detection dataset, most of the transactions are non-fraud, and a very few cases are fraud. This leaves us with a very unbalanced ratio of fraud vs non-fraud cases. The Balancer class can oversample the minority class or undersample the majority class using any of the transformers implemented in the imblearn package. It can be accessed from atom through the balance method.", "title": "Balancing the data"}, {"location": "user_guide/data_cleaning/#standard-data-cleaning", "text": "There are many data cleaning steps that are useful to perform on any dataset before modelling. These are general rules that apply almost on every use-case and every task. The Cleaner class is a convenient tool to apply such steps. It can be accessed from atom through the clean method. Use the class' parameters to choose which transformations to perform. The available steps are: Drop columns with specific data types. Strip categorical features from white spaces. Drop duplicate rows. Drop rows with missing values in the target column. Encode the target column.", "title": "Standard data cleaning"}, {"location": "user_guide/data_cleaning/#binning-numerical-features", "text": "Discretization (otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes. Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins. The Discretizer class can be used to bin continuous data into intervals. It can be accessed from atom through the discretize method.", "title": "Binning numerical features"}, {"location": "user_guide/data_cleaning/#encoding-categorical-features", "text": "Many datasets contain categorical features. Their variables are typically stored as text values which represent various classes. Some examples include color (\u201cRed\u201d, \u201cYellow\u201d, \u201cBlue\u201d), size (\u201cSmall\u201d, \u201cMedium\u201d, \u201cLarge\u201d) or geographic designations (city or country). Regardless of what the value is used for, the challenge is determining how to use this data in the analysis. The majority of sklearn's models don't support direct manipulation of this kind of data. Use the Encoder class to encode categorical features to numerical values. It can be accessed from atom through the encode method. There are many strategies to encode categorical columns. The Encoder class applies one strategy or another depending on the number of classes in the column to be encoded. When there are only two, the values are encoded with 0 or 1. When there are more than two, the columns can be encoded using one-hot encoding or any other strategy of the category-encoders package, depending on the value of the max_onehot parameter. One-hot encodes the column making a dummy feature for every class. This approach preserves all the information but increases the size of the dataset considerably, making it often an undesirable strategy for high cardinality features. Other strategies like LeaveOneOut transform the column in place.", "title": "Encoding categorical features"}, {"location": "user_guide/data_cleaning/#imputing-missing-values", "text": "For various reasons, many real world datasets contain missing values, often encoded as blanks, NaNs or other placeholders. Such datasets however are incompatible with ATOM's models which assume that all values in an array are numerical, and that all have and hold meaning. The Imputer class handles missing values in the dataset by either dropping or imputing the value. It can be accessed from atom through the impute method.", "title": "Imputing missing values"}, {"location": "user_guide/data_cleaning/#normalizing-the-feature-set", "text": "Use the Normalizer class to transform the feature set to follow a Normal (Gaussian)-like distribution. In general, data must be transformed when using models that assume normality in the residuals. Examples of such models are LogisticRegression , LinearDiscriminantAnalysis and GaussianNB . The class can be accessed from atom through the normalize method.", "title": "Normalizing the feature set"}, {"location": "user_guide/data_cleaning/#handling-outliers", "text": "When modelling, it is important to clean the data sample to ensure that the observations best represent the problem. Sometimes a dataset can contain extreme values that are outside the range of what is expected and unlike the other data. These are called outliers. Often, machine learning modelling and model skill in general can be improved by understanding and even removing these outlier samples. The Pruner class offers 7 different strategies to detect outliers (described hereunder). It can be accessed from atom through the prune method. z-score The z-score of a value in the dataset is defined as the number of standard deviations by which the value is above or below the mean of the column. Values above or below a certain threshold (specified with the parameter max_sigma ) are considered outliers. Note that, contrary to the rest of the strategies, this approach selects outlier values, not outlier samples! Because of this, it is possible to replace the outlier value instead of dropping the entire sample. Isolation Forest Uses a tree-based anomaly detection algorithm. It is based on modeling the normal data in such a way as to isolate anomalies that are both few and different in the feature space. Read more in sklearn's documentation . Elliptic Envelope If the input variables have a Gaussian distribution, then simple statistical methods can be used to detect outliers. For example, if the dataset has two input variables and both are Gaussian, the feature space forms a multidimensional Gaussian, and knowledge of this distribution can be used to identify values far from the distribution. This approach can be generalized by defining a hypersphere (ellipsoid) that covers the normal data, and data that falls outside this shape is considered an outlier. Read more in sklearn's documentation . Local Outlier Factor A simple approach to identifying outliers is to locate those examples that are far from the other examples in the feature space. This can work well for feature spaces with low dimensionality (few features) but becomes less reliable as the number of features is increased. The local outlier factor is a technique that attempts to harness the idea of nearest neighbors for outlier detection. Each example is assigned a score of how isolated or how likely it is to be outliers based on the size of its local neighborhood. Those examples with the largest score are more likely to be outliers. Read more in sklearn's documentation . One-class SVM The support vector machine algorithm, initially developed for binary classification tasks, can also be used for one-class classification. When modeling one class, the algorithm captures the density of the majority class and classifies examples on the extremes of the density function as outliers. This modification of SVM is referred to as One-Class SVM. Read more in sklearn's documentation . DBSCAN The DBSCAN algorithm views clusters as areas of high density separated by areas of low density. Due to this rather generic view, clusters found by DBSCAN can be any shape, as opposed to k-means which assumes that clusters are convex shaped. Samples that lie outside any cluster are considered outliers. Read more in sklearn's documentation . OPTICS The OPTICS algorithm shares many similarities with the DBSCAN algorithm, and can be considered a generalization of DBSCAN that relaxes the eps requirement from a single value to a value range. The key difference between DBSCAN and OPTICS is that the OPTICS algorithm builds a reachability graph, and a spot within the cluster ordering. These two attributes are assigned when the model is fitted, and are used to determine cluster membership. Read more in sklearn's documentation .", "title": "Handling outliers"}, {"location": "user_guide/data_cleaning/#scaling-the-feature-set", "text": "Standardization of a dataset is a common requirement for many machine learning estimators; they might behave badly if the individual features do not more or less look like standard normally distributed data (e.g. Gaussian with zero mean and unit variance). The Scaler class let you quickly scale atom's dataset using one of sklearn's scalers. It can be accessed from atom through the scale method. Info All strategies can utilize GPU speed-up. Click here for further information about GPU implementation.", "title": "Scaling the feature set"}, {"location": "user_guide/data_management/", "text": "Data management Data sets ATOM is designed to work around one single dataset: the one with which atom is initialized. This is the dataset you want to explore, transform, and use for model training and validation. ATOM differentiates three different data sets: The training set is usually the largest of the data sets. As the name suggests, this set is used to train the pipeline. During hyperparameter tuning , only the training set is used to fit and evaluate the estimator in every call. The training set in the current branch can be accessed through the train attribute. It's features and target can be accessed through X_train and y_train respectively. The test set is used to evaluate the models. The model scores on this set give an indication on how the model performs on new data. The test set can be accessed through the test attribute. It's features and target can be accessed through X_test and y_test respectively. The holdout set is an optional, separate set that should only be used to evaluate the final model's performance. Create this set when you are going to use the test set for an intermediate validation step. The holdout set is immediately set apart during initialization and is not considered part of atom's dataset (the dataset attribute only returns the train and test sets). The holdout set is left untouched until predictions are made on it, i.e. it does not undergo any pipeline transformations. The holdout set is stored in atom's holdout attribute. It's features and target can not be accessed separately. See here an example that shows how to use the holdout data set. The data can be provided in different formats. If the data sets are not specified beforehand, you can input the features and target separately or together: X X, y Remember to use the y parameter to indicate the target column in X when using the first option. If not specified, the last column in X is used as target. In both these cases, the size of the sets are defined using the test_size and holdout_size parameters. Note that the splits are made after the subsample of the dataset with the n_rows parameter (when not left to its default value). If you already have the separate data sets, provide them using one of the following formats: train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) The input data is always converted internally to a pandas dataframe , if it isn't one already. The column names should always be strings. If they are not, atom changes their type at initialization. If no column names are provided, default names are given of the form X[N-1] , where N stands for the n-th feature in the dataset. Indexing By default, atom resets the dataframe's index after initialization and after every transformation in the pipeline. To avoid this, specify the index parameter. If the dataset has an 'identifier' column, it is useful to use it as index for two reasons: An identifier doesn't usually contain any useful information on the target column, and should therefore be removed before training. Predictions of specific rows can be accessed through their index. Warning Avoid duplicate indices in the dataframe. Having them may potentially lead to unexpected behavior. Sparse datasets If atom is initialized using a scipy sparse matrix, it is converted internally to a dataframe of sparse columns. Read more about pandas' sparse data structures here . The same conversion takes place when a transformer returns a sparse matrix, like for example, the Vectorizer . Note that ATOM considers a dataset to be sparse if any of the columns is sparse. A dataset can only benefit from sparsity when all its columns are sparse, hence mixing sparse and non-sparse columns is not recommended and can cause estimators to decrease their training speed or even crash. Use the shrink method to convert dense features to sparse and the available_models method to check which models have native support for sparse matrices. Click here to see an example that uses sparse data. Branches You might want to compare how a model performs on a dataset transformed through multiple pipelines, each using different transformers. For example, on one pipeline with an undersampling strategy and the other with an oversampling strategy. To be able to do this, ATOM has the branching system. The branching system helps the user to manage multiple data pipelines within the same atom instance. Branches are created and accessed through atom's branch property. A branch contains a specific pipeline, the dataset transformed through that pipeline, and all data and utility attributes that refer to that dataset. Transformers and models called from atom use the dataset in the current branch, as well as data attributes such as atom.dataset . Use the branch's __repr__ to get an overview of the transformers in the branch. It's not allowed to change the data in a branch after fitting a model with it. Doing this would cause unexpected model behaviour and break down the plotting methods. Instead, create a new branch for every unique pipeline. By default, atom starts with one branch called \"master\". To start a new branch, set a new name to the property, e.g. atom . branch = \"undersample\" . This creates a new branch from the current one. To create a branch from any other branch type \"_from_\" between the new name and the branch from which to split, e.g. atom . branch = \"oversample_from_master\" creates branch \"oversample\" from branch \"master\", even if the current branch is \"undersample\". To switch between existing branches, just type the name of the desired branch, e.g. atom . branch = \"master\" brings you back to the master branch. Note that every branch contains a unique copy of the whole dataset! Creating many branches can cause memory issues for large datasets. See the Imbalanced datasets or Feature engineering examples for branching use cases. Warning Always create a new branch if you want to change the dataset after fitting a model! Figure 1. Diagram of a possible branch system to compare an oversampling with an undersampling pipeline. Memory considerations An atom instance stores one copy of the dataframe in each branch, and one copy of the initial dataset with which the instance is initialized (this copy is necessary to avoid data leakage during hyperparameter tuning and for some specific methods like cross_validate and reset ). This initial copy is created as soon as there are no branches in the initial state (usually after calling the first data transformation) and it's stored in an internal branch called og (original). The og branch is not accessible by the user. If the dataset is occupying too much memory, consider using the shrink method to convert the dtypes to their smallest possible matching dtype. Apart from the dataset itself, a model's prediction attributes (e.g. atom . lr . predict_train ), metric scores and shap values are also stored as attributes of the model to avoid having to recalculate them every time they are needed. This data can occupy a considerable amount of memory for large datasets. You can delete all these attributes using the clear method in order to free some memory before saving the class. Data transformations Performing data transformations is a common requirement of many datasets before they are ready to be ingested by a model. ATOM provides various classes to apply data cleaning and feature engineering transformations to the data. This tooling should be able to help you apply most of the typically needed transformations to get the data ready for modelling. For further fine-tuning, it's also possible to transform the data using custom transformers (see the add method) or through a function (see the apply method). Remember that all transformations are only applied to the dataset in the current branch.", "title": "Data management"}, {"location": "user_guide/data_management/#data-management", "text": "", "title": "Data management"}, {"location": "user_guide/data_management/#data-sets", "text": "ATOM is designed to work around one single dataset: the one with which atom is initialized. This is the dataset you want to explore, transform, and use for model training and validation. ATOM differentiates three different data sets: The training set is usually the largest of the data sets. As the name suggests, this set is used to train the pipeline. During hyperparameter tuning , only the training set is used to fit and evaluate the estimator in every call. The training set in the current branch can be accessed through the train attribute. It's features and target can be accessed through X_train and y_train respectively. The test set is used to evaluate the models. The model scores on this set give an indication on how the model performs on new data. The test set can be accessed through the test attribute. It's features and target can be accessed through X_test and y_test respectively. The holdout set is an optional, separate set that should only be used to evaluate the final model's performance. Create this set when you are going to use the test set for an intermediate validation step. The holdout set is immediately set apart during initialization and is not considered part of atom's dataset (the dataset attribute only returns the train and test sets). The holdout set is left untouched until predictions are made on it, i.e. it does not undergo any pipeline transformations. The holdout set is stored in atom's holdout attribute. It's features and target can not be accessed separately. See here an example that shows how to use the holdout data set. The data can be provided in different formats. If the data sets are not specified beforehand, you can input the features and target separately or together: X X, y Remember to use the y parameter to indicate the target column in X when using the first option. If not specified, the last column in X is used as target. In both these cases, the size of the sets are defined using the test_size and holdout_size parameters. Note that the splits are made after the subsample of the dataset with the n_rows parameter (when not left to its default value). If you already have the separate data sets, provide them using one of the following formats: train, test train, test, holdout X_train, X_test, y_train, y_test X_train, X_test, X_holdout, y_train, y_test, y_holdout (X_train, y_train), (X_test, y_test) (X_train, y_train), (X_test, y_test), (X_holdout, y_holdout) The input data is always converted internally to a pandas dataframe , if it isn't one already. The column names should always be strings. If they are not, atom changes their type at initialization. If no column names are provided, default names are given of the form X[N-1] , where N stands for the n-th feature in the dataset.", "title": "Data sets"}, {"location": "user_guide/data_management/#indexing", "text": "By default, atom resets the dataframe's index after initialization and after every transformation in the pipeline. To avoid this, specify the index parameter. If the dataset has an 'identifier' column, it is useful to use it as index for two reasons: An identifier doesn't usually contain any useful information on the target column, and should therefore be removed before training. Predictions of specific rows can be accessed through their index. Warning Avoid duplicate indices in the dataframe. Having them may potentially lead to unexpected behavior.", "title": "Indexing"}, {"location": "user_guide/data_management/#sparse-datasets", "text": "If atom is initialized using a scipy sparse matrix, it is converted internally to a dataframe of sparse columns. Read more about pandas' sparse data structures here . The same conversion takes place when a transformer returns a sparse matrix, like for example, the Vectorizer . Note that ATOM considers a dataset to be sparse if any of the columns is sparse. A dataset can only benefit from sparsity when all its columns are sparse, hence mixing sparse and non-sparse columns is not recommended and can cause estimators to decrease their training speed or even crash. Use the shrink method to convert dense features to sparse and the available_models method to check which models have native support for sparse matrices. Click here to see an example that uses sparse data.", "title": "Sparse datasets"}, {"location": "user_guide/data_management/#branches", "text": "You might want to compare how a model performs on a dataset transformed through multiple pipelines, each using different transformers. For example, on one pipeline with an undersampling strategy and the other with an oversampling strategy. To be able to do this, ATOM has the branching system. The branching system helps the user to manage multiple data pipelines within the same atom instance. Branches are created and accessed through atom's branch property. A branch contains a specific pipeline, the dataset transformed through that pipeline, and all data and utility attributes that refer to that dataset. Transformers and models called from atom use the dataset in the current branch, as well as data attributes such as atom.dataset . Use the branch's __repr__ to get an overview of the transformers in the branch. It's not allowed to change the data in a branch after fitting a model with it. Doing this would cause unexpected model behaviour and break down the plotting methods. Instead, create a new branch for every unique pipeline. By default, atom starts with one branch called \"master\". To start a new branch, set a new name to the property, e.g. atom . branch = \"undersample\" . This creates a new branch from the current one. To create a branch from any other branch type \"_from_\" between the new name and the branch from which to split, e.g. atom . branch = \"oversample_from_master\" creates branch \"oversample\" from branch \"master\", even if the current branch is \"undersample\". To switch between existing branches, just type the name of the desired branch, e.g. atom . branch = \"master\" brings you back to the master branch. Note that every branch contains a unique copy of the whole dataset! Creating many branches can cause memory issues for large datasets. See the Imbalanced datasets or Feature engineering examples for branching use cases. Warning Always create a new branch if you want to change the dataset after fitting a model! Figure 1. Diagram of a possible branch system to compare an oversampling with an undersampling pipeline.", "title": "Branches"}, {"location": "user_guide/data_management/#memory-considerations", "text": "An atom instance stores one copy of the dataframe in each branch, and one copy of the initial dataset with which the instance is initialized (this copy is necessary to avoid data leakage during hyperparameter tuning and for some specific methods like cross_validate and reset ). This initial copy is created as soon as there are no branches in the initial state (usually after calling the first data transformation) and it's stored in an internal branch called og (original). The og branch is not accessible by the user. If the dataset is occupying too much memory, consider using the shrink method to convert the dtypes to their smallest possible matching dtype. Apart from the dataset itself, a model's prediction attributes (e.g. atom . lr . predict_train ), metric scores and shap values are also stored as attributes of the model to avoid having to recalculate them every time they are needed. This data can occupy a considerable amount of memory for large datasets. You can delete all these attributes using the clear method in order to free some memory before saving the class.", "title": "Memory considerations"}, {"location": "user_guide/data_management/#data-transformations", "text": "Performing data transformations is a common requirement of many datasets before they are ready to be ingested by a model. ATOM provides various classes to apply data cleaning and feature engineering transformations to the data. This tooling should be able to help you apply most of the typically needed transformations to get the data ready for modelling. For further fine-tuning, it's also possible to transform the data using custom transformers (see the add method) or through a function (see the apply method). Remember that all transformations are only applied to the dataset in the current branch.", "title": "Data transformations"}, {"location": "user_guide/feature_engineering/", "text": "Feature engineering Feature engineering is the process of creating new features from the existing ones, in order to capture relationships with the target column that the first set of features didn't have on their own. This process is very important to improve the performance of machine learning algorithms. Although feature engineering works best when the data scientist applies use-case specific transformations, there are ways to do this in an automated manner, without prior domain knowledge. One of the problems of creating new features without human expert intervention, is that many of the newly created features can be useless, i.e. they do not help the algorithm to make better predictions. Even worse, having useless features can drop your performance. To avoid this, we perform feature selection, a process in which we select the relevant features in the dataset. See the Feature engineering example. Note All of atom's feature engineering methods automatically adopt the relevant transformer attributes ( n_jobs , verbose , logger , random_state ) from atom. A different choice can be added as parameter to the method call, e.g. atom . feature_selection ( \"pca\" , n_features = 10 , random_state = 2 ) . Note Like the add method, the feature engineering methods accept the columns parameter to only transform a subset of the dataset's features, e.g. atom . feature_selection ( \"pca\" , n_features = 10 , columns = slice ( 5 , 15 )) . Extracting datetime features Features that contain dates or timestamps can not be directly ingested by models since they are not strictly numerical. Encoding them as categorical features is not an option since the encoding does not capture the relationship between the different moments in time. The FeatureExtractor class creates new features extracting datetime elements (e.g. day, month, year, hour...) from the columns. It can be accessed from atom through the feature_extraction method. The new features are named equally to the column from which they are extracted, followed by an underscore and the datetime element they create, e.g. x0_day for the day element of x0 . Note that many time features have a cyclic pattern, e.g. after Sunday comes Monday. This means that if we would encode the days of the week from 0 to 6, we would lose that relation. A common method used to encode cyclical features is to transform the data into two dimensions using a sine and cosine transformation: \\[ x_{sin} = sin\\left(\\frac{2\\pi * x}{max(x)}\\right) \\] \\[ x_{cos} = cos\\left(\\frac{2\\pi * x}{max(x)}\\right) \\] The resulting features have their names followed by sin or cos, e.g. x0_day_sin and x0_day_cos . The datetime elements that can be encoded in a cyclic fashion are: microsecond, second, minute, hour, weekday, day, day_of_year, month and quarter. Note that decision trees based algorithms build their split rules according to one feature at a time. This means that they will fail to correctly process cyclic features since the sin/cos values are expected to be considered as one single coordinate system. Use the fmt parameter to specify your feature's format in case the column is categorical. The FeatureExtractor class will convert the column to the datetime dtype before extracting the specified features. Click here for an overview of the available formats. Generating new features The FeatureGenerator class creates new non-linear features based on the original feature set. It can be accessed from atom through the feature_generation method. You can choose between two strategies: Deep Feature Synthesis and Genetic Feature Generation. Deep Feature Synthesis Deep feature synthesis (DFS) applies the selected operators on the features in the dataset. For example, if the operator is \"log\", it will create the new feature LOG(old_feature) and if the operator is \"mul\", it will create the new feature old_feature_1 x old_feature_2 . The operators can be chosen through the operators parameter. Choose from: add : Take the sum of two features. sub: Subtract two features from each other. mul: Multiply two features with each other. div: Divide two features with each other. abs: Calculate the absolute value of a feature. srqt: Calculate the square root of a feature. log: Calculate the natural logarithm of a feature. sin: Calculate the sine of a feature. cos: Calculate the cosine of a feature. tan: Calculate the tangent of a feature. ATOM's implementation of DFS uses the featuretools package. Genetic Feature Generation Genetic feature generation (GFG) uses genetic programming , a branch of evolutionary programming, to determine which features are successful and create new ones based on those. Where dfs can be seen as some kind of \"brute force\" for feature engineering, gfg tries to improve its features with every generation of the algorithm. gfg uses the same operators as dfs, but instead of only applying the transformations once, it evolves them further, creating nested structures of combinations of features. The new features are given the name feature_n , where n stands for the n-th feature in the dataset. You can access the genetic feature's fitness and description (how they are calculated) through the genetic_features attribute. ATOM uses the SymbolicTransformer class from the gplearn package for the genetic algorithm. Read more about this implementation here . Grouping similar features When your dataset contains many similar features corresponding to a certain natural group or entity, it's possible to replace these features for a handful of them, that should capture the relations of the group, in order to lose as little information as possible. To achieve this, the FeatureGrouper class computes certain statistical properties that describe the group's distribution, like the mean or the median, and replaces the columns with the result of these statistical calculations over every row in the dataset. The goal of this approach is to reduce the number of columns in the dataset, avoiding the curse of dimensionality . Selecting useful features The FeatureSelector class provides tooling to select the relevant features from a dataset. It can be accessed from atom through the feature_selection method. Standard strategies Univariate Univariate feature selection works by selecting the best features based on univariate statistical F-test. The test is provided via the solver parameter. It takes any function taking two arrays (X, y), and returning arrays (scores, p-values). Read more in sklearn's documentation . Principal Components Analysis Applying PCA reduces the dimensionality of the dataset by maximizing the variance of each dimension. The new features are called pca0 , pca1 , etc... PCA can be applied in three ways: If the data is dense (i.e. not sparse), the estimator used is PCA . Before fitting the transformer, the data is scaled to mean=0 and std=1 if it wasn't already. Read more in sklearn's documentation . If the data is [sparse][sparse datasets] (often the case for term-document matrices, see Vectorizer ), the estimator used is TruncatedSVD . Read more in sklearn's documentation . If engine is \"sklearnex\" or \"cuml\", the estimator used is the package's PCA implementation. Sparse data is not supported for neither engine. Selection from model SFM uses an estimator with feature_importances_ or coef_ attributes to select the best features in a dataset based on importance weights. The estimator is provided through the solver parameter and can be already fitted. ATOM allows you to use one its predefined models , e.g. solver = \"RF\" . If you didn't call the FeatureSelector through atom, don't forget to indicate the estimator's task adding _class or _reg after the name, e.g. RF_class to use a random forest classifier. Read more in sklearn's documentation . Sequential Feature Selection Sequential feature selection adds (forward selection) or removes (backward selection) features to form a feature subset in a greedy fashion. At each stage, this estimator chooses the best feature to add or remove based on the cross-validation score of an estimator. Read more in sklearn's documentation . Recursive Feature Elimination Select features by recursively considering smaller and smaller sets of features. First, the estimator is trained on the initial set of features, and the importance of each feature is obtained either through a coef_ or through a feature_importances_ attribute. Then, the least important features are pruned from current set of features. That procedure is recursively repeated on the pruned set until the desired number of features to select is eventually reached. Note that, since RFE needs to fit the model again every iteration, this method can be fairly slow. RFECV applies the same algorithm as RFE but uses a cross-validated metric (under the scoring parameter, see RFECV ) to assess every step's performance. Also, where RFE returns the number of features selected by n_features , RFECV returns the number of features that achieved the optimal score on the specified metric. Note that this is not always equal to the amount specified by n_features . Read more in sklearn's documentation . Advanced strategies The following strategies are a collection of nature-inspired optimization algorithms that maximize an objective function. If not manually specified, the function calculates the cross-validated score of a model on the data. Use the scoring parameter (not present in description, part of kwargs) to specify the metric to optimize on. Particle Swarm Optimization Particle Swarm Optimization (PSO) optimizes a problem by having a population of candidate solutions (particles), and moving them around in the search-space according to simple mathematical formula over the particle's position and velocity. Each particle's movement is influenced by its local best known position, but is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions. Read more here . Harris Hawks Optimization Harris Hawks Optimization (HHO) mimics the action and reaction of Hawk's team collaboration hunting in nature and prey escaping to discover the solutions of the single-objective problem. Read more here . Grey Wolf Optimization The Grey Wolf Optimizer (GWO) mimics the leadership hierarchy and hunting mechanism of grey wolves in nature. Four types of grey wolves such as alpha, beta, delta, and omega are employed for simulating the leadership hierarchy. In addition, three main steps of hunting, searching for prey, encircling prey, and attacking prey, are implemented to perform optimization. Read more here . Dragonfly Optimization The Dragonfly Algorithm (DFO) algorithm originates from static and dynamic swarming behaviours. These two swarming behaviours are very similar to the two main phases of optimization using meta-heuristics: exploration and exploitation. Dragonflies create sub swarms and fly over different areas in a static swarm, which is the main objective of the exploration phase. In the static swarm, however, dragonflies fly in bigger swarms and along one direction, which is favourable in the exploitation phase. Read more here . Genetic Optimization Genetic Optimization is a metaheuristic inspired by the process of natural selection that belongs to the larger class of evolutionary algorithms. Genetic algorithms are commonly used to generate high-quality solutions to optimization and search problems by relying on biologically inspired operators such as mutation, crossover and selection. Read more here . Other selection methods Removing features with low or high variance Variance is the expectation of the squared deviation of a random variable from its mean. Features with low variance have many values repeated, which means the model can't learn much from them. In a similar way, features with very high variance have very few values repeated, which makes it also difficult for a model to learn from this feature. FeatureSelector removes a categorical feature when the maximum number of occurrences for any value is below min_repeated or when the same value is repeated in at least max_repeated fraction of the rows. The default option is to remove a feature if all values in it are either different or exactly the same. Removing features with multi-collinearity Two features that are highly correlated are redundant, i.e. two will not contribute more to the model than only one of them. FeatureSelector will drop a feature that has a Pearson correlation coefficient larger than max_correlation with another feature. A correlation of 1 means the two columns are equal. A dataframe of the removed features and their correlation values can be accessed through the collinear attribute.", "title": "Feature engineering"}, {"location": "user_guide/feature_engineering/#feature-engineering", "text": "Feature engineering is the process of creating new features from the existing ones, in order to capture relationships with the target column that the first set of features didn't have on their own. This process is very important to improve the performance of machine learning algorithms. Although feature engineering works best when the data scientist applies use-case specific transformations, there are ways to do this in an automated manner, without prior domain knowledge. One of the problems of creating new features without human expert intervention, is that many of the newly created features can be useless, i.e. they do not help the algorithm to make better predictions. Even worse, having useless features can drop your performance. To avoid this, we perform feature selection, a process in which we select the relevant features in the dataset. See the Feature engineering example. Note All of atom's feature engineering methods automatically adopt the relevant transformer attributes ( n_jobs , verbose , logger , random_state ) from atom. A different choice can be added as parameter to the method call, e.g. atom . feature_selection ( \"pca\" , n_features = 10 , random_state = 2 ) . Note Like the add method, the feature engineering methods accept the columns parameter to only transform a subset of the dataset's features, e.g. atom . feature_selection ( \"pca\" , n_features = 10 , columns = slice ( 5 , 15 )) .", "title": "Feature engineering"}, {"location": "user_guide/feature_engineering/#extracting-datetime-features", "text": "Features that contain dates or timestamps can not be directly ingested by models since they are not strictly numerical. Encoding them as categorical features is not an option since the encoding does not capture the relationship between the different moments in time. The FeatureExtractor class creates new features extracting datetime elements (e.g. day, month, year, hour...) from the columns. It can be accessed from atom through the feature_extraction method. The new features are named equally to the column from which they are extracted, followed by an underscore and the datetime element they create, e.g. x0_day for the day element of x0 . Note that many time features have a cyclic pattern, e.g. after Sunday comes Monday. This means that if we would encode the days of the week from 0 to 6, we would lose that relation. A common method used to encode cyclical features is to transform the data into two dimensions using a sine and cosine transformation: \\[ x_{sin} = sin\\left(\\frac{2\\pi * x}{max(x)}\\right) \\] \\[ x_{cos} = cos\\left(\\frac{2\\pi * x}{max(x)}\\right) \\] The resulting features have their names followed by sin or cos, e.g. x0_day_sin and x0_day_cos . The datetime elements that can be encoded in a cyclic fashion are: microsecond, second, minute, hour, weekday, day, day_of_year, month and quarter. Note that decision trees based algorithms build their split rules according to one feature at a time. This means that they will fail to correctly process cyclic features since the sin/cos values are expected to be considered as one single coordinate system. Use the fmt parameter to specify your feature's format in case the column is categorical. The FeatureExtractor class will convert the column to the datetime dtype before extracting the specified features. Click here for an overview of the available formats.", "title": "Extracting datetime features"}, {"location": "user_guide/feature_engineering/#generating-new-features", "text": "The FeatureGenerator class creates new non-linear features based on the original feature set. It can be accessed from atom through the feature_generation method. You can choose between two strategies: Deep Feature Synthesis and Genetic Feature Generation. Deep Feature Synthesis Deep feature synthesis (DFS) applies the selected operators on the features in the dataset. For example, if the operator is \"log\", it will create the new feature LOG(old_feature) and if the operator is \"mul\", it will create the new feature old_feature_1 x old_feature_2 . The operators can be chosen through the operators parameter. Choose from: add : Take the sum of two features. sub: Subtract two features from each other. mul: Multiply two features with each other. div: Divide two features with each other. abs: Calculate the absolute value of a feature. srqt: Calculate the square root of a feature. log: Calculate the natural logarithm of a feature. sin: Calculate the sine of a feature. cos: Calculate the cosine of a feature. tan: Calculate the tangent of a feature. ATOM's implementation of DFS uses the featuretools package. Genetic Feature Generation Genetic feature generation (GFG) uses genetic programming , a branch of evolutionary programming, to determine which features are successful and create new ones based on those. Where dfs can be seen as some kind of \"brute force\" for feature engineering, gfg tries to improve its features with every generation of the algorithm. gfg uses the same operators as dfs, but instead of only applying the transformations once, it evolves them further, creating nested structures of combinations of features. The new features are given the name feature_n , where n stands for the n-th feature in the dataset. You can access the genetic feature's fitness and description (how they are calculated) through the genetic_features attribute. ATOM uses the SymbolicTransformer class from the gplearn package for the genetic algorithm. Read more about this implementation here .", "title": "Generating new features"}, {"location": "user_guide/feature_engineering/#grouping-similar-features", "text": "When your dataset contains many similar features corresponding to a certain natural group or entity, it's possible to replace these features for a handful of them, that should capture the relations of the group, in order to lose as little information as possible. To achieve this, the FeatureGrouper class computes certain statistical properties that describe the group's distribution, like the mean or the median, and replaces the columns with the result of these statistical calculations over every row in the dataset. The goal of this approach is to reduce the number of columns in the dataset, avoiding the curse of dimensionality .", "title": "Grouping similar features"}, {"location": "user_guide/feature_engineering/#selecting-useful-features", "text": "The FeatureSelector class provides tooling to select the relevant features from a dataset. It can be accessed from atom through the feature_selection method.", "title": "Selecting useful features"}, {"location": "user_guide/feature_engineering/#standard-strategies", "text": "Univariate Univariate feature selection works by selecting the best features based on univariate statistical F-test. The test is provided via the solver parameter. It takes any function taking two arrays (X, y), and returning arrays (scores, p-values). Read more in sklearn's documentation . Principal Components Analysis Applying PCA reduces the dimensionality of the dataset by maximizing the variance of each dimension. The new features are called pca0 , pca1 , etc... PCA can be applied in three ways: If the data is dense (i.e. not sparse), the estimator used is PCA . Before fitting the transformer, the data is scaled to mean=0 and std=1 if it wasn't already. Read more in sklearn's documentation . If the data is [sparse][sparse datasets] (often the case for term-document matrices, see Vectorizer ), the estimator used is TruncatedSVD . Read more in sklearn's documentation . If engine is \"sklearnex\" or \"cuml\", the estimator used is the package's PCA implementation. Sparse data is not supported for neither engine. Selection from model SFM uses an estimator with feature_importances_ or coef_ attributes to select the best features in a dataset based on importance weights. The estimator is provided through the solver parameter and can be already fitted. ATOM allows you to use one its predefined models , e.g. solver = \"RF\" . If you didn't call the FeatureSelector through atom, don't forget to indicate the estimator's task adding _class or _reg after the name, e.g. RF_class to use a random forest classifier. Read more in sklearn's documentation . Sequential Feature Selection Sequential feature selection adds (forward selection) or removes (backward selection) features to form a feature subset in a greedy fashion. At each stage, this estimator chooses the best feature to add or remove based on the cross-validation score of an estimator. Read more in sklearn's documentation . Recursive Feature Elimination Select features by recursively considering smaller and smaller sets of features. First, the estimator is trained on the initial set of features, and the importance of each feature is obtained either through a coef_ or through a feature_importances_ attribute. Then, the least important features are pruned from current set of features. That procedure is recursively repeated on the pruned set until the desired number of features to select is eventually reached. Note that, since RFE needs to fit the model again every iteration, this method can be fairly slow. RFECV applies the same algorithm as RFE but uses a cross-validated metric (under the scoring parameter, see RFECV ) to assess every step's performance. Also, where RFE returns the number of features selected by n_features , RFECV returns the number of features that achieved the optimal score on the specified metric. Note that this is not always equal to the amount specified by n_features . Read more in sklearn's documentation .", "title": "Standard strategies"}, {"location": "user_guide/feature_engineering/#advanced-strategies", "text": "The following strategies are a collection of nature-inspired optimization algorithms that maximize an objective function. If not manually specified, the function calculates the cross-validated score of a model on the data. Use the scoring parameter (not present in description, part of kwargs) to specify the metric to optimize on. Particle Swarm Optimization Particle Swarm Optimization (PSO) optimizes a problem by having a population of candidate solutions (particles), and moving them around in the search-space according to simple mathematical formula over the particle's position and velocity. Each particle's movement is influenced by its local best known position, but is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions. Read more here . Harris Hawks Optimization Harris Hawks Optimization (HHO) mimics the action and reaction of Hawk's team collaboration hunting in nature and prey escaping to discover the solutions of the single-objective problem. Read more here . Grey Wolf Optimization The Grey Wolf Optimizer (GWO) mimics the leadership hierarchy and hunting mechanism of grey wolves in nature. Four types of grey wolves such as alpha, beta, delta, and omega are employed for simulating the leadership hierarchy. In addition, three main steps of hunting, searching for prey, encircling prey, and attacking prey, are implemented to perform optimization. Read more here . Dragonfly Optimization The Dragonfly Algorithm (DFO) algorithm originates from static and dynamic swarming behaviours. These two swarming behaviours are very similar to the two main phases of optimization using meta-heuristics: exploration and exploitation. Dragonflies create sub swarms and fly over different areas in a static swarm, which is the main objective of the exploration phase. In the static swarm, however, dragonflies fly in bigger swarms and along one direction, which is favourable in the exploitation phase. Read more here . Genetic Optimization Genetic Optimization is a metaheuristic inspired by the process of natural selection that belongs to the larger class of evolutionary algorithms. Genetic algorithms are commonly used to generate high-quality solutions to optimization and search problems by relying on biologically inspired operators such as mutation, crossover and selection. Read more here .", "title": "Advanced strategies"}, {"location": "user_guide/feature_engineering/#other-selection-methods", "text": "Removing features with low or high variance Variance is the expectation of the squared deviation of a random variable from its mean. Features with low variance have many values repeated, which means the model can't learn much from them. In a similar way, features with very high variance have very few values repeated, which makes it also difficult for a model to learn from this feature. FeatureSelector removes a categorical feature when the maximum number of occurrences for any value is below min_repeated or when the same value is repeated in at least max_repeated fraction of the rows. The default option is to remove a feature if all values in it are either different or exactly the same. Removing features with multi-collinearity Two features that are highly correlated are redundant, i.e. two will not contribute more to the model than only one of them. FeatureSelector will drop a feature that has a Pearson correlation coefficient larger than max_correlation with another feature. A correlation of 1 means the two columns are equal. A dataframe of the removed features and their correlation values can be accessed through the collinear attribute.", "title": "Other selection methods"}, {"location": "user_guide/introduction/", "text": "Introduction There is no magic formula in data science that can tell us which type of machine learning estimator in combination with which pipeline will perform best for a given raw dataset. Different models are better suited for different types of data and different types of problems. You can follow some rough guide on how to approach problems with regard to which model to try, but these are incomplete at best. During the exploration phase of a machine learning project, a data scientist tries to find the optimal pipeline for his specific use case. This usually involves applying standard data cleaning steps, creating or selecting useful features, trying out different models, etc. Testing multiple pipelines requires many lines of code, and writing it all in the same notebook often makes it long and cluttered. On the other hand, using multiple notebooks makes it harder to compare the results and to keep an overview. On top of that, refactoring the code for every test can be quite time-consuming. How many times have you conducted the same action to pre-process a raw dataset? How many times have you copy-and-pasted code from an old repository to re-use it in a new use case? Although best practices tell us to start with a simple model and build up to more complicated ones, many data scientists just use the model best known to them in order to avoid the aforementioned problems. This can result in poor performance (because the model is just not the right one for the task) or in inefficient management of time and computing resources (because a simpler/faster model could have achieved a similar performance). ATOM is here to help solve these common issues. The package acts as a wrapper of the whole machine learning pipeline, helping the data scientist to rapidly find a good model for his problem. Avoid endless imports and documentation lookups. Avoid rewriting the same code over and over again. With just a few lines of code, it's now possible to perform basic data cleaning steps, select relevant features and compare the performance of multiple models on a given dataset, providing quick insights on which pipeline performs best for the task at hand. It is important to realize that ATOM is not here to replace all the work a data scientist has to do before getting his model into production. ATOM doesn't spit out production-ready models just by tuning some parameters in its API. After helping you determine the right pipeline, you will most probably need to fine-tune it using use-case specific features and data cleaning steps in order to achieve maximum performance. Example steps taken by ATOM's pipeline: Data Cleaning Handle missing values Encode categorical features Detect and remove outliers Balance the training set Feature engineering Create new non-linear features Select the most promising features Train and validate multiple models Apply hyperparameter tuning Fit the models on the training set Evaluate the results on the test set Analyze the results Get the scores on various metrics Make plots to compare the model performances ![diagram_pipeline](../img/diagram_pipeline.png) <figcaption>Figure 1. Diagram of a possible pipeline created by ATOM.</figcaption>", "title": "Introduction"}, {"location": "user_guide/introduction/#introduction", "text": "There is no magic formula in data science that can tell us which type of machine learning estimator in combination with which pipeline will perform best for a given raw dataset. Different models are better suited for different types of data and different types of problems. You can follow some rough guide on how to approach problems with regard to which model to try, but these are incomplete at best. During the exploration phase of a machine learning project, a data scientist tries to find the optimal pipeline for his specific use case. This usually involves applying standard data cleaning steps, creating or selecting useful features, trying out different models, etc. Testing multiple pipelines requires many lines of code, and writing it all in the same notebook often makes it long and cluttered. On the other hand, using multiple notebooks makes it harder to compare the results and to keep an overview. On top of that, refactoring the code for every test can be quite time-consuming. How many times have you conducted the same action to pre-process a raw dataset? How many times have you copy-and-pasted code from an old repository to re-use it in a new use case? Although best practices tell us to start with a simple model and build up to more complicated ones, many data scientists just use the model best known to them in order to avoid the aforementioned problems. This can result in poor performance (because the model is just not the right one for the task) or in inefficient management of time and computing resources (because a simpler/faster model could have achieved a similar performance). ATOM is here to help solve these common issues. The package acts as a wrapper of the whole machine learning pipeline, helping the data scientist to rapidly find a good model for his problem. Avoid endless imports and documentation lookups. Avoid rewriting the same code over and over again. With just a few lines of code, it's now possible to perform basic data cleaning steps, select relevant features and compare the performance of multiple models on a given dataset, providing quick insights on which pipeline performs best for the task at hand. It is important to realize that ATOM is not here to replace all the work a data scientist has to do before getting his model into production. ATOM doesn't spit out production-ready models just by tuning some parameters in its API. After helping you determine the right pipeline, you will most probably need to fine-tune it using use-case specific features and data cleaning steps in order to achieve maximum performance. Example steps taken by ATOM's pipeline: Data Cleaning Handle missing values Encode categorical features Detect and remove outliers Balance the training set Feature engineering Create new non-linear features Select the most promising features Train and validate multiple models Apply hyperparameter tuning Fit the models on the training set Evaluate the results on the test set Analyze the results Get the scores on various metrics Make plots to compare the model performances ![diagram_pipeline](../img/diagram_pipeline.png) <figcaption>Figure 1. Diagram of a possible pipeline created by ATOM.</figcaption>", "title": "Introduction"}, {"location": "user_guide/logging/", "text": "Logging & Tracking Logging To start logging your experiments, fill the logger parameter with the name or path to store the logging file. If automatic naming is used, the file is saved using the __name__ of the class followed by the timestamp of the logger's creation, e.g. ATOMClassifier_11May21_20h11m03s . The logging file contains method calls, all printed messages to stdout with maximum verbosity, and any exception raised during running. Tracking ATOM uses mlflow tracking as a backend API and UI for logging the models in its pipeline. Start tracking your experiments assigning a name to the experiment parameter. Every model is tracked using a separate run. When no backend is configured, the data is stored locally at ./mlruns . To configure the backend, use mlflow.set_tracking_uri in your notebook or IDE before initializing atom. This does not affect the currently active run (if one exists), but takes effect for successive runs. Info When using ATOM on Databricks , the experiment's name should include the complete path to the storage, e.g. /Users/username@domain.com/experiment_name . The following elements are tracked: Tags The runs are automatically tagged with the model's full name, the branch from which the model was trained, and the time it took to fit the model. Parameters All parameters used by the estimator at initialization are tracked (only if the estimator has a get_params method). Additional parameters passed to the fit method are not tracked. Model The model's estimator is stored as artifact. The estimator has to be compatible with the mlflow.sklearn , module. This option can be switched off using atom's log_model attribute, e.g. atom . log_model = False . Hyperparameter tuning If hyperparameter tuning is performed, every call of the BO is tracked as a nested run in the model's main run. This option can be switched off using atom's log_ht attribute, e.g. atom . log_ht = False . Metrics All metric results are tracked, not only during training, but also when the evaluate method is called at a later point. Metrics calculated during in-training validation are also logged. Dataset The train and test sets used to fit and evaluate the model can be stored as .csv files to the run's artifacts. This option can be switched on using atom's log_data attribute, e.g. atom . log_data = True . Pipeline The model's pipeline (returned from the export_pipeline method) can be stored as an artifact using atom's log_pipeline attribute, e.g. atom . log_pipeline = True . Plots By default, plots are stored as .png artifacts in all runs corresponding to the models that are showed in the plot. If the filename parameter is specified, they are stored under that name, else the plot's name is used. This option can be switched off using atom's log_plots attribute, e.g. atom . log_plots = False .", "title": "Logging & Tracking"}, {"location": "user_guide/logging/#logging-tracking", "text": "", "title": "Logging &amp; Tracking"}, {"location": "user_guide/logging/#logging", "text": "To start logging your experiments, fill the logger parameter with the name or path to store the logging file. If automatic naming is used, the file is saved using the __name__ of the class followed by the timestamp of the logger's creation, e.g. ATOMClassifier_11May21_20h11m03s . The logging file contains method calls, all printed messages to stdout with maximum verbosity, and any exception raised during running.", "title": "Logging"}, {"location": "user_guide/logging/#tracking", "text": "ATOM uses mlflow tracking as a backend API and UI for logging the models in its pipeline. Start tracking your experiments assigning a name to the experiment parameter. Every model is tracked using a separate run. When no backend is configured, the data is stored locally at ./mlruns . To configure the backend, use mlflow.set_tracking_uri in your notebook or IDE before initializing atom. This does not affect the currently active run (if one exists), but takes effect for successive runs. Info When using ATOM on Databricks , the experiment's name should include the complete path to the storage, e.g. /Users/username@domain.com/experiment_name . The following elements are tracked: Tags The runs are automatically tagged with the model's full name, the branch from which the model was trained, and the time it took to fit the model. Parameters All parameters used by the estimator at initialization are tracked (only if the estimator has a get_params method). Additional parameters passed to the fit method are not tracked. Model The model's estimator is stored as artifact. The estimator has to be compatible with the mlflow.sklearn , module. This option can be switched off using atom's log_model attribute, e.g. atom . log_model = False . Hyperparameter tuning If hyperparameter tuning is performed, every call of the BO is tracked as a nested run in the model's main run. This option can be switched off using atom's log_ht attribute, e.g. atom . log_ht = False . Metrics All metric results are tracked, not only during training, but also when the evaluate method is called at a later point. Metrics calculated during in-training validation are also logged. Dataset The train and test sets used to fit and evaluate the model can be stored as .csv files to the run's artifacts. This option can be switched on using atom's log_data attribute, e.g. atom . log_data = True . Pipeline The model's pipeline (returned from the export_pipeline method) can be stored as an artifact using atom's log_pipeline attribute, e.g. atom . log_pipeline = True . Plots By default, plots are stored as .png artifacts in all runs corresponding to the models that are showed in the plot. If the filename parameter is specified, they are stored under that name, else the plot's name is used. This option can be switched off using atom's log_plots attribute, e.g. atom . log_plots = False .", "title": "Tracking"}, {"location": "user_guide/models/", "text": "Models Predefined models ATOM provides many models for classification and regression tasks that can be used to fit the data in the pipeline. After fitting, a class containing the underlying estimator is attached to atom as an attribute. We refer to these \"subclasses\" as models. Apart from the estimator, the models contain a variety of attributes and methods that can help you understand how the underlying estimator performed. They can be accessed using their acronyms, e.g. atom.LGB to access the LightGBM model. The available models and their corresponding acronyms are: \"AdaB\" for AdaBoost \"ARD\" for AutomaticRelevanceDetermination \"Bag\" for Bagging \"BR\" for BayesianRidge \"BNB\" for BernoulliNB \"CatB\" for CatBoost \"CatNB\" for CategoricalNB \"CNB\" for ComplementNB \"Tree\" for DecisionTree \"Dummy\" for Dummy \"EN\" for ElasticNet \"ETree\" for ExtraTree \"ET\" for ExtraTrees \"GNB\" for GaussianNB \"GP\" for GaussianProcess \"GBM\" for GradientBoosting \"Huber\" for HuberRegression \"hGBM\" for HistGradientBoosting \"KNN\" for KNearestNeighbors \"Lasso\" for Lasso \"Lars\" for LeastAngleRegression \"LGB\" for LightGBM \"LDA\" for LinearDiscriminantAnalysis \"lSVM\" for LinearSVM \"LR\" for LogisticRegression \"MLP\" for MultiLayerPerceptron \"MNB\" for MultinomialNB \"OLS\" for OrdinaryLeastSquares \"OMP\" for OrthogonalMatchingPursuit \"PA\" for PassiveAggressive \"Perc\" for Perceptron \"QDA\" for QuadraticDiscriminantAnalysis \"RNN\" for RadiusNearestNeighbors \"RF\" for RandomForest \"Ridge\" for Ridge \"SGD\" for StochasticGradientDescent \"SVM\" for SupportVectorMachine \"XGB\" for XGBoost Warning The model classes can not be initialized directly by the user! Use them only through atom. Tip The acronyms are case-insensitive, e.g. atom.lgb also calls the LightGBM model. Custom models It is also possible to create your own models in ATOM's pipeline. For example, imagine we want to use sklearn's RANSACRegressor estimator (note that is not included in ATOM's predefined models ). There are two ways to achieve this: Using ATOMModel (recommended). With this approach you can pass the required model characteristics to the pipeline. >>> from atom import ATOMRegressor , ATOMModel >>> from sklearn.linear_model import RANSACRegressor >>> ransac = ATOMModel ( ... models = RANSACRegressor , ... acronym = \"RANSAC\" , ... fullname = \"Random Sample Consensus\" , ... needs_scaling = True , ... ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( ransac ) Using the estimator's class or an instance of the class. This approach will also call ATOMModel under the hood, but it will leave its parameters to their default values. >>> from atom import ATOMRegressor >>> from sklearn.linear_model import RANSACRegressor >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( RANSACRegressor ) Additional things to take into account: Custom models can be accessed through their acronym like any other model, e.g. atom.ransac in the example above. Custom models are not restricted to sklearn estimators, but they should follow sklearn's API , i.e. have a fit and predict method. Parameter customization (for the initializer) is only possible for custom models which provide an estimator that has a set_params() method, i.e. it's a child class of BaseEstimator . Hyperparameter tuning for custom models is ignored unless appropriate dimensions are provided through ht_params . Deep learning Deep learning models can be used through ATOM's custom models as long as they follow sklearn's API . For example, models implemented with the Keras package should use the scikeras wrappers KerasClassifier or KerasRegressor . Many deep learning use cases, for example in computer vision, use datasets with more than 2 dimensions, e.g. image data can have shape (n_samples, length, width, rgb). Luckily, scikeras has a workaround to be able to work with such datasets. Learn with this example how to use ATOM to train and validate a Convolutional Neural Network on an image dataset. Warning Models implemented with keras can only use custom hyperparameter tuning when n_jobs = 1 or ht_params = { \"cv\" : 1 } . Using n_jobs > 1 and cv > 1 raises a PicklingError due to incompatibilities of the APIs. Ensembles Ensemble models use multiple estimators to obtain better predictive performance than could be obtained from any of the constituent learning algorithms alone. ATOM implements two ensemble techniques: voting and stacking. Click here to see an example that uses ensemble models. If the ensemble's underlying estimator is a model that used automated feature scaling , it's added as a Pipeline containing the scaler and estimator. If a mlflow experiment is active, the ensembles start their own run, just like the predefined models do. Warning Combining models trained on different branches into one ensemble is not allowed and will raise an exception. Voting The idea behind voting is to combine the predictions of conceptually different models to make new predictions. Such a technique can be useful for a set of equally well performing models in order to balance out their individual weaknesses. Read more in sklearn's documentation . A voting model is created from a trainer through the voting method. The voting model is added automatically to the list of models in the trainer, under the Vote acronym. The underlying estimator is a custom adaptation of VotingClassifier or VotingRegressor depending on the task. The differences between ATOM's and sklearn's implementation are: ATOM's implementation doesn't fit estimators if they're already fitted. ATOM's instance is considered fitted at initialization when all underlying estimators are. ATOM's VotingClassifier doesn't implement a LabelEncoder to encode the target column. The two estimators are customized in this way to save time and computational resources, since the classes are always initialized with fitted estimators. As a consequence of this, the VotingClassifier can not use sklearn's build-in LabelEncoder for the target column since it can't be fitted when initializing the class. For the vast majority of use cases, the changes will have no effect. If you want to export the estimator and retrain it on different data, just make sure to clone the underlying estimators first. Stacking Stacking is a method for combining estimators to reduce their biases. More precisely, the predictions of each individual estimator are stacked together and used as input to a final estimator to compute the prediction. Read more in sklearn's documentation . A stacking model is created from a trainer through the stacking method. The stacking model is added automatically to the list of models in the trainer, under the Stack acronym. The underlying estimator is a custom adaptation of StackingClassifier or StackingRegressor depending on the task. The only difference between ATOM's and sklearn's implementation is that ATOM's implementation doesn't fit estimators if they're already fitted. The two estimators are customized in this way to save time and computational resources, since the classes are always initialized with fitted estimators. For the vast majority of use cases, the changes will have no effect. If you want to export the estimator and retrain it on different data, just make sure to clone the underlying estimators first.", "title": "Models"}, {"location": "user_guide/models/#models", "text": "", "title": "Models"}, {"location": "user_guide/models/#predefined-models", "text": "ATOM provides many models for classification and regression tasks that can be used to fit the data in the pipeline. After fitting, a class containing the underlying estimator is attached to atom as an attribute. We refer to these \"subclasses\" as models. Apart from the estimator, the models contain a variety of attributes and methods that can help you understand how the underlying estimator performed. They can be accessed using their acronyms, e.g. atom.LGB to access the LightGBM model. The available models and their corresponding acronyms are: \"AdaB\" for AdaBoost \"ARD\" for AutomaticRelevanceDetermination \"Bag\" for Bagging \"BR\" for BayesianRidge \"BNB\" for BernoulliNB \"CatB\" for CatBoost \"CatNB\" for CategoricalNB \"CNB\" for ComplementNB \"Tree\" for DecisionTree \"Dummy\" for Dummy \"EN\" for ElasticNet \"ETree\" for ExtraTree \"ET\" for ExtraTrees \"GNB\" for GaussianNB \"GP\" for GaussianProcess \"GBM\" for GradientBoosting \"Huber\" for HuberRegression \"hGBM\" for HistGradientBoosting \"KNN\" for KNearestNeighbors \"Lasso\" for Lasso \"Lars\" for LeastAngleRegression \"LGB\" for LightGBM \"LDA\" for LinearDiscriminantAnalysis \"lSVM\" for LinearSVM \"LR\" for LogisticRegression \"MLP\" for MultiLayerPerceptron \"MNB\" for MultinomialNB \"OLS\" for OrdinaryLeastSquares \"OMP\" for OrthogonalMatchingPursuit \"PA\" for PassiveAggressive \"Perc\" for Perceptron \"QDA\" for QuadraticDiscriminantAnalysis \"RNN\" for RadiusNearestNeighbors \"RF\" for RandomForest \"Ridge\" for Ridge \"SGD\" for StochasticGradientDescent \"SVM\" for SupportVectorMachine \"XGB\" for XGBoost Warning The model classes can not be initialized directly by the user! Use them only through atom. Tip The acronyms are case-insensitive, e.g. atom.lgb also calls the LightGBM model.", "title": "Predefined models"}, {"location": "user_guide/models/#custom-models", "text": "It is also possible to create your own models in ATOM's pipeline. For example, imagine we want to use sklearn's RANSACRegressor estimator (note that is not included in ATOM's predefined models ). There are two ways to achieve this: Using ATOMModel (recommended). With this approach you can pass the required model characteristics to the pipeline. >>> from atom import ATOMRegressor , ATOMModel >>> from sklearn.linear_model import RANSACRegressor >>> ransac = ATOMModel ( ... models = RANSACRegressor , ... acronym = \"RANSAC\" , ... fullname = \"Random Sample Consensus\" , ... needs_scaling = True , ... ) >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( ransac ) Using the estimator's class or an instance of the class. This approach will also call ATOMModel under the hood, but it will leave its parameters to their default values. >>> from atom import ATOMRegressor >>> from sklearn.linear_model import RANSACRegressor >>> atom = ATOMRegressor ( X , y ) >>> atom . run ( RANSACRegressor ) Additional things to take into account: Custom models can be accessed through their acronym like any other model, e.g. atom.ransac in the example above. Custom models are not restricted to sklearn estimators, but they should follow sklearn's API , i.e. have a fit and predict method. Parameter customization (for the initializer) is only possible for custom models which provide an estimator that has a set_params() method, i.e. it's a child class of BaseEstimator . Hyperparameter tuning for custom models is ignored unless appropriate dimensions are provided through ht_params .", "title": "Custom models"}, {"location": "user_guide/models/#deep-learning", "text": "Deep learning models can be used through ATOM's custom models as long as they follow sklearn's API . For example, models implemented with the Keras package should use the scikeras wrappers KerasClassifier or KerasRegressor . Many deep learning use cases, for example in computer vision, use datasets with more than 2 dimensions, e.g. image data can have shape (n_samples, length, width, rgb). Luckily, scikeras has a workaround to be able to work with such datasets. Learn with this example how to use ATOM to train and validate a Convolutional Neural Network on an image dataset. Warning Models implemented with keras can only use custom hyperparameter tuning when n_jobs = 1 or ht_params = { \"cv\" : 1 } . Using n_jobs > 1 and cv > 1 raises a PicklingError due to incompatibilities of the APIs.", "title": "Deep learning"}, {"location": "user_guide/models/#ensembles", "text": "Ensemble models use multiple estimators to obtain better predictive performance than could be obtained from any of the constituent learning algorithms alone. ATOM implements two ensemble techniques: voting and stacking. Click here to see an example that uses ensemble models. If the ensemble's underlying estimator is a model that used automated feature scaling , it's added as a Pipeline containing the scaler and estimator. If a mlflow experiment is active, the ensembles start their own run, just like the predefined models do. Warning Combining models trained on different branches into one ensemble is not allowed and will raise an exception.", "title": "Ensembles"}, {"location": "user_guide/models/#voting", "text": "The idea behind voting is to combine the predictions of conceptually different models to make new predictions. Such a technique can be useful for a set of equally well performing models in order to balance out their individual weaknesses. Read more in sklearn's documentation . A voting model is created from a trainer through the voting method. The voting model is added automatically to the list of models in the trainer, under the Vote acronym. The underlying estimator is a custom adaptation of VotingClassifier or VotingRegressor depending on the task. The differences between ATOM's and sklearn's implementation are: ATOM's implementation doesn't fit estimators if they're already fitted. ATOM's instance is considered fitted at initialization when all underlying estimators are. ATOM's VotingClassifier doesn't implement a LabelEncoder to encode the target column. The two estimators are customized in this way to save time and computational resources, since the classes are always initialized with fitted estimators. As a consequence of this, the VotingClassifier can not use sklearn's build-in LabelEncoder for the target column since it can't be fitted when initializing the class. For the vast majority of use cases, the changes will have no effect. If you want to export the estimator and retrain it on different data, just make sure to clone the underlying estimators first.", "title": "Voting"}, {"location": "user_guide/models/#stacking", "text": "Stacking is a method for combining estimators to reduce their biases. More precisely, the predictions of each individual estimator are stacked together and used as input to a final estimator to compute the prediction. Read more in sklearn's documentation . A stacking model is created from a trainer through the stacking method. The stacking model is added automatically to the list of models in the trainer, under the Stack acronym. The underlying estimator is a custom adaptation of StackingClassifier or StackingRegressor depending on the task. The only difference between ATOM's and sklearn's implementation is that ATOM's implementation doesn't fit estimators if they're already fitted. The two estimators are customized in this way to save time and computational resources, since the classes are always initialized with fitted estimators. For the vast majority of use cases, the changes will have no effect. If you want to export the estimator and retrain it on different data, just make sure to clone the underlying estimators first.", "title": "Stacking"}, {"location": "user_guide/nlp/", "text": "Natural Language Processing Natural Language Processing (NLP) is the subfield of machine learning that works with human language data. The nlp module contains four classes that help to convert raw text to meaningful numeric values, ready to be ingested by a model. ATOM uses the nltk library for the majority of its NLP processes. The text documents are expected to be provided in a column of the dataframe named corpus (the name is case-insensitive). Only the corpus is changed by the transformers, leaving the rest of the columns as is. This mechanism allows atom to combine datasets containing a text corpus with other non-text features. If an array is provided as input, it should consist of only one feature containing the text (one document per row). ATOM will then automatically convert the array to a dataframe with the desired column name. Documents are expected to be strings or sequences of words. Click here for an example using text data. Note All of atom's NLP methods automatically adopt the relevant transformer attributes ( verbose , logger ) from atom. A different choice can be added as parameter to the method call, e.g. atom . tokenize ( verbose = 0 ) . Info ATOM doesn't do topic modelling! The module's goal is to help process text documents into features that can be used for supervised learning. Text cleaning Text data is rarely clean. Whether it's scraped from a website or inferred from paper documents, it's always populated with irrelevant information for the model, such as email addresses, HTML tags, numbers or punctuation marks. Use the TextCleaner class to clean the corpus from such noise. It can be accessed from atom through the textclean method. Use the class' parameters to choose which transformations to perform. The available steps are: Decode unicode characters to their ascii representations. Convert all characters to lower case. Drop email addresses from the text. Drop URL links from the text. Drop HTML tags from the text. Drop emojis from the text. Drop numbers from the text. Drop punctuations from the text. Tokenization Some text processing algorithms, like stemming or lemmatization, require the corpus to be made out of tokens, instead of strings, in order to know what to consider as words. Tokenization is used to achieve this. It separates every document into a sequence of smaller units. In this case, the words. Sometimes, words have a different meaning on their own than when combined with adjacent words. For example, the word new has a completely different meaning when the word york is directly after it than when it's not. These combinations of two words are called bigrams. When there are three words, they are called trigrams, and with four words quadgrams. The Tokenizer class converts a document into a sequence of words, and can create the most frequent bigrams, trigrams and quadgrams. It can be accessed from atom through the tokenize method. Text Normalization Normalization for texts is a process that converts a list of words to a more uniform standard. This is useful to reduce the amount of different information that the computer has to deal with, and therefore improves efficiency. The goal of normalization techniques like stemming and lemmatization is to reduce inflectional and related forms of a word to a common base form. Normalize the words in the corpus using the TextNormalizer class. It can be accessed from atom through the textnormalize method. Vectorization Text data cannot be fed directly to the algorithms themselves, as most of them expect numerical feature vectors with a fixed size, rather than words in the text documents with variable length. Vectorization is the general process of turning a collection of text documents into numerical feature vectors. You can apply it to the corpus using the Vectorizer class. It can be accessed from atom through the vectorize method. Info All strategies can utilize GPU speed-up. Click here for further information about GPU acceleration. Bag of Words The Bag of Words (BOW) strategy applies tokenization, counting and normalization to the corpus. Documents are described by word occurrences while completely ignoring the relative position information of the words in the document. The created columns are named with the words they are embedding with the prefix corpus_ . Read more in sklearn's documentation . TF-IDF In a large text corpus, some words will be very present (e.g. \u201cthe\u201d, \u201ca\u201d, \u201cis\u201d in English), hence carrying very little meaningful information about the actual contents of the document. If we were to feed the direct count data directly to a classifier, those very frequent terms would shadow the frequencies of rarer, yet more interesting, terms. Use the TF-IDF strategy to re-weight the count features into floating point values. The created columns are named with the words they are embedding with the prefix corpus_ . Read more in sklearn's documentation . Hashing The larger the corpus, the larger the vocabulary will grow and thus increasing the number of features and memory use. Use the Hashing strategy to hash the words to a specified number of features. The created features are named hash0 , hash1 , etc... Read more in sklearn's documentation .", "title": "NLP"}, {"location": "user_guide/nlp/#natural-language-processing", "text": "Natural Language Processing (NLP) is the subfield of machine learning that works with human language data. The nlp module contains four classes that help to convert raw text to meaningful numeric values, ready to be ingested by a model. ATOM uses the nltk library for the majority of its NLP processes. The text documents are expected to be provided in a column of the dataframe named corpus (the name is case-insensitive). Only the corpus is changed by the transformers, leaving the rest of the columns as is. This mechanism allows atom to combine datasets containing a text corpus with other non-text features. If an array is provided as input, it should consist of only one feature containing the text (one document per row). ATOM will then automatically convert the array to a dataframe with the desired column name. Documents are expected to be strings or sequences of words. Click here for an example using text data. Note All of atom's NLP methods automatically adopt the relevant transformer attributes ( verbose , logger ) from atom. A different choice can be added as parameter to the method call, e.g. atom . tokenize ( verbose = 0 ) . Info ATOM doesn't do topic modelling! The module's goal is to help process text documents into features that can be used for supervised learning.", "title": "Natural Language Processing"}, {"location": "user_guide/nlp/#text-cleaning", "text": "Text data is rarely clean. Whether it's scraped from a website or inferred from paper documents, it's always populated with irrelevant information for the model, such as email addresses, HTML tags, numbers or punctuation marks. Use the TextCleaner class to clean the corpus from such noise. It can be accessed from atom through the textclean method. Use the class' parameters to choose which transformations to perform. The available steps are: Decode unicode characters to their ascii representations. Convert all characters to lower case. Drop email addresses from the text. Drop URL links from the text. Drop HTML tags from the text. Drop emojis from the text. Drop numbers from the text. Drop punctuations from the text.", "title": "Text cleaning"}, {"location": "user_guide/nlp/#tokenization", "text": "Some text processing algorithms, like stemming or lemmatization, require the corpus to be made out of tokens, instead of strings, in order to know what to consider as words. Tokenization is used to achieve this. It separates every document into a sequence of smaller units. In this case, the words. Sometimes, words have a different meaning on their own than when combined with adjacent words. For example, the word new has a completely different meaning when the word york is directly after it than when it's not. These combinations of two words are called bigrams. When there are three words, they are called trigrams, and with four words quadgrams. The Tokenizer class converts a document into a sequence of words, and can create the most frequent bigrams, trigrams and quadgrams. It can be accessed from atom through the tokenize method.", "title": "Tokenization"}, {"location": "user_guide/nlp/#text-normalization", "text": "Normalization for texts is a process that converts a list of words to a more uniform standard. This is useful to reduce the amount of different information that the computer has to deal with, and therefore improves efficiency. The goal of normalization techniques like stemming and lemmatization is to reduce inflectional and related forms of a word to a common base form. Normalize the words in the corpus using the TextNormalizer class. It can be accessed from atom through the textnormalize method.", "title": "Text Normalization"}, {"location": "user_guide/nlp/#vectorization", "text": "Text data cannot be fed directly to the algorithms themselves, as most of them expect numerical feature vectors with a fixed size, rather than words in the text documents with variable length. Vectorization is the general process of turning a collection of text documents into numerical feature vectors. You can apply it to the corpus using the Vectorizer class. It can be accessed from atom through the vectorize method. Info All strategies can utilize GPU speed-up. Click here for further information about GPU acceleration. Bag of Words The Bag of Words (BOW) strategy applies tokenization, counting and normalization to the corpus. Documents are described by word occurrences while completely ignoring the relative position information of the words in the document. The created columns are named with the words they are embedding with the prefix corpus_ . Read more in sklearn's documentation . TF-IDF In a large text corpus, some words will be very present (e.g. \u201cthe\u201d, \u201ca\u201d, \u201cis\u201d in English), hence carrying very little meaningful information about the actual contents of the document. If we were to feed the direct count data directly to a classifier, those very frequent terms would shadow the frequencies of rarer, yet more interesting, terms. Use the TF-IDF strategy to re-weight the count features into floating point values. The created columns are named with the words they are embedding with the prefix corpus_ . Read more in sklearn's documentation . Hashing The larger the corpus, the larger the vocabulary will grow and thus increasing the number of features and memory use. Use the Hashing strategy to hash the words to a specified number of features. The created features are named hash0 , hash1 , etc... Read more in sklearn's documentation .", "title": "Vectorization"}, {"location": "user_guide/nomenclature/", "text": "Nomenclature This documentation consistently uses terms to refer to certain concepts related to this package. The most frequent terms are described hereunder. ATOM Refers to this package. atom Instance of the ATOMClassifier or ATOMRegressor classes (note that the examples use it as the default variable name). branch A pipeline , corresponding dataset and models fitted to that dataset. See the branches section of the user guide. categorical columns Refers to all columns of type object or category . class Unique value in a column, e.g. a binary classifier has 2 classes in the target column. dataframe-like Any type object from which a pd.DataFrame can be created. This includes an iterable , a dict whose values are 1d-arrays, a two-dimensional list , tuple , np.ndarray or sps.csr_matrix , and most commonly, a dataframe. This is the standard input format for any dataset. estimator An object which manages the estimation and decoding of an algorithm. The algorithm is estimated as a deterministic function of a set of parameters, a dataset and a random state. Should implement a fit method. Often used interchangeably with predictor because of user preference. missing values All values in the missing attribute, as well as None , NaN , +inf and -inf . model Instance of a model in the pipeline. Not to confuse with estimator . outliers Sample that contains one or more outlier values. Note that the Pruner class can use a different definition for outliers depending on the chosen strategy. outlier value Value that lies further than 3 times the standard deviation away from the mean of its column, i.e. |z-score| > 3. pipeline Sequence of transformers in a specific (usually the current) branch . predictor An estimator implementing a predict method. scorer A non-estimator callable object which evaluates an estimator on given test data, returning a number. Unlike evaluation metrics, a greater returned number must correspond with a better score. See sklearn's documentation . sequence A one-dimensional array of type list , tuple , np.ndarray or pd.Series . This is the standard input format for a dataset's target column. target The dependent variable in a supervised learning task. Passed as y to an estimator's fit method. task One of the three supervised machine learning approaches that ATOM supports: binary classification multiclass classification regression transformer An estimator implementing a transform method. This encompasses all data cleaning and feature engineering classes.", "title": "Nomenclature"}, {"location": "user_guide/nomenclature/#nomenclature", "text": "This documentation consistently uses terms to refer to certain concepts related to this package. The most frequent terms are described hereunder. ATOM Refers to this package. atom Instance of the ATOMClassifier or ATOMRegressor classes (note that the examples use it as the default variable name). branch A pipeline , corresponding dataset and models fitted to that dataset. See the branches section of the user guide. categorical columns Refers to all columns of type object or category . class Unique value in a column, e.g. a binary classifier has 2 classes in the target column. dataframe-like Any type object from which a pd.DataFrame can be created. This includes an iterable , a dict whose values are 1d-arrays, a two-dimensional list , tuple , np.ndarray or sps.csr_matrix , and most commonly, a dataframe. This is the standard input format for any dataset. estimator An object which manages the estimation and decoding of an algorithm. The algorithm is estimated as a deterministic function of a set of parameters, a dataset and a random state. Should implement a fit method. Often used interchangeably with predictor because of user preference. missing values All values in the missing attribute, as well as None , NaN , +inf and -inf . model Instance of a model in the pipeline. Not to confuse with estimator . outliers Sample that contains one or more outlier values. Note that the Pruner class can use a different definition for outliers depending on the chosen strategy. outlier value Value that lies further than 3 times the standard deviation away from the mean of its column, i.e. |z-score| > 3. pipeline Sequence of transformers in a specific (usually the current) branch . predictor An estimator implementing a predict method. scorer A non-estimator callable object which evaluates an estimator on given test data, returning a number. Unlike evaluation metrics, a greater returned number must correspond with a better score. See sklearn's documentation . sequence A one-dimensional array of type list , tuple , np.ndarray or pd.Series . This is the standard input format for a dataset's target column. target The dependent variable in a supervised learning task. Passed as y to an estimator's fit method. task One of the three supervised machine learning approaches that ATOM supports: binary classification multiclass classification regression transformer An estimator implementing a transform method. This encompasses all data cleaning and feature engineering classes.", "title": "Nomenclature"}, {"location": "user_guide/plots/", "text": "Plots ATOM provides many plotting methods to analyze the data or compare the model performances. Descriptions and examples can be found in the API section. ATOM mainly uses the plotly library for plotting. Plotly makes interactive, publication-quality graphs that are rendered using html. Some plots require other libraries like matplotlib , shap , wordcloud and schemdraw . Plots that compare model performances (methods with the models parameter) can be called directly from atom, e.g. atom . plot_roc () , or from one of the models, e.g. atom . adab . plot_roc () . If called from atom, use the models parameter to specify which models to plot. If called from a specific model, it makes the plot only for that model and the models parameter becomes unavailable. Plots that analyze the data (methods without the models parameter) can only be called from atom, and not from the models. Parameters Apart from the plot-specific parameters, all plots have five parameters in common: The title parameter adds a title to the plot. The default value doesn't show any title. Provide a configuration (as dictionary) to customize its appearance, e.g. title = dict ( text = \"Awesome plot\" , color = \"red\" ) . Read more in plotly's documentation . The legend parameter is used to show/hide, position or customize the plot's legend. Provide a configuration (as dictionary) to customize its appearance (e.g. legend = dict ( title = \"Title for legend\" , title_font_color = \"red\" ) ) or choose one of the following locations: upper left upper right lower left lower right upper center lower center center left center right center out: Position the legend outside the axis, on the right hand side. This is plotly's default position. Note that this shrinks the size of the axis to fit both legend and axes in the specified figsize . The figsize parameter adjust the plot's size. The filename parameter is used to save the plot. The display parameter determines whether to show or return the plot. Aesthetics The plot's aesthetics can be customized using the plot attributes, e.g. atom . title_fontsize = 30 . The default values are: palette: [\"rgb(0, 98, 98)\", \"rgb(56, 166, 165)\", \"rgb(115, 175, 72)\", \"rgb(237, 173, 8)\", \"rgb(225, 124, 5)\", \"rgb(204, 80, 62)\", \"rgb(148, 52, 110)\", \"rgb(111, 64, 112)\", \"rgb(102, 102, 102)\"] title_fontsize: 24 label_fontsize: 16 tick_fontsize: 12 Use atom's update_layout method to further customize the plot's aesthetics using any of plotly's layout properties , e.g. atom . update_layout ( template = \"plotly_dark\" ) . Use the reset_aesthetics method to reset the aesthetics to their default value. See advanced plotting for various examples. Canvas Use the canvas method to draw multiple plots side by side, for example to make it easier to compare similar results. The canvas method is a @contextmanager , i.e. it's used through Python's with command. Plots in a canvas ignore the legend, figsize, filename and display parameters. Instead, specify these parameters in the canvas. If a variable is assigned to the canvas (e.g. with atom . canvas () as fig ), it yields the resulting figure. For example, we can use a canvas to compare the results of a XGBoost and LightGBM model on the train and test set. We could also draw the lines for both models in the same axes, but that would clutter the plot too much. Click here for more examples. >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"xgb\" , \"lgb\" ]) >>> with atom . canvas ( 2 , 2 , title = \"XGBoost vs LightGBM\" ): ... atom . xgb . plot_roc ( dataset = \"both\" , title = \"ROC - XGBoost\" ) ... atom . lgb . plot_roc ( dataset = \"both\" , title = \"ROC - LightGBM\" ) ... atom . xgb . plot_prc ( dataset = \"both\" , title = \"PRC - XGBoost\" ) ... atom . lgb . plot_prc ( dataset = \"both\" , title = \"PRC - LightGBM\" ) ; SHAP The SHAP (SHapley Additive exPlanations) python package uses a game theoretic approach to explain the output of any machine learning model. It connects optimal credit allocation with local explanations using the classic Shapley values from game theory and their related extensions. ATOM implements methods to plot 7 of SHAP's plotting functions directly from its API. A list of available shap plots can be found here . Calculating the Shapley values is computationally expensive, especially for model agnostic explainers like Permutation . To avoid having to recalculate the values for every plot, ATOM stores the shapley values internally after the first calculation, and access them later when needed again. Note Since the plot figures are not made by ATOM, note the following: It's not possible to draw multiple models in the same figure. Selecting more than one model will raise an exception. To avoid this, call the plot directly from a model, e.g. atom . lr . plot_shap_force () . The returned plot is a matplotlib figure, not plotly's. Available plots A list of available plots can be found hereunder. Note that not all plots can be called from every class and that their availability can depend on the task at hand. Feature selection plots plot_components Plot the explained variance ratio per component. plot_pca Plot the explained variance ratio vs number of components. plot_rfecv Plot the rfecv results. Data plots plot_correlation Plot a correlation matrix. plot_distribution Plot column distributions. plot_ngrams Plot n-gram frequencies. plot_qq Plot a quantile-quantile plot. plot_relationships Plot pairwise relationships in a dataset. plot_wordcloud Plot a wordcloud from the corpus. Hyperparameter tuning plots plot_edf Plot the Empirical Distribution Function of a study. plot_hyperparameter_importance Plot a model's hyperparameter importance. plot_hyperparameters Plot hyperparameter relationships in a study. plot_parallel_coordinate Plot high-dimensional parameter relationships in a study. plot_pareto_front Plot the Pareto front of a study. plot_slice Plot the parameter relationship in a study. plot_trials Plot the hyperparameter tuning trials. Prediction plots plot_calibration Plot the calibration curve for a binary classifier. plot_confusion_matrix Plot a model's confusion matrix. plot_det Plot the Detection Error Tradeoff curve. plot_errors Plot a model's prediction errors. plot_evals Plot evaluation curves. plot_feature_importance Plot a model's feature importance. plot_gains Plot the cumulative gains curve. plot_learning_curve Plot the learning curve: score vs number of training samples. plot_lift Plot the lift curve. plot_parshap Plot the partial correlation of shap values. plot_partial_dependence Plot the partial dependence of features. plot_permutation_importance Plot the feature permutation importance of models. plot_pipeline Plot a diagram of the pipeline. plot_prc Plot the precision-recall curve. plot_probabilities Plot the probability distribution of the target classes. plot_residuals Plot a model's residuals. plot_results Plot the model results. plot_roc Plot the Receiver Operating Characteristics curve. plot_successive_halving Plot scores per iteration of the successive halving. plot_threshold Plot metric performances against threshold values. Shap plots plot_shap_bar Plot SHAP's bar plot. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_decision Plot SHAP's decision plot. plot_shap_force Plot SHAP's force plot. plot_shap_heatmap Plot SHAP's heatmap plot. plot_shap_scatter Plot SHAP's scatter plot. plot_shap_waterfall Plot SHAP's waterfall plot.", "title": "Plots"}, {"location": "user_guide/plots/#plots", "text": "ATOM provides many plotting methods to analyze the data or compare the model performances. Descriptions and examples can be found in the API section. ATOM mainly uses the plotly library for plotting. Plotly makes interactive, publication-quality graphs that are rendered using html. Some plots require other libraries like matplotlib , shap , wordcloud and schemdraw . Plots that compare model performances (methods with the models parameter) can be called directly from atom, e.g. atom . plot_roc () , or from one of the models, e.g. atom . adab . plot_roc () . If called from atom, use the models parameter to specify which models to plot. If called from a specific model, it makes the plot only for that model and the models parameter becomes unavailable. Plots that analyze the data (methods without the models parameter) can only be called from atom, and not from the models.", "title": "Plots"}, {"location": "user_guide/plots/#parameters", "text": "Apart from the plot-specific parameters, all plots have five parameters in common: The title parameter adds a title to the plot. The default value doesn't show any title. Provide a configuration (as dictionary) to customize its appearance, e.g. title = dict ( text = \"Awesome plot\" , color = \"red\" ) . Read more in plotly's documentation . The legend parameter is used to show/hide, position or customize the plot's legend. Provide a configuration (as dictionary) to customize its appearance (e.g. legend = dict ( title = \"Title for legend\" , title_font_color = \"red\" ) ) or choose one of the following locations: upper left upper right lower left lower right upper center lower center center left center right center out: Position the legend outside the axis, on the right hand side. This is plotly's default position. Note that this shrinks the size of the axis to fit both legend and axes in the specified figsize . The figsize parameter adjust the plot's size. The filename parameter is used to save the plot. The display parameter determines whether to show or return the plot.", "title": "Parameters"}, {"location": "user_guide/plots/#aesthetics", "text": "The plot's aesthetics can be customized using the plot attributes, e.g. atom . title_fontsize = 30 . The default values are: palette: [\"rgb(0, 98, 98)\", \"rgb(56, 166, 165)\", \"rgb(115, 175, 72)\", \"rgb(237, 173, 8)\", \"rgb(225, 124, 5)\", \"rgb(204, 80, 62)\", \"rgb(148, 52, 110)\", \"rgb(111, 64, 112)\", \"rgb(102, 102, 102)\"] title_fontsize: 24 label_fontsize: 16 tick_fontsize: 12 Use atom's update_layout method to further customize the plot's aesthetics using any of plotly's layout properties , e.g. atom . update_layout ( template = \"plotly_dark\" ) . Use the reset_aesthetics method to reset the aesthetics to their default value. See advanced plotting for various examples.", "title": "Aesthetics"}, {"location": "user_guide/plots/#canvas", "text": "Use the canvas method to draw multiple plots side by side, for example to make it easier to compare similar results. The canvas method is a @contextmanager , i.e. it's used through Python's with command. Plots in a canvas ignore the legend, figsize, filename and display parameters. Instead, specify these parameters in the canvas. If a variable is assigned to the canvas (e.g. with atom . canvas () as fig ), it yields the resulting figure. For example, we can use a canvas to compare the results of a XGBoost and LightGBM model on the train and test set. We could also draw the lines for both models in the same axes, but that would clutter the plot too much. Click here for more examples. >>> from atom import ATOMClassifier >>> import pandas as pd >>> X = pd . read_csv ( \"./examples/datasets/weatherAUS.csv\" ) >>> atom = ATOMClassifier ( X , y = \"RainTomorrow\" ) >>> atom . impute () >>> atom . encode () >>> atom . run ([ \"xgb\" , \"lgb\" ]) >>> with atom . canvas ( 2 , 2 , title = \"XGBoost vs LightGBM\" ): ... atom . xgb . plot_roc ( dataset = \"both\" , title = \"ROC - XGBoost\" ) ... atom . lgb . plot_roc ( dataset = \"both\" , title = \"ROC - LightGBM\" ) ... atom . xgb . plot_prc ( dataset = \"both\" , title = \"PRC - XGBoost\" ) ... atom . lgb . plot_prc ( dataset = \"both\" , title = \"PRC - LightGBM\" ) ;", "title": "Canvas"}, {"location": "user_guide/plots/#shap", "text": "The SHAP (SHapley Additive exPlanations) python package uses a game theoretic approach to explain the output of any machine learning model. It connects optimal credit allocation with local explanations using the classic Shapley values from game theory and their related extensions. ATOM implements methods to plot 7 of SHAP's plotting functions directly from its API. A list of available shap plots can be found here . Calculating the Shapley values is computationally expensive, especially for model agnostic explainers like Permutation . To avoid having to recalculate the values for every plot, ATOM stores the shapley values internally after the first calculation, and access them later when needed again. Note Since the plot figures are not made by ATOM, note the following: It's not possible to draw multiple models in the same figure. Selecting more than one model will raise an exception. To avoid this, call the plot directly from a model, e.g. atom . lr . plot_shap_force () . The returned plot is a matplotlib figure, not plotly's.", "title": "SHAP"}, {"location": "user_guide/plots/#available-plots", "text": "A list of available plots can be found hereunder. Note that not all plots can be called from every class and that their availability can depend on the task at hand.", "title": "Available plots"}, {"location": "user_guide/plots/#feature-selection-plots", "text": "plot_components Plot the explained variance ratio per component. plot_pca Plot the explained variance ratio vs number of components. plot_rfecv Plot the rfecv results.", "title": "Feature selection plots"}, {"location": "user_guide/plots/#data-plots", "text": "plot_correlation Plot a correlation matrix. plot_distribution Plot column distributions. plot_ngrams Plot n-gram frequencies. plot_qq Plot a quantile-quantile plot. plot_relationships Plot pairwise relationships in a dataset. plot_wordcloud Plot a wordcloud from the corpus.", "title": "Data plots"}, {"location": "user_guide/plots/#hyperparameter-tuning-plots", "text": "plot_edf Plot the Empirical Distribution Function of a study. plot_hyperparameter_importance Plot a model's hyperparameter importance. plot_hyperparameters Plot hyperparameter relationships in a study. plot_parallel_coordinate Plot high-dimensional parameter relationships in a study. plot_pareto_front Plot the Pareto front of a study. plot_slice Plot the parameter relationship in a study. plot_trials Plot the hyperparameter tuning trials.", "title": "Hyperparameter tuning plots"}, {"location": "user_guide/plots/#prediction-plots", "text": "plot_calibration Plot the calibration curve for a binary classifier. plot_confusion_matrix Plot a model's confusion matrix. plot_det Plot the Detection Error Tradeoff curve. plot_errors Plot a model's prediction errors. plot_evals Plot evaluation curves. plot_feature_importance Plot a model's feature importance. plot_gains Plot the cumulative gains curve. plot_learning_curve Plot the learning curve: score vs number of training samples. plot_lift Plot the lift curve. plot_parshap Plot the partial correlation of shap values. plot_partial_dependence Plot the partial dependence of features. plot_permutation_importance Plot the feature permutation importance of models. plot_pipeline Plot a diagram of the pipeline. plot_prc Plot the precision-recall curve. plot_probabilities Plot the probability distribution of the target classes. plot_residuals Plot a model's residuals. plot_results Plot the model results. plot_roc Plot the Receiver Operating Characteristics curve. plot_successive_halving Plot scores per iteration of the successive halving. plot_threshold Plot metric performances against threshold values.", "title": "Prediction plots"}, {"location": "user_guide/plots/#shap-plots", "text": "plot_shap_bar Plot SHAP's bar plot. plot_shap_beeswarm Plot SHAP's beeswarm plot. plot_shap_decision Plot SHAP's decision plot. plot_shap_force Plot SHAP's force plot. plot_shap_heatmap Plot SHAP's heatmap plot. plot_shap_scatter Plot SHAP's scatter plot. plot_shap_waterfall Plot SHAP's waterfall plot.", "title": "Shap plots"}, {"location": "user_guide/predicting/", "text": "Predicting Prediction methods After training a model, you probably want to make predictions on new, unseen data. Just like a sklearn estimator, you can call the prediction methods from the model, e.g. atom.tree.predict(X) . All prediction methods transform the provided data through the pipeline in the model's branch before making the predictions. Transformers that should only be applied on the training set are excluded from this step (e.g. outlier pruning or class balancing). The available prediction methods are the most common methods for estimators in sklearn's API: decision_function Get confidence scores on new data or rows in the dataset. predict Get class predictions on new data or rows in the dataset. predict_log_proba Get class log-probabilities on new data or rows in the dataset. predict_proba Get class probabilities on new data or rows in the dataset. score Get a metric score on new data. Prediction attributes The prediction methods can be calculated on the train, test and holdout set. You can access them through attributes of the form [method]_[data_set], e.g. atom.mnb.predict_train , atom.mnb.predict_test or atom.mnb.predict_holdout . The predictions for these attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to make (perhaps) expensive calculations that are never used, saving time and memory. Warning The prediction attributes for the score method return atom's metric score on that set, not the metric returned by sklearn's score method for estimators. Use the method's metric parameter to calculate a different metric. Note Many of the plots use the prediction attributes. This can considerably increase the size of the instance for large datasets. Use the clear method if you need to free some memory. Predictions on rows in the dataset It's also possible to get the prediction for a specific row or rows in the dataset, providing the names or positions of their indices, e.g. atom.rf.predict(10) returns the random forest's prediction on the 10th row in the dataset, or atom.rf.predict_proba([\"index1\", \"index2\"]) returns the class probabilities for the rows in the dataset with indices index1 and index2 .", "title": "Predicting"}, {"location": "user_guide/predicting/#predicting", "text": "", "title": "Predicting"}, {"location": "user_guide/predicting/#prediction-methods", "text": "After training a model, you probably want to make predictions on new, unseen data. Just like a sklearn estimator, you can call the prediction methods from the model, e.g. atom.tree.predict(X) . All prediction methods transform the provided data through the pipeline in the model's branch before making the predictions. Transformers that should only be applied on the training set are excluded from this step (e.g. outlier pruning or class balancing). The available prediction methods are the most common methods for estimators in sklearn's API: decision_function Get confidence scores on new data or rows in the dataset. predict Get class predictions on new data or rows in the dataset. predict_log_proba Get class log-probabilities on new data or rows in the dataset. predict_proba Get class probabilities on new data or rows in the dataset. score Get a metric score on new data.", "title": "Prediction methods"}, {"location": "user_guide/predicting/#prediction-attributes", "text": "The prediction methods can be calculated on the train, test and holdout set. You can access them through attributes of the form [method]_[data_set], e.g. atom.mnb.predict_train , atom.mnb.predict_test or atom.mnb.predict_holdout . The predictions for these attributes are not calculated until the attribute is called for the first time. This mechanism avoids having to make (perhaps) expensive calculations that are never used, saving time and memory. Warning The prediction attributes for the score method return atom's metric score on that set, not the metric returned by sklearn's score method for estimators. Use the method's metric parameter to calculate a different metric. Note Many of the plots use the prediction attributes. This can considerably increase the size of the instance for large datasets. Use the clear method if you need to free some memory.", "title": "Prediction attributes"}, {"location": "user_guide/predicting/#predictions-on-rows-in-the-dataset", "text": "It's also possible to get the prediction for a specific row or rows in the dataset, providing the names or positions of their indices, e.g. atom.rf.predict(10) returns the random forest's prediction on the 10th row in the dataset, or atom.rf.predict_proba([\"index1\", \"index2\"]) returns the class probabilities for the rows in the dataset with indices index1 and index2 .", "title": "Predictions on rows in the dataset"}, {"location": "user_guide/training/", "text": "Training The training phase is where the models are fitted on the training data. After this, you can use the plots and prediction methods to evaluate the results. The training applies the following steps for all models: Use hyperparameter tuning to select the optimal hyperparameters for the model (optional). The model is fitted on the training set using the best combination of hyperparameters found. After that, the model is evaluated on the tes set. Calculate various scores on the test set using a bootstrap algorithm (optional). There are three approaches to run the training. Direct training: DirectClassifier DirectRegressor Training via successive halving : SuccessiveHalvingClassifier SuccessiveHalvingRegressor Training via train sizing : TrainSizingClassifier TrainSizingRegressor The direct fashion repeats the aforementioned steps only once, while the other two approaches repeats them more than once. Just like the data cleaning and feature engineering classes, it's discouraged to use these classes directly. Instead, every approach can be called directly from atom through the run , successive_halving and train_sizing methods respectively. Models are called through their acronyms , e.g. atom . run ( models = \"RF\" ) will train a RandomForest . If you want to run the same model multiple times, add a tag after the acronym to differentiate them. >>> atom . run ( ... models = [ \"RF1\" , \"RF2\" ], ... est_params = { ... \"RF1\" : { \"n_estimators\" : 100 }, ... \"RF2\" : { \"n_estimators\" : 200 }, ... } ... ) For example, this pipeline fits two Random Forest models, one with 100 and the other with 200 decision trees. The models can be accessed through atom.rf1 and atom.rf2 . Use tagged models to test how the same model performs when fitted with different parameters or on different data sets. See the Imbalanced datasets example. Additional things to take into account: If an exception is encountered while fitting an estimator, the pipeline will automatically jump to the next model. The exceptions are stored in the errors attribute. Note that when a model is skipped, there is no model subclass for that estimator. When showing the final results, a ! indicates the highest score and a ~ indicates that the model is possibly overfitting (training set has a score at least 20% higher than the test set). Metric ATOM uses sklearn's scorers for model evaluation. A scorer consists of a metric function and some parameters that define the scorer's properties , such as if a higher or lower score is better (score or loss function) or if the function needs probability estimates or rounded predictions (see the make_scorer function). The metric parameter accepts three ways of defining the scorer: Using the name of one of the predefined scorers . Using a function with signature function ( y_true , y_pred ) -> score . In this case, ATOM uses make_scorer with default parameters. Using a scorer object. Note that all scorers follow the convention that higher return values are better than lower return values. Thus, metrics which measure the distance between the model and the data (i.e. loss functions), like max_error or mean_squared_error , will return the negated value of the metric. Predefined scorers ATOM accepts all sklearn's scorers as well as some custom acronyms and custom scorers. Since some of sklearn's scorers have quite long names and ATOM is all about lazy fast experimentation, the package provides acronyms for some of the most commonly used ones. These acronyms are case-insensitive and can be used in the metric parameter instead of the scorer's full name, e.g. atom . run ( \"LR\" , metric = \"BA\" ) uses balanced_accuracy . The available acronyms are: \"AP\" for \"average_precision\" \"BA\" for \"balanced_accuracy\" \"AUC\" for \"roc_auc\" \"LogLoss\" for \"neg_log_loss\" \"EV\" for \"explained_variance\" \"ME\" for \"max_error\" \"MAE\" for \"neg_mean_absolute_error\" \"MSE\" for \"neg_mean_squared_error\" \"RMSE\" for \"neg_root_mean_squared_error\" \"MSLE\" for \"neg_mean_squared_log_error\" \"MEDAE\" for \"neg_median_absolute_error\" \"MAPE\" for \"neg_mean_absolute_percentage_error\" \"POISSON\" for \"neg_mean_poisson_deviance\" \"GAMMA\" for \"neg_mean_gamma_deviance\" ATOM also provides some extra common metrics for binary classification tasks. \"TN\" for True Negatives \"FP\" for False Positives \"FN\" for False Negatives \"TP\" for True Positives \"FPR\" for False Positive rate (fall-out) \"TPR\" for True Positive Rate (sensitivity, recall) \"TNR\" for True Negative Rate (specificity) \"FNR\" for False Negative Rate (miss rate) \"MCC\" for Matthews Correlation Coefficient (also for multiclass classification) Multi-metric runs Sometimes it is useful to measure the performance of the models in more than one way. ATOM lets you run the pipeline with multiple metrics at the same time. To do so, provide the metric parameter with a list of desired metrics, e.g. atom . run ( \"LDA\" , metric = [ \"r2\" , \"mse\" ]) . When fitting multi-metric runs, the resulting scores will return a list of metrics. For example, if you provided three metrics to the pipeline, atom . knn . score_train could return [0.8734, 0.6672, 0.9001]. Only the first metric of a multi-metric run (this metric is called the main metric) is used to select the winning model. Info The winning model is retrieved comparing only the main metric. Some plots let you choose which of the metrics in a multi-metric run to show using the metric parameter, e.g. plot_results . Automated feature scaling Models that require feature scaling will automatically do so before training, unless the data is sparse or already scaled. The data is considered scaled if it has one of the following prerequisites: The mean value over the mean of all columns lies between -0.05 and 0.05 and the mean of the standard deviation over all columns lies between 0.85 and 1.15. Categorical and binary columns (only 0s and 1s) are excluded from the calculation. There is a transformer in the pipeline whose __name__ contains the word scaler . The scaling is applied using a Scaler with default parameters. It can be accessed from the model through the scaler attribute. The scaled dataset can be examined through the model's data attributes . Use the available_models method to see which models require feature scaling. See here an example. In-training validation Some predefined models allow in-training validation. This means that the estimator is evaluated (using only the main metric ) on the train and test set after every round of the training (a round can be an iteration for linear models or an added tree for boosted tree models). The validation scores are stored in the evals attribute, a dictionary of the train and test performances per round (also when pruning isn't applied). Click here for an example using in-training validation. The predefined models that support in-training validation are: CatBoost LightGBM MultiLayerPerceptron PassiveAggressive Perceptron StochasticGradientDescent XGBoost To apply in-training validation to a custom model , use the has_validation parameter when creating the custom model. Warning In-training validation is not calculated during hyperparameter tuning . Tip Use the plot_evals method to visualize the in-training validation on the train and test sets. Parameter customization By default, every estimator uses the default parameters they get from their respective packages. To select different ones, use the est_params . parameter of the run method. There are two ways to add custom parameters to the models: adding them directly to the dictionary as key-value pairs or through dictionaries. Adding the parameters directly to est_params (or using a dict with the key 'all') shares them across all models in the trainer. In this example, both the XGBoost and the LightGBM model use 200 boosted trees. Make sure all the models do have the specified parameters or an exception will be raised! >>> atom . run ( models = [ \"XGB\" , \"LGB\" ], est_params = { \"n_estimators\" : 200 }) To specify parameters per model, use the model name as key and a dict of the parameters as value. In this example, the XGBoost model uses n_estimators=200 and the MultiLayerPerceptron uses one hidden layer with 75 neurons. >>> atom . run ( ... models = [ \"XGB\" , \"MLP\" ], ... est_params = { ... \"XGB\" : { \"n_estimators\" : 200 }, ... \"MLP\" : { \"hidden_layer_sizes\" : ( 75 ,)}, ... } ... ) Some estimators allow you to pass extra parameters to the fit method (besides X and y). This can be done adding _fit at the end of the parameter. For example, to change XGBoost 's verbosity, we can run: >>> atom . run ( models = \"XGB\" , est_params = { \"verbose_fit\" : True }) Note If a parameter is specified through est_params , it's ignored by the study, even if it's added manually to ht_params [ \"distributions\" ] . Info The estimator's n_jobs and random_state parameters adopt atom's values (when available), unless specified through est_params . Hyperparameter tuning In order to achieve maximum performance, it's important to tune an estimator's hyperparameters before training it. ATOM provides hyperparameter tuning through the optuna package. Just like optuna, we use the terms study and trial as follows: Study: optimization based on an objective function. Trial: a single execution of the objective function. Each trial is either computed by cross-validation on the complete training set or by randomly splitting the training set every iteration into a (sub)training and validation set. This process can create some minimum data leakage towards specific parameters (since the estimator is evaluated on data that is used to train the next estimator), but it ensures maximal use of the provided data. However, the leakage is not present in the independent test set, thus the final score of every model is unbiased. Note that, if the dataset is relatively small, the tuning's best score can consistently be lower than the final score on the test set due to the considerable lower fraction of instances on which it is trained. After finishing the study, the parameters that resulted in the best score are used to fit the final model on the complete training set. Info Unless specified differently by the user, the used samplers are TPESampler for single-metric runs and NSGAIISampler for multi-metric runs . For multi-metric runs , the selected best trial is the trial that performed best on the main metric. Use the property's @setter to change it to any other trial. See the hyperparameter tuning example. There are many possibilities to tune the study to your liking. The main parameter is n_trials , which determine the number of trials that are performed. Extra things to take into account: The train/validation splits are different per trial but equal for all models. Re-evaluating the objective function at the same point (with the same hyperparameters) automatically skips the calculation and returns the same score as the equivalent trial. Tip The hyperparameter tuning output can become quite wide for models with many hyperparameters. If you are working in a Jupyter Notebook, you can change the output's width running the following code in a cell: >>> from IPython.display import display , HTML >>> display ( HTML ( \"<style>.container { width:100% !important; }</style>\" )) Other settings can be changed through the ht_params parameter, a dictionary where every key-value combination can be used to further customize the optimization. By default, which hyperparameters are tuned and their corresponding distributions are predefined by ATOM. Use the 'distributions' key to customize these. Just like with est_params , it's possible to share the same parameters across models or use a dictionary with the model name as key to specify the parameters for every individual model. Use the key 'all' to tune some hyperparameters for all models when you also want to tune other parameters only for specific ones. The following example tunes the n_estimators parameter for both models but the max_depth parameter only for the RandomForest . >>> atom . run ( ... models = [ \"ET\" , \"RF\" ], ... n_trials = 30 , ... ht_params = { \"distributions\" : { \"all\" : \"n_estimators\" , \"RF\" : \"max_depth\" }}, ... ) Like the columns parameter in atom's methods, you can exclude parameters from the optimization adding ! before its name. It's possible to exclude multiple parameters, but not to combine inclusion and exclusion for the same model. For example, to optimize a RandomForest using all its predefined parameters except n_estimators , run: >>> atom . run ( ... models = \"ET\" , ... n_trials = 15 , ... ht_params = { \"distributions\" : \"!n_estimators\" }, ... ) If just the parameter name is provided, the predefined distribution is used. It's also possible to provide custom distributions spaces, but make sure they are compliant with optuna's API . See every model's individual documentation in ATOM's API section for an overview of their hyperparameters and distributions. >>> from optuna.distributions import ( ... IntDistribution , FloatDistribution , CategoricalDistribution ... ) >>> atom . run ( ... models = [ \"ET\" , \"RF\" ], ... n_trials = 30 , ... ht_params = { ... \"dimensions\" : { ... \"all\" : { \"n_estimators\" : IntDistribution ( 10 , 100 , step = 10 ), ... \"RF\" : { ... \"max_depth\" : IntDistribution ( 1 , 10 ), ... \"max_features\" : CategoricalDistribution ([ \"sqrt\" , \"log2\" ]), ... }, ... }, ... }, ... ) Parameters for optuna's study and the study's optimize method can be added as kwargs to ht_params . For example, to use a different sampler or add a custom callback. >>> from optuna.samplers import RandomSampler >>> atom . run ( ... models = \"LR\" , ... n_trials = 30 , ... ht_params = { ... \"sampler\" : RandomSampler ( seed = atom . random_state ), ... \"callbacks\" : custom_callback (), ... }, ... ) Note If you use the default sampler, it\u2019s recommended to consider setting larger n_trials to make full use of the characteristics of TPESampler because TPESampler uses some (by default, 10) trials for its startup. When specifying distributions manually, make sure to import the distribution types from optuna: from optuna.distributions import ... . Warning Keras' models can only use hyperparameter tuning when n_jobs = 1 or ht_params = { \"cv\" : 1 } . Using n_jobs > 1 and cv > 1 raises a PicklingError due to incompatibilities of the APIs. Read here more about deep learning models. Tip ATOM has several plots that can help you examine a model's study and trials. Have a look at them here . Pruning During hyperparameter tuning, pruning stops unpromising trials at the early stages of the training (a.k.a., automated early-stopping). This can save the pipeline much time that would otherwise be wasted on an estimator that is unlikely to yield the best results. A pruned trial can't be selected as best_trial . Click here to see an example that uses pruning. The study uses MedianPruner as default pruner. You can use any other of optuna's pruners through the ht_params parameter. >>> from optuna.pruners import HyperbandPruner >>> atom . run ( \"SGD\" , n_trials = 30 , ht_params = { \"pruner\" : HyperbandPruner ()}) Warning Pruning is disabled for multi-metric runs . Pruning is only available for models that support in-training validation . Bootstrapping After fitting the estimator, you can assess the robustness of the model using the bootstrap technique. This technique creates several new data sets selecting random samples from the training set (with replacement) and evaluates them on the test set. This way you can get a distribution of the performance of the model. The sets are the same for every model. The number of sets can be chosen through the n_bootstrap parameter. Tip Use the plot_results method to plot the boostrap scores in a boxplot. Successive halving Successive halving is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, we recommend only to use this technique with similar models, e.g. only using tree-based models. Run successive halving from atom via the successive_halving method. Consecutive runs of the same model are saved with the model's acronym followed by the number of models in the run. For example, a RandomForest in a run with 4 models would become model RF4 . See here a successive halving example. Tip Use the plot_successive_halving method to see every model's performance per iteration of the successive halving. Train sizing When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. Train sizing can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set. Run train sizing from atom via the train_sizing method. The number of iterations and the number of samples per training can be specified with the train_sizes parameter. Consecutive runs of the same model are saved with the model's acronym followed by the fraction of rows in the training set (the . is removed from the fraction!). For example, a RandomForest in a run with 80% of the training samples would become model RF08 . See here a train sizing example. Tip Use the plot_learning_curve method to see the model's performance per size of the training set.", "title": "Training"}, {"location": "user_guide/training/#training", "text": "The training phase is where the models are fitted on the training data. After this, you can use the plots and prediction methods to evaluate the results. The training applies the following steps for all models: Use hyperparameter tuning to select the optimal hyperparameters for the model (optional). The model is fitted on the training set using the best combination of hyperparameters found. After that, the model is evaluated on the tes set. Calculate various scores on the test set using a bootstrap algorithm (optional). There are three approaches to run the training. Direct training: DirectClassifier DirectRegressor Training via successive halving : SuccessiveHalvingClassifier SuccessiveHalvingRegressor Training via train sizing : TrainSizingClassifier TrainSizingRegressor The direct fashion repeats the aforementioned steps only once, while the other two approaches repeats them more than once. Just like the data cleaning and feature engineering classes, it's discouraged to use these classes directly. Instead, every approach can be called directly from atom through the run , successive_halving and train_sizing methods respectively. Models are called through their acronyms , e.g. atom . run ( models = \"RF\" ) will train a RandomForest . If you want to run the same model multiple times, add a tag after the acronym to differentiate them. >>> atom . run ( ... models = [ \"RF1\" , \"RF2\" ], ... est_params = { ... \"RF1\" : { \"n_estimators\" : 100 }, ... \"RF2\" : { \"n_estimators\" : 200 }, ... } ... ) For example, this pipeline fits two Random Forest models, one with 100 and the other with 200 decision trees. The models can be accessed through atom.rf1 and atom.rf2 . Use tagged models to test how the same model performs when fitted with different parameters or on different data sets. See the Imbalanced datasets example. Additional things to take into account: If an exception is encountered while fitting an estimator, the pipeline will automatically jump to the next model. The exceptions are stored in the errors attribute. Note that when a model is skipped, there is no model subclass for that estimator. When showing the final results, a ! indicates the highest score and a ~ indicates that the model is possibly overfitting (training set has a score at least 20% higher than the test set).", "title": "Training"}, {"location": "user_guide/training/#metric", "text": "ATOM uses sklearn's scorers for model evaluation. A scorer consists of a metric function and some parameters that define the scorer's properties , such as if a higher or lower score is better (score or loss function) or if the function needs probability estimates or rounded predictions (see the make_scorer function). The metric parameter accepts three ways of defining the scorer: Using the name of one of the predefined scorers . Using a function with signature function ( y_true , y_pred ) -> score . In this case, ATOM uses make_scorer with default parameters. Using a scorer object. Note that all scorers follow the convention that higher return values are better than lower return values. Thus, metrics which measure the distance between the model and the data (i.e. loss functions), like max_error or mean_squared_error , will return the negated value of the metric.", "title": "Metric"}, {"location": "user_guide/training/#predefined-scorers", "text": "ATOM accepts all sklearn's scorers as well as some custom acronyms and custom scorers. Since some of sklearn's scorers have quite long names and ATOM is all about lazy fast experimentation, the package provides acronyms for some of the most commonly used ones. These acronyms are case-insensitive and can be used in the metric parameter instead of the scorer's full name, e.g. atom . run ( \"LR\" , metric = \"BA\" ) uses balanced_accuracy . The available acronyms are: \"AP\" for \"average_precision\" \"BA\" for \"balanced_accuracy\" \"AUC\" for \"roc_auc\" \"LogLoss\" for \"neg_log_loss\" \"EV\" for \"explained_variance\" \"ME\" for \"max_error\" \"MAE\" for \"neg_mean_absolute_error\" \"MSE\" for \"neg_mean_squared_error\" \"RMSE\" for \"neg_root_mean_squared_error\" \"MSLE\" for \"neg_mean_squared_log_error\" \"MEDAE\" for \"neg_median_absolute_error\" \"MAPE\" for \"neg_mean_absolute_percentage_error\" \"POISSON\" for \"neg_mean_poisson_deviance\" \"GAMMA\" for \"neg_mean_gamma_deviance\" ATOM also provides some extra common metrics for binary classification tasks. \"TN\" for True Negatives \"FP\" for False Positives \"FN\" for False Negatives \"TP\" for True Positives \"FPR\" for False Positive rate (fall-out) \"TPR\" for True Positive Rate (sensitivity, recall) \"TNR\" for True Negative Rate (specificity) \"FNR\" for False Negative Rate (miss rate) \"MCC\" for Matthews Correlation Coefficient (also for multiclass classification)", "title": "Predefined scorers"}, {"location": "user_guide/training/#multi-metric-runs", "text": "Sometimes it is useful to measure the performance of the models in more than one way. ATOM lets you run the pipeline with multiple metrics at the same time. To do so, provide the metric parameter with a list of desired metrics, e.g. atom . run ( \"LDA\" , metric = [ \"r2\" , \"mse\" ]) . When fitting multi-metric runs, the resulting scores will return a list of metrics. For example, if you provided three metrics to the pipeline, atom . knn . score_train could return [0.8734, 0.6672, 0.9001]. Only the first metric of a multi-metric run (this metric is called the main metric) is used to select the winning model. Info The winning model is retrieved comparing only the main metric. Some plots let you choose which of the metrics in a multi-metric run to show using the metric parameter, e.g. plot_results .", "title": "Multi-metric runs"}, {"location": "user_guide/training/#automated-feature-scaling", "text": "Models that require feature scaling will automatically do so before training, unless the data is sparse or already scaled. The data is considered scaled if it has one of the following prerequisites: The mean value over the mean of all columns lies between -0.05 and 0.05 and the mean of the standard deviation over all columns lies between 0.85 and 1.15. Categorical and binary columns (only 0s and 1s) are excluded from the calculation. There is a transformer in the pipeline whose __name__ contains the word scaler . The scaling is applied using a Scaler with default parameters. It can be accessed from the model through the scaler attribute. The scaled dataset can be examined through the model's data attributes . Use the available_models method to see which models require feature scaling. See here an example.", "title": "Automated feature scaling"}, {"location": "user_guide/training/#in-training-validation", "text": "Some predefined models allow in-training validation. This means that the estimator is evaluated (using only the main metric ) on the train and test set after every round of the training (a round can be an iteration for linear models or an added tree for boosted tree models). The validation scores are stored in the evals attribute, a dictionary of the train and test performances per round (also when pruning isn't applied). Click here for an example using in-training validation. The predefined models that support in-training validation are: CatBoost LightGBM MultiLayerPerceptron PassiveAggressive Perceptron StochasticGradientDescent XGBoost To apply in-training validation to a custom model , use the has_validation parameter when creating the custom model. Warning In-training validation is not calculated during hyperparameter tuning . Tip Use the plot_evals method to visualize the in-training validation on the train and test sets.", "title": "In-training validation"}, {"location": "user_guide/training/#parameter-customization", "text": "By default, every estimator uses the default parameters they get from their respective packages. To select different ones, use the est_params . parameter of the run method. There are two ways to add custom parameters to the models: adding them directly to the dictionary as key-value pairs or through dictionaries. Adding the parameters directly to est_params (or using a dict with the key 'all') shares them across all models in the trainer. In this example, both the XGBoost and the LightGBM model use 200 boosted trees. Make sure all the models do have the specified parameters or an exception will be raised! >>> atom . run ( models = [ \"XGB\" , \"LGB\" ], est_params = { \"n_estimators\" : 200 }) To specify parameters per model, use the model name as key and a dict of the parameters as value. In this example, the XGBoost model uses n_estimators=200 and the MultiLayerPerceptron uses one hidden layer with 75 neurons. >>> atom . run ( ... models = [ \"XGB\" , \"MLP\" ], ... est_params = { ... \"XGB\" : { \"n_estimators\" : 200 }, ... \"MLP\" : { \"hidden_layer_sizes\" : ( 75 ,)}, ... } ... ) Some estimators allow you to pass extra parameters to the fit method (besides X and y). This can be done adding _fit at the end of the parameter. For example, to change XGBoost 's verbosity, we can run: >>> atom . run ( models = \"XGB\" , est_params = { \"verbose_fit\" : True }) Note If a parameter is specified through est_params , it's ignored by the study, even if it's added manually to ht_params [ \"distributions\" ] . Info The estimator's n_jobs and random_state parameters adopt atom's values (when available), unless specified through est_params .", "title": "Parameter customization"}, {"location": "user_guide/training/#hyperparameter-tuning", "text": "In order to achieve maximum performance, it's important to tune an estimator's hyperparameters before training it. ATOM provides hyperparameter tuning through the optuna package. Just like optuna, we use the terms study and trial as follows: Study: optimization based on an objective function. Trial: a single execution of the objective function. Each trial is either computed by cross-validation on the complete training set or by randomly splitting the training set every iteration into a (sub)training and validation set. This process can create some minimum data leakage towards specific parameters (since the estimator is evaluated on data that is used to train the next estimator), but it ensures maximal use of the provided data. However, the leakage is not present in the independent test set, thus the final score of every model is unbiased. Note that, if the dataset is relatively small, the tuning's best score can consistently be lower than the final score on the test set due to the considerable lower fraction of instances on which it is trained. After finishing the study, the parameters that resulted in the best score are used to fit the final model on the complete training set. Info Unless specified differently by the user, the used samplers are TPESampler for single-metric runs and NSGAIISampler for multi-metric runs . For multi-metric runs , the selected best trial is the trial that performed best on the main metric. Use the property's @setter to change it to any other trial. See the hyperparameter tuning example. There are many possibilities to tune the study to your liking. The main parameter is n_trials , which determine the number of trials that are performed. Extra things to take into account: The train/validation splits are different per trial but equal for all models. Re-evaluating the objective function at the same point (with the same hyperparameters) automatically skips the calculation and returns the same score as the equivalent trial. Tip The hyperparameter tuning output can become quite wide for models with many hyperparameters. If you are working in a Jupyter Notebook, you can change the output's width running the following code in a cell: >>> from IPython.display import display , HTML >>> display ( HTML ( \"<style>.container { width:100% !important; }</style>\" )) Other settings can be changed through the ht_params parameter, a dictionary where every key-value combination can be used to further customize the optimization. By default, which hyperparameters are tuned and their corresponding distributions are predefined by ATOM. Use the 'distributions' key to customize these. Just like with est_params , it's possible to share the same parameters across models or use a dictionary with the model name as key to specify the parameters for every individual model. Use the key 'all' to tune some hyperparameters for all models when you also want to tune other parameters only for specific ones. The following example tunes the n_estimators parameter for both models but the max_depth parameter only for the RandomForest . >>> atom . run ( ... models = [ \"ET\" , \"RF\" ], ... n_trials = 30 , ... ht_params = { \"distributions\" : { \"all\" : \"n_estimators\" , \"RF\" : \"max_depth\" }}, ... ) Like the columns parameter in atom's methods, you can exclude parameters from the optimization adding ! before its name. It's possible to exclude multiple parameters, but not to combine inclusion and exclusion for the same model. For example, to optimize a RandomForest using all its predefined parameters except n_estimators , run: >>> atom . run ( ... models = \"ET\" , ... n_trials = 15 , ... ht_params = { \"distributions\" : \"!n_estimators\" }, ... ) If just the parameter name is provided, the predefined distribution is used. It's also possible to provide custom distributions spaces, but make sure they are compliant with optuna's API . See every model's individual documentation in ATOM's API section for an overview of their hyperparameters and distributions. >>> from optuna.distributions import ( ... IntDistribution , FloatDistribution , CategoricalDistribution ... ) >>> atom . run ( ... models = [ \"ET\" , \"RF\" ], ... n_trials = 30 , ... ht_params = { ... \"dimensions\" : { ... \"all\" : { \"n_estimators\" : IntDistribution ( 10 , 100 , step = 10 ), ... \"RF\" : { ... \"max_depth\" : IntDistribution ( 1 , 10 ), ... \"max_features\" : CategoricalDistribution ([ \"sqrt\" , \"log2\" ]), ... }, ... }, ... }, ... ) Parameters for optuna's study and the study's optimize method can be added as kwargs to ht_params . For example, to use a different sampler or add a custom callback. >>> from optuna.samplers import RandomSampler >>> atom . run ( ... models = \"LR\" , ... n_trials = 30 , ... ht_params = { ... \"sampler\" : RandomSampler ( seed = atom . random_state ), ... \"callbacks\" : custom_callback (), ... }, ... ) Note If you use the default sampler, it\u2019s recommended to consider setting larger n_trials to make full use of the characteristics of TPESampler because TPESampler uses some (by default, 10) trials for its startup. When specifying distributions manually, make sure to import the distribution types from optuna: from optuna.distributions import ... . Warning Keras' models can only use hyperparameter tuning when n_jobs = 1 or ht_params = { \"cv\" : 1 } . Using n_jobs > 1 and cv > 1 raises a PicklingError due to incompatibilities of the APIs. Read here more about deep learning models. Tip ATOM has several plots that can help you examine a model's study and trials. Have a look at them here .", "title": "Hyperparameter tuning"}, {"location": "user_guide/training/#pruning", "text": "During hyperparameter tuning, pruning stops unpromising trials at the early stages of the training (a.k.a., automated early-stopping). This can save the pipeline much time that would otherwise be wasted on an estimator that is unlikely to yield the best results. A pruned trial can't be selected as best_trial . Click here to see an example that uses pruning. The study uses MedianPruner as default pruner. You can use any other of optuna's pruners through the ht_params parameter. >>> from optuna.pruners import HyperbandPruner >>> atom . run ( \"SGD\" , n_trials = 30 , ht_params = { \"pruner\" : HyperbandPruner ()}) Warning Pruning is disabled for multi-metric runs . Pruning is only available for models that support in-training validation .", "title": "Pruning"}, {"location": "user_guide/training/#bootstrapping", "text": "After fitting the estimator, you can assess the robustness of the model using the bootstrap technique. This technique creates several new data sets selecting random samples from the training set (with replacement) and evaluates them on the test set. This way you can get a distribution of the performance of the model. The sets are the same for every model. The number of sets can be chosen through the n_bootstrap parameter. Tip Use the plot_results method to plot the boostrap scores in a boxplot.", "title": "Bootstrapping"}, {"location": "user_guide/training/#successive-halving", "text": "Successive halving is a bandit-based algorithm that fits N models to 1/N of the data. The best half are selected to go to the next iteration where the process is repeated. This continues until only one model remains, which is fitted on the complete dataset. Beware that a model's performance can depend greatly on the amount of data on which it is trained. For this reason, we recommend only to use this technique with similar models, e.g. only using tree-based models. Run successive halving from atom via the successive_halving method. Consecutive runs of the same model are saved with the model's acronym followed by the number of models in the run. For example, a RandomForest in a run with 4 models would become model RF4 . See here a successive halving example. Tip Use the plot_successive_halving method to see every model's performance per iteration of the successive halving.", "title": "Successive halving"}, {"location": "user_guide/training/#train-sizing", "text": "When training models, there is usually a trade-off between model performance and computation time, that is regulated by the number of samples in the training set. Train sizing can be used to create insights in this trade-off, and help determine the optimal size of the training set. The models are fitted multiple times, ever-increasing the number of samples in the training set. Run train sizing from atom via the train_sizing method. The number of iterations and the number of samples per training can be specified with the train_sizes parameter. Consecutive runs of the same model are saved with the model's acronym followed by the fraction of rows in the training set (the . is removed from the fraction!). For example, a RandomForest in a run with 80% of the training samples would become model RF08 . See here a train sizing example. Tip Use the plot_learning_curve method to see the model's performance per size of the training set.", "title": "Train sizing"}]}